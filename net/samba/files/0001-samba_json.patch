diff --git a/lib/audit_logging/audit_logging.c b/lib/audit_logging/audit_logging.c
index b4fb9116487..e6a2f49f303 100644
--- a/lib/audit_logging/audit_logging.c
+++ b/lib/audit_logging/audit_logging.c
@@ -1035,4 +1035,258 @@ struct json_object json_get_object(struct json_object *object, const char *name)
 	}
 	return o;
 }
+
+/*
+ * @brief iterate through objects in a json array
+ *
+ * Iterate through elements of json array and call callback
+ * function for each of them.
+ *
+ * @param object the json object
+ * @param fn callback function
+ * @param private_data private data to pass to callback function
+ *
+ * @return 0 on success -1 on failure
+ */
+int iter_json_array(struct json_object *object,
+		    bool (*fn)(int index,
+			       struct json_object *entry,
+			       void *state),
+		    void *private_data)
+{
+	int i;
+	size_t array_size;
+
+	if (json_is_invalid(object)) {
+		DBG_ERR("Invalid JSON object.\n");
+		return -1;
+	}
+	if (!json_is_array(object->root)) {
+		DBG_ERR("JSON object is not an array\n");
+		return -1;
+	}
+
+	array_size = json_array_size(object->root);
+	for (i = 0; i < array_size; i++) {
+		bool ok;
+		json_t *entry = NULL;
+		struct json_object jsobj = json_empty_object;
+
+		entry = json_array_get(object->root, i);
+		if (entry == NULL) {
+			DBG_ERR("Idx [%d] in JSON array is invalid\n", i);
+			return -1;
+		}
+
+		jsobj = (struct json_object) {
+			.root = entry,
+			.valid = true,
+		};
+
+		ok = fn(i, &jsobj, private_data);
+		if (!ok) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
+/*
+ * @brief iterate through keys in a json object
+ *
+ * Iterate through keys in a json object, and call callback
+ * function for each of them.
+ *
+ * @param object the json object
+ * @param fn callback function
+ * @param private_data private data to pass to callback function
+ *
+ * @return 0 on success -1 on failure
+ */
+int iter_json_object(struct json_object *object,
+		     bool (*fn)(const char *key,
+				struct json_object *value,
+				void *state),
+		     void *private_data)
+{
+	void *tmp = NULL;
+	const char *key = NULL;
+	json_t *value = NULL;
+
+	if (json_is_invalid(object)) {
+		DBG_ERR("Invalid JSON object.\n");
+		return -1;
+	}
+
+	json_object_foreach_safe(object->root, tmp, key, value) {
+		bool ok;
+		struct json_object jsobj = json_empty_object;
+
+		jsobj = (struct json_object) {
+			.root = value,
+			.valid = true,
+		};
+
+		ok = fn(key, &jsobj, private_data);
+		if (!ok) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
+int json_get_string_value(const struct json_object *object,
+			  const char *key,
+			  const char **valp)
+{
+	json_t *to_check = NULL;
+	const char *value = NULL;
+
+	if (json_is_invalid(object)) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	to_check = json_object_get(object->root, key);
+	if (to_check == NULL) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	if (!json_is_string(to_check)) {
+		DBG_ERR("%s: Unexpected JSON type: %d\n",
+			key, json_typeof(to_check));
+		errno = EINVAL;
+		return -1;
+	}
+
+	value = json_string_value(to_check);
+	*valp = value;
+	return 0;
+}
+
+int json_get_bool_value(const struct json_object *object,
+			const char *key,
+			bool *valp)
+{
+	json_t *to_check = NULL;
+	bool value;
+
+	if (json_is_invalid(object)) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	to_check = json_object_get(object->root, key);
+	if (to_check == NULL) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	if (!json_is_boolean(to_check)) {
+		DBG_ERR("%s: unexpected JSON type: %d\n",
+			key, json_typeof(to_check));
+		errno = EINVAL;
+		return -1;
+	}
+
+	value = json_boolean_value(to_check);
+	*valp = value;
+	return 0;
+}
+
+int json_get_int_value(const struct json_object *object,
+		       const char *key,
+		       int *valp)
+{
+	json_t *to_check = NULL;
+	int value;
+
+	if (json_is_invalid(object)) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	to_check = json_object_get(object->root, key);
+	if (to_check == NULL) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	if (!json_is_integer(to_check)) {
+		DBG_ERR("%d: unexpected JSON type: %d\n",
+			key, json_typeof(to_check));
+		errno = EINVAL;
+		return -1;
+	}
+
+	value = json_integer_value(to_check);
+	*valp = value;
+	return 0;
+}
+
+int json_get_array_value(const struct json_object *object,
+			 const char *key,
+			 struct json_object *valp)
+{
+	json_t *to_check = NULL;
+	int value;
+
+	if (json_is_invalid(object)) {
+		errno = EINVAL;
+		valp->valid = false;
+		return -1;
+	}
+
+	to_check = json_object_get(object->root, key);
+	if (to_check == NULL) {
+		errno = ENOENT;
+		valp->valid = false;
+		return -1;
+	}
+
+	if (!json_is_array(to_check)) {
+		DBG_ERR("%d: unexpected JSON type: %d\n",
+			key, json_typeof(to_check));
+		errno = EINVAL;
+		valp->valid = false;
+		return -1;
+	}
+
+	valp->root = to_check;
+	valp->valid = true;
+	return 0;
+}
+
+/*
+ * @brief convert text into a json object
+ *
+ * Load json from text. This is primarily useful for adding
+ * json input support for utilities. libjansson will perform
+ * validation and report errors, which we print at DBG_ERR.
+ *
+ * @param text string to convert to struct json object
+ *
+ * @return a struct json_object, valid will be set to false if the object
+ *         could not be created.
+ */
+struct json_object load_json(const char *text)
+{
+	struct json_object object = json_empty_object;
+	json_t *root = NULL;
+	json_error_t error;
+
+	root = json_loads(text, 0, &error);
+	if (root == NULL) {
+		DBG_ERR("JSON error on line %d: %s\n",
+			error.line, error.text);
+		object.valid = false;
+		return object;
+	}
+	object = (struct json_object) {
+		.root = root,
+		.valid = true,
+	};
+	return object;
+}
 #endif
diff --git a/lib/audit_logging/audit_logging.h b/lib/audit_logging/audit_logging.h
index 86e9134a86a..23c3a296544 100644
--- a/lib/audit_logging/audit_logging.h
+++ b/lib/audit_logging/audit_logging.h
@@ -93,5 +93,28 @@ _WARN_UNUSED_RESULT_ struct json_object json_get_object(
     struct json_object *object, const char *name);
 _WARN_UNUSED_RESULT_ char *json_to_string(TALLOC_CTX *mem_ctx,
 					  const struct json_object *object);
+
+_WARN_UNUSED_RESULT_ int iter_json_array(struct json_object *object,
+					 bool (*fn)(int index,
+						    struct json_object *entry,
+						    void *private_data),
+					 void *private_data);
+
+_WARN_UNUSED_RESULT_ int iter_json_object(struct json_object *object,
+					  bool (*fn)(const char *key,
+						     struct json_object *value,
+						     void *private_data),
+					  void *private_data);
+
+_WARN_UNUSED_RESULT_ int json_get_string_value(
+    const struct json_object *object, const char *key, const char **valp);
+_WARN_UNUSED_RESULT_ int json_get_bool_value(
+    const struct json_object *object, const char *key, bool *valp);
+_WARN_UNUSED_RESULT_ int json_get_int_value(
+    const struct json_object *object, const char *key, int *valp);
+_WARN_UNUSED_RESULT_ int json_get_array_value(
+    const struct json_object *object, const char *key, struct json_object *valp);
+
+_WARN_UNUSED_RESULT_ struct json_object load_json(const char *text);
 #endif
 #endif
diff --git a/source3/include/util_sd.h b/source3/include/util_sd.h
index 7f82969badf..dc4ec88e578 100644
--- a/source3/include/util_sd.h
+++ b/source3/include/util_sd.h
@@ -23,6 +23,12 @@
 
 #ifndef __UTIL_SD_H__
 #define __UTIL_SD_H__
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
+#endif /*HAVE_JANSSON*/
+
 
 void SidToString(struct cli_state *cli, fstring str, const struct dom_sid *sid,
 		 bool numeric);
@@ -33,5 +39,7 @@ bool parse_ace(struct cli_state *cli, struct security_ace *ace,
 	       const char *orig_str);
 void sec_desc_print(struct cli_state *cli, FILE *f,
 		    struct security_descriptor *sd, bool numeric);
+bool sec_desc_to_json(struct cli_state *cli, struct json_object *out,
+                      struct security_descriptor *sd, bool numeric, bool share_acl);
 
 #endif
diff --git a/source3/lib/util_sd.c b/source3/lib/util_sd.c
index 39083b15438..e7396237f50 100644
--- a/source3/lib/util_sd.c
+++ b/source3/lib/util_sd.c
@@ -28,30 +28,53 @@
 #include "../libcli/security/security.h"
 #include "rpc_client/cli_pipe.h"
 #include "rpc_client/cli_lsarpc.h"
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#endif /* [HAVE_JANSSON] */
 
 /* These values discovered by inspection */
 
 struct perm_value {
 	const char *perm;
+	const char *text;
 	uint32_t mask;
 };
 
 static const struct perm_value special_values[] = {
-	{ "R", SEC_RIGHTS_FILE_READ },
-	{ "W", SEC_RIGHTS_FILE_WRITE },
-	{ "X", SEC_RIGHTS_FILE_EXECUTE },
-	{ "D", SEC_STD_DELETE },
-	{ "P", SEC_STD_WRITE_DAC },
-	{ "O", SEC_STD_WRITE_OWNER },
-	{ NULL, 0 },
+	{ "R", "READ", SEC_RIGHTS_FILE_READ },
+	{ "W", "WRITE", SEC_RIGHTS_FILE_WRITE },
+	{ "X", "EXECUTE", SEC_RIGHTS_FILE_EXECUTE },
+	{ "D", "DELETE", SEC_STD_DELETE },
+	{ "P", "WRITE_DAC", SEC_STD_WRITE_DAC },
+	{ "O", "WRITE_OWNER", SEC_STD_WRITE_OWNER },
+	{ NULL, NULL, 0 },
+};
+
+static const struct perm_value extended_values[] = {
+	{ "R", "READ", SEC_FILE_READ_DATA },
+	{ "W", "WRITE", SEC_FILE_WRITE_DATA },
+	{ "X", "EXECUTE", SEC_FILE_EXECUTE },
+	{ "p", "APPEND_DATA", SEC_FILE_APPEND_DATA},
+	{ "a", "READ_ATTRIBUTES", SEC_FILE_READ_ATTRIBUTE},
+	{ "A", "WRITE_ATTRIBUTES", SEC_FILE_WRITE_ATTRIBUTE},
+	{ "r", "READ_EA", SEC_FILE_READ_EA},
+	{ "w", "WRITE_EA", SEC_FILE_WRITE_EA},
+	{ "D", "DELETE", SEC_STD_DELETE },
+	{ "d", "DELETE_CHILD", FILE_DELETE_CHILD},
+	{ "c", "READ_CONTROL", SEC_STD_READ_CONTROL},
+	{ "P", "WRITE_DAC", SEC_STD_WRITE_DAC },
+	{ "O", "WRITE_OWNER", SEC_STD_WRITE_OWNER },
+	{ "S", "SYNCHRONIZE", SEC_STD_SYNCHRONIZE},
+	{ NULL, NULL, 0 },
 };
 
 static const struct perm_value standard_values[] = {
-	{ "READ",   SEC_RIGHTS_DIR_READ|SEC_DIR_TRAVERSE },
-	{ "CHANGE", SEC_RIGHTS_DIR_READ|SEC_STD_DELETE|\
+	{ "READ", "READ", SEC_RIGHTS_DIR_READ|SEC_DIR_TRAVERSE },
+	{ "CHANGE", "CHANGE", SEC_RIGHTS_DIR_READ|SEC_STD_DELETE|\
 	  SEC_RIGHTS_DIR_WRITE|SEC_DIR_TRAVERSE },
-	{ "FULL",   SEC_RIGHTS_DIR_ALL },
-	{ NULL, 0 },
+	{ "FULL", "FULL",  SEC_RIGHTS_DIR_ALL },
+	{ NULL, NULL, 0 },
 };
 
 static const struct {
@@ -366,6 +389,364 @@ void print_ace(struct cli_state *cli, FILE *f, struct security_ace *ace,
 	}
 }
 
+static bool add_acl_ctrl_json(struct json_object *jsobj, uint16_t ctrl, bool numeric)
+{
+	struct json_object control, tmp;
+	int i, ret;
+	control = json_new_object();
+	if (json_is_invalid(&control)) {
+		fprintf(stderr, "Failed to get JSON array for ACL control\n");
+		return false;
+	}
+
+	for (i = ARRAY_SIZE(sec_desc_ctrl_bits) - 1; i >= 0; i--) {
+		if (ctrl & sec_desc_ctrl_bits[i].mask) {
+			ret =json_add_bool(&control, sec_desc_ctrl_bits[i].desc, true);
+			if (ret != 0) {
+				fprintf(stderr, "Failed to add control bits\n");
+				json_free(&control);
+				return false;
+			}
+
+		}
+		else {
+			ret = json_add_bool(&control, sec_desc_ctrl_bits[i].desc, false);
+			if (ret != 0) {
+				fprintf(stderr, "Failed to add control bits\n");
+				json_free(&control);
+				return false;
+			}
+		}
+	}
+	ret = json_add_object(jsobj, "control", &control);
+	return true;
+}
+
+static bool add_trustee_json(struct json_object *jsobj, struct cli_state *cli,
+			     const struct dom_sid *sid, char *title,
+			     bool numeric)
+{
+	struct json_object trustee;
+	int ret;
+	NTSTATUS status;
+	char *domain = NULL;
+	char *name = NULL;
+	fstring str;
+
+	enum lsa_SidType type;
+
+	trustee = json_new_object();
+	if (json_is_invalid(&trustee)) {
+		fprintf(stderr, "New JSON object for trustee is invalid\n");
+		return false;
+	}
+	ret = json_add_sid(&trustee, "sid", sid);
+	if (ret != 0) {
+		fprintf(stderr, "Failed to add SID to trustee JSON object: %s\n",
+			strerror(errno));
+		json_free(&trustee);
+		return false;
+	}
+        if (numeric || cli == NULL) {
+		ret = json_add_string(&trustee, "name", "");
+		if (ret != 0) {
+			json_free(&trustee);
+			return false;
+		}
+        }
+	else {
+		status = cli_lsa_lookup_sid(cli, sid, talloc_tos(), &type,
+					    &domain, &name);
+
+		if (!NT_STATUS_IS_OK(status)) {
+			fprintf(stderr, "cli_lsa_lookup_sid failed\n");
+			json_free(&trustee);
+			return false;
+		}
+		if (*domain) {
+			slprintf(str, sizeof(fstring) - 1, "%s%s%s",
+				domain, lp_winbind_separator(), name);
+			ret = json_add_string(&trustee, "name", str);
+			if (ret != 0) {
+				fprintf(stderr, "Failed to add name to trustee: %s",
+					strerror(errno));
+				json_free(&trustee);
+				return false;
+			}
+		} else {
+			ret = json_add_string(&trustee, "name", "");
+			if (ret != 0) {
+				json_free(&trustee);
+				return false;
+			}
+		}
+	}
+	ret = json_add_object(jsobj, title, &trustee);
+	if (ret != 0) {
+		fprintf(stderr, "Failed to %s to JSON object: %s\n",
+			title, strerror(errno));
+		json_free(&trustee);
+		return false;
+	}
+	return true;
+}
+
+static bool add_ace_flags_json(struct json_object *jsobj, uint8_t flags)
+{
+	struct json_object js_flags;
+	int ret;
+	if (json_is_invalid(jsobj)) {
+		return false;
+	}
+	js_flags = json_new_object();
+	if (json_is_invalid(&js_flags)) {
+		return false;
+	}
+
+	ret = json_add_bool(&js_flags, "OBJECT_INHERIT",
+			    (flags & SEC_ACE_FLAG_OBJECT_INHERIT)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+	ret = json_add_bool(&js_flags, "CONTAINER_INHERIT",
+			    (flags & SEC_ACE_FLAG_CONTAINER_INHERIT)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+	ret = json_add_bool(&js_flags, "NO_PROPAGATE_INHERIT",
+			    (flags & SEC_ACE_FLAG_NO_PROPAGATE_INHERIT)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+	ret = json_add_bool(&js_flags, "INHERIT_ONLY",
+			    (flags & SEC_ACE_FLAG_INHERIT_ONLY)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+	ret = json_add_bool(&js_flags, "INHERITED",
+			    (flags & SEC_ACE_FLAG_INHERITED_ACE)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+
+	ret = json_add_object(jsobj, "flags", &js_flags);
+	if (ret < 0) {
+		fprintf(stderr, "Failed to add flags to JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	return true;
+
+failure:
+	json_free(&js_flags);
+	return false;
+}
+
+static bool add_perms_json(struct json_object *jsobj,
+			   const struct perm_value *perm,
+			   struct security_ace *ace,
+			   uint32_t *got_mask)
+{
+	int ret;
+	const struct perm_value *v;
+
+	for (v = perm; v->perm; v++) {
+		if ((ace->access_mask & v->mask) == v->mask) {
+			ret = json_add_bool(jsobj, v->text, true);
+			if (ret < 0) {
+				return false;
+			}
+			*got_mask &= ~v->mask;
+		}
+		else {
+			ret = json_add_bool(jsobj, v->text, false);
+			if (ret < 0) {
+				return false;
+			}
+		}
+	}
+	return true;
+}
+
+static bool add_access_mask_json(struct json_object *jsobj,
+				 struct security_ace *ace,
+				 bool share_acl)
+{
+	struct json_object js_amask, special;
+	int ret;
+	const struct perm_value *v;
+	char buf[80];
+	bool has_standard = false;
+	uint32_t got_mask;
+	if (json_is_invalid(jsobj)) {
+		return false;
+	}
+	js_amask = json_new_object();
+	if (json_is_invalid(&js_amask)) {
+		return false;
+	}
+	special = json_new_object();
+	if (json_is_invalid(&special)) {
+		json_free(&js_amask);
+		return false;
+	}
+	snprintf(buf, sizeof(buf), "0x%08x", ace->access_mask);
+	ret = json_add_string(&js_amask, "hex", buf);
+	if (ret < 0) {
+		goto failure;
+	}
+	for (v = standard_values; v->perm; v++) {
+		if (ace->access_mask == v->mask) {
+			ret = json_add_string(&js_amask, "standard", v->perm);
+			if (ret < 0) {
+				json_free(&js_amask);
+				return false;
+			}
+			has_standard = true;
+		}
+	}
+	if (share_acl) {
+		goto done;
+	}
+
+	if (!has_standard) {
+		ret = json_add_string(&js_amask, "standard", "");
+		if (ret < 0) {
+			goto failure;
+		}
+	}
+
+	got_mask = ace->access_mask;
+
+	ret = add_perms_json(&special, extended_values, ace, &got_mask);
+	if (!ret) {
+		goto failure;
+	}
+
+	ret = json_add_object(&js_amask, "special", &special);
+	if (ret < 0) {
+		fprintf(stderr,
+			"failed to add special entries to access mask "
+			"JSON object: %s\n", strerror(errno));
+		goto failure;
+	}
+	snprintf(buf, sizeof(buf), "0x%08x", got_mask);
+	ret = json_add_string(&js_amask, "unknown", buf);
+	if (ret < 0) {
+		goto failure;
+	}
+done:
+	ret = json_add_object(jsobj, "access_mask", &js_amask);
+	if (ret < 0) {
+		fprintf(stderr, "Failed to add access mask to JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	return true;
+failure:
+	json_free(&js_amask);
+	json_free(&special);
+	return false;
+}
+
+static bool add_ace_json(struct cli_state *cli, struct json_object *jsobj,
+			 struct security_ace *ace, bool numeric, bool share_acl)
+{
+	const struct perm_value *v;
+	struct json_object jsace, trustee;
+	fstring sidstr;
+	int do_print = 0;
+	int ret;
+	bool rv;
+	char buf[80] = {0};
+	bool has_js_amask = false;
+	if (json_is_invalid(jsobj)) {
+		return false;
+	}
+	jsace = json_new_object();
+	if (json_is_invalid(&jsace)) {
+		fprintf(stderr, "Failed to create new JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	trustee = json_new_object();
+	if (json_is_invalid(&trustee)) {
+		fprintf(stderr, "Failed to create new JSON object: %s\n",
+			strerror(errno));
+		goto failure;
+	}
+
+	rv = add_trustee_json(&jsace, cli, &ace->trustee, "trustee", numeric);
+	if (!rv) {
+		goto failure;
+	}
+
+	if (numeric) {
+		ret = json_add_int(&jsace, "type", ace->type);
+		if (ret < 0 ) {
+			goto failure;
+		}
+		ret = json_add_int(&jsace, "flags", ace->flags);
+		if (ret < 0 ) {
+			goto failure;
+		}
+		snprintf(buf, sizeof(buf), "0x%08x", ace->access_mask);
+		ret = json_add_string(&jsace, "access_mask", buf);
+		if (ret < 0 ) {
+			goto failure;
+		}
+		ret = json_add_object(jsobj, NULL, &jsace);
+		if (ret < 0 ) {
+			goto failure;
+		}
+		return true;
+	}
+	switch(ace->type) {
+	case SEC_ACE_TYPE_ACCESS_ALLOWED:
+		snprintf(buf, sizeof(buf), "%s", "ALLOWED");
+		break;
+	case SEC_ACE_TYPE_ACCESS_DENIED:
+		snprintf(buf, sizeof(buf), "%s", "DENIED");
+		break;
+	default:
+		snprintf(buf, sizeof(buf), "UNKNOWN - %d", ace->type);
+		break;
+	}
+	ret = json_add_string(&jsace, "type", buf);
+	if (ret != 0) {
+		fprintf(stderr,
+			"Failed to add ace_type [%s] to JSON object "
+			"for ACE: %s\n", buf, strerror(errno));
+		goto failure;
+	}
+	ret = add_access_mask_json(&jsace, ace, share_acl);
+	if (!ret) {
+		goto failure;
+	}
+	if (!share_acl) {
+		ret = add_ace_flags_json(&jsace, ace->flags);
+		if (!ret) {
+			goto failure;
+		}
+	}
+	ret = json_add_object(jsobj, NULL, &jsace);
+	if (ret < 0) {
+		fprintf(stderr, "Failed to add new ACE to JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	return true;
+
+failure:
+	json_free(&jsace);
+	return false;
+}
+
 static bool parse_ace_flags(const char *str, unsigned int *pflags)
 {
 	const char *p = str;
@@ -647,3 +1028,71 @@ void sec_desc_print(struct cli_state *cli, FILE *f,
 	}
 
 }
+
+bool sec_desc_to_json(struct cli_state *cli, struct json_object *out,
+		      struct security_descriptor *sd, bool numeric,
+		      bool share_acl)
+{
+	struct json_object jsret, dacl, owner, group, control;
+	fstring sidstr;
+	uint32_t i;
+	int ret;
+	bool rv;
+	jsret = json_new_object();
+	if (json_is_invalid(&jsret)) {
+		fprintf(stderr, "Failed to create new JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	ret = json_add_int(&jsret, "revision", sd->revision);
+	if (ret < 0) {
+		fprintf(stderr, "Failed to add REVISION to JSON object\n");
+		goto failure;
+	}
+
+	if (!share_acl) {
+		rv = add_trustee_json(&jsret, cli, sd->owner_sid, "owner", numeric);
+		if (!rv) {
+			fprintf(stderr, "Failed to add owner to JSON object: %s\n",
+				strerror(errno));
+			goto failure;
+		}
+		rv = add_trustee_json(&jsret, cli, sd->group_sid, "group", numeric);
+		if (!rv) {
+			fprintf(stderr, "Failed to add owner to JSON object: %s\n",
+				strerror(errno));
+			goto failure;
+		}
+	}
+
+	dacl = json_get_array(&jsret, "dacl");
+	if (json_is_invalid(&dacl)) {
+		goto failure;
+	}
+	for (i = 0; sd->dacl && i < sd->dacl->num_aces; i++) {
+		struct security_ace *ace = &sd->dacl->aces[i];
+		ret = add_ace_json(cli, &dacl, ace, numeric, share_acl);
+		if (!ret) {
+			json_free(&dacl);
+			goto failure;
+		}
+	}
+	ret = json_add_object(&jsret, "dacl", &dacl);
+	if (ret == -1) {
+		fprintf(stderr, "Failed to add DACL to jsret: %s\n",
+			strerror(errno));
+	}
+
+	rv = add_acl_ctrl_json(&jsret, sd->type, numeric);
+	if (!rv) {
+		fprintf(stderr, "Failed to do control: %s\n", strerror(errno));
+		goto failure;
+	}
+
+	*out = jsret;
+	return true;
+
+failure:
+	json_free(&jsret);
+	return false;
+}
diff --git a/source3/utils/net.c b/source3/utils/net.c
index 683b46794e4..1523e00abdb 100644
--- a/source3/utils/net.c
+++ b/source3/utils/net.c
@@ -1425,5 +1425,6 @@ static void get_credentials_file(struct net_context *c,
 	poptFreeContext(pc);
 
 	TALLOC_FREE(frame);
+	TALLOC_FREE(c->msg_ctx);
 	return rc;
 }
diff --git a/source3/utils/net_groupmap.c b/source3/utils/net_groupmap.c
index b4da9bae556..e29be550111 100644
--- a/source3/utils/net_groupmap.c
+++ b/source3/utils/net_groupmap.c
@@ -27,6 +27,15 @@
 #include "../libcli/security/security.h"
 #include "passdb.h"
 
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h"
+#define JS_MAJ_VER	0
+#define JS_MIN_VER	1
+#endif /* HAVE_JANSSON */
+
+bool is_batch_op = false;
+
 /*********************************************************
  Figure out if the input was an NT group or a SID string.
  Return the SID.
@@ -86,9 +95,396 @@ static void print_map_entry (const GROUP_MAP *map, bool long_list)
 	}
 
 }
+
+/*********************************************************
+ JSON helper functions
+**********************************************************/
+#ifdef HAVE_JANSSON
+static bool json_to_groupmap(struct json_object *jsdata,
+			     GROUP_MAP *map)
+{
+	const char *nt_name = NULL;
+	const char *comment = NULL;
+	const char *sid = NULL;
+	const char *group_type = NULL;
+	const char *unix_group = NULL;
+	int rid = 0, error, sid_type;
+
+	map->gid = -1;
+	map->sid_name_use = SID_NAME_DOM_GRP;
+
+	error = json_get_string_value(jsdata, "nt_name", &nt_name);
+	if (error) {
+		if (errno == EINVAL) {
+			d_fprintf(stderr, _("\"nt_name\" must be string.\n"));
+			return false;
+		}
+	} else {
+		map->nt_name = talloc_strdup(map, nt_name);
+		if (map->nt_name == NULL) {
+			d_fprintf(stderr, _("memory error\n"));
+			return false;
+		}
+	}
+
+	error = json_get_int_value(jsdata, "rid", &rid);
+	if (error) {
+		if (errno == EINVAL) {
+			d_fprintf(stderr, _("\"rid\" must be integer.\n"));
+			return false;
+		}
+	}
+
+	error = json_get_string_value(jsdata, "sid", &sid);
+	if (error) {
+		if (errno == EINVAL) {
+			d_fprintf(stderr, _("\"sid\" must be string.\n"));
+			return false;
+		}
+	}
+
+	if (sid != NULL) {
+		bool ok;
+		const char *sid_endptr = NULL;
+		ok = dom_sid_parse_endp(sid, &map->sid, &sid_endptr);
+		if (!ok || (*sid_endptr != '\0')) {
+			d_fprintf(stderr, _("\"sid\" is invalid.\n"));
+			return false;
+		}
+	}
+	else if (rid != 0) {
+		sid_compose(&map->sid, get_global_sam_sid(), rid);
+	}
+	else if (nt_name != NULL) {
+		bool ok;
+		GROUP_MAP *tmp = NULL;
+		struct dom_sid *rv = NULL;
+
+		tmp = talloc_zero(talloc_tos(), GROUP_MAP);
+		if (tmp == NULL) {
+			return false;
+		}
+		ok = pdb_getgrnam(tmp, nt_name);
+		if (ok) {
+			rv = dom_sid_dup(map, &tmp->sid);
+			if (rv == NULL) {
+				TALLOC_FREE(tmp);
+				return false;
+			}
+			map->sid = *rv;
+		}
+		TALLOC_FREE(tmp);
+	}
+
+	error = json_get_int_value(jsdata, "gid", &map->gid);
+	if (error && (errno == EINVAL)) {
+		d_fprintf(stderr, _("Key [gid] must be an integer.\n"));
+		return false;
+	}
+
+	error = json_get_string_value(jsdata, "group_type_str", &group_type);
+	if (error) {
+		if (errno == EINVAL) {
+			d_fprintf(stderr, _("\"group_type_str\" must be string.\n"));
+			return false;
+		}
+	} else {
+		switch (group_type[0]) {
+		case 'b':
+		case 'B':
+			map->sid_name_use = SID_NAME_WKN_GRP;
+			break;
+		case 'd':
+		case 'D':
+			map->sid_name_use = SID_NAME_DOM_GRP;
+			break;
+		case 'l':
+		case 'L':
+			map->sid_name_use = SID_NAME_ALIAS;
+			break;
+		default:
+			d_fprintf(stderr,
+				  _("unknown group type: %s\n"),
+				  group_type);
+			return false;
+		}
+	}
+
+	error = json_get_int_value(jsdata, "group_type", &sid_type);
+	if (error) {
+		if (errno == EINVAL) {
+			d_fprintf(stderr, _("\"group_type\" must be integer.\n"));
+			return false;
+		}
+	} else {
+		switch(sid_type) {
+		case SID_NAME_WKN_GRP:
+		case SID_NAME_DOM_GRP:
+		case SID_NAME_ALIAS:
+			map->sid_name_use = sid_type;
+			break;
+		default:
+			d_fprintf(stderr, _("Invalid group type: %d\n"), sid_type);
+			return false;
+		}
+	}
+
+	error = json_get_string_value(jsdata, "unix_group", &unix_group);
+	if (error) {
+		if (errno == EINVAL) {
+			d_fprintf(stderr, _("\"unix_group\" must be string.\n"));
+			return false;
+		}
+	} else {
+		struct group *grp = NULL;
+		grp = getgrnam(unix_group);
+		if (grp == NULL) {
+			d_fprintf(stderr, _("%s: getgrnam() failed: %s\n"),
+					 unix_group, strerror(errno));
+			return false;
+		}
+		map->gid = grp->gr_gid;
+	}
+	error = json_get_string_value(jsdata, "comment", &comment);
+	if (error) {
+		if (errno == EINVAL) {
+			d_fprintf(stderr, _("\"comment\" must be string.\n"));
+			return false;
+		}
+		map->comment = talloc_strdup(map, "");
+		if (map->comment == NULL) {
+			return false;
+		}
+	} else {
+		map->comment = talloc_strdup(map, comment);
+		if (map->comment == NULL) {
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static bool groupmap_to_json(struct json_object *gm_array,
+			     GROUP_MAP *map,
+			     bool verbose)
+{
+	struct json_object entry;
+	struct dom_sid_buf buf;
+	int error;
+
+	entry = json_new_object();
+	if (json_is_invalid(&entry)) {
+		return false;
+	}
+
+	error = json_add_string(&entry, "nt_name", map->nt_name);
+	if (error) {
+		goto fail;
+	}
+
+	error = json_add_sid(&entry, "sid", &map->sid);
+	if (error) {
+		goto fail;
+	}
+
+	error = json_add_int(&entry, "gid", map->gid);
+	if (error) {
+		goto fail;
+	}
+
+	error = json_add_int(&entry, "group_type_int", map->sid_name_use);
+	if (error) {
+		goto fail;
+	}
+
+	error = json_add_string(&entry, "comment", map->comment);
+	if (error) {
+		goto fail;
+	}
+
+	error = json_add_int(&entry, "group_type_int", map->sid_name_use);
+	if (verbose) {
+		char *group = NULL;
+		const char *sid_type = sid_type_lookup(map->sid_name_use);
+
+		group = gidtoname(map->gid);
+		error = json_add_string(&entry, "unix_group", group);
+		TALLOC_FREE(group);
+		if (error) {
+			goto fail;
+		}
+
+		error = json_add_string(&entry, "group_type_str", sid_type);
+		if (error) {
+			goto fail;
+		}
+	}
+
+	error = json_add_object(gm_array, NULL, &entry);
+	if (error) {
+		goto fail;
+	}
+
+	return true;
+
+fail:
+	json_free(&entry);
+	return false;
+
+}
+#endif
+
 /*********************************************************
  List the groups.
 **********************************************************/
+#ifdef HAVE_JANSSON
+static int net_groupmap_list_json(struct net_context *c, int argc, const char **argv)
+{
+	size_t entries;
+	struct json_object jsdata, jsgroup = json_empty_object;
+	struct json_object output, gm_array;
+	bool verbose = false, ok;
+	int error;
+	char *jsout = NULL;
+
+	if (argc == 0) {
+		jsdata = json_new_object();
+		if (json_is_invalid(&jsdata)) {
+			return -1;
+		}
+	} else {
+		jsdata = load_json(argv[0]);
+		if (json_is_invalid(&jsdata)) {
+			return -1;
+		}
+	}
+
+	output = json_new_object();
+	if (json_is_invalid(&output)) {
+		json_free(&jsdata);
+		return -1;
+	}
+
+	gm_array = json_new_array();
+	if (json_is_invalid(&gm_array)) {
+		goto fail;
+	}
+
+	error = json_add_version(&output, JS_MAJ_VER, JS_MIN_VER);
+	if (error) {
+		goto fail;
+	}
+
+	error = json_get_bool_value(&jsdata, "verbose", &verbose);
+	if (error && (errno != ENOENT)) {
+		goto fail;
+	}
+
+	if (json_object_get(jsdata.root, "group")) {
+		fstring sid;
+		GROUP_MAP *map = NULL;
+		struct dom_sid *to_check = NULL;
+
+		map = talloc_zero(to_check, GROUP_MAP);
+		if (map == NULL) {
+			goto fail;
+		}
+
+		jsgroup = json_get_object(&jsdata, "group");
+		if (json_is_invalid(&jsgroup)) {
+			goto fail;
+		}
+
+		map = talloc_zero(talloc_tos(), GROUP_MAP);
+		if (map == NULL) {
+			goto fail;
+		}
+
+		ok = json_to_groupmap(&jsgroup, map);
+		if (!ok) {
+			TALLOC_FREE(map);
+			goto fail;
+		}
+
+		sid_to_fstring(sid, &map->sid);
+		if (strncmp(sid, "S-0-0", 5) == 0) {
+			d_fprintf(stderr, _("\rid\", \"sid\", or \"nt_p\" "
+					    "is required for lookup of specific "
+					    "mapping.\n"));
+			TALLOC_FREE(map);
+			goto fail;
+		}
+
+		to_check = dom_sid_dup(talloc_tos(), &map->sid);
+		if (to_check == NULL) {
+			TALLOC_FREE(map);
+			goto fail;
+		}
+
+		if (!pdb_getgrsid(map, *to_check)) {
+			d_fprintf(stderr, _("Failed to locate group SID [%s] "
+					    "in the group database.\n"), sid);
+			TALLOC_FREE(map);
+			TALLOC_FREE(to_check);
+			goto fail;
+		}
+		TALLOC_FREE(to_check);
+
+		ok = groupmap_to_json(&gm_array, map, verbose);
+		if (!ok) {
+			TALLOC_FREE(map);
+			goto fail;
+		}
+
+		TALLOC_FREE(map);
+
+	} else {
+		GROUP_MAP **maps = NULL;
+		size_t entries;
+		int i;
+
+		ok = pdb_enum_group_mapping(NULL, SID_NAME_UNKNOWN,
+					    &maps, &entries, ENUM_ALL_MAPPED);
+		if (!ok) {
+			TALLOC_FREE(maps);
+			goto fail;
+		}
+
+		for (i = 0; i < entries; i++) {
+			bool ok;
+
+			ok = groupmap_to_json(&gm_array, maps[i], verbose);
+			if (!ok) {
+				TALLOC_FREE(maps);
+				goto fail;
+			}
+		}
+	}
+
+	error = json_add_object(&output, "groupmap", &gm_array);
+	if (error) {
+		goto fail;
+	}
+
+	jsout = json_to_string(talloc_tos(), &output);
+	if (jsout == NULL) {
+		goto fail;
+	}
+
+	printf("%s\n", jsout);
+	TALLOC_FREE(jsout);
+	json_free(&jsdata);
+	json_free(&output);
+	return 0;
+
+fail:
+	json_free(&output);
+	json_free(&jsdata);
+	return -1;
+}
+#endif /* HAVE_JANSSON */
+
 static int net_groupmap_list(struct net_context *c, int argc, const char **argv)
 {
 	size_t entries;
@@ -107,6 +503,12 @@ static int net_groupmap_list(struct net_context *c, int argc, const char **argv)
 		return 0;
 	}
 
+#ifdef HAVE_JANSSON
+	if (c->opt_json) {
+		return net_groupmap_list_json(c, argc, argv);
+	}
+#endif /* HAVE_JANSSON */
+
 	if (c->opt_verbose || c->opt_long_list_entries)
 		long_list = true;
 
@@ -189,6 +591,140 @@ static int net_groupmap_list(struct net_context *c, int argc, const char **argv)
 /*********************************************************
  Add a new group mapping entry
 **********************************************************/
+#ifdef HAVE_JANSSON
+static bool add_json_mapping(int idx, struct json_object *entry, void *state)
+{
+	bool ok;
+	GROUP_MAP *map = NULL, *tmp = NULL;
+	fstring sid;
+	int rid = -1;
+	NTSTATUS status;
+
+	map = talloc_zero(talloc_tos(), GROUP_MAP);
+	if (map == NULL) {
+		d_fprintf(stderr, _("memory error.\n"));
+		return false;
+	}
+
+	ok = json_to_groupmap(entry, map);
+	if (!ok) {
+		d_fprintf(stderr, _("[%d]: Failed to convert entry to "
+				    "GROUP_MAP.\n"), idx);
+		TALLOC_FREE(map);
+		return false;
+	}
+
+	if (map->gid == -1) {
+		d_fprintf(stderr,
+			  _("[%d]: unable to determine group id for "
+			    "mapping group. Either \"gid\" or valid "
+			    "\"unix_group\" is required.\n"), idx);
+		TALLOC_FREE(map);
+		return false;
+	}
+	else if (!map->nt_name[0]) {
+		d_fprintf(stderr,
+			  _("[%d]: \"nt_name\" is required when \"gid\" is "
+			    "not specified."), idx);
+		TALLOC_FREE(map);
+		return false;
+	}
+
+	tmp = talloc_zero(talloc_tos(), GROUP_MAP);
+	if (tmp == NULL) {
+		d_fprintf(stderr, _("memory error.\n"));
+		TALLOC_FREE(map);
+		return false;
+	}
+
+	tmp->sid_name_use = SID_NAME_DOM_GRP;
+	if (pdb_getgrgid(tmp, map->gid)) {
+		sid_to_fstring(sid, &map->sid);
+		d_fprintf(stderr, _("[%d] unix gid %d already mapped to SID %s\n"),
+				    idx, map->gid, sid);
+		TALLOC_FREE(map);
+		TALLOC_FREE(tmp);
+		return false;
+	}
+	TALLOC_FREE(tmp);
+
+	sid_to_fstring(sid, &map->sid);
+	if (strequal(sid, "S-0-0")) {
+		if (pdb_capabilities() & PDB_CAP_STORE_RIDS) {
+			if (!pdb_new_rid(&rid)) {
+				d_fprintf(stderr,
+					  _("[%d]: Failed to allocate "
+					    "new RID.\n"), idx);
+				return false;
+			}
+		} else {
+			rid = algorithmic_pdb_gid_to_group_rid(map->gid);
+		}
+	}
+
+	if (rid != -1) {
+		struct dom_sid thesid;
+		sid_compose(&thesid, get_global_sam_sid(), rid);
+		sid_to_fstring(sid, &thesid);
+	}
+
+
+	status = add_initial_entry(map->gid,
+				   sid,
+				   map->sid_name_use,
+				   map->nt_name,
+				   map->comment);
+
+	TALLOC_FREE(map);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		d_fprintf(stderr,
+			  _("[%s] failed to add entry for gid %d\n"),
+			  idx, map->gid);
+		return false;
+	}
+
+	return true;
+}
+
+static int net_groupmap_add_json(struct net_context *c, int argc, const char **argv)
+{
+	struct json_object jsdata, jsgroupmap;
+	int error;
+	bool quiet = false;
+
+	jsdata = load_json(argv[0]);
+	if (json_is_invalid(&jsdata)) {
+		return -1;
+	}
+
+	error = json_get_bool_value(&jsdata, "quiet", &quiet);
+	if (error && (errno == EINVAL)) {
+		d_fprintf(stderr, _("key \"quiet\" must be boolean.\n"));
+		json_free(&jsdata);
+		return -1;
+	}
+
+	jsgroupmap = json_get_array(&jsdata, "groupmap");
+	if (json_is_invalid(&jsgroupmap)) {
+		json_free(&jsdata);
+		return -1;
+	}
+
+	error = iter_json_array(&jsgroupmap, add_json_mapping, NULL);
+	if (error) {
+		json_free(&jsdata);
+		return -1;
+	}
+	json_free(&jsdata);
+
+	if (!quiet && !is_batch_op) {
+		net_groupmap_list_json(c, argc, argv);
+	}
+
+	return 0;
+}
+#endif /* HAVE_JANSSON */
 
 static int net_groupmap_add(struct net_context *c, int argc, const char **argv)
 {
@@ -203,7 +739,6 @@ static int net_groupmap_add(struct net_context *c, int argc, const char **argv)
 	gid_t gid;
 	int i;
 	GROUP_MAP *map;
-
 	const char *name_type;
 	const char add_usage_str[] = N_("net groupmap add "
 					"{rid=<int>|sid=<string>}"
@@ -214,6 +749,12 @@ static int net_groupmap_add(struct net_context *c, int argc, const char **argv)
 
 	name_type = "domain group";
 
+#ifdef HAVE_JANSSON
+	if (c->opt_json) {
+		return net_groupmap_add_json(c, argc, argv);
+	}
+#endif /* HAVE_JANSSON */
+
 	if (c->display_usage) {
 		d_printf("%s\n%s\n", _("Usage:\n"), add_usage_str);
 		return 0;
@@ -363,6 +904,141 @@ static int net_groupmap_add(struct net_context *c, int argc, const char **argv)
 	return 0;
 }
 
+#ifdef HAVE_JANSSON
+static bool mod_json_mapping(int idx, struct json_object *entry, void *state)
+{
+	bool ok;
+	GROUP_MAP *map = NULL, *to_set = NULL;
+	fstring sid;
+	int rid = -1;
+	NTSTATUS status;
+
+	map = talloc_zero(talloc_tos(), GROUP_MAP);
+	if (map == NULL) {
+		d_fprintf(stderr, _("memory error.\n"));
+		return false;
+	}
+
+	ok = json_to_groupmap(entry, map);
+	if (!ok) {
+		d_fprintf(stderr, _("[%d]: Failed to convert entry to "
+				    "GROUP_MAP.\n"), idx);
+		TALLOC_FREE(map);
+		return false;
+	}
+
+	sid_to_fstring(sid, &map->sid);
+	if (strequal(sid, "S-0-0")) {
+		d_fprintf(stderr,
+			  _("[%d]: either \"sid\" or \"nt_name\" "
+			    "is required.\n"), idx);
+		TALLOC_FREE(map);
+		return false;
+	}
+
+	to_set = talloc_zero(talloc_tos(), GROUP_MAP);
+	if (to_set == NULL) {
+		d_fprintf(stderr, _("memory error.\n"));
+		TALLOC_FREE(map);
+		return false;
+	}
+
+	ok = pdb_getgrsid(to_set, map->sid);
+	if (!ok) {
+		d_fprintf(stderr,
+			  _("[%d]: Failed to find sid %s in database\n"),
+			  idx, sid);
+		goto fail;
+	}
+
+	if (map->sid_name_use == SID_NAME_UNKNOWN) {
+		d_fprintf(stderr,
+			  _("[%d] Can't map to an unknown group type.\n"), idx);
+		goto fail;
+	}
+
+	if (to_set->sid_name_use == SID_NAME_WKN_GRP) {
+		d_fprintf(stderr,
+			  _("[%d] Can only change between domain and local.\n"), idx);
+		goto fail;
+	}
+
+	to_set->sid_name_use = map->sid_name_use;
+
+	if (map->comment[0]) {
+		to_set->comment = talloc_strdup(to_set, map->comment);
+		if (to_set->comment == NULL) {
+			d_fprintf(stderr, _("memory error.\n"));
+			goto fail;
+		}
+	}
+
+	if (map->gid != -1) {
+		to_set->gid = map->gid;
+	}
+
+	if (map->nt_name[0]) {
+		to_set->nt_name = talloc_strdup(to_set, map->nt_name);
+		if (to_set->nt_name == NULL) {
+			d_fprintf(stderr, _("memory error.\n"));
+			goto fail;
+		}
+	}
+
+	status = pdb_update_group_mapping_entry(map);
+	if (!NT_STATUS_IS_OK(status)) {
+		goto fail;
+	}
+
+	TALLOC_FREE(map);
+	TALLOC_FREE(to_set);
+	return true;
+
+fail:
+	TALLOC_FREE(map);
+	TALLOC_FREE(to_set);
+	return false;
+}
+
+static int net_groupmap_modify_json(struct net_context *c, int argc, const char **argv)
+{
+	struct json_object jsdata, jsgroupmap;
+	int error;
+	bool quiet = false;
+
+	jsdata = load_json(argv[0]);
+	if (json_is_invalid(&jsdata)) {
+		return -1;
+	}
+
+	error = json_get_bool_value(&jsdata, "quiet", &quiet);
+	if (error && (errno == EINVAL)) {
+		d_fprintf(stderr, _("key \"quiet\" must be boolean.\n"));
+		json_free(&jsdata);
+		return -1;
+	}
+
+	jsgroupmap = json_get_array(&jsdata, "groupmap");
+	if (json_is_invalid(&jsgroupmap)) {
+		json_free(&jsdata);
+		return -1;
+	}
+
+	error = iter_json_array(&jsgroupmap, mod_json_mapping, NULL);
+	if (error) {
+		json_free(&jsdata);
+		return -1;
+	}
+	json_free(&jsdata);
+
+	if (!quiet && !is_batch_op) {
+		net_groupmap_list_json(c, argc, argv);
+	}
+
+	return 0;
+}
+#endif /* HAVE_JANSSON */
+
 static int net_groupmap_modify(struct net_context *c, int argc, const char **argv)
 {
 	struct dom_sid sid;
@@ -381,6 +1057,12 @@ static int net_groupmap_modify(struct net_context *c, int argc, const char **arg
 					   "[unixgroup=<string>] "
 					   "[type=<domain|local>]");
 
+#ifdef HAVE_JANSSON
+	if (c->opt_json) {
+		return net_groupmap_modify_json(c, argc, argv);
+	}
+#endif /* HAVE_JANSSON */
+
 	if (c->display_usage) {
 		d_printf("%s\n%s\n", _("Usage:\n"), modify_usage_str);
 		return 0;
@@ -532,6 +1214,88 @@ static int net_groupmap_modify(struct net_context *c, int argc, const char **arg
 	return 0;
 }
 
+#ifdef HAVE_JANSSON
+static bool del_json_mapping(int idx, struct json_object *entry, void *state)
+{
+	bool ok;
+	GROUP_MAP *map = NULL;
+	fstring sid;
+	NTSTATUS status;
+
+	map = talloc_zero(talloc_tos(), GROUP_MAP);
+	if (map == NULL) {
+		d_fprintf(stderr, _("memory error.\n"));
+		return false;
+	}
+
+	ok = json_to_groupmap(entry, map);
+	if (!ok) {
+		d_fprintf(stderr, _("[%d]: Failed to convert entry to "
+				    "GROUP_MAP.\n"), idx);
+		TALLOC_FREE(map);
+		return false;
+	}
+
+	sid_to_fstring(sid, &map->sid);
+	if (strequal(sid, "S-0-0")) {
+		d_fprintf(stderr,
+			  _("[%d]: either \"sid\" or \"nt_name\" "
+			    "is required.\n"), idx);
+		TALLOC_FREE(map);
+		return false;
+	}
+
+	status = pdb_delete_group_mapping_entry(map->sid);
+	if (!NT_STATUS_IS_OK(status)) {
+		d_fprintf(stderr,
+			  _("[%d]: Failed to remove SID %s from the mapping db!\n"),
+			  idx, sid);
+		return false;
+	}
+	TALLOC_FREE(map);
+
+	return true;
+}
+
+static int net_groupmap_delete_json(struct net_context *c, int argc, const char **argv)
+{
+	struct json_object jsdata, jsgroupmap;
+	int error;
+	bool quiet = false;
+
+	jsdata = load_json(argv[0]);
+	if (json_is_invalid(&jsdata)) {
+		return -1;
+	}
+
+	error = json_get_bool_value(&jsdata, "quiet", &quiet);
+	if (error && (errno == EINVAL)) {
+		d_fprintf(stderr, _("key \"quiet\" must be boolean.\n"));
+		json_free(&jsdata);
+		return -1;
+	}
+
+	jsgroupmap = json_get_array(&jsdata, "groupmap");
+	if (json_is_invalid(&jsgroupmap)) {
+		json_free(&jsdata);
+		return -1;
+	}
+
+	error = iter_json_array(&jsgroupmap, del_json_mapping, NULL);
+	if (error) {
+		json_free(&jsdata);
+		return -1;
+	}
+
+	json_free(&jsdata);
+
+	if (!quiet && !is_batch_op) {
+		net_groupmap_list_json(c, 0, NULL);
+	}
+	return 0;
+}
+#endif /* HAVE_JANSSON */
+
 static int net_groupmap_delete(struct net_context *c, int argc, const char **argv)
 {
 	struct dom_sid sid;
@@ -541,6 +1305,12 @@ static int net_groupmap_delete(struct net_context *c, int argc, const char **arg
 	const char delete_usage_str[] = N_("net groupmap delete "
 					   "{ntgroup=<string>|sid=<SID>}");
 
+#ifdef HAVE_JANSSON
+	if (c->opt_json) {
+		return net_groupmap_delete_json(c, argc, argv);
+	}
+#endif /* HAVE_JANSSON */
+
 	if (c->display_usage) {
 		d_printf("%s\n%s\n", _("Usage:\n"), delete_usage_str);
 		return 0;
@@ -784,10 +1554,126 @@ static int net_groupmap_cleanup(struct net_context *c, int argc, const char **ar
 	return 0;
 }
 
+#ifdef HAVE_JANSSON
+struct alias_member_token {
+	struct dom_sid *alias;
+	struct dom_sid *members;
+	uint32_t n_members;
+};
+
+static bool add_member_sid(int idx, struct json_object *member, void *private_data)
+{
+	struct alias_member_token *token = NULL;
+	const char *sid_string = NULL;
+	struct dom_sid member_sid;
+	int error;
+	NTSTATUS status;
+	bool ok;
+
+	token = talloc_get_type_abort(private_data, struct alias_member_token);
+	error = json_get_string_value(member, "sid", &sid_string);
+	if (error) {
+		d_fprintf(stderr, _("[%d]: \"sid\" string is required\n"), idx);
+		return false;
+	}
+
+	ok = string_to_sid(&member_sid, sid_string);
+	if (!ok) {
+		d_fprintf(stderr, _("[%d]: failed to convert %s to dom_sid\n"),
+			  idx, sid_string);
+		return false;
+	}
+	status = add_sid_to_array(token, &member_sid,
+				  &token->members, &token->n_members);
+	if (!NT_STATUS_IS_OK(status)) {
+		d_fprintf(stderr, _("[%d]: failed to add %s to members array\n"),
+			  idx, sid_string);
+		return false;
+	}
+	return true;
+}
+
+static bool json_to_sids(struct json_object *data, struct alias_member_token *token)
+{
+	int error;
+	const char *alias = NULL;
+	struct json_object members;
+
+	error = json_get_string_value(data, "alias", &alias);
+	if (error) {
+		return false;
+	}
+
+	token->alias = dom_sid_parse_talloc(token, alias);
+	if (token->alias == NULL) {
+		return false;
+	}
+
+	members = json_get_array(data, "members");
+	if (json_is_invalid(&members)) {
+		return false;
+	}
+
+	error = iter_json_array(&members, add_member_sid, token);
+	if (error) {
+		return false;
+	}
+	return true;
+}
+
+
+static int net_groupmap_addmem_json(struct net_context *c, int argc, const char **argv)
+{
+	struct json_object jsdata;
+	bool ok;
+	struct alias_member_token *token = NULL;
+	int i;
+
+	jsdata = load_json(argv[0]);
+	if (json_is_invalid(&jsdata)) {
+		return -1;
+	}
+
+	token = talloc_zero(talloc_tos(), struct alias_member_token);
+	if (token == NULL) {
+		json_free(&jsdata);
+		return -1;
+	}
+
+	ok = json_to_sids(&jsdata, token);
+	if (!ok) {
+		printf("json to sids failed\n");
+		json_free(&jsdata);
+		return -1;
+	}
+	json_free(&jsdata);
+
+	for (i = 0; i < token->n_members; i++) {
+		NTSTATUS status;
+		status = pdb_add_aliasmem(token->alias, &token->members[i]);
+		if (!NT_STATUS_IS_OK(status)) {
+			d_fprintf(stderr, _("[%d]: failed to add member: %s\n"),
+				  i, nt_errstr(status));
+			TALLOC_FREE(token);
+			return -1;
+		}
+	}
+
+	TALLOC_FREE(token);
+	return 0;
+}
+#endif /* HAVE_JANSSON */
+
 static int net_groupmap_addmem(struct net_context *c, int argc, const char **argv)
 {
 	struct dom_sid alias, member;
 
+#ifdef HAVE_JANSSON
+	if (c->opt_json) {
+		return net_groupmap_addmem_json(c, argc, argv);
+	}
+#endif /* HAVE_JANSSON */
+
 	if ( (argc != 2) ||
 	     c->display_usage ||
 	     !string_to_sid(&alias, argv[0]) ||
@@ -807,10 +1693,59 @@ static int net_groupmap_addmem(struct net_context *c, int argc, const char **arg
 	return 0;
 }
 
+#ifdef HAVE_JANSSON
+static int net_groupmap_delmem_json(struct net_context *c, int argc, const char **argv)
+{
+	struct json_object jsdata;
+	bool ok;
+	struct alias_member_token *token = NULL;
+	int i;
+
+	jsdata = load_json(argv[0]);
+	if (json_is_invalid(&jsdata)) {
+		return -1;
+	}
+
+	token = talloc_zero(talloc_tos(), struct alias_member_token);
+	if (token == NULL) {
+		json_free(&jsdata);
+		return -1;
+	}
+
+	ok = json_to_sids(&jsdata, token);
+	if (!ok) {
+		printf("json to sids failed\n");
+		json_free(&jsdata);
+		return -1;
+	}
+	json_free(&jsdata);
+
+	for (i = 0; i < token->n_members; i++) {
+		NTSTATUS status;
+		status = pdb_del_aliasmem(token->alias, &token->members[i]);
+		if (!NT_STATUS_IS_OK(status)) {
+			d_fprintf(stderr, _("[%d]: failed to add member: %s\n"),
+				  i, nt_errstr(status));
+			TALLOC_FREE(token);
+			return -1;
+		}
+	}
+
+	TALLOC_FREE(token);
+	return 0;
+}
+#endif /* HAVE_JANSSON */
+
 static int net_groupmap_delmem(struct net_context *c, int argc, const char **argv)
 {
 	struct dom_sid alias, member;
 
+#ifdef HAVE_JANSSON
+	if (c->opt_json) {
+		return net_groupmap_delmem_json(c, argc, argv);
+	}
+#endif /* HAVE_JANSSON */
+
 	if ( (argc != 2) ||
 	     c->display_usage ||
 	     !string_to_sid(&alias, argv[0]) ||
@@ -830,12 +1765,126 @@ static int net_groupmap_delmem(struct net_context *c, int argc, const char **arg
 	return 0;
 }
 
+#ifdef HAVE_JANSSON
+static int net_groupmap_listmem_json(struct net_context *c, int argc, const char **argv)
+{
+	struct json_object jsdata, out, jsmembers;
+	bool ok;
+	struct alias_member_token *token = NULL;
+	int i, error;
+	size_t num;
+	struct dom_sid *members = NULL;
+	char *toprint= NULL;
+	NTSTATUS status;
+
+	jsdata = load_json(argv[0]);
+	if (json_is_invalid(&jsdata)) {
+		return -1;
+	}
+
+	token = talloc_zero(talloc_tos(), struct alias_member_token);
+	if (token == NULL) {
+		json_free(&jsdata);
+		return -1;
+	}
+
+	ok = json_to_sids(&jsdata, token);
+	if (!ok) {
+		printf("json to sids failed\n");
+		json_free(&jsdata);
+		return -1;
+	}
+	json_free(&jsdata);
+
+	out = json_new_object();
+	if (json_is_invalid(&out)) {
+		d_fprintf(stderr, _("Failed to create JSON object %s\n"));
+		TALLOC_FREE(token);
+		return -1;
+	}
+
+	jsmembers = json_new_array();
+	if (json_is_invalid(&jsmembers)) {
+		d_fprintf(stderr, _("Failed to create JSON object %s\n"));
+		json_free(&out);
+		TALLOC_FREE(token);
+		return -1;
+	}
+
+	error = json_add_version(&out, JS_MAJ_VER, JS_MIN_VER);
+	if (error) {
+		goto fail;
+	}
+
+	error = json_add_sid(&out, "alias", token->alias);
+	if (error) {
+		goto fail;
+	}
+
+	status = pdb_enum_aliasmem(token->alias, talloc_tos(),
+				   &members, &num);
+	if (!NT_STATUS_IS_OK(status)) {
+		d_fprintf(stderr, _("Failed to enumerate alias members: %s\n"),
+			  nt_errstr(status));
+		goto fail;
+	}
+
+	for (i = 0; i < num; i++) {
+		struct json_object member;
+		member = json_new_object();
+		if (json_is_invalid(&member)) {
+			goto fail;
+		}
+
+		error = json_add_sid(&member, "sid", &members[i]);
+		if (error) {
+			json_free(&member);
+			goto fail;
+		}
+
+		error = json_add_object(&jsmembers, NULL, &member);
+		if (error) {
+			goto fail;
+		}
+	}
+
+	error = json_add_object(&out, "members", &jsmembers);
+	if (error) {
+		json_free(&out);
+		TALLOC_FREE(token);
+		return -1;
+	}
+
+	toprint = json_to_string(token, &out);
+	printf("%s\n", toprint);
+	TALLOC_FREE(token);
+	json_free(&out);
+	return 0;
+
+fail:
+	json_free(&out);
+	json_free(&jsmembers);
+	TALLOC_FREE(token);
+	if (NT_STATUS_EQUAL(status, NT_STATUS_NO_SUCH_ALIAS)) {
+		return ENOENT;
+	}
+	return -1;
+
+}
+#endif
+
 static int net_groupmap_listmem(struct net_context *c, int argc, const char **argv)
 {
 	struct dom_sid alias;
 	struct dom_sid *members;
 	size_t i, num;
 
+#ifdef HAVE_JANSSON
+	if (c->opt_json) {
+		return net_groupmap_listmem_json(c, argc, argv);
+	}
+#endif /* HAVE_JANSSON */
+
 	if ( (argc != 1) ||
 	     c->display_usage ||
 	     !string_to_sid(&alias, argv[0]) ) {
@@ -928,6 +1977,117 @@ static int net_groupmap_memberships(struct net_context *c, int argc, const char
 	return 0;
 }
 
+#ifdef HAVE_JANSSON
+const struct {
+	const char *name;
+	int (*fn)(struct net_context *c, int argc, const char **argv);
+} optable[] = {
+	{ "DEL", net_groupmap_delete },
+	{ "ADD", net_groupmap_add },
+	{ "MOD", net_groupmap_modify },
+	{ "DELMEM", net_groupmap_delmem },
+	{ "ADDMEM", net_groupmap_addmem },
+};
+
+struct batch_op_state {
+	struct net_context *ctx;
+	int (*fn)(struct net_context *c, int argc, const char **argv);
+};
+
+static bool dispatch_batch_op(int idx,
+			      struct json_object *data,
+			      void *private_data)
+{
+	int error;
+	struct batch_op_state *state = NULL;
+	char *js_data = NULL, *payload = NULL;
+
+	state = talloc_get_type_abort(private_data, struct batch_op_state);
+
+	payload = json_dumps(data->root, 0);
+	if (payload == NULL) {
+		d_fprintf(stderr, _("Failed to convert \"data\" to string.\n"));
+		return false;
+	}
+
+	const char *args[] = { payload, NULL };
+	error = state->fn(state->ctx, 1, args);
+	if (error) {
+		d_fprintf(stderr, _("operation failed on element: %d.\n"), idx);
+		return false;
+		free(js_data);
+	}
+	free(js_data);
+
+	return true;
+}
+
+static int net_groupmap_batch_json(struct net_context *c, int argc, const char **argv)
+{
+	struct json_object batch_data = json_empty_object;
+	size_t array_size;
+	int i, error;
+
+	is_batch_op = true;
+	batch_data = load_json(argv[0]);
+
+	if (batch_data.root == NULL) {
+		d_fprintf(stderr, _("Failed to load JSON data.\n"));
+		return false;
+	}
+
+	if (!json_is_object(batch_data.root)) {
+		d_fprintf(stderr, _("data is not a JSON object.\n"));
+		json_free(&batch_data);
+		return -1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(optable); i++) {
+		struct json_object op_array;
+		struct batch_op_state *state = NULL;
+
+		op_array = json_get_array(&batch_data, optable[i].name);
+		if (json_is_invalid(&op_array)) {
+			continue;
+		}
+
+		state = talloc_zero(talloc_tos(), struct batch_op_state);
+		if (state == NULL) {
+			d_fprintf(stderr, _("memory error\n"));
+			json_free(&batch_data);
+			return -1;
+		}
+
+		state->ctx = c;
+		state->fn = optable[i].fn;
+
+		error = iter_json_array(&op_array, dispatch_batch_op, state);
+		if (error) {
+			d_fprintf(stderr,
+				  _("%s: operation failed\n"),
+				  optable[i].name);
+			json_free(&batch_data);
+			return -1;
+		}
+		TALLOC_FREE(state);
+	}
+
+	if (error) {
+		d_fprintf(stderr, _("No valid operations specified\n"));
+		json_free(&batch_data);
+	}
+
+	json_free(&batch_data);
+
+	error = net_groupmap_list(c, 0, NULL);
+	if (error) {
+		d_fprintf(stderr, _("failed to add updated groupmap\n"));
+	}
+
+	return 0;
+}
+#endif
+
 /***********************************************************
  migrated functionality from smbgroupedit
  **********************************************************/
@@ -1014,6 +2174,18 @@ int net_groupmap(struct net_context *c, int argc, const char **argv)
 			N_("net groupmap list\n"
 			   "    List current group map")
 		},
+#ifdef HAVE_JANSSON
+		{
+			"batch",
+			net_groupmap_batch_json,
+			NET_TRANSPORT_LOCAL,
+			N_("Perform multiple json operations"),
+			N_("net groupmap batch\n"
+			   "    Perform batch operation based on supplied JSON. "
+			   "    Current supported operations are \"ADD\", \"MOD\", \"DEL\" \n"
+			   "    '{ \"<OP>\": [ {ENTRY}, {ENTRY}, ... ]'")
+		},
+#endif
 		{NULL, NULL, 0, NULL, NULL}
 	};
 
diff --git a/source3/utils/sharesec.c b/source3/utils/sharesec.c
index 419a6411334..69dfb12b047 100644
--- a/source3/utils/sharesec.c
+++ b/source3/utils/sharesec.c
@@ -29,6 +29,11 @@ struct cli_state;
 #include "passdb/machine_sid.h"
 #include "util_sd.h"
 #include "cmdline_contexts.h"
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
+#endif /* [HAVE_JANSSON] */
 
 static TALLOC_CTX *ctx;
 
@@ -155,12 +160,15 @@ static void sort_acl(struct security_acl *the_acl)
 }
 
 
-static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename, char *the_acl, enum acl_mode mode)
+static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename,
+			    char *the_acl, enum acl_mode mode, struct json_object *jsobj)
 {
 	struct security_descriptor *sd = NULL;
 	struct security_descriptor *old = NULL;
 	size_t sd_size = 0;
 	uint32_t i, j;
+	bool rv;
+	char *to_free = NULL;
 	NTSTATUS status;
 
 	if (mode != SMB_ACL_SET && mode != SMB_SD_DELETE) {
@@ -182,7 +190,15 @@ static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename, char *th
 		/* should not happen */
 		return 0;
 	case SMB_ACL_VIEW:
-		sec_desc_print(NULL, stdout, old, false);
+		if (jsobj != NULL) {
+			rv = sec_desc_to_json(NULL, jsobj, old, false, true);
+			if (!rv) {
+				return -1;
+			}
+		}
+		else {
+			sec_desc_print(NULL, stdout, old, false);
+		}
 		return 0;
 	case SMB_ACL_DELETE:
 	    for (i=0;sd->dacl && i<sd->dacl->num_aces;i++) {
@@ -328,10 +344,13 @@ int main(int argc, const char *argv[])
 	int retval = 0;
 	enum acl_mode mode = SMB_ACL_SET;
 	static char *the_acl = NULL;
+	char *to_free = NULL;
 	fstring sharename;
 	bool force_acl = False;
+	bool do_json = False;
 	int snum;
 	poptContext pc;
+	struct json_object jsobj, jsint;
 	bool initialize_sid = False;
 	struct poptOption long_options[] = {
 		POPT_AUTOHELP
@@ -428,6 +447,14 @@ int main(int argc, const char *argv[])
 			.descrip    = "Force storing the ACL",
 			.argDescrip = "ACLS",
 		},
+		{
+			.longName   = "json",
+			.shortName  = 'j',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'J',
+			.descrip    = "View ACL in JSON",
+		},
 		POPT_COMMON_SAMBA
 		POPT_TABLEEND
 	};
@@ -491,6 +518,10 @@ int main(int argc, const char *argv[])
 			force_acl = True;
 			break;
 
+		case 'J':
+			do_json = True;
+			break;
+
 		case 'M':
 			initialize_sid = True;
 			break;
@@ -529,6 +560,13 @@ int main(int argc, const char *argv[])
 
 	if (mode == SMB_ACL_VIEW_ALL) {
 		int i;
+		if (do_json) {
+			jsobj = json_new_object();
+			if (json_is_invalid(&jsobj)) {
+				fprintf(stderr, "Failed to generate valid JSON object\n");
+				goto done;
+			}
+		}
 
 		for (i=0; i<lp_numservices(); i++) {
 			TALLOC_CTX *frame = talloc_stackframe();
@@ -540,11 +578,29 @@ int main(int argc, const char *argv[])
 				continue;
 			}
 
-			printf("[%s]\n", service);
-			change_share_sec(frame, service, NULL, SMB_ACL_VIEW);
-			printf("\n");
+			if (do_json) {
+				change_share_sec(frame, service, NULL, SMB_ACL_VIEW, &jsint);
+				retval = json_add_object(&jsobj, service, &jsint);
+				if (retval != 0) {
+					fprintf(stderr,
+						"Failed to add JSON object for [%s]: %s\n",
+						service, strerror(errno));
+					goto done;
+				}
+			}
+			else {
+				printf("[%s]\n", service);
+				change_share_sec(frame, service, NULL, SMB_ACL_VIEW, NULL);
+				printf("\n");
+			}
 			TALLOC_FREE(frame);
 		}
+		if (do_json) {
+			to_free =  json_to_string(talloc_tos(), &jsobj);
+                        printf("%s", to_free);
+			TALLOC_FREE(to_free);
+			json_free(&jsobj);
+		}
 		goto done;
 	}
 
@@ -574,7 +630,7 @@ int main(int argc, const char *argv[])
 		retval = view_sharesec_sddl(sharename);
 		break;
 	default:
-		retval = change_share_sec(ctx, sharename, the_acl, mode);
+		retval = change_share_sec(ctx, sharename, the_acl, mode, NULL);
 		break;
 	}
 
diff --git a/source3/utils/smbcacls.c b/source3/utils/smbcacls.c
index f3209c31877..1ba33f0fa6a 100644
--- a/source3/utils/smbcacls.c
+++ b/source3/utils/smbcacls.c
@@ -32,6 +32,11 @@
 #include "passdb/machine_sid.h"
 #include "../librpc/gen_ndr/ndr_lsa_c.h"
 #include "util_sd.h"
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
+#endif /* [HAVE_JANSSON] */
 
 static int test_args;
 static int sddl;
@@ -425,6 +430,48 @@ static int cacl_dump(struct cli_state *cli, const char *filename, bool numeric)
 	return EXIT_OK;
 }
 
+static int cacl_dump_json(struct cli_state *cli, const char *filename, bool numeric)
+{
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct security_descriptor *sd;
+	struct json_object jsobj;
+	int ret;
+
+	if (test_args) {
+		return EXIT_OK;
+	}
+
+	sd = get_secdesc(cli, filename);
+	if (sd == NULL) {
+		return EXIT_FAILED;
+	}
+
+	if (sddl) {
+		char *str = sddl_encode(talloc_tos(), sd, get_domain_sid(cli));
+		if (str == NULL) {
+			return EXIT_FAILED;
+		}
+		printf("%s\n", str);
+		TALLOC_FREE(str);
+	} else {
+		ret = sec_desc_to_json(cli, &jsobj, sd, numeric, false);
+		if (!ret) {
+			fprintf(stderr, "Failed to get secdesc_json\n");
+			TALLOC_FREE(frame);
+			return ret;
+		}
+		printf("%s", json_to_string(frame, &jsobj));
+	}
+	if (want_mxac) {
+		ret = cacl_mxac(cli, filename);
+		if (ret != EXIT_OK) {
+			return ret;
+		}
+	}
+	TALLOC_FREE(frame);
+	return EXIT_OK;
+}
+
 /***************************************************** 
 Change the ownership or group ownership of a file. Just
 because the NT docs say this can't be done :-). JRA.
@@ -812,6 +859,7 @@ int main(int argc, char *argv[])
 	int result;
 	char *path;
 	char *filename = NULL;
+	bool json_output = false;
 	poptContext pc;
 	/* numeric is set when the user wants numeric SIDs and ACEs rather
 	   than going via LSA calls to resolve them */
@@ -908,6 +956,14 @@ int main(int argc, char *argv[])
 			.val        = 1,
 			.descrip    = "The security-info flags for queries"
 		},
+		{
+			.longName   = "json-output",
+			.shortName  = 'j',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'j',
+			.descrip    = "JSON output"
+		},
 		{
 			.longName   = "set-security-info",
 			.shortName  = 0,
@@ -1011,6 +1067,9 @@ int main(int argc, char *argv[])
 			owner_username = poptGetOptArg(pc);
 			change_mode = REQUEST_INHERIT;
 			break;
+		case 'j':
+			json_output = true;
+			break;
 		case 'm':
 			lp_set_cmdline("client max protocol", poptGetOptArg(pc));
 			break;
@@ -1100,6 +1159,8 @@ int main(int argc, char *argv[])
 		result = owner_set(targetcli, change_mode, targetfile, owner_username);
 	} else if (the_acl) {
 		result = cacl_set(targetcli, targetfile, the_acl, mode, numeric);
+	} else if (json_output) {
+		result = cacl_dump_json(targetcli, filename, numeric);
 	} else {
 		result = cacl_dump(targetcli, targetfile, numeric);
 	}
diff --git a/source3/utils/smbcontrol.c b/source3/utils/smbcontrol.c
index 6836b3ad7db..eefe76e24d2 100644
--- a/source3/utils/smbcontrol.c
+++ b/source3/utils/smbcontrol.c
@@ -1776,5 +1776,6 @@ int main(int argc, const char **argv)
 
 	poptFreeContext(pc);
 	TALLOC_FREE(frame);
+	TALLOC_FREE(msg_ctx);
 	return ret;
 }
diff --git a/source3/utils/status.c b/source3/utils/status.c
index 36f7030e4f4..1cc7470cb72 100644
--- a/source3/utils/status.c
+++ b/source3/utils/status.c
@@ -51,6 +51,12 @@
 #include "cmdline_contexts.h"
 #include "locking/leases_db.h"
 
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
+#endif /* [HAVE_JANSSON] */
+
 #define SMB_MAXPIDS		2048
 static uid_t 		Ucrit_uid = 0;               /* added by OH */
 static struct server_id	Ucrit_pid[SMB_MAXPIDS];  /* Ugly !!! */   /* added by OH */
@@ -64,9 +70,81 @@ static bool processes_only;
 static bool show_brl;
 static bool numeric_only;
 static bool do_checks = true;
+static bool json_output = false;
+static bool csv_output = false;
+static bool resolve_uids = false;
 
 const char *username = NULL;
 
+static const char *session_dialect_str(uint16_t dialect);
+
+#ifdef HAVE_JANSSON
+struct txt2mask {
+	char	*field;
+	int	mask;
+};
+
+struct txt2mask accessmask[] = {
+	{"READ_DATA", FILE_READ_DATA},
+	{"WRITE_DATA", FILE_WRITE_DATA},
+	{"APPEND_DATA", FILE_APPEND_DATA},
+	{"READ_EA", FILE_READ_EA},
+	{"WRITE_EA", FILE_WRITE_EA},
+	{"EXECUTE", FILE_EXECUTE},
+	{"READ_ATTRIBUTES", FILE_READ_ATTRIBUTES},
+	{"WRITE_ATTRIBUTES", FILE_WRITE_ATTRIBUTES},
+	{"DELETE_CHILD", FILE_DELETE_CHILD},
+	{"DELETE", SEC_STD_DELETE},
+	{"READ_CONTROL", SEC_STD_READ_CONTROL},
+	{"WRITE_DAC", SEC_STD_WRITE_DAC},
+	{"SYNCHRONIZE", SEC_STD_SYNCHRONIZE},
+	{"ACCESS_SYSTEM_SECURITY", SEC_FLAG_SYSTEM_SECURITY},
+	{"MAXIMUM_ALLOWED", SEC_FLAG_MAXIMUM_ALLOWED},
+	{"GENERIC_ALL", SEC_GENERIC_ALL},
+	{"GENERIC_EXECUTE", SEC_GENERIC_EXECUTE},
+	{"GENERIC_WRITE", SEC_GENERIC_WRITE},
+	{"GENERIC_READ", SEC_GENERIC_READ},
+	{0, 0}
+};
+
+struct txt2mask oplockmask[] = {
+	{"EXCLUSIVE", EXCLUSIVE_OPLOCK},
+	{"BATCH", BATCH_OPLOCK},
+	{"LEVEL_II", LEVEL_II_OPLOCK},
+	{"LEASE", LEASE_OPLOCK},
+	{0, 0}
+};
+
+struct txt2mask leasemask[] = {
+	{"READ", SMB2_LEASE_READ},
+	{"WRITE", SMB2_LEASE_WRITE},
+	{"HANDLE", SMB2_LEASE_HANDLE},
+	{0, 0}
+};
+
+/*
+ * Convert a mask of some sort (access, oplock, leases),
+ * to key/value pairs in a JSON object.
+ */
+static int map_json_mask(struct json_object *jsobj,
+                         int tomap,
+                         const struct txt2mask *table)
+{
+        const struct txt2mask *a;
+        int ret = 0;
+        for (a = table; a->field !=0; a++) {
+                if (json_add_bool(jsobj,
+                                  a->field,
+                                  (tomap & a->mask)
+                                  ?true:false) < 0){
+                        return -1;
+                }
+        }
+
+        return 0;
+}
+#endif /* [HAVE_JANSSON] */
+
 /* added by OH */
 static void Ucrit_addUid(uid_t uid)
 {
@@ -118,12 +196,634 @@ static bool Ucrit_addPid( struct server_id pid )
 	return True;
 }
 
+#ifdef HAVE_JANSSON
+static int print_share_mode_json(struct file_id fid,
+				 const struct share_mode_data *d,
+				 const struct share_mode_entry *e,
+				 void *private_data)
+{
+	TALLOC_CTX *tmp_ctx = talloc_new(NULL);
+	if (tmp_ctx == NULL) {
+		return -1;
+	}
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+	static int count;
+	const char *denymode = NULL;
+	char *access_mask = NULL;
+	const char *lstate_hex = NULL;
+
+	if (do_checks && !is_valid_share_mode_entry(e)) {
+		TALLOC_FREE(tmp_ctx);
+		json_free(&jsobjint);
+		return 0;
+	}
+
+	count++;
+
+	if (do_checks && !serverid_exists(&e->pid)) {
+		/* the process for this entry does not exist any more */
+		TALLOC_FREE(tmp_ctx);
+		json_free(&jsobjint);
+		return 0;
+	}
+	if (Ucrit_checkPid(e->pid)) {
+		struct server_id_buf tmp;
+		uint denymode_int = 0;
+		denymode_int = map_share_mode_to_deny_mode(e->share_access,
+							   e->private_options);
+
+		if (json_is_invalid(&jsobjint)) {
+			return -1;
+		}
+		if (json_add_string(&jsobjint, "pid",
+				    server_id_str_buf(e->pid, &tmp)) < 0) {
+			goto failure;
+		}
+		if (resolve_uids && (json_add_string(&jsobjint, "username",
+					    uidtoname(e->uid)) < 0)) {
+			goto failure;
+		}
+		if (json_add_int(&jsobjint, "uid", (unsigned int)e->uid) < 0) {
+			goto failure;
+		}
+		switch (denymode_int) {
+			case DENY_NONE: denymode = "DENY_NONE"; break;
+			case DENY_ALL:  denymode = "DENY_ALL"; break;
+			case DENY_DOS:  denymode = "DENY_DOS"; break;
+			case DENY_READ: denymode = "DENY_READ"; break;
+			case DENY_WRITE:denymode = "DENY_WRITE"; break;
+			case DENY_FCB:  denymode = "DENY_FCB"; break;
+			default: {
+				denymode = talloc_asprintf(tmp_ctx,
+							   "UNKNOWN(0x%08x)",
+							   denymode_int);
+				break;
+			}
+		}
+	        struct json_object amask;
+	        amask = json_new_object();
+		if (json_is_invalid(&amask)) {
+			goto failure;
+		}
+		access_mask = talloc_asprintf(tmp_ctx, "0x%08x",
+					      (unsigned int)e->access_mask);
+		if (json_add_string(&amask, "hex", access_mask) < 0) {
+			goto failure;
+		}
+		TALLOC_FREE(access_mask);
+		if (verbose) {
+			if (map_json_mask(&amask, e->access_mask, accessmask) < 0) {
+				json_free(&amask);
+				goto failure;
+			}
+		}
+		if (json_add_object(&jsobjint, "access_mask", &amask) < 0) {
+			json_free(&amask);
+			goto failure;
+		}
+
+		struct json_object oplock;
+		oplock = json_new_object();
+		if (json_is_invalid(&oplock)) {
+			goto failure;
+		}
+
+		struct txt2mask *o;
+		if (map_json_mask(&oplock, e->op_type, oplockmask) < 0) {
+			json_free(&amask);
+			goto failure;
+		}
+		if (json_add_object(&jsobjint, "oplock", &oplock) < 0) {
+			json_free(&oplock);
+			goto failure;
+		}
+
+		struct json_object lease;
+		lease = json_new_object();
+		if (json_is_invalid(&lease)) {
+			goto failure;
+		}
+		if (e->op_type & LEASE_OPLOCK) {
+			NTSTATUS status;
+			uint32_t lstate;
+
+			status = leases_db_get(
+				&e->client_guid,
+				&e->lease_key,
+				&d->id,
+				&lstate, /* current_state */
+				NULL, /* breaking */
+				NULL, /* breaking_to_requested */
+				NULL, /* breaking_to_required */
+				NULL, /* lease_version */
+				NULL); /* epoch */
+
+			if (NT_STATUS_IS_OK(status)) {
+				if (map_json_mask(&lease,
+						  lstate,
+						  leasemask) < 0) {
+					json_free(&lease);
+					goto failure;
+				}
+			}
+			if (lstate > SMB2_LEASE_WRITE) {
+				const char *lstate_hex;
+				lstate_hex = talloc_asprintf(tmp_ctx,
+							     "0x%04x",
+							     lstate);
+				if (json_add_bool(&lease,
+						  "UNKNOWN",
+						  lstate_hex) < 0) {
+					json_free(&lease);
+					goto failure;
+				}
+			}
+			if (json_add_object(&jsobjint, "lease", &lease) < 0) {
+				json_free(&lease);
+				goto failure;
+			}
+		}
+		else {
+			if (map_json_mask(&lease, 0, leasemask) < 0) {
+				json_free(&lease);
+				goto failure;
+			}
+			if (json_add_object(&jsobjint, "lease", &lease) < 0) {
+				json_free(&lease);
+				goto failure;
+			}
+		}
+		if (json_add_string(&jsobjint, "service_path", d->servicepath) < 0) {
+			goto failure;
+		}
+		char *filename = NULL;
+		filename = talloc_asprintf(tmp_ctx, "%s%s", d->base_name,
+			(d->stream_name != NULL) ? d->stream_name : "");
+		if (json_add_string(&jsobjint, "filename", filename) < 0) {
+			TALLOC_FREE(filename);
+			goto failure;
+		}
+		if (json_add_object(&jsobj, NULL, &jsobjint) < 0) {
+			goto failure;
+		}
+	}
+	TALLOC_FREE(tmp_ctx);
+	return 0;
+
+failure:
+	TALLOC_FREE(tmp_ctx);
+	json_free(&jsobjint);
+	return -1;
+}
+
+static void print_brl_json(struct file_id id,
+			struct server_id pid,
+			enum brl_type lock_type,
+			enum brl_flavour lock_flav,
+			br_off start,
+			br_off size,
+			void *private_data)
+{
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+	static int count;
+	unsigned int i;
+	static const struct {
+		enum brl_type lock_type;
+		const char *desc;
+	} lock_types[] = {
+		{ READ_LOCK, "R" },
+		{ WRITE_LOCK, "W" },
+		{ UNLOCK_LOCK, "U" }
+	};
+	const char *desc="X";
+	const char *sharepath = "";
+	char *fname = NULL;
+	struct share_mode_lock *share_mode;
+	struct server_id_buf tmp;
+	struct file_id_buf ftmp;
+
+	count++;
+
+	share_mode = fetch_share_mode_unlocked(NULL, id);
+	if (share_mode) {
+		bool has_stream = share_mode->data->stream_name != NULL;
+
+		fname = talloc_asprintf(NULL, "%s%s%s",
+					share_mode->data->base_name,
+					has_stream ? ":" : "",
+					has_stream ?
+					share_mode->data->stream_name :
+					"");
+	} else {
+		fname = talloc_strdup(NULL, "");
+		if (fname == NULL) {
+			return;
+		}
+	}
+
+	for (i=0;i<ARRAY_SIZE(lock_types);i++) {
+		if (lock_type == lock_types[i].lock_type) {
+			desc = lock_types[i].desc;
+		}
+	}
+	if (json_is_invalid(&jsobjint)) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "pid",
+			    server_id_str_buf(pid, &tmp)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "dev_inode",
+			    file_id_str_buf(id, &ftmp)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "read_write", desc) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "start", (intmax_t)start) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "size", (intmax_t)size) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "share_path", sharepath) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "file_name", fname) < 0) {
+		goto failure;
+	}
+	if (json_add_object(&jsobj, NULL, &jsobjint) < 0) {
+		goto failure;
+	}
+
+	TALLOC_FREE(fname);
+	TALLOC_FREE(share_mode);
+
+failure:
+	TALLOC_FREE(fname);
+	TALLOC_FREE(share_mode);
+	json_free(&jsobjint);
+}
+
+static int traverse_connections_json(const struct connections_key *key,
+				const struct connections_data *crec,
+				void *private_data)
+{
+	TALLOC_CTX *tmp_ctx = talloc_new(NULL);
+	if (tmp_ctx == NULL) {
+		return -1;
+	}
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+	struct server_id_buf tmp;
+	char *timestr = NULL;
+	int result = 0;
+	const char *encryption = "-";
+	const char *signing = "-";
+	if (json_is_invalid(&jsobjint)) {
+		TALLOC_FREE(tmp_ctx);
+		return -1;
+	}
+
+	if (crec->cnum == TID_FIELD_INVALID)
+		TALLOC_FREE(tmp_ctx);
+		json_free(&jsobjint);
+		return 0;
+
+	if (do_checks &&
+	    (!process_exists(crec->pid) || !Ucrit_checkUid(crec->uid))) {
+		TALLOC_FREE(tmp_ctx);
+		json_free(&jsobjint);
+		return 0;
+	}
+
+	timestr = timestring(tmp_ctx, crec->start);
+	if (timestr == NULL) {
+		goto failure;
+	}
+
+	if (smbXsrv_is_encrypted(crec->encryption_flags)) {
+		switch (crec->cipher) {
+		case SMB_ENCRYPTION_GSSAPI:
+			encryption = "GSSAPI";
+			break;
+		case SMB2_ENCRYPTION_AES128_CCM:
+			encryption = "AES-128-CCM";
+			break;
+		case SMB2_ENCRYPTION_AES128_GCM:
+			encryption = "AES-128-GCM";
+			break;
+		default:
+			encryption = talloc_asprintf(tmp_ctx,
+						     "UNKNOWN(0x%08x)",
+						     crec->cipher);
+			result = -1;
+			break;
+		}
+	}
+
+	if (smbXsrv_is_signed(crec->signing_flags)) {
+		switch (crec->dialect) {
+		case SMB3_DIALECT_REVISION_311:
+		case SMB3_DIALECT_REVISION_302:
+			signing = "AES-128-CMAC";
+			break;
+		case SMB2_DIALECT_REVISION_2FF:
+		case SMB2_DIALECT_REVISION_224:
+		case SMB2_DIALECT_REVISION_222:
+		case SMB2_DIALECT_REVISION_210:
+		case SMB2_DIALECT_REVISION_202:
+			signing = "HMAC-SHA256";
+			break;
+		case SMB2_DIALECT_REVISION_000:
+			signing = "HMAC-MD5";
+			break;
+		default:
+			signing = talloc_asprintf(tmp_ctx,
+						  "UNKNOWN_DIALECT(0x%08x)",
+						  crec->dialect);
+			result = -1;
+			break;
+		}
+	}
+
+	if (json_add_string(&jsobjint, "service", crec->servicename) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "pid",
+			    server_id_str_buf(crec->pid, &tmp)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "machine", crec->machine) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "connected_at", timestr) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "encryption", encryption) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "signing", signing) < 0) {
+		goto failure;
+	}
+	if (json_add_object(&jsobj, NULL, &jsobjint) < 0) {
+		goto failure;
+	}
+
+	TALLOC_FREE(tmp_ctx);
+	return result;
+
+failure:
+	TALLOC_FREE(tmp_ctx);
+	json_free(&jsobjint);
+	return -1;
+}
+
+static int traverse_sessionid_json(const char *key, struct sessionid *session,
+				    void *private_data)
+{
+	TALLOC_CTX *tmp_ctx = talloc_new(NULL);
+	if (tmp_ctx == NULL) {
+		return -1;
+	}
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+	struct server_id_buf tmp;
+	int result = 0;
+	const char *encryption = "-";
+	const char *signing = "-";
+
+	if (do_checks &&
+	    (!process_exists(session->pid) ||
+	     !Ucrit_checkUid(session->uid))) {
+		return 0;
+	}
+
+	Ucrit_addPid(session->pid);
+
+	if (json_is_invalid(&jsobjint)) {
+		return -1;
+	}
+
+	if (json_add_int(&jsobjint, "uid",
+			 (unsigned int)session->uid) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "gid",
+			 (unsigned int)session->gid) < 0) {
+		goto failure;
+	}
+	if (!numeric_only) {
+		if (session->uid == -1 && session->gid == -1) {
+			/*
+			 * The session is not fully authenticated yet.
+			 */
+			if (json_add_string(&jsobjint, "username",
+					    "(auth in progress)") < 0) {
+				goto failure;
+			}
+			if (json_add_string(&jsobjint, "groupname",
+					    "(auth in progress)") < 0) {
+				goto failure;
+			}
+		} else {
+			/*
+			 * In theory it should not happen that one of
+			 * session->uid and session->gid is valid (ie != -1)
+			 * while the other is not (ie = -1), so we a check for
+			 * that case that bails out would be reasonable.
+			 */
+			const char *uid_name = "-1";
+			const char *gid_name = "-1";
+
+			if (session->uid != -1) {
+				uid_name = uidtoname(session->uid);
+				if (uid_name == NULL) {
+					return -1;
+				}
+			}
+			if (session->gid != -1) {
+				gid_name = gidtoname(session->gid);
+				if (gid_name == NULL) {
+					return -1;
+				}
+			}
+			if (json_add_string(&jsobjint, "username",
+					    uid_name) < 0) {
+				goto failure;
+			}
+			if (json_add_string(&jsobjint, "groupname",
+					    gid_name) < 0) {
+				goto failure;
+			}
+		}
+	}
+
+	if (smbXsrv_is_encrypted(session->encryption_flags)) {
+		switch (session->cipher) {
+		case SMB2_ENCRYPTION_AES128_CCM:
+			encryption = "AES-128-CCM";
+			break;
+		case SMB2_ENCRYPTION_AES128_GCM:
+			encryption = "AES-128-GCM";
+			break;
+		default:
+			encryption = talloc_asprintf(tmp_ctx,
+						     "UNKNOWN(0x%08x)",
+						     session->cipher);
+			result = -1;
+			break;
+		}
+	} else if (smbXsrv_is_partially_encrypted(session->encryption_flags)) {
+		switch (session->cipher) {
+		case SMB_ENCRYPTION_GSSAPI:
+			encryption = "partial(GSSAPI)";
+			break;
+		case SMB2_ENCRYPTION_AES128_CCM:
+			encryption = "partial(AES-128-CCM)";
+			break;
+		case SMB2_ENCRYPTION_AES128_GCM:
+			encryption = "partial(AES-128-GCM)";
+			break;
+		default:
+			encryption = talloc_asprintf(tmp_ctx,
+						     "UNKNOWN(0x%08x)",
+						     session->cipher);
+			result = -1;
+			break;
+		}
+	}
+
+	if (smbXsrv_is_signed(session->signing_flags)) {
+		switch (session->connection_dialect) {
+		case SMB3_DIALECT_REVISION_311:
+		case SMB3_DIALECT_REVISION_302:
+			signing = "AES-128-CMAC";
+			break;
+		case SMB2_DIALECT_REVISION_2FF:
+		case SMB2_DIALECT_REVISION_224:
+		case SMB2_DIALECT_REVISION_222:
+		case SMB2_DIALECT_REVISION_210:
+		case SMB2_DIALECT_REVISION_202:
+			signing = "HMAC-SHA256";
+			break;
+		case SMB2_DIALECT_REVISION_000:
+			signing = "HMAC-MD5";
+			break;
+		default:
+			signing = talloc_asprintf(tmp_ctx,
+						  "UNKNOWN_DIALECT(0x%08x)",
+						  session->connection_dialect);
+			result = -1;
+			break;
+		}
+	} else if (smbXsrv_is_partially_signed(session->signing_flags)) {
+		switch (session->connection_dialect) {
+		case SMB3_DIALECT_REVISION_311:
+		case SMB3_DIALECT_REVISION_302:
+			signing = "AES-128-CMAC";
+			break;
+		case SMB2_DIALECT_REVISION_2FF:
+		case SMB2_DIALECT_REVISION_224:
+		case SMB2_DIALECT_REVISION_222:
+		case SMB2_DIALECT_REVISION_210:
+		case SMB2_DIALECT_REVISION_202:
+			signing = "HMAC-SHA256";
+			break;
+		case SMB2_DIALECT_REVISION_000:
+			signing = "HMAC-MD5";
+			break;
+		default:
+			signing = talloc_asprintf(tmp_ctx,
+						  "UNKNOWN_DIALECT(0x%08x)",
+						  session->connection_dialect);
+			result = -1;
+			break;
+		}
+	}
+
+	if (json_add_string(&jsobjint, "remote_machine",
+			    session->remote_machine) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "hostname", session->hostname) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "session_dialect",
+		    session_dialect_str(session->connection_dialect)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "encryption", encryption) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "signing", signing) < 0) {
+		goto failure;
+	}
+	if (json_add_object(&jsobj, server_id_str_buf(session->pid, &tmp), &jsobjint) < 0) {
+		goto failure;
+	}
+
+	TALLOC_FREE(tmp_ctx);
+	return result;
+
+failure:
+	TALLOC_FREE(tmp_ctx);
+	json_free(&jsobjint);
+	return -1;
+}
+
+static bool print_notify_rec_json(const char *path, struct server_id server,
+			     const struct notify_instance *instance,
+			     void *private_data)
+{
+	struct server_id_buf idbuf;
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+
+	if (json_is_invalid(&jsobjint)) {
+		return false;
+	}
+	if (json_add_string(&jsobjint, "pid", server_id_str_buf(server, &idbuf)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "path", path) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "filter", (unsigned)instance->filter) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "subdir_filter", (unsigned)instance->subdir_filter) < 0) {
+		goto failure;
+	}
+	if (json_add_object(&jsobj, NULL, &jsobjint) < 0) {
+		goto failure;
+	}
+
+	return true;
+
+failure:
+	json_free(&jsobjint);
+	return false;
+}
+#endif /* [HAVE_JANSSON] */
+
 static int print_share_mode(struct file_id fid,
 			    const struct share_mode_data *d,
 			    const struct share_mode_entry *e,
 			    void *private_data)
 {
-	bool resolve_uids = *((bool *)private_data);
 	static int count;
 
 	if (do_checks && !is_valid_share_mode_entry(e)) {
@@ -510,7 +1210,6 @@ static int traverse_sessionid(const char *key, struct sessionid *session,
 	return result;
 }
 
-
 static bool print_notify_rec(const char *path, struct server_id server,
 			     const struct notify_instance *instance,
 			     void *private_data)
@@ -531,11 +1230,12 @@ enum {
 int main(int argc, const char *argv[])
 {
 	int c;
+	uint64_t interval = 1;
 	int profile_only = 0;
 	bool show_processes, show_locks, show_shares;
 	bool show_notify = false;
-	bool resolve_uids = false;
 	poptContext pc = NULL;
+	enum PROFILE_OUTPUT pout = PROF_TEXT;
 	struct poptOption long_options[] = {
 		POPT_AUTOHELP
 		{
@@ -610,6 +1310,14 @@ int main(int argc, const char *argv[])
 			.val        = 'R',
 			.descrip    = "Show call rates",
 		},
+		{
+			.longName   = "profile-timed-dump",
+			.shortName  = 'D',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'D',
+			.descrip    = "Show call rates",
+		},
 		{
 			.longName   = "byterange",
 			.shortName  = 'B',
@@ -626,6 +1334,30 @@ int main(int argc, const char *argv[])
 			.val        = 'n',
 			.descrip    = "Numeric uid/gid"
 		},
+		{
+			.longName   = "json",
+			.shortName  = 'j',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'j',
+			.descrip    = "JSON output"
+		},
+		{
+			.longName   = "csv",
+			.shortName  = 'c',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'c',
+			.descrip    = "CSV output"
+		},
+		{
+			.longName   = "sample-interval",
+			.shortName  = 'i',
+			.argInfo    = POPT_ARG_INT,
+			.arg        = &interval,
+			.val        = 'i',
+			.descrip    = "CSV output"
+		},
 		{
 			.longName   = "fast",
 			.shortName  = 'f',
@@ -657,14 +1389,37 @@ int main(int argc, const char *argv[])
 	setup_logging(argv[0], DEBUG_STDERR);
 	lp_set_cmdline("log level", "0");
 
+	#ifdef HAVE_JANSSON
+	struct json_object jsobj = json_new_object();
+	#else /* [HAVE_JANSSON] */
+	if (json_output) {
+		fprintf(stderr, "JSON support not available\n");
+		goto done;
+	}
+	#endif /* [HAVE_JANSSON] */
+	if (json_output && csv_output) {
+		fprintf(stderr, "simultaneous CSV and json output not permitted\n");
+		goto done;
+	}
+
 	if (getuid() != geteuid()) {
-		d_printf("smbstatus should not be run setuid\n");
+		if (json_output) {
+			fprintf(stderr, "smbstatus should not be run setuid\n");
+		}
+		else {
+			d_printf("smbstatus should not be run setuid\n");
+		}
 		ret = 1;
 		goto done;
 	}
 
 	if (getuid() != 0) {
-		d_printf("smbstatus only works as root!\n");
+		if (json_output) {
+			fprintf(stderr, "smbstatus only works as root!\n");
+		}
+		else {
+			d_printf("smbstatus only works as root!\n");
+		}
 		ret = 1;
 		goto done;
 	}
@@ -696,6 +1451,7 @@ int main(int argc, const char *argv[])
 		case 'u':
 			Ucrit_addUid(nametouid(poptGetOptArg(pc)));
 			break;
+		case 'D':
 		case 'P':
 		case 'R':
 			profile_only = c;
@@ -706,6 +1462,16 @@ int main(int argc, const char *argv[])
 		case 'n':
 			numeric_only = true;
 			break;
+		case 'j':
+			json_output = true;
+			pout = PROF_JSON;
+			break;
+		case 'c':
+			csv_output = true;
+			pout = PROF_CSV;
+			break;
+		case 'i':
+			break;
 		case 'f':
 			do_checks = false;
 			break;
@@ -724,13 +1490,18 @@ int main(int argc, const char *argv[])
 	if ( username )
 		Ucrit_addUid( nametouid(username) );
 
-	if (verbose) {
+	if (verbose && !json_output) {
 		d_printf("using configfile = %s\n", get_dyn_CONFIGFILE());
 	}
 
 	msg_ctx = cmdline_messaging_context(get_dyn_CONFIGFILE());
 	if (msg_ctx == NULL) {
-		fprintf(stderr, "Could not initialize messaging, not root?\n");
+		if (json_output) {
+			fprintf(stderr, "Could not initialize messaging, not root?\n");
+		}
+		else {
+			fprintf(stderr, "Could not initialize messaging, not root?\n");
+		}
 		ret = -1;
 		goto done;
 	}
@@ -745,7 +1516,7 @@ int main(int argc, const char *argv[])
 	switch (profile_only) {
 		case 'P':
 			/* Dump profile data */
-			ok = status_profile_dump(verbose);
+			ok = status_profile_dump(verbose, pout);
 			ret = ok ? 0 : 1;
 			goto done;
 		case 'R':
@@ -753,16 +1524,41 @@ int main(int argc, const char *argv[])
 			ok = status_profile_rates(verbose);
 			ret = ok ? 0 : 1;
 			goto done;
+		case 'D':
+			/* Continuously display profile dump (Big D)*/
+			fprintf(stderr, "Sampling interval: %lu\n", interval);
+			ok = status_profile_timed_dump(verbose, pout, interval);
+			ret = ok ? 0 : 1;
+			goto done;
 		default:
 			break;
 	}
 
 	if ( show_processes ) {
-		d_printf("\nSamba version %s\n",samba_version_string());
-		d_printf("%-7s %-12s %-12s %-41s %-17s %-20s %-21s\n", "PID", "Username", "Group", "Machine", "Protocol Version", "Encryption", "Signing");
-		d_printf("----------------------------------------------------------------------------------------------------------------------------------------\n");
+		if (!json_output) {
+			d_printf("\nSamba version %s\n",samba_version_string());
+			d_printf("%-7s %-12s %-12s %-41s %-17s %-20s %-21s\n", "PID", "Username", "Group", "Machine", "Protocol Version", "Encryption", "Signing");
+			d_printf("----------------------------------------------------------------------------------------------------------------------------------------\n");
+			sessionid_traverse_read(traverse_sessionid, frame);
+		}
+		#ifdef HAVE_JANSSON
+		else {
+			struct json_object sessions = json_new_object();
+			if (json_is_invalid(&sessions)) {
+				fprintf(stderr, "Failed to create JSON object [sessions]\n");
+				ret = -1;
+				goto done;
+			}
 
-		sessionid_traverse_read(traverse_sessionid, frame);
+			sessionid_traverse_read(traverse_sessionid_json, &sessions);
+			if (json_add_object(&jsobj, "sessions", &sessions) < 0) {
+				fprintf(stderr, "Failed to add JSON object [sessions]\n");
+				json_free(&sessions);
+				ret = -1;
+				goto done;
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 
 		if (processes_only) {
 			goto done;
@@ -774,12 +1570,32 @@ int main(int argc, const char *argv[])
 			goto done;
 		}
 
-		d_printf("\n%-12s %-7s %-13s %-32s %-12s %-12s\n", "Service", "pid", "Machine", "Connected at", "Encryption", "Signing");
-		d_printf("---------------------------------------------------------------------------------------------\n");
-
-		connections_forall_read(traverse_connections, frame);
+		if (!json_output) {
+			d_printf("\n%-12s %-7s %-13s %-32s %-12s %-12s\n", "Service", "pid", "Machine", "Connected at", "Encryption", "Signing");
+			d_printf("---------------------------------------------------------------------------------------------\n");
+			connections_forall_read(traverse_connections, frame);
+		}
+		#ifdef HAVE_JANSSON
+		else {
+			struct json_object shares_array = json_new_array();
+			if (json_is_invalid(&shares_array)) {
+				fprintf(stderr, "Failed to create JSON array [shares_array]\n");
+				ret = 1;
+				goto done;
+			}
+			connections_forall_read(traverse_connections_json, &shares_array);
+			if (json_add_object(&jsobj, "shares", &shares_array) < 0) {
+				fprintf(stderr, "Failed to add JSON array [shares_array]\n");
+				json_free(&shares_array);
+				ret = -1;
+				goto done;
+			}
 
-		d_printf("\n");
+			if (!json_output) {
+				d_printf("\n");
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 
 		if ( shares_only ) {
 			goto done;
@@ -792,7 +1608,12 @@ int main(int argc, const char *argv[])
 
 		db_path = lock_path(talloc_tos(), "locking.tdb");
 		if (db_path == NULL) {
-			d_printf("Out of memory - exiting\n");
+			if (json_output) {
+				fprintf(stderr, "Out of memory - exiting\n");
+			}
+			else {
+				d_printf("Out of memory - exiting\n");
+			}
 			ret = -1;
 			goto done;
 		}
@@ -802,9 +1623,16 @@ int main(int argc, const char *argv[])
 			     DBWRAP_LOCK_ORDER_1, DBWRAP_FLAG_NONE);
 
 		if (!db) {
-			d_printf("%s not initialised\n", db_path);
-			d_printf("This is normal if an SMB client has never "
-				 "connected to your server.\n");
+			if (json_output) {
+				fprintf(stderr, "%s not initialised\n", db_path);
+				fprintf(stderr, "This is normal if an SMB client has never "
+					 "connected to your server.\n");
+			}
+			else {
+				d_printf("%s not initialised\n", db_path);
+				d_printf("This is normal if an SMB client has never "
+					 "connected to your server.\n");
+			}
 			TALLOC_FREE(db_path);
 			exit(0);
 		} else {
@@ -817,20 +1645,66 @@ int main(int argc, const char *argv[])
 			ret = 1;
 			goto done;
 		}
-
-		result = share_entry_forall(print_share_mode, &resolve_uids);
+		if (!json_output) {
+			result = share_entry_forall(print_share_mode, NULL);
+		}
+		#if HAVE_JANSSON
+		else {
+			struct json_object locks_array = json_new_array();
+			if (json_is_invalid(&locks_array)) {
+				locking_end();
+				fprintf(stderr, "Failed to create JSON array [locks_array]\n");
+				ret = 1;
+				goto done;
+			}
+			result = share_entry_forall(print_share_mode_json, &locks_array);
+			if (json_add_object(&jsobj, "locked_files", &locks_array) < 0) {
+				locking_end();
+				fprintf(stderr, "Failed to add JSON array [locks_array]\n");
+				ret = 1;
+				goto done;
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 
 		if (result == 0) {
-			d_printf("No locked files\n");
+			if (!json_output) {
+				d_printf("No locked files\n");
+			}
 		} else if (result < 0) {
-			d_printf("locked file list truncated\n");
+			if (json_output) {
+				fprintf(stderr, "locked file list truncated\n");
+			}
+			else {
+				d_printf("locked file list truncated\n");
+			}
 		}
 
-		d_printf("\n");
+		if (!json_output) {
+			d_printf("\n");
+		}
 
-		if (show_brl) {
+		if (show_brl && !json_output) {
 			brl_forall(print_brl, NULL);
 		}
+		#if HAVE_JANSSON
+		else if (show_brl) {
+			struct json_object brl_array = json_new_array();
+			if (json_is_invalid(&brl_array)) {
+				locking_end();
+				fprintf(stderr, "Failed to create JSON array [brl_array]\n");
+				ret = 1;
+				goto done;
+			}
+			brl_forall(print_brl_json, &brl_array);
+			if (json_add_object(&jsobj, "brl", &brl_array) < 0) {
+				locking_end();
+				fprintf(stderr, "Failed to add JSON array [brl_array]\n");
+				ret = 1;
+				goto done;
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 
 		locking_end();
 	}
@@ -843,12 +1717,41 @@ int main(int argc, const char *argv[])
 		if (n == NULL) {
 			goto done;
 		}
-		notify_walk(n, print_notify_rec, NULL);
+		if (!json_output) {
+			notify_walk(n, print_notify_rec, NULL);
+		}
+		#if HAVE_JANSSON
+		else {
+			struct json_object notify_array = json_new_array();
+			if (json_is_invalid(&notify_array)) {
+				locking_end();
+				fprintf(stderr, "Failed to create JSON array [notify_array]\n");
+				ret = 1;
+				goto done;
+			}
+			notify_walk(n, print_notify_rec_json, &notify_array);
+			if (json_add_object(&jsobj, "notify", &notify_array) < 0) {
+				locking_end();
+				fprintf(stderr, "Failed to add JSON array [notify_array]\n");
+				ret = 1;
+				goto done;
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 		TALLOC_FREE(n);
 	}
 
 done:
 	poptFreeContext(pc);
+	#ifdef HAVE_JANSSON
+	if (json_output && !profile_only) {
+		d_printf("%s\n", json_to_string(frame, &jsobj));
+	}
+	json_free(&jsobj);
+	#endif /* [HAVE_JANSSON] */
 	TALLOC_FREE(frame);
+	if (msg_ctx) {
+		TALLOC_FREE(msg_ctx);
+	}
 	return ret;
 }
diff --git a/source3/utils/status_profile.c b/source3/utils/status_profile.c
index 829e84cef1c..5f6a9db855d 100644
--- a/source3/utils/status_profile.c
+++ b/source3/utils/status_profile.c
@@ -21,43 +21,130 @@
 #include "includes.h"
 #include "smbprofile.h"
 #include "status_profile.h"
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
 
-static void profile_separator(const char * title)
-{
-    char line[79 + 1];
-    char * end;
-
-    snprintf(line, sizeof(line), "**** %s ", title);
+static bool first_done;
+static bool header_complete;
 
-    for (end = line + strlen(line); end < &line[sizeof(line) -1]; ++end) {
-	    *end = '*';
-    }
+static void profile_separator(const char * title, struct json_object jsobj,
+			      struct json_object *jo, enum PROFILE_OUTPUT proft)
+{
+	int ret;
+	size_t tlen;
+	char l[80] = {0};
+	char * end;
+	switch (proft) {
+	case PROF_TEXT:
+		snprintf(l, sizeof(l), "**** %s ", title);
+
+		for (end = l + strlen(l); end < &l[sizeof(l) -1]; ++end) {
+			*end = '*';
+		}
 
-    line[sizeof(line) - 1] = '\0';
-    d_printf("%s\n", line);
+		l[sizeof(l) - 1] = '\0';
+		d_printf("%s\n", l);
+		break;
+	case PROF_JSON:
+		tlen = strlen(title);
+		SMB_ASSERT(tlen < 80);
+		memcpy(l, title + 1, (tlen -2));
+
+		*jo = json_new_object();
+		if (json_is_invalid(jo)) {
+			fprintf(stderr, "jo is invalid JSON\n");
+			return;
+		}
+		ret = json_add_object(&jsobj, l, jo);
+		if (ret != 0) {
+			fprintf(stderr, "failed to add new json object: %s\n",
+				title);
+		}
+		break;
+	case PROF_CSV:
+		break;
+	}
+	return;
 }
 
 /*******************************************************************
  dump the elements of the profile structure
   ******************************************************************/
-bool status_profile_dump(bool verbose)
+bool status_profile_dump(bool verbose,  enum PROFILE_OUTPUT proft)
 {
+	TALLOC_CTX *mem_ctx = NULL;
+	int ret;
 	struct profile_stats stats = {};
+	struct json_object jo, jsobj;
+	bool json, csv;
+	char fname[80] = {0};
+	char elem[3] = {0};
+	char csvout[1024] = {0};
+	struct timeval tv;
 
 	if (!profile_setup(NULL, True)) {
 		fprintf(stderr,"Failed to initialise profile memory\n");
 		return False;
 	}
+	if (proft == PROF_JSON) {
+		mem_ctx = talloc_new(NULL);
+		if (mem_ctx == NULL) {
+			fprintf(stderr, "talloc_new() failed\n");
+			return False;
+		}
+		jsobj = json_new_object();
+		if (json_is_invalid(&jsobj)) {
+			fprintf(stderr, "jsobj is invalid\n");
+			return False;
+		}
+		ret = json_add_timestamp(&jsobj);
+		if (ret < 0) {
+			fprintf(stderr, "Failed to add timestamp to JSON.\n");
+			json_free(&jsobj);
+			return False;
+		}
+	}
 
 	smbprofile_collect(&stats);
 
 #define __PRINT_FIELD_LINE(name, _stats, field) do { \
-	d_printf("%-59s%20ju\n", \
-		 name "_" #field ":", \
-		 (uintmax_t)stats.values._stats.field); \
+	uintmax_t val = (uintmax_t)stats.values._stats.field; \
+	if (proft == PROF_JSON) { \
+		snprintf(fname, sizeof(fname), "%s_%s", name, #field); \
+		if (json_add_int(&jo, fname, val) < 0) { \
+			json_free(&jsobj); \
+			return False; \
+		} \
+	} \
+	else if (proft == PROF_CSV) { \
+		if (!header_complete) { \
+			if (!first_done) { \
+				printf("timestamp"); \
+				gettimeofday(&tv, NULL); \
+				snprintf(csvout, sizeof(csvout), "%ld", tv.tv_sec); \
+			} \
+			printf(",%s_%s", name, #field); \
+			snprintf(elem, sizeof(elem), ",%lu", val); \
+		} \
+		else { \
+			if (!first_done) { \
+				gettimeofday(&tv, NULL); \
+				snprintf(csvout, sizeof(csvout), "%ld", tv.tv_sec); \
+			} \
+			snprintf(elem, sizeof(elem), ",%lu", val); \
+		} \
+		first_done = True; \
+		strncat(csvout, elem, sizeof(csvout) - strlen(csvout) - 1); \
+	} \
+	else {\
+		d_printf("%-59s%20ju\n", \
+			 name "_" #field ":", \
+			 val); \
+	}\
 } while(0);
 #define SMBPROFILE_STATS_START
-#define SMBPROFILE_STATS_SECTION_START(name, display) profile_separator(#display);
+#define SMBPROFILE_STATS_SECTION_START(name, display) profile_separator(#display, jsobj, &jo, proft);
 #define SMBPROFILE_STATS_COUNT(name) do { \
 	__PRINT_FIELD_LINE(#name, name##_stats,  count); \
 } while(0);
@@ -95,6 +182,19 @@ bool status_profile_dump(bool verbose)
 #undef SMBPROFILE_STATS_SECTION_END
 #undef SMBPROFILE_STATS_END
 
+	first_done = False;
+	if (proft == PROF_JSON) {
+		printf("%s\n", json_to_string(mem_ctx, &jsobj));
+		TALLOC_FREE(mem_ctx);
+		json_free(&jsobj);
+	}
+	else if (proft == PROF_CSV) {
+		if (!header_complete) {
+			printf("\n");
+		}
+		printf("%s\n", csvout);
+	}
+	header_complete = True;
 	return True;
 }
 
@@ -361,3 +461,41 @@ bool status_profile_rates(bool verbose)
 
 	return True;
 }
+
+bool status_profile_timed_dump(bool verbose, enum PROFILE_OUTPUT proft, uint64_t sample_interval)
+{
+	uint64_t remain_usec;
+	uint64_t next_usec;
+	uint64_t delta_usec;
+	uint64_t interval;
+	bool ret;
+	int last = 0;
+	int current = 1;
+	int tmp;
+	interval = sample_interval * one_second_usec;
+
+	for (;/*ever*/;) {
+		sample_time[current] = profile_timestamp();
+		next_usec = sample_time[current] + interval;
+		ret = status_profile_dump(verbose, proft);
+		if (!ret) {
+			fprintf(stderr, "Timed dump failed\n");
+			return False;
+		}
+		last = current;
+		current = tmp;
+		ret = fflush(stdout);
+		if (ret != 0) {
+			fprintf(stderr, "Failed to flush output stream: %s\n",
+				strerror(errno));
+			return False;
+		}
+		remain_usec = next_usec - profile_timestamp();
+		if (remain_usec > interval) {
+			fprintf(stderr, "eek! falling behind sampling rate!\n");
+		} else {
+			usleep(remain_usec);
+		}
+	}
+	return True;
+}
diff --git a/source3/utils/status_profile.h b/source3/utils/status_profile.h
index a8a73e12178..485a55e6d2a 100644
--- a/source3/utils/status_profile.h
+++ b/source3/utils/status_profile.h
@@ -21,8 +21,10 @@
 #define __STATUS_PROFILE_H__
 
 #include "replace.h"
+enum PROFILE_OUTPUT {PROF_TEXT, PROF_CSV, PROF_JSON};
 
-bool status_profile_dump(bool be_verbose);
+bool status_profile_dump(bool be_verbose, enum PROFILE_OUTPUT proft);
 bool status_profile_rates(bool be_verbose);
+bool status_profile_timed_dump(bool be_verbose, enum PROFILE_OUTPUT proft, uint64_t sample_interval);
 
 #endif
