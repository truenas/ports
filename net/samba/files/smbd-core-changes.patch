diff --git a/docs-xml/smbdotconf/misc/smbdmaxxattrsize.xml b/docs-xml/smbdotconf/misc/smbdmaxxattrsize.xml
new file mode 100644
index 00000000000..dde01088c8f
--- /dev/null
+++ b/docs-xml/smbdotconf/misc/smbdmaxxattrsize.xml
@@ -0,0 +1,28 @@
+<samba:parameter name="smbd max xattr size"
+                 context="S"
+                 type="integer"
+                 xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
+<description>
+	<para>
+	  This parameter controls the maximum size of extended attributes
+	  that may be written to the server as EAs or as alternate data
+	  streams if vfs_streams_xattr is enabled. The maximum size of
+	  extended attributes depends on the Samba server's operating system
+	  and the underlying filesystem. The Linux VFS currently sets an
+	  upper boundary of 64 KiB per extended attribute. FreeBSD does not
+	  set a practical upper limit, but since pread() and pwrite() are not
+	  possible via the extattr on FreeBSD, it is not recommended to
+	  increase this value above a few MiB.
+
+	  If a client attempts to write an overly-large alternate datastream,
+	  the Samba server will return STATUS_FILESYSTEM_LIMITATION.
+	  If this error is encountered, users may try increasing the maximum
+	  size supported for xattr writes. If this is not possible, and
+	  writes are from a MacOS client and to an AFP_Resource extended
+	  attribute, the user may enable the vfs_fruit module and configure
+	  to allow stream writes for AFP_Resource to an alternative storage
+	  location. See vfs_fruit documentation for further details.
+	</para>
+</description>
+<value type="default">2097152</value>
+</samba:parameter>
diff --git a/lib/param/loadparm.c b/lib/param/loadparm.c
index 006caabc092..2cba4eb71b2 100644
--- a/lib/param/loadparm.c
+++ b/lib/param/loadparm.c
@@ -3079,6 +3079,10 @@ struct loadparm_context *loadparm_init(TALLOC_CTX *mem_ctx)
 	lpcfg_do_global_parameter(
 		lp_ctx, "ldap max search request size", "256000");
 
+	lpcfg_do_global_parameter(lp_ctx,
+				  "smbd max xattr size",
+				  "2097152");
+
 	for (i = 0; parm_table[i].label; i++) {
 		if (!(lp_ctx->flags[i] & FLAG_CMDLINE)) {
 			lp_ctx->flags[i] |= FLAG_DEFAULT;
diff --git a/lib/util/memcache.c b/lib/util/memcache.c
index 7b0b27eaddb..7b0c0efce28 100644
--- a/lib/util/memcache.c
+++ b/lib/util/memcache.c
@@ -60,6 +60,7 @@ static bool memcache_is_talloc(enum memcache_number n)
 	case SINGLETON_CACHE_TALLOC:
 	case SHARE_MODE_LOCK_CACHE:
 	case GETWD_CACHE:
+	case ZFS_CACHE:
 	case VIRUSFILTER_SCAN_RESULTS_CACHE_TALLOC:
 		result = true;
 		break;
diff --git a/lib/util/memcache.h b/lib/util/memcache.h
index 4331c2f1465..fb3dc5eac02 100644
--- a/lib/util/memcache.h
+++ b/lib/util/memcache.h
@@ -46,6 +46,7 @@ enum memcache_number {
 	SMB1_SEARCH_OFFSET_MAP,
 	SHARE_MODE_LOCK_CACHE,	/* talloc */
 	VIRUSFILTER_SCAN_RESULTS_CACHE_TALLOC, /* talloc */
+	ZFS_CACHE,
 	DFREE_CACHE,
 };
 
diff --git a/source3/include/vfs.h b/source3/include/vfs.h
index d527f850628..1e02ae330ca 100644
--- a/source3/include/vfs.h
+++ b/source3/include/vfs.h
@@ -355,6 +355,14 @@ typedef union unid_t {
 	gid_t gid;
 } unid_t;
 
+enum acl_brand {
+	SMB_ACL_BRAND_POSIX,
+	SMB_ACL_BRAND_NFS40,
+	SMB_ACL_BRAND_NFS41,
+	SMB_ACL_BRAND_RICH,
+	SMB_ACL_BRAND_NONE,
+};
+
 struct fd_handle {
 	size_t ref_count;
 	int fd;
@@ -530,6 +538,7 @@ typedef struct connection_struct {
 	   sub second timestamps on files
 	   and directories when setting time ? */
 	enum timestamp_set_resolution ts_res;
+	enum acl_brand aclbrand;
 	char *connectpath;
 	struct files_struct *cwd_fsp; /* Working directory. */
 	bool tcon_done;
diff --git a/source3/modules/vfs_default.c b/source3/modules/vfs_default.c
index cf5e1cbc296..47002084ee7 100644
--- a/source3/modules/vfs_default.c
+++ b/source3/modules/vfs_default.c
@@ -40,6 +40,8 @@
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_VFS
 
+#define ROBOCOPYTS 315619200
+
 /* Check for NULL pointer parameters in vfswrap_* functions */
 
 /* We don't want to have NULL function pointers lying around.  Someone
@@ -48,7 +50,10 @@
 
 static int vfswrap_connect(vfs_handle_struct *handle, const char *service, const char *user)
 {
-    return 0;    /* Return >= 0 for success */
+	if (access(handle->conn->connectpath, F_OK) != 0) {
+		return -1;
+	}
+	return 0;
 }
 
 static void vfswrap_disconnect(vfs_handle_struct *handle)
@@ -77,32 +82,14 @@ static int vfswrap_get_quota(struct vfs_handle_struct *handle,
 				unid_t id,
 				SMB_DISK_QUOTA *qt)
 {
-#ifdef HAVE_SYS_QUOTAS
-	int result;
-
-	START_PROFILE(syscall_get_quota);
-	result = sys_get_quota(smb_fname->base_name, qtype, id, qt);
-	END_PROFILE(syscall_get_quota);
-	return result;
-#else
 	errno = ENOSYS;
 	return -1;
-#endif
 }
 
 static int vfswrap_set_quota(struct vfs_handle_struct *handle, enum SMB_QUOTA_TYPE qtype, unid_t id, SMB_DISK_QUOTA *qt)
 {
-#ifdef HAVE_SYS_QUOTAS
-	int result;
-
-	START_PROFILE(syscall_set_quota);
-	result = sys_set_quota(handle->conn->connectpath, qtype, id, qt);
-	END_PROFILE(syscall_set_quota);
-	return result;
-#else
 	errno = ENOSYS;
 	return -1;
-#endif
 }
 
 static int vfswrap_get_shadow_copy_data(struct vfs_handle_struct *handle,
@@ -2069,6 +2056,12 @@ static struct tevent_req *vfswrap_offload_write_send(
 		return tevent_req_post(req, ev);
 	}
 
+	if (vfswrap_offload_ctx == NULL) {
+		DBG_ERR("vfswrap_offload_ctx is not initialized\n");
+		tevent_req_nterror(req, NT_STATUS_INTERNAL_ERROR);
+		return tevent_req_post(req, ev);
+	}
+
 	status = vfs_offload_token_db_fetch_fsp(vfswrap_offload_ctx,
 						token, &src_fsp);
 	if (tevent_req_nterror(req, status)) {
@@ -2504,6 +2497,18 @@ static struct smb_filename *vfswrap_getwd(vfs_handle_struct *handle,
  nsec timestamp resolution call. Convert down to whatever the underlying
  system will support.
 **********************************************************************/
+static bool is_robocopy_init(struct smb_file_time *ft)
+{
+	if (!null_timespec(ft->atime) ||
+	    !null_timespec(ft->create_time)) {
+		return false;
+	}
+	if (!null_timespec(ft->mtime) &&
+	    ft->mtime.tv_sec == ROBOCOPYTS) {
+		return true;
+	}
+	return false;
+}
 
 static int vfswrap_ntimes(vfs_handle_struct *handle,
 			  const struct smb_filename *smb_fname,
@@ -2542,7 +2547,10 @@ static int vfswrap_ntimes(vfs_handle_struct *handle,
 	}
 
 #if defined(HAVE_UTIMENSAT)
-	if (ft != NULL) {
+	if (ft != NULL && is_robocopy_init(ft)) {
+		return 0;
+	} else if ((ft != NULL) &&
+	    (timespec_compare(&ft->mtime, &smb_fname->st.st_ex_btime) == 1)) {
 		struct timespec ts[2];
 		ts[0] = ft->atime;
 		ts[1] = ft->mtime;
diff --git a/source3/modules/vfs_streams_xattr.c b/source3/modules/vfs_streams_xattr.c
index 14532395e8a..c73d5d9e0eb 100644
--- a/source3/modules/vfs_streams_xattr.c
+++ b/source3/modules/vfs_streams_xattr.c
@@ -948,6 +948,27 @@ static ssize_t streams_xattr_pwrite(vfs_handle_struct *handle,
 		return -1;
 	}
 
+	if ((offset + n) >= lp_smbd_max_xattr_size(SNUM(handle->conn))) {
+		/*
+		 * Requested write is beyond what can be read based on
+		 * samba configuration.
+		 * ReFS returns STATUS_FILESYSTEM_LIMITATION, which causes
+		 * entire file to be skipped by File Explorer. VFAT returns
+		 * NT_STATUS_OBJECT_NAME_COLLISION causes user to be prompted
+		 * to skip writing metadata, but copy data.
+		 */
+		DBG_ERR("Write to xattr [%s] on file [%s] exceeds maximum "
+			"supported extended attribute size. "
+			"Depending on filesystem type and operating system "
+			"(OS) specifics, this value may be increased using "
+			"the value of the parameter: "
+			"smbd max xattr size = <bytes>. Consult OS and "
+			"filesystem manpages prior to increasing this limit.\n",
+			sio->xattr_name, sio->base);
+		errno = EOVERFLOW;
+		return -1;
+	}
+
 	/* Create an smb_filename with stream_name == NULL. */
 	smb_fname_base = synthetic_smb_fname(talloc_tos(),
 					sio->base,
diff --git a/source3/smbd/fake_file.c b/source3/smbd/fake_file.c
index 90921a65e36..865da147d8d 100644
--- a/source3/smbd/fake_file.c
+++ b/source3/smbd/fake_file.c
@@ -22,6 +22,7 @@
 #include "smbd/globals.h"
 #include "fake_file.h"
 #include "auth.h"
+#include "privileges.h"
 
 struct fake_file_type {
 	const char *name;
@@ -130,6 +131,8 @@ NTSTATUS open_fake_file(struct smb_request *req, connection_struct *conn,
 		loadparm_s3_global_substitution();
 	files_struct *fsp = NULL;
 	NTSTATUS status;
+	bool is_disk_op;
+	int ret;
 
 	status = smbd_calculate_access_mask(conn,
 					conn->cwd_fsp,
@@ -146,15 +149,34 @@ NTSTATUS open_fake_file(struct smb_request *req, connection_struct *conn,
 		return status;
 	}
 
-	/* access check */
-	if (geteuid() != sec_initial_uid()) {
-		DEBUG(3, ("open_fake_file_shared: access_denied to "
-			  "service[%s] file[%s] user[%s]\n",
-			  lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
-			  smb_fname_str_dbg(smb_fname),
-			  conn->session_info->unix_info->unix_name));
-		return NT_STATUS_ACCESS_DENIED;
-
+	/* access check
+	 * Allow access to QUOTA fake file if user has DISK_OPERATOR
+	 * privileges. This is a subset of local admin rights.
+	 */
+	switch(fake_file_type){
+	case FAKE_FILE_TYPE_QUOTA:
+		is_disk_op = security_token_has_privilege(
+			conn->session_info->security_token,
+			SEC_PRIV_DISK_OPERATOR);
+		if (!is_disk_op) {
+			DBG_NOTICE("Access denied to "
+				   "service[%s] file[%s]. User [%s] "
+				   "lacks SE_PRIV_DISK_OPERATOR\n",
+				   lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
+				   smb_fname_str_dbg(smb_fname),
+				   conn->session_info->unix_info->unix_name);
+			return NT_STATUS_ACCESS_DENIED;
+		}
+		break;
+	default:
+		if (geteuid() != sec_initial_uid()) {
+			DEBUG(3, ("open_fake_file_shared: access_denied to "
+				  "service[%s] file[%s] user[%s]\n",
+				  lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
+				  smb_fname_str_dbg(smb_fname),
+				  conn->session_info->unix_info->unix_name));
+			return NT_STATUS_ACCESS_DENIED;
+		}
 	}
 
 	status = file_new(req, conn, &fsp);
diff --git a/source3/smbd/globals.h b/source3/smbd/globals.h
index ae935f413e0..4955473983c 100644
--- a/source3/smbd/globals.h
+++ b/source3/smbd/globals.h
@@ -24,6 +24,7 @@
 #include "system/select.h"
 #include "librpc/gen_ndr/smbXsrv.h"
 #include "smbprofile.h"
+#include "modules/smb_libzfs.h"
 
 #ifdef USE_DMAPI
 struct smbd_dmapi_context;
diff --git a/source3/smbd/open.c b/source3/smbd/open.c
index ef158657684..754f3a88a92 100644
--- a/source3/smbd/open.c
+++ b/source3/smbd/open.c
@@ -227,6 +227,7 @@ NTSTATUS smbd_check_access_rights(struct connection_struct *conn,
 	if ((access_mask & FILE_WRITE_ATTRIBUTES) &&
 			(rejected_mask & FILE_WRITE_ATTRIBUTES) &&
 			!lp_store_dos_attributes(SNUM(conn)) &&
+			!lp_kernel_dosmodes(SNUM(conn)) &&
 			(lp_map_readonly(SNUM(conn)) ||
 			lp_map_archive(SNUM(conn)) ||
 			lp_map_hidden(SNUM(conn)) ||
@@ -3074,13 +3075,13 @@ static bool open_match_attributes(connection_struct *conn,
 		  (unsigned int)*returned_unx_mode ));
 
 	/* If we're mapping SYSTEM and HIDDEN ensure they match. */
-	if (lp_map_system(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {
+	if (lp_map_system(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn)) ||  lp_kernel_dosmodes(SNUM(conn))) {
 		if ((old_dos_attr & FILE_ATTRIBUTE_SYSTEM) &&
 		    !(new_dos_attr & FILE_ATTRIBUTE_SYSTEM)) {
 			return False;
 		}
 	}
-	if (lp_map_hidden(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {
+	if (lp_map_hidden(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn)) || lp_kernel_dosmodes(SNUM(conn))) {
 		if ((old_dos_attr & FILE_ATTRIBUTE_HIDDEN) &&
 		    !(new_dos_attr & FILE_ATTRIBUTE_HIDDEN)) {
 			return False;
@@ -3788,13 +3789,28 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 	/*
 	 * Ensure we pay attention to default ACLs on directories if required.
 	 */
-
-        if ((flags2 & O_CREAT) && lp_inherit_acls(SNUM(conn)) &&
-	    (def_acl = directory_has_default_acl(conn,
-				conn->cwd_fsp,
-				parent_dir_fname)))
-	{
-		unx_mode = (0777 & lp_create_mask(SNUM(conn)));
+	switch(conn->aclbrand) {
+	case SMB_ACL_BRAND_POSIX:
+		if ((flags2 & O_CREAT) && lp_inherit_acls(SNUM(conn)) &&
+		    (def_acl = directory_has_default_acl(conn,
+					conn->cwd_fsp,
+					parent_dir_fname))) {
+			unx_mode = (0777 & lp_create_mask(SNUM(conn)));
+		}
+		break;
+	case SMB_ACL_BRAND_NFS40:
+	case SMB_ACL_BRAND_NFS41:
+	default:
+		/*
+		 * Pass along to VFS to determine whether the ACL has
+		 * any inheriting entries.
+		 */
+		if (flags2 & O_CREAT) {
+			def_acl = directory_has_default_acl(conn,
+					conn->cwd_fsp,
+					parent_dir_fname);
+		}
+		break;
 	}
 
 	DEBUG(4,("calling open_file with flags=0x%X flags2=0x%X mode=0%o, "
@@ -4165,6 +4181,10 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 				}
 			}
 		}
+		else if (lp_kernel_dosmodes(SNUM(conn)) && !posix_open) {
+			SMB_VFS_SET_DOS_ATTRIBUTES(conn, smb_fname,
+						   new_dos_attributes | FILE_ATTRIBUTE_ARCHIVE);
+		}
 	}
 
 	/* Determine sparse flag. */
@@ -4335,6 +4355,10 @@ static NTSTATUS mkdir_internal(connection_struct *conn,
 					 parent_dir_fname, true);
 		}
 	}
+	else if (lp_kernel_dosmodes(SNUM(conn)) && !posix_open) {
+		SMB_VFS_SET_DOS_ATTRIBUTES(conn, smb_dname,
+					   file_attributes | FILE_ATTRIBUTE_DIRECTORY);
+	}
 
 	if (lp_inherit_permissions(SNUM(conn))) {
 		inherit_access_posix_acl(conn, parent_dir_fname,
diff --git a/source3/smbd/reply.c b/source3/smbd/reply.c
index a0da2910350..2c8c415b00d 100644
--- a/source3/smbd/reply.c
+++ b/source3/smbd/reply.c
@@ -7600,7 +7600,9 @@ NTSTATUS rename_internals_fsp(connection_struct *conn,
 	NTSTATUS status = NT_STATUS_OK;
 	struct share_mode_lock *lck = NULL;
 	uint32_t access_mask = SEC_DIR_ADD_FILE;
-	bool dst_exists, old_is_stream, new_is_stream;
+	bool dst_exists, old_is_stream, new_is_stream, is_same_fileid;
+	struct file_id fileid_src;
+	struct file_id fileid_dst;
 	int ret;
 
 	status = check_name(conn, smb_fname_dst_in);
@@ -7613,10 +7615,17 @@ NTSTATUS rename_internals_fsp(connection_struct *conn,
 		return status;
 	}
 
+/*
+        FIXME: OS-X clients will set a RH lease on AFP_Resource streams which results
+        in a share-mode lock being set on a file. Which causes the following check to
+        prevent users from renaming the file until the OS-X client with the lease disconnects.
+        This is incorrect behavior per MS docs.
+ */
+/*
 	if (file_has_open_streams(fsp)) {
 		return NT_STATUS_ACCESS_DENIED;
 	}
-
+ */
 	/* Make a copy of the dst smb_fname structs */
 
 	smb_fname_dst = cp_smb_filename(ctx, smb_fname_dst_in);
@@ -7762,7 +7771,19 @@ NTSTATUS rename_internals_fsp(connection_struct *conn,
 
 	dst_exists = SMB_VFS_STAT(conn, smb_fname_dst) == 0;
 
-	if(!replace_if_exists && dst_exists) {
+	/*
+	 * Some filesystems are case-insensitive, but case-preserving
+	 * Compare fileid in this situation to determine whether the
+	 * source and destination are the same file. If this is the
+	 * case, then bypass these checks and hand off to VFS_RENAME
+	 * and hope that a VFS module is enabled that has special
+	 * handling for this situation.
+	 */
+	fileid_src = vfs_file_id_from_sbuf(conn, &fsp->fsp_name->st);
+	fileid_dst = vfs_file_id_from_sbuf(conn, &smb_fname_dst->st);
+	is_same_fileid = file_id_equal(&fileid_src, &fileid_dst);
+
+	if(!replace_if_exists && dst_exists && !is_same_fileid) {
 		DEBUG(3, ("rename_internals_fsp: dest exists doing rename "
 			  "%s -> %s\n", smb_fname_str_dbg(fsp->fsp_name),
 			  smb_fname_str_dbg(smb_fname_dst)));
@@ -7770,7 +7791,7 @@ NTSTATUS rename_internals_fsp(connection_struct *conn,
 		goto out;
 	}
 
-	if (dst_exists) {
+	if (dst_exists && !is_same_fileid) {
 		struct file_id fileid = vfs_file_id_from_sbuf(conn,
 		    &smb_fname_dst->st);
 		files_struct *dst_fsp = file_find_di_first(conn->sconn,
diff --git a/source3/smbd/smb2_write.c b/source3/smbd/smb2_write.c
index e49e623d796..612c89d59d1 100644
--- a/source3/smbd/smb2_write.c
+++ b/source3/smbd/smb2_write.c
@@ -193,7 +193,12 @@ static NTSTATUS smb2_write_complete_internal(struct tevent_req *req,
 	files_struct *fsp = state->fsp;
 
 	if (nwritten == -1) {
-		status = map_nt_error_from_unix(err);
+		if (err == EOVERFLOW &&
+		    is_ntfs_stream_smb_fname(fsp->fsp_name)) {
+			status = NT_STATUS_FILE_SYSTEM_LIMITATION;
+		} else {
+			status = map_nt_error_from_unix(err);
+		}
 
 		DEBUG(2, ("smb2_write failed: %s, file %s, "
 			  "length=%lu offset=%lu nwritten=-1: %s\n",
diff --git a/source3/smbd/trans2.c b/source3/smbd/trans2.c
index 7acde285a90..c46e38828ab 100644
--- a/source3/smbd/trans2.c
+++ b/source3/smbd/trans2.c
@@ -271,6 +271,7 @@ NTSTATUS get_ea_value(TALLOC_CTX *mem_ctx,
 	size_t attr_size = 256;
 	char *val = NULL;
 	ssize_t sizeret;
+	size_t max_xattr_size = lp_smbd_max_xattr_size(SNUM(conn));
 
  again:
 
@@ -286,8 +287,8 @@ NTSTATUS get_ea_value(TALLOC_CTX *mem_ctx,
 				ea_name, val, attr_size);
 	}
 
-	if (sizeret == -1 && errno == ERANGE && attr_size != 65536) {
-		attr_size = 65536;
+	if (sizeret == -1 && errno == ERANGE && attr_size < max_xattr_size) {
+		attr_size = max_xattr_size;
 		goto again;
 	}
 
@@ -535,6 +536,17 @@ static NTSTATUS get_ea_list_from_file_path(TALLOC_CTX *mem_ctx,
 			 */
 			TALLOC_FREE(listp);
 			continue;
+		} else if (listp->ea.value.length > 65536) {
+			/*
+			 * SMB clients may report error with file
+			 * if large EA is presented to them.
+			 */
+			DBG_ERR("EA [%s] on file [%s] exceeds "
+				"maximum permitted EA size of 64KiB: %zu\n.",
+				listp->ea.name, fsp_str_dbg(fsp),
+				listp->ea.value.length);
+			TALLOC_FREE(listp);
+			continue;
 		}
 
 		push_ascii_fstring(dos_ea_name, listp->ea.name);
@@ -3636,8 +3648,11 @@ NTSTATUS smbd_do_qfsinfo(struct smbXsrv_connection *xconn,
 
 	DEBUG(3,("smbd_do_qfsinfo: level = %d\n", info_level));
 
-	ZERO_STRUCT(smb_fname);
-	smb_fname.base_name = discard_const_p(char, filename);
+	smb_fname = (struct smb_filename) {
+		.base_name = discard_const_p(char, filename),
+		.flags = fname ? fname->flags : 0,
+		.twrp = fname ? fname->twrp : 0,
+	};
 
 	if(info_level != SMB_FS_QUOTA_INFORMATION
 	   && SMB_VFS_STAT(conn, &smb_fname) != 0) {
