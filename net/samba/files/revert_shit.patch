diff --git a/.gitignore b/.gitignore
index ffdb2e3bd11..49abc2e9099 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,6 +3,7 @@
 /st/
 .waf*
 .lock-wscript
+.build.log
 *~
 *.swp
 /tags
diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 9bd083cb63e..56adf10c7be 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -22,7 +22,7 @@ variables:
   # Set this to the contents of bootstrap/sha1sum.txt
   # which is generated by bootstrap/template.py --render
   #
-  SAMBA_CI_CONTAINER_TAG: 187702e2a9c65f874aa13e5eb1c8b68703e72299
+  SAMBA_CI_CONTAINER_TAG: 41319f2580c026f66b2750604a0eb15d6b6f7b50
   #
   # We use the ubuntu1804 image as default as
   # it matches what we have on sn-devel-184.
@@ -36,6 +36,7 @@ variables:
   SAMBA_CI_CONTAINER_IMAGE_ubuntu1804: ${SAMBA_CI_CONTAINER_REGISTRY}/samba-ci-ubuntu1804:${SAMBA_CI_CONTAINER_TAG}
   SAMBA_CI_CONTAINER_IMAGE_ubuntu1604: ${SAMBA_CI_CONTAINER_REGISTRY}/samba-ci-ubuntu1604:${SAMBA_CI_CONTAINER_TAG}
   SAMBA_CI_CONTAINER_IMAGE_debian9: ${SAMBA_CI_CONTAINER_REGISTRY}/samba-ci-debian9:${SAMBA_CI_CONTAINER_TAG}
+  SAMBA_CI_CONTAINER_IMAGE_debian10: ${SAMBA_CI_CONTAINER_REGISTRY}/samba-ci-debian10:${SAMBA_CI_CONTAINER_TAG}
   SAMBA_CI_CONTAINER_IMAGE_opensuse150: ${SAMBA_CI_CONTAINER_REGISTRY}/samba-ci-opensuse150:${SAMBA_CI_CONTAINER_TAG}
   SAMBA_CI_CONTAINER_IMAGE_opensuse151: ${SAMBA_CI_CONTAINER_REGISTRY}/samba-ci-opensuse151:${SAMBA_CI_CONTAINER_TAG}
   SAMBA_CI_CONTAINER_IMAGE_fedora29: ${SAMBA_CI_CONTAINER_REGISTRY}/samba-ci-fedora29:${SAMBA_CI_CONTAINER_TAG}
@@ -98,6 +99,10 @@ include:
     - echo "Running cmd script/autobuild.py $AUTOBUILD_JOB_NAME $SAMBA_CI_AUTOBUILD_ENABLE_COVERAGE --verbose --nocleanup --keeplogs --tail --testbase /tmp/samba-testbase"
     - script/autobuild.py $AUTOBUILD_JOB_NAME $SAMBA_CI_AUTOBUILD_ENABLE_COVERAGE  --verbose --nocleanup --keeplogs --tail --testbase /tmp/samba-testbase
 
+# Ensure when adding a new job below that you also add it to
+# the dependencies for 'pages' below for the code coverage page
+# generation.
+
 others:
   extends: .shared_template
   script:
@@ -150,6 +155,9 @@ samba-libs:
 samba-static:
   extends: .shared_template
 
+samba-fuzz:
+  extends: .shared_template
+
 ctdb:
   extends: .shared_template
 
@@ -210,31 +218,35 @@ pages:
     - docker
     - shared
   dependencies:  # tell gitlab to download artifacts for these jobs
+    - others
     - samba
-    - samba-ad-dc-1
-    - samba-ad-dc-1-mitkrb5
+    - samba-mitkrb5
+    - samba-none-env
+    - samba-nopython
+    - samba-nopython-py2
+    - samba-xc
+    - samba-admem
     - samba-ad-dc-2
     - samba-ad-dc-3
     - samba-ad-dc-4
-    - samba-ad-dc-4-mitkrb5
     - samba-ad-dc-5
     - samba-ad-dc-6
-    - samba-ad-dc-backup
+    - samba-libs
+    - samba-static
+    - samba-fuzz
+    # - ctdb  # TODO
+    - samba-ctdb
     - samba-ad-dc-ntvfs
-    - samba-admem
     - samba-admem-mit
-    - samba-ctdb
+    - samba-ad-dc-4-mitkrb5
+    - samba-ad-dc-backup
+    - samba-simpleserver
     - samba-fileserver
-    - samba-libs
-    - samba-none-env
-    - samba-nopython
-    - samba-nopython-py2
+    - samba-ktest-heimdal
+    - samba-ad-dc-1
     - samba-nt4
     - samba-schemaupgrade
-    - samba-static
-    - samba-xc
-    # - ctdb  # TODO
-    - others
+    - samba-ad-dc-1-mitkrb5
   script:
     - ./configure.developer
     - make -j
@@ -273,6 +285,10 @@ debian9-samba-o3:
   extends: .samba-o3-template
   image: $SAMBA_CI_CONTAINER_IMAGE_debian9
 
+debian10-samba-o3:
+  extends: .samba-o3-template
+  image: $SAMBA_CI_CONTAINER_IMAGE_debian10
+
 opensuse150-samba-o3:
   extends: .samba-o3-template
   image: $SAMBA_CI_CONTAINER_IMAGE_opensuse150
diff --git a/VERSION b/VERSION
index 3f4e84bf0f4..5fcdb65ffb9 100644
--- a/VERSION
+++ b/VERSION
@@ -77,7 +77,7 @@ SAMBA_VERSION_BETA_RELEASE=
 # e.g. SAMBA_VERSION_PRE_RELEASE=1                     #
 #  ->  "2.2.9pre1"                                     #
 ########################################################
-SAMBA_VERSION_PRE_RELEASE=1
+SAMBA_VERSION_PRE_RELEASE=
 
 ########################################################
 # For 'rc' releases the version will be                #
@@ -99,7 +99,7 @@ SAMBA_VERSION_RC_RELEASE=
 # e.g. SAMBA_VERSION_IS_SVN_SNAPSHOT=yes               #
 #  ->  "3.0.0-SVN-build-199"                           #
 ########################################################
-SAMBA_VERSION_IS_GIT_SNAPSHOT=yes
+SAMBA_VERSION_IS_GIT_SNAPSHOT=no
 
 ########################################################
 # This is for specifying a release nickname            #
diff --git a/WHATSNEW.txt b/WHATSNEW.txt
index f84cfcf7623..82525ebff0a 100644
--- a/WHATSNEW.txt
+++ b/WHATSNEW.txt
@@ -1,16 +1,11 @@
-Release Announcements
-=====================
+                   ==============================
+                   Release Notes for Samba 4.12.0
+                           March 03, 2019
+		   ==============================
 
-This is the first preview release of Samba 4.12.  This is *not*
-intended for production environments and is designed for testing
-purposes only.  Please report any defects via the Samba bug reporting
-system at https://bugzilla.samba.org/.
 
-Samba 4.12 will be the next version of the Samba suite.
-
-
-UPGRADING
-=========
+This is the first stable release of the Samba 4.12 release series.
+Please read the release notes carefully before upgrading.
 
 
 NEW FEATURES/CHANGES
@@ -27,8 +22,8 @@ we test with in our CI infrastructure.
 (Build time support for the file server with Python 2.6 has not
 changed)
 
-GnuTLS 3.4.7 required
----------------------
+Removing in-tree cryptography: GnuTLS 3.4.7 required
+----------------------------------------------------
 
 Samba is making efforts to remove in-tree cryptographic functionality,
 and to instead rely on externally maintained libraries.  To this end,
@@ -38,6 +33,11 @@ Samba now requires GnuTLS 3.4.7 to be installed (including development
 headers at build time) for all configurations, not just the Samba AD
 DC.
 
+Thanks to this work Samba no longer ships an in-tree DES
+implementation and on GnuTLS 3.6.5 or later Samba will include no
+in-tree cryptography other than the MD4 hash and that
+implemented in our copy of Heimdal.
+
 Using GnuTLS for SMB3 encryption you will notice huge performance and copy
 speed improvements. Tests with the CIFS Kernel client from Linux Kernel 5.3
 show a 3x speed improvement for writing and a 2.5x speed improvement for reads!
@@ -52,14 +52,143 @@ A future Samba version will mitigate this to some extent where good
 cryptography effectively wraps bad cryptography, but for now that above
 applies.
 
+zlib library is now required to build Samba
+-------------------------------------------
+
+Samba no longer includes a local copy of zlib in our source tarball.
+By removing this we do not need to ship (even where we did not
+build) the old, broken zip encryption code found there.
+
+New Spotlight backend for Elasticsearch
+---------------------------------------
 
-"net ads kerberos pac save" and "net eventlog export"
+Support for the macOS specific Spotlight search protocol has been enhanced
+significantly. Starting with 4.12 Samba supports using Elasticsearch as search
+backend. Various new parameters have been added to configure this:
+
+  spotlight backend = noindex | elasticsearch | tracker
+  elasticsearch:address = ADDRESS
+  elasticsearch:port = PORT
+  elasticsearch:use tls = BOOLEAN
+  elasticsearch:index = INDEXNAME
+  elasticsearch:mappings = PATH
+  elasticsearch:max results = NUMBER
+
+Samba also ships a Spotlight client command "mdfind" which can be used to search
+any SMB server that runs the Spotlight RPC service. See the manpage of mdfind
+for details.
+
+Note that when upgrading existing installations that are using the previous
+default Spotlight backend Gnome Tracker must explicitly set "spotlight backend =
+tracker" as the new default is "noindex".
+
+'net ads kerberos pac save' and 'net eventlog export'
 -----------------------------------------------------
 
-The "net ads kerberos pac save" and "net eventlog export" tools will
+The 'net ads kerberos pac save' and 'net eventlog export' tools will
 no longer silently overwrite an existing file during data export.  If
 the filename given exits, an error will be shown.
 
+Fuzzing
+-------
+
+A large number of fuzz targets have been added to Samba, and Samba has
+been registered in Google's oss-fuzz cloud fuzzing service.  In
+particular, we now have good fuzzing coverage of our generated NDR
+parsing code.
+
+A large number of issues have been found and fixed thanks to this
+effort.
+
+'samba-tool' improvements add contacts as member to groups
+----------------------------------------------------------
+
+Previously 'samba-tool group addmemers' can just add users, groups and
+computers as members to groups. But also contacts can be members of
+groups. Samba 4.12 adds the functionality to add contacts to
+groups. Since contacts have no sAMAccountName, it's possible that
+there are more than one contact with the same name in different
+organizational units. Therefore it's necessary to have an option to
+handle group members by their DN.
+
+To get the DN of an object there is now the "--full-dn" option available
+for all necessary commands.
+
+The MS Windows UI allows to search for specific types of group members
+when searching for new members for a group. This feature is included
+here with the new samba-tool group addmembers "--object-type=OBJECTYPE"
+option. The different types are selected accordingly to the Windows
+UI. The default samba-toole behaviour shouldn't be changed.
+
+Allow filtering by OU or subtree in samba-tool
+----------------------------------------------
+
+A new "--base-dn" and "--member-base-dn" option is added to relevant
+samba-tool user, group and ou management commands to allow operation
+on just one part of the AD tree, such as a single OU.
+
+VFS
+===
+
+SMB_VFS_NTIMES
+--------------
+
+Samba now uses a sentinel value based on utimensat(2) UTIME_OMIT to denote
+to-be-ignored timestamp variables passed to the SMB_VFS_NTIMES() VFS function.
+
+VFS modules can check whether any of the time values inside a struct
+smb_file_time is to be ignored by calling is_omit_timespec() on the value.
+
+'io_uring' vfs module
+---------------------
+
+The module makes use of the new io_uring infrastructure
+(intruduced in Linux 5.1), see https://lwn.net/Articles/776703/
+
+Currently this implements SMB_VFS_{PREAD,PWRITE,FSYNC}_SEND/RECV
+and avoids the overhead of the userspace threadpool in the default
+vfs backend. See also vfs_io_uring(8).
+
+In order to build the module you need the liburing userspace library
+and its developement headers installed, see
+https://git.kernel.dk/cgit/liburing/
+
+At runtime you'll need a Linux kernel with version 5.1 or higher.
+Note that 5.4.14 and 5.4.15 have a regression that breaks the Samba
+module! The regression was fixed in Linux 5.4.16 again.
+
+MS-DFS changes in the VFS
+-------------------------
+
+This release changes set getting and setting of MS-DFS redirects
+on the filesystem to go through two new VFS functions:
+
+SMB_VFS_CREATE_DFS_PATHAT()
+SMB_VFS_READ_DFS_PATHAT()
+
+instead of smbd explicitly storing MS-DFS redirects inside
+symbolic links on the filesystem. The underlying default
+implementations of this has not changed, the redirects are
+still stored inside symbolic links on the filesystem, but
+moving the creation and reading of these links into the VFS
+as first-class functions now allows alternate methods of
+storing them (maybe in extended attributes) for OEMs who
+don't want to mis-use filesystem symbolic links in this
+way.
+
+
+CTDB changes
+============
+
+* The ctdb_mutex_fcntl_helper periodically re-checks the lock file
+
+  The re-check period is specified using a 2nd argument to this
+  helper.  The default re-check period is 5s.
+
+  If the file no longer exists or the inode number changes then the
+  helper exits.  This triggers an election.
+
+
 REMOVED FEATURES
 ================
 
@@ -80,20 +209,6 @@ critical code path.
 If required for specialist purposes, it can be recreated as a VFS
 module.
 
-BIND9_FLATFILE deprecated
--------------------------
-
-The BIND9_FLATFILE DNS backend is deprecated in this release and will
-be removed in the future.  This was only practically useful on a single
-domain controller or under expert care and supervision.
-
-This release removes the "rndc command" smb.conf parameter, which
-supported this configuration by writing out a list of DCs permitted to
-make changes to the DNS Zone and nudging the 'named' server if a new
-DC was added to the domain.  Administrators using BIND9_FLATFILE will
-need to maintain this manually from now on.
-
-
 Retiring DES encryption types in Kerberos.
 ------------------------------------------
 With this release, support for DES encryption types has been removed from
@@ -112,6 +227,25 @@ Heimdal-DC: removal of weak-crypto.
 Following removal of DES encryption types from Samba, the embedded Heimdal
 build has been updated to not compile weak crypto code (HEIM_WEAK_CRYPTO).
 
+vfs_netatalk: The netatalk VFS module has been removed.
+-------------------------------------------------------
+
+The netatalk VFS module has been removed. It was unmaintained and is not needed
+any more.
+
+BIND9_FLATFILE deprecated
+-------------------------
+
+The BIND9_FLATFILE DNS backend is deprecated in this release and will
+be removed in the future.  This was only practically useful on a single
+domain controller or under expert care and supervision.
+
+This release removes the 'rndc command' smb.conf parameter, which
+supported this configuration by writing out a list of DCs permitted to
+make changes to the DNS Zone and nudging the 'named' server if a new
+DC was added to the domain.  Administrators using BIND9_FLATFILE will
+need to maintain this manually from now on.
+
 
 smb.conf changes
 ================
@@ -119,9 +253,80 @@ smb.conf changes
   Parameter Name                     Description                Default
   --------------                     -----------                -------
 
+  elasticsearch:address              New                        localhost
+  elasticsearch:port                 New                        9200
+  elasticsearch:use tls              New                        No
+  elasticsearch:index                New                        _all
+  elasticsearch:mappings             New                        DATADIR/elasticsearch_mappings.json
+  elasticsearch:max results          New                        100
   nfs4:acedup                        Changed default            merge
   rndc command                       Removed
   write cache size                   Removed
+  spotlight backend		     New			noindex
+
+
+CHANGES SINCE 4.12.0rc4
+=======================
+
+o  Andrew Bartlett <abartlet@samba.org>
+   * BUG 14258: dsdb: Correctly handle memory in objectclass_attrs.
+
+
+CHANGES SINCE 4.12.0rc3
+=======================
+
+o  Jeremy Allison <jra@samba.org>
+   * BUG 14269: s3: DFS: Don't allow link deletion on a read-only share.
+
+o  Douglas Bagnall <douglas.bagnall@catalyst.net.nz>
+   * BUG 14284: pidl/wscript: configure should insist on Parse::Yapp::Driver.
+
+o  Andrew Bartlett <abartlet@samba.org>
+   * BUG 14270: ldb: Fix search with scope ONE and small result sets. 
+   * BUG 14284: build: Do not check if system perl modules should be bundled.
+
+o  Volker Lendecke <vl@samba.org>
+   * BUG 14285: smbd fails to handle EINTR from open(2) properly.
+
+o  Stefan Metzmacher <metze@samba.org>
+   * BUG 14270: ldb: version 2.1.1.
+
+
+CHANGES SINCE 4.12.0rc2
+=======================
+
+o  Jeremy Allison <jra@samba.org>
+   * BUG 14282: Set getting and setting of MS-DFS redirects on the filesystem
+     to go through two new VFS functions SMB_VFS_CREATE_DFS_PATHAT() and
+     SMB_VFS_READ_DFS_PATHAT().
+
+o  Andrew Bartlett <abartlet@samba.org>
+   * BUG 14255: bootstrap: Remove un-used dependency python3-crypto.
+
+o  Volker Lendecke <vl@samba.org>
+   * BUG 14247: Fix CID 1458418 and 1458420.
+   * BUG 14281: lib: Fix a shutdown crash with "clustering = yes".
+
+o  Stefan Metzmacher <metze@samba.org>
+   * BUG 14247: Winbind member (source3) fails local SAM auth with empty domain
+     name.
+   * BUG 14265: winbindd: Handle missing idmap in getgrgid().
+   * BUG 14271: Don't use forward declaration for GnuTLS typedefs.
+   * BUG 14280: Add io_uring vfs module.
+
+o  Andreas Schneider <asn@samba.org>
+   * BUG 14250: libcli:smb: Improve check for gnutls_aead_cipher_(en|de)cryptv2.
+
+
+CHANGES SINCE 4.12.0rc1
+=======================
+
+o  Jeremy Allison <jra@samba.org>
+   * BUG 14239: s3: lib: nmblib. Clean up and harden nmb packet processing.
+
+o  Andreas Schneider <asn@samba.org>
+   * BUG 14253: lib:util: Log mkdir error on correct debug levels.
+
 
 KNOWN ISSUES
 ============
diff --git a/auth/common_auth.h b/auth/common_auth.h
index 9f04c9b9cbb..0452c673ebc 100644
--- a/auth/common_auth.h
+++ b/auth/common_auth.h
@@ -129,12 +129,6 @@ struct auth4_context {
 	/* Private data for the callbacks on this auth context */
 	void *private_data;
 
-	NTSTATUS (*check_ntlm_password)(struct auth4_context *auth_ctx,
-					TALLOC_CTX *mem_ctx,
-					const struct auth_usersupplied_info *user_info,
-					uint8_t *pauthoritative,
-					void **server_returned_info,
-					DATA_BLOB *nt_session_key, DATA_BLOB *lm_session_key);
 	struct tevent_req *(*check_ntlm_password_send)(TALLOC_CTX *mem_ctx,
 					struct tevent_context *ev,
 					struct auth4_context *auth_ctx,
diff --git a/auth/credentials/credentials_ntlm.c b/auth/credentials/credentials_ntlm.c
index bf55ab97b04..f1b22a6c9e2 100644
--- a/auth/credentials/credentials_ntlm.c
+++ b/auth/credentials/credentials_ntlm.c
@@ -51,6 +51,7 @@ _PUBLIC_ NTSTATUS cli_credentials_get_ntlm_response(struct cli_credentials *cred
 	DATA_BLOB lm_session_key = data_blob_null;
 	DATA_BLOB session_key = data_blob_null;
 	const struct samr_Password *nt_hash = NULL;
+	int rc;
 
 	if (cred->use_kerberos == CRED_MUST_USE_KERBEROS) {
 		TALLOC_FREE(frame);
@@ -159,7 +160,6 @@ _PUBLIC_ NTSTATUS cli_credentials_get_ntlm_response(struct cli_credentials *cred
 		uint8_t session_nonce[16];
 		uint8_t session_nonce_hash[16];
 		uint8_t user_session_key[16];
-		int rc;
 
 		lm_response = data_blob_talloc_zero(frame, 24);
 		if (lm_response.data == NULL) {
@@ -188,9 +188,13 @@ _PUBLIC_ NTSTATUS cli_credentials_get_ntlm_response(struct cli_credentials *cred
 			TALLOC_FREE(frame);
 			return NT_STATUS_NO_MEMORY;
 		}
-		SMBOWFencrypt(nt_hash->hash,
-			      session_nonce_hash,
-			      nt_response.data);
+		rc = SMBOWFencrypt(nt_hash->hash,
+				   session_nonce_hash,
+                                   nt_response.data);
+		if (rc != 0) {
+			TALLOC_FREE(frame);
+			return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 
 		ZERO_ARRAY(session_nonce_hash);
 
@@ -228,8 +232,12 @@ _PUBLIC_ NTSTATUS cli_credentials_get_ntlm_response(struct cli_credentials *cred
 			TALLOC_FREE(frame);
 			return NT_STATUS_NO_MEMORY;
 		}
-		SMBOWFencrypt(nt_hash->hash, challenge.data,
-			      nt_response.data);
+		rc = SMBOWFencrypt(nt_hash->hash, challenge.data,
+				   nt_response.data);
+		if (rc != 0) {
+			TALLOC_FREE(frame);
+			return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 
 		session_key = data_blob_talloc_zero(frame, 16);
 		if (session_key.data == NULL) {
@@ -254,9 +262,14 @@ _PUBLIC_ NTSTATUS cli_credentials_get_ntlm_response(struct cli_credentials *cred
 				return NT_STATUS_NO_MEMORY;
 			}
 
-			SMBencrypt_hash(lm_hash,
-					challenge.data,
-					lm_response.data);
+			rc = SMBencrypt_hash(lm_hash,
+					     challenge.data,
+					     lm_response.data);
+			if (rc != 0) {
+				ZERO_STRUCT(lm_hash);
+				TALLOC_FREE(frame);
+				return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			}
 		} else {
 			/* just copy the nt_response */
 			lm_response = data_blob_dup_talloc(frame, nt_response);
diff --git a/auth/ntlmssp/ntlmssp_client.c b/auth/ntlmssp/ntlmssp_client.c
index 2a80feb4fed..58e4e3d6f42 100644
--- a/auth/ntlmssp/ntlmssp_client.c
+++ b/auth/ntlmssp/ntlmssp_client.c
@@ -673,12 +673,20 @@ NTSTATUS ntlmssp_client_challenge(struct gensec_security *gensec_security,
 	    && ntlmssp_state->allow_lm_key && lm_session_key.length == 16) {
 		DATA_BLOB new_session_key = data_blob_talloc(mem_ctx, NULL, 16);
 		if (lm_response.length == 24) {
-			SMBsesskeygen_lm_sess_key(lm_session_key.data, lm_response.data,
-						  new_session_key.data);
+			nt_status = SMBsesskeygen_lm_sess_key(lm_session_key.data,
+							      lm_response.data,
+							      new_session_key.data);
+			if (!NT_STATUS_IS_OK(nt_status)) {
+				return nt_status;
+			}
 		} else {
 			static const uint8_t zeros[24];
-			SMBsesskeygen_lm_sess_key(lm_session_key.data, zeros,
-						  new_session_key.data);
+			nt_status = SMBsesskeygen_lm_sess_key(lm_session_key.data,
+                                                              zeros,
+                                                              new_session_key.data);
+			if (!NT_STATUS_IS_OK(nt_status)) {
+				return nt_status;
+			}
 		}
 		session_key = new_session_key;
 		dump_data_pw("LM session key\n", session_key.data, session_key.length);
diff --git a/auth/ntlmssp/ntlmssp_server.c b/auth/ntlmssp/ntlmssp_server.c
index 5a56a4db99f..001238278d7 100644
--- a/auth/ntlmssp/ntlmssp_server.c
+++ b/auth/ntlmssp/ntlmssp_server.c
@@ -335,8 +335,8 @@ struct tevent_req *ntlmssp_server_auth_send(TALLOC_CTX *mem_ctx,
 				      struct gensec_ntlmssp_context);
 	struct auth4_context *auth_context = gensec_security->auth_context;
 	struct tevent_req *req = NULL;
+	struct tevent_req *subreq = NULL;
 	struct ntlmssp_server_auth_state *state = NULL;
-	uint8_t authoritative = 0;
 	NTSTATUS status;
 
 	req = tevent_req_create(mem_ctx, &state,
@@ -355,54 +355,13 @@ struct tevent_req *ntlmssp_server_auth_send(TALLOC_CTX *mem_ctx,
 		return tevent_req_post(req, ev);
 	}
 
-	if (auth_context->check_ntlm_password_send != NULL) {
-		struct tevent_req *subreq = NULL;
-
-		subreq = auth_context->check_ntlm_password_send(state, ev,
-						auth_context,
-						state->user_info);
-		if (tevent_req_nomem(subreq, req)) {
-			return tevent_req_post(req, ev);
-		}
-		tevent_req_set_callback(subreq,
-					ntlmssp_server_auth_done,
-					req);
-		return req;
-	}
-
-	if (auth_context->check_ntlm_password == NULL) {
-		tevent_req_nterror(req, NT_STATUS_INTERNAL_ERROR);
-		return tevent_req_post(req, ev);
-	}
-
-	status = auth_context->check_ntlm_password(auth_context,
-						   gensec_ntlmssp,
-						   state->user_info,
-						   &authoritative,
-						   &gensec_ntlmssp->server_returned_info,
-						   &state->user_session_key,
-						   &state->lm_session_key);
-	if (!NT_STATUS_IS_OK(status)) {
-		DBG_INFO("Checking NTLMSSP password for %s\\%s failed: %s\n",
-			 state->user_info->client.domain_name,
-			 state->user_info->client.account_name,
-			 nt_errstr(status));
-	}
-	if (tevent_req_nterror(req, status)) {
+	subreq = auth_context->check_ntlm_password_send(
+		state, ev, auth_context, state->user_info);
+	if (tevent_req_nomem(subreq, req)) {
 		return tevent_req_post(req, ev);
 	}
-	talloc_steal(state, state->user_session_key.data);
-	talloc_steal(state, state->lm_session_key.data);
-
-	status = ntlmssp_server_postauth(gensec_security,
-					 gensec_ntlmssp,
-					 state, in);
-	if (tevent_req_nterror(req, status)) {
-		return tevent_req_post(req, ev);
-	}
-
-	tevent_req_done(req);
-	return tevent_req_post(req, ev);
+	tevent_req_set_callback(subreq,	ntlmssp_server_auth_done, req);
+	return req;
 }
 
 /**
@@ -970,8 +929,12 @@ static NTSTATUS ntlmssp_server_postauth(struct gensec_security *gensec_security,
 				if (session_key.data == NULL) {
 					return NT_STATUS_NO_MEMORY;
 				}
-				SMBsesskeygen_lm_sess_key(lm_session_key.data, ntlmssp_state->lm_resp.data,
-							  session_key.data);
+				nt_status = SMBsesskeygen_lm_sess_key(lm_session_key.data,
+								      ntlmssp_state->lm_resp.data,
+								      session_key.data);
+				if (!NT_STATUS_IS_OK(nt_status)) {
+					return nt_status;
+				}
 				DEBUG(10,("ntlmssp_server_auth: Created NTLM session key.\n"));
 			} else {
 				static const uint8_t zeros[24] = {0, };
@@ -980,8 +943,11 @@ static NTSTATUS ntlmssp_server_postauth(struct gensec_security *gensec_security,
 				if (session_key.data == NULL) {
 					return NT_STATUS_NO_MEMORY;
 				}
-				SMBsesskeygen_lm_sess_key(zeros, zeros,
-							  session_key.data);
+				nt_status = SMBsesskeygen_lm_sess_key(zeros, zeros,
+								      session_key.data);
+				if (!NT_STATUS_IS_OK(nt_status)) {
+					return nt_status;
+				}
 				DEBUG(10,("ntlmssp_server_auth: Created NTLM session key.\n"));
 			}
 			dump_data_pw("LM session key:\n", session_key.data,
diff --git a/bootstrap/.gitlab-ci.yml b/bootstrap/.gitlab-ci.yml
index 865d93485a8..aa0b6448d74 100644
--- a/bootstrap/.gitlab-ci.yml
+++ b/bootstrap/.gitlab-ci.yml
@@ -6,7 +6,7 @@ services:
   stage: images
   tags:
     - docker
-    - shared
+    - gce
   variables:
     SAMBA_CI_IS_BROKEN_IMAGE: "no"
   before_script:
@@ -92,6 +92,9 @@ ubuntu1604:
 ubuntu1404:
   extends: .build_image_template_force_broken
 
+debian10:
+  extends: .build_image_template
+
 debian9:
   extends: .build_image_template
 
diff --git a/bootstrap/READMD.md b/bootstrap/READMD.md
index d653d6d340b..b8a30098b67 100644
--- a/bootstrap/READMD.md
+++ b/bootstrap/READMD.md
@@ -12,7 +12,7 @@ A pure python3 module with CLI to bootstrap Samba envs for multiple distribution
 
 ## Supported Distributions
 
-deb: Debian 7|8|9, Ubuntu 1404|1604|1804
+deb: Debian 7|8|9|10, Ubuntu 1404|1604|1804
 rpm: CentOS 6|7, Fedora 28|29, openSUSE Leap 15.0|15.1
 
 Easy to add more.
diff --git a/bootstrap/config.py b/bootstrap/config.py
index 06fd1142f94..bcada1dc628 100644
--- a/bootstrap/config.py
+++ b/bootstrap/config.py
@@ -37,6 +37,7 @@ COMMON = [
     'binutils',
     'bison',
     'curl',
+    'chrpath',
     'flex',
     'gcc',
     'gdb',
@@ -68,7 +69,7 @@ PKGS = [
     ('mingw-w64', 'mingw64-gcc'),
     ('zlib1g-dev', 'zlib-devel'),
     ('libbsd-dev', 'libbsd-devel'),
-    ('libaio-dev', 'libaio-devel'),
+    ('liburing-dev', 'liburing-devel'),
     ('libarchive-dev', 'libarchive-devel'),
     ('libblkid-dev', 'libblkid-devel'),
     ('libcap-dev', 'libcap-devel'),
@@ -132,7 +133,6 @@ PKGS = [
     ('python3-dbg', ''),
     ('python3-iso8601', ''),
     ('python3-gpg', 'python3-gpg'),  # defaults to ubuntu/fedora latest
-    ('python3-crypto', 'python3-crypto'),
     ('python3-markdown', 'python3-markdown'),
     ('python3-matplotlib', ''),
     ('python3-dnspython', 'python3-dns'),
@@ -385,6 +385,7 @@ DEB_DISTS = {
             'python-gpg': 'python-gpgme',
             'python3-gpg': '',  # no python3 gpg pkg available, remove
             'language-pack-en': '',   # included in locales
+            'liburing-dev': '',   # not available
         }
     },
     'debian8': {
@@ -394,6 +395,7 @@ DEB_DISTS = {
             'python-gpg': 'python-gpgme',
             'python3-gpg': 'python3-gpgme',
             'language-pack-en': '',   # included in locales
+            'liburing-dev': '',   # not available
         }
     },
     'debian9': {
@@ -401,6 +403,15 @@ DEB_DISTS = {
         'vagrant_box': 'debian/stretch64',
         'replace': {
             'language-pack-en': '',   # included in locales
+            'liburing-dev': '',   # not available
+        }
+    },
+    'debian10': {
+        'docker_image': 'debian:10',
+        'vagrant_box': 'debian/buster64',
+        'replace': {
+            'language-pack-en': '',   # included in locales
+            'liburing-dev': '',   # not available
         }
     },
     'ubuntu1404': {
@@ -416,6 +427,7 @@ DEB_DISTS = {
             'libunwind-dev': 'libunwind8-dev',
             'glusterfs-common': '',
             'libcephfs-dev': '',
+            'liburing-dev': '',   # not available
         }
     },
     'ubuntu1604': {
@@ -426,11 +438,15 @@ DEB_DISTS = {
             'python3-gpg': 'python3-gpgme',
             'glusterfs-common': '',
             'libcephfs-dev': '',
+            'liburing-dev': '',   # not available
         }
     },
     'ubuntu1804': {
         'docker_image': 'ubuntu:18.04',
         'vagrant_box': 'ubuntu/bionic64',
+        'replace': {
+            'liburing-dev': '',   # not available
+        }
     },
 }
 
@@ -457,6 +473,7 @@ RPM_DISTS = {
             'glusterfs-api-devel': '',
             'glusterfs-devel': '',
             'libcephfs-devel': '',
+            'liburing-devel': '',   # not available
         }
     },
     'centos7': {
@@ -488,6 +505,7 @@ RPM_DISTS = {
             'glusterfs-devel': '',
             'libcephfs-devel': '',
             'gnutls-devel': 'compat-gnutls34-devel',
+            'liburing-devel': '',   # not available
         }
     },
     'centos8': {
@@ -504,6 +522,7 @@ RPM_DISTS = {
             'policycoreutils-python': 'python3-policycoreutils',
             'python3-crypto': '',
             'quota-devel': '', # FIXME: Add me back, once available!
+            'liburing-devel': '', # not available yet, Add me back, once available!
         }
     },
     'fedora29': {
@@ -512,6 +531,7 @@ RPM_DISTS = {
         'bootstrap': DNF_BOOTSTRAP,
         'replace': {
             'lsb-release': 'redhat-lsb',
+            'liburing-devel': '',   # not available
         }
     },
     'fedora30': {
@@ -520,6 +540,7 @@ RPM_DISTS = {
         'bootstrap': DNF_BOOTSTRAP,
         'replace': {
             'lsb-release': 'redhat-lsb',
+            'liburing-devel': '',   # not available
         }
     },
     'fedora31': {
@@ -562,6 +583,7 @@ RPM_DISTS = {
             'glusterfs-api-devel': '',
             'libtasn1-tools': '', # asn1Parser is part of libtasn1
             'mingw64-gcc': '', # doesn't exist
+            'liburing-devel': '',   # not available
         }
     },
     'opensuse151': {
@@ -594,6 +616,7 @@ RPM_DISTS = {
             'glusterfs-api-devel': '',
             'libtasn1-tools': '', # asn1Parser is part of libtasn1
             'mingw64-gcc': '', # doesn't exist
+            'liburing-devel': '',   # not available, will be added in 15.2
         }
     }
 }
diff --git a/bootstrap/generated-dists/Vagrantfile b/bootstrap/generated-dists/Vagrantfile
index 4381dca6496..b3cb6bea485 100644
--- a/bootstrap/generated-dists/Vagrantfile
+++ b/bootstrap/generated-dists/Vagrantfile
@@ -31,6 +31,13 @@ Vagrant.configure("2") do |config|
         v.vm.provision :shell, path: "centos8/locale.sh"
     end
 
+    config.vm.define "debian10" do |v|
+        v.vm.box = "debian/buster64"
+        v.vm.hostname = "debian10"
+        v.vm.provision :shell, path: "debian10/bootstrap.sh"
+        v.vm.provision :shell, path: "debian10/locale.sh"
+    end
+
     config.vm.define "debian7" do |v|
         v.vm.box = "debian/wheezy64"
         v.vm.hostname = "debian7"
diff --git a/bootstrap/generated-dists/centos6/bootstrap.sh b/bootstrap/generated-dists/centos6/bootstrap.sh
index 129cc3d557b..ee6fcc33799 100755
--- a/bootstrap/generated-dists/centos6/bootstrap.sh
+++ b/bootstrap/generated-dists/centos6/bootstrap.sh
@@ -22,6 +22,7 @@ yum install -y \
     bind-utils \
     binutils \
     bison \
+    chrpath \
     cups-devel \
     curl \
     dbus-devel \
@@ -45,7 +46,6 @@ yum install -y \
     krb5-server \
     lcov \
     libacl-devel \
-    libaio-devel \
     libarchive-devel \
     libattr-devel \
     libblkid-devel \
@@ -82,7 +82,6 @@ yum install -y \
     popt-devel \
     procps \
     psmisc \
-    python3-crypto \
     python3-dns \
     python3-markdown \
     python36 \
diff --git a/bootstrap/generated-dists/centos6/packages.yml b/bootstrap/generated-dists/centos6/packages.yml
index a9225035e02..1e2b5a98fa6 100644
--- a/bootstrap/generated-dists/centos6/packages.yml
+++ b/bootstrap/generated-dists/centos6/packages.yml
@@ -8,6 +8,7 @@ packages:
   - bind-utils
   - binutils
   - bison
+  - chrpath
   - cups-devel
   - curl
   - dbus-devel
@@ -31,7 +32,6 @@ packages:
   - krb5-server
   - lcov
   - libacl-devel
-  - libaio-devel
   - libarchive-devel
   - libattr-devel
   - libblkid-devel
@@ -68,7 +68,6 @@ packages:
   - popt-devel
   - procps
   - psmisc
-  - python3-crypto
   - python3-dns
   - python3-markdown
   - python36
diff --git a/bootstrap/generated-dists/centos7/bootstrap.sh b/bootstrap/generated-dists/centos7/bootstrap.sh
index fb8ee8b72f6..2f0bb1bcc28 100755
--- a/bootstrap/generated-dists/centos7/bootstrap.sh
+++ b/bootstrap/generated-dists/centos7/bootstrap.sh
@@ -22,6 +22,7 @@ yum install -y \
     bind-utils \
     binutils \
     bison \
+    chrpath \
     compat-gnutls34-devel \
     cups-devel \
     curl \
@@ -45,7 +46,6 @@ yum install -y \
     krb5-server \
     lcov \
     libacl-devel \
-    libaio-devel \
     libarchive-devel \
     libattr-devel \
     libblkid-devel \
@@ -83,7 +83,6 @@ yum install -y \
     procps-ng \
     psmisc \
     python36 \
-    python36-crypto \
     python36-devel \
     python36-dns \
     python36-markdown \
diff --git a/bootstrap/generated-dists/centos7/packages.yml b/bootstrap/generated-dists/centos7/packages.yml
index 3d37fd52d51..475326b6db7 100644
--- a/bootstrap/generated-dists/centos7/packages.yml
+++ b/bootstrap/generated-dists/centos7/packages.yml
@@ -8,6 +8,7 @@ packages:
   - bind-utils
   - binutils
   - bison
+  - chrpath
   - compat-gnutls34-devel
   - cups-devel
   - curl
@@ -31,7 +32,6 @@ packages:
   - krb5-server
   - lcov
   - libacl-devel
-  - libaio-devel
   - libarchive-devel
   - libattr-devel
   - libblkid-devel
@@ -69,7 +69,6 @@ packages:
   - procps-ng
   - psmisc
   - python36
-  - python36-crypto
   - python36-devel
   - python36-dns
   - python36-markdown
diff --git a/bootstrap/generated-dists/centos8/bootstrap.sh b/bootstrap/generated-dists/centos8/bootstrap.sh
index 4b12476dd36..22484b3f6ad 100755
--- a/bootstrap/generated-dists/centos8/bootstrap.sh
+++ b/bootstrap/generated-dists/centos8/bootstrap.sh
@@ -23,6 +23,7 @@ yum install -y \
     bind-utils \
     binutils \
     bison \
+    chrpath \
     cups-devel \
     curl \
     dbus-devel \
@@ -48,7 +49,6 @@ yum install -y \
     krb5-devel \
     krb5-server \
     libacl-devel \
-    libaio-devel \
     libarchive-devel \
     libattr-devel \
     libblkid-devel \
diff --git a/bootstrap/generated-dists/centos8/packages.yml b/bootstrap/generated-dists/centos8/packages.yml
index d8e2d02391f..07be0deeceb 100644
--- a/bootstrap/generated-dists/centos8/packages.yml
+++ b/bootstrap/generated-dists/centos8/packages.yml
@@ -8,6 +8,7 @@ packages:
   - bind-utils
   - binutils
   - bison
+  - chrpath
   - cups-devel
   - curl
   - dbus-devel
@@ -33,7 +34,6 @@ packages:
   - krb5-devel
   - krb5-server
   - libacl-devel
-  - libaio-devel
   - libarchive-devel
   - libattr-devel
   - libblkid-devel
diff --git a/bootstrap/generated-dists/debian10/Dockerfile b/bootstrap/generated-dists/debian10/Dockerfile
new file mode 100644
index 00000000000..a7141db7e17
--- /dev/null
+++ b/bootstrap/generated-dists/debian10/Dockerfile
@@ -0,0 +1,27 @@
+#
+# This file is generated by 'bootstrap/template.py --render'
+# See also bootstrap/config.py
+#
+
+FROM debian:10
+
+# pass in with --build-arg while build
+ARG SHA1SUM
+RUN [ -n $SHA1SUM ] && echo $SHA1SUM > /sha1sum.txt
+
+ADD *.sh /tmp/
+# need root permission, do it before USER samba
+RUN /tmp/bootstrap.sh && /tmp/locale.sh
+
+# if ld.gold exists, force link it to ld
+RUN set -x; LD=$(which ld); LD_GOLD=$(which ld.gold); test -x $LD_GOLD && ln -sf $LD_GOLD $LD && test -x $LD && echo "$LD is now $LD_GOLD"
+
+# make test can not work with root, so we have to create a new user
+RUN useradd -m -U -s /bin/bash samba && \
+    mkdir -p /etc/sudoers.d && \
+    echo "samba ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/samba
+
+USER samba
+WORKDIR /home/samba
+# samba tests rely on this
+ENV USER=samba LC_ALL=en_US.utf8 LANG=en_US.utf8
\ No newline at end of file
diff --git a/bootstrap/generated-dists/debian10/bootstrap.sh b/bootstrap/generated-dists/debian10/bootstrap.sh
new file mode 100755
index 00000000000..f0847eb3c20
--- /dev/null
+++ b/bootstrap/generated-dists/debian10/bootstrap.sh
@@ -0,0 +1,105 @@
+#!/bin/bash
+
+#
+# This file is generated by 'bootstrap/template.py --render'
+# See also bootstrap/config.py
+#
+
+set -xueo pipefail
+
+export DEBIAN_FRONTEND=noninteractive
+apt-get -y update
+
+apt-get -y install \
+    acl \
+    apt-utils \
+    attr \
+    autoconf \
+    bind9utils \
+    binutils \
+    bison \
+    build-essential \
+    chrpath \
+    curl \
+    debhelper \
+    dnsutils \
+    docbook-xml \
+    docbook-xsl \
+    flex \
+    gcc \
+    gdb \
+    git \
+    glusterfs-common \
+    gzip \
+    heimdal-multidev \
+    hostname \
+    htop \
+    krb5-config \
+    krb5-kdc \
+    krb5-user \
+    lcov \
+    libacl1-dev \
+    libarchive-dev \
+    libattr1-dev \
+    libavahi-common-dev \
+    libblkid-dev \
+    libbsd-dev \
+    libcap-dev \
+    libcephfs-dev \
+    libcups2-dev \
+    libdbus-1-dev \
+    libglib2.0-dev \
+    libgnutls28-dev \
+    libgpgme11-dev \
+    libicu-dev \
+    libjansson-dev \
+    libjs-jquery \
+    libjson-perl \
+    libkrb5-dev \
+    libldap2-dev \
+    liblmdb-dev \
+    libncurses5-dev \
+    libpam0g-dev \
+    libparse-yapp-perl \
+    libpcap-dev \
+    libpopt-dev \
+    libreadline-dev \
+    libsystemd-dev \
+    libtasn1-bin \
+    libtasn1-dev \
+    libunwind-dev \
+    lmdb-utils \
+    locales \
+    lsb-release \
+    make \
+    mawk \
+    mingw-w64 \
+    patch \
+    perl \
+    perl-modules \
+    pkg-config \
+    procps \
+    psmisc \
+    python3 \
+    python3-dbg \
+    python3-dev \
+    python3-dnspython \
+    python3-gpg \
+    python3-iso8601 \
+    python3-markdown \
+    python3-matplotlib \
+    python3-pexpect \
+    rng-tools \
+    rsync \
+    sed \
+    sudo \
+    tar \
+    tree \
+    uuid-dev \
+    xfslibs-dev \
+    xsltproc \
+    zlib1g-dev
+
+apt-get -y autoremove
+apt-get -y autoclean
+apt-get -y clean
\ No newline at end of file
diff --git a/bootstrap/generated-dists/debian10/locale.sh b/bootstrap/generated-dists/debian10/locale.sh
new file mode 100755
index 00000000000..cc64e180483
--- /dev/null
+++ b/bootstrap/generated-dists/debian10/locale.sh
@@ -0,0 +1,55 @@
+#!/bin/bash
+
+#
+# This file is generated by 'bootstrap/template.py --render'
+# See also bootstrap/config.py
+#
+
+set -xueo pipefail
+
+# refer to /usr/share/i18n/locales
+INPUTFILE=en_US
+# refer to /usr/share/i18n/charmaps
+CHARMAP=UTF-8
+# locale to generate in /usr/lib/locale
+# glibc/localedef will normalize UTF-8 to utf8, follow the naming style
+LOCALE=$INPUTFILE.utf8
+
+# if locale is already correct, exit
+( locale | grep LC_ALL | grep -i $LOCALE ) && exit 0
+
+# if locale not available, generate locale into /usr/lib/locale
+if ! ( locale --all-locales | grep -i $LOCALE )
+then
+    # no-archive means create its own dir
+    localedef --inputfile $INPUTFILE --charmap $CHARMAP --no-archive $LOCALE
+fi
+
+# update locale conf and global env file
+# set both LC_ALL and LANG for safe
+
+# update conf for Debian family
+FILE=/etc/default/locale
+if [ -f $FILE ]
+then
+    echo LC_ALL="$LOCALE" > $FILE
+    echo LANG="$LOCALE" >> $FILE
+fi
+
+# update conf for RedHat family
+FILE=/etc/locale.conf
+if [ -f $FILE ]
+then
+    # LC_ALL is not valid in this file, set LANG only
+    echo LANG="$LOCALE" > $FILE
+fi
+
+# update global env file
+FILE=/etc/environment
+if [ -f $FILE ]
+then
+    # append LC_ALL if not exist
+    grep LC_ALL $FILE || echo LC_ALL="$LOCALE" >> $FILE
+    # append LANG if not exist
+    grep LANG $FILE || echo LANG="$LOCALE" >> $FILE
+fi
\ No newline at end of file
diff --git a/bootstrap/generated-dists/debian10/packages.yml b/bootstrap/generated-dists/debian10/packages.yml
new file mode 100644
index 00000000000..a242cd8b362
--- /dev/null
+++ b/bootstrap/generated-dists/debian10/packages.yml
@@ -0,0 +1,90 @@
+---
+packages:
+  - acl
+  - apt-utils
+  - attr
+  - autoconf
+  - bind9utils
+  - binutils
+  - bison
+  - build-essential
+  - chrpath
+  - curl
+  - debhelper
+  - dnsutils
+  - docbook-xml
+  - docbook-xsl
+  - flex
+  - gcc
+  - gdb
+  - git
+  - glusterfs-common
+  - gzip
+  - heimdal-multidev
+  - hostname
+  - htop
+  - krb5-config
+  - krb5-kdc
+  - krb5-user
+  - lcov
+  - libacl1-dev
+  - libarchive-dev
+  - libattr1-dev
+  - libavahi-common-dev
+  - libblkid-dev
+  - libbsd-dev
+  - libcap-dev
+  - libcephfs-dev
+  - libcups2-dev
+  - libdbus-1-dev
+  - libglib2.0-dev
+  - libgnutls28-dev
+  - libgpgme11-dev
+  - libicu-dev
+  - libjansson-dev
+  - libjs-jquery
+  - libjson-perl
+  - libkrb5-dev
+  - libldap2-dev
+  - liblmdb-dev
+  - libncurses5-dev
+  - libpam0g-dev
+  - libparse-yapp-perl
+  - libpcap-dev
+  - libpopt-dev
+  - libreadline-dev
+  - libsystemd-dev
+  - libtasn1-bin
+  - libtasn1-dev
+  - libunwind-dev
+  - lmdb-utils
+  - locales
+  - lsb-release
+  - make
+  - mawk
+  - mingw-w64
+  - patch
+  - perl
+  - perl-modules
+  - pkg-config
+  - procps
+  - psmisc
+  - python3
+  - python3-dbg
+  - python3-dev
+  - python3-dnspython
+  - python3-gpg
+  - python3-iso8601
+  - python3-markdown
+  - python3-matplotlib
+  - python3-pexpect
+  - rng-tools
+  - rsync
+  - sed
+  - sudo
+  - tar
+  - tree
+  - uuid-dev
+  - xfslibs-dev
+  - xsltproc
+  - zlib1g-dev
\ No newline at end of file
diff --git a/bootstrap/generated-dists/debian7/bootstrap.sh b/bootstrap/generated-dists/debian7/bootstrap.sh
index ea22b863afb..daedce84fd9 100755
--- a/bootstrap/generated-dists/debian7/bootstrap.sh
+++ b/bootstrap/generated-dists/debian7/bootstrap.sh
@@ -19,6 +19,7 @@ apt-get -y install \
     binutils \
     bison \
     build-essential \
+    chrpath \
     curl \
     debhelper \
     dnsutils \
@@ -38,7 +39,6 @@ apt-get -y install \
     krb5-user \
     lcov \
     libacl1-dev \
-    libaio-dev \
     libarchive-dev \
     libattr1-dev \
     libavahi-common-dev \
@@ -78,7 +78,6 @@ apt-get -y install \
     procps \
     psmisc \
     python3 \
-    python3-crypto \
     python3-dbg \
     python3-dev \
     python3-dnspython \
diff --git a/bootstrap/generated-dists/debian7/packages.yml b/bootstrap/generated-dists/debian7/packages.yml
index 3303e68d87b..3cac6870b3e 100644
--- a/bootstrap/generated-dists/debian7/packages.yml
+++ b/bootstrap/generated-dists/debian7/packages.yml
@@ -8,6 +8,7 @@ packages:
   - binutils
   - bison
   - build-essential
+  - chrpath
   - curl
   - debhelper
   - dnsutils
@@ -27,7 +28,6 @@ packages:
   - krb5-user
   - lcov
   - libacl1-dev
-  - libaio-dev
   - libarchive-dev
   - libattr1-dev
   - libavahi-common-dev
@@ -67,7 +67,6 @@ packages:
   - procps
   - psmisc
   - python3
-  - python3-crypto
   - python3-dbg
   - python3-dev
   - python3-dnspython
diff --git a/bootstrap/generated-dists/debian8/bootstrap.sh b/bootstrap/generated-dists/debian8/bootstrap.sh
index 687e7723847..010508360ed 100755
--- a/bootstrap/generated-dists/debian8/bootstrap.sh
+++ b/bootstrap/generated-dists/debian8/bootstrap.sh
@@ -19,6 +19,7 @@ apt-get -y install \
     binutils \
     bison \
     build-essential \
+    chrpath \
     curl \
     debhelper \
     dnsutils \
@@ -38,7 +39,6 @@ apt-get -y install \
     krb5-user \
     lcov \
     libacl1-dev \
-    libaio-dev \
     libarchive-dev \
     libattr1-dev \
     libavahi-common-dev \
@@ -81,7 +81,6 @@ apt-get -y install \
     procps \
     psmisc \
     python3 \
-    python3-crypto \
     python3-dbg \
     python3-dev \
     python3-dnspython \
diff --git a/bootstrap/generated-dists/debian8/packages.yml b/bootstrap/generated-dists/debian8/packages.yml
index 008d58c9514..1c9552b85f3 100644
--- a/bootstrap/generated-dists/debian8/packages.yml
+++ b/bootstrap/generated-dists/debian8/packages.yml
@@ -8,6 +8,7 @@ packages:
   - binutils
   - bison
   - build-essential
+  - chrpath
   - curl
   - debhelper
   - dnsutils
@@ -27,7 +28,6 @@ packages:
   - krb5-user
   - lcov
   - libacl1-dev
-  - libaio-dev
   - libarchive-dev
   - libattr1-dev
   - libavahi-common-dev
@@ -70,7 +70,6 @@ packages:
   - procps
   - psmisc
   - python3
-  - python3-crypto
   - python3-dbg
   - python3-dev
   - python3-dnspython
diff --git a/bootstrap/generated-dists/debian9/bootstrap.sh b/bootstrap/generated-dists/debian9/bootstrap.sh
index 6970c477b38..f0847eb3c20 100755
--- a/bootstrap/generated-dists/debian9/bootstrap.sh
+++ b/bootstrap/generated-dists/debian9/bootstrap.sh
@@ -19,6 +19,7 @@ apt-get -y install \
     binutils \
     bison \
     build-essential \
+    chrpath \
     curl \
     debhelper \
     dnsutils \
@@ -38,7 +39,6 @@ apt-get -y install \
     krb5-user \
     lcov \
     libacl1-dev \
-    libaio-dev \
     libarchive-dev \
     libattr1-dev \
     libavahi-common-dev \
@@ -81,7 +81,6 @@ apt-get -y install \
     procps \
     psmisc \
     python3 \
-    python3-crypto \
     python3-dbg \
     python3-dev \
     python3-dnspython \
diff --git a/bootstrap/generated-dists/debian9/packages.yml b/bootstrap/generated-dists/debian9/packages.yml
index 5943f28704b..a242cd8b362 100644
--- a/bootstrap/generated-dists/debian9/packages.yml
+++ b/bootstrap/generated-dists/debian9/packages.yml
@@ -8,6 +8,7 @@ packages:
   - binutils
   - bison
   - build-essential
+  - chrpath
   - curl
   - debhelper
   - dnsutils
@@ -27,7 +28,6 @@ packages:
   - krb5-user
   - lcov
   - libacl1-dev
-  - libaio-dev
   - libarchive-dev
   - libattr1-dev
   - libavahi-common-dev
@@ -70,7 +70,6 @@ packages:
   - procps
   - psmisc
   - python3
-  - python3-crypto
   - python3-dbg
   - python3-dev
   - python3-dnspython
diff --git a/bootstrap/generated-dists/fedora29/bootstrap.sh b/bootstrap/generated-dists/fedora29/bootstrap.sh
index 1c8357c5cb5..effe2a9d214 100755
--- a/bootstrap/generated-dists/fedora29/bootstrap.sh
+++ b/bootstrap/generated-dists/fedora29/bootstrap.sh
@@ -19,6 +19,7 @@ dnf install -y \
     bind-utils \
     binutils \
     bison \
+    chrpath \
     cups-devel \
     curl \
     dbus-devel \
@@ -45,7 +46,6 @@ dnf install -y \
     krb5-server \
     lcov \
     libacl-devel \
-    libaio-devel \
     libarchive-devel \
     libattr-devel \
     libblkid-devel \
@@ -84,7 +84,6 @@ dnf install -y \
     procps-ng \
     psmisc \
     python3 \
-    python3-crypto \
     python3-devel \
     python3-dns \
     python3-gpg \
diff --git a/bootstrap/generated-dists/fedora29/packages.yml b/bootstrap/generated-dists/fedora29/packages.yml
index dc37c6f15dd..3b767f8ba08 100644
--- a/bootstrap/generated-dists/fedora29/packages.yml
+++ b/bootstrap/generated-dists/fedora29/packages.yml
@@ -8,6 +8,7 @@ packages:
   - bind-utils
   - binutils
   - bison
+  - chrpath
   - cups-devel
   - curl
   - dbus-devel
@@ -34,7 +35,6 @@ packages:
   - krb5-server
   - lcov
   - libacl-devel
-  - libaio-devel
   - libarchive-devel
   - libattr-devel
   - libblkid-devel
@@ -73,7 +73,6 @@ packages:
   - procps-ng
   - psmisc
   - python3
-  - python3-crypto
   - python3-devel
   - python3-dns
   - python3-gpg
diff --git a/bootstrap/generated-dists/fedora30/bootstrap.sh b/bootstrap/generated-dists/fedora30/bootstrap.sh
index 1c8357c5cb5..effe2a9d214 100755
--- a/bootstrap/generated-dists/fedora30/bootstrap.sh
+++ b/bootstrap/generated-dists/fedora30/bootstrap.sh
@@ -19,6 +19,7 @@ dnf install -y \
     bind-utils \
     binutils \
     bison \
+    chrpath \
     cups-devel \
     curl \
     dbus-devel \
@@ -45,7 +46,6 @@ dnf install -y \
     krb5-server \
     lcov \
     libacl-devel \
-    libaio-devel \
     libarchive-devel \
     libattr-devel \
     libblkid-devel \
@@ -84,7 +84,6 @@ dnf install -y \
     procps-ng \
     psmisc \
     python3 \
-    python3-crypto \
     python3-devel \
     python3-dns \
     python3-gpg \
diff --git a/bootstrap/generated-dists/fedora30/packages.yml b/bootstrap/generated-dists/fedora30/packages.yml
index dc37c6f15dd..3b767f8ba08 100644
--- a/bootstrap/generated-dists/fedora30/packages.yml
+++ b/bootstrap/generated-dists/fedora30/packages.yml
@@ -8,6 +8,7 @@ packages:
   - bind-utils
   - binutils
   - bison
+  - chrpath
   - cups-devel
   - curl
   - dbus-devel
@@ -34,7 +35,6 @@ packages:
   - krb5-server
   - lcov
   - libacl-devel
-  - libaio-devel
   - libarchive-devel
   - libattr-devel
   - libblkid-devel
@@ -73,7 +73,6 @@ packages:
   - procps-ng
   - psmisc
   - python3
-  - python3-crypto
   - python3-devel
   - python3-dns
   - python3-gpg
diff --git a/bootstrap/generated-dists/fedora31/bootstrap.sh b/bootstrap/generated-dists/fedora31/bootstrap.sh
index b423481af67..18c58092eff 100755
--- a/bootstrap/generated-dists/fedora31/bootstrap.sh
+++ b/bootstrap/generated-dists/fedora31/bootstrap.sh
@@ -19,6 +19,7 @@ dnf install -y \
     bind-utils \
     binutils \
     bison \
+    chrpath \
     cups-devel \
     curl \
     dbus-devel \
@@ -45,7 +46,6 @@ dnf install -y \
     krb5-server \
     lcov \
     libacl-devel \
-    libaio-devel \
     libarchive-devel \
     libattr-devel \
     libblkid-devel \
@@ -59,6 +59,7 @@ dnf install -y \
     libtasn1-tools \
     libtirpc-devel \
     libunwind-devel \
+    liburing-devel \
     libuuid-devel \
     libxslt \
     lmdb \
@@ -82,7 +83,6 @@ dnf install -y \
     procps-ng \
     psmisc \
     python3 \
-    python3-crypto \
     python3-devel \
     python3-dns \
     python3-gpg \
diff --git a/bootstrap/generated-dists/fedora31/packages.yml b/bootstrap/generated-dists/fedora31/packages.yml
index d56faf8a859..3165af8dd82 100644
--- a/bootstrap/generated-dists/fedora31/packages.yml
+++ b/bootstrap/generated-dists/fedora31/packages.yml
@@ -8,6 +8,7 @@ packages:
   - bind-utils
   - binutils
   - bison
+  - chrpath
   - cups-devel
   - curl
   - dbus-devel
@@ -34,7 +35,6 @@ packages:
   - krb5-server
   - lcov
   - libacl-devel
-  - libaio-devel
   - libarchive-devel
   - libattr-devel
   - libblkid-devel
@@ -48,6 +48,7 @@ packages:
   - libtasn1-tools
   - libtirpc-devel
   - libunwind-devel
+  - liburing-devel
   - libuuid-devel
   - libxslt
   - lmdb
@@ -71,7 +72,6 @@ packages:
   - procps-ng
   - psmisc
   - python3
-  - python3-crypto
   - python3-devel
   - python3-dns
   - python3-gpg
diff --git a/bootstrap/generated-dists/opensuse150/bootstrap.sh b/bootstrap/generated-dists/opensuse150/bootstrap.sh
index a970cde7679..3fbcaacb24f 100755
--- a/bootstrap/generated-dists/opensuse150/bootstrap.sh
+++ b/bootstrap/generated-dists/opensuse150/bootstrap.sh
@@ -19,6 +19,7 @@ zypper --non-interactive install \
     bind-utils \
     binutils \
     bison \
+    chrpath \
     cups-devel \
     curl \
     dbus-1-devel \
@@ -42,7 +43,6 @@ zypper --non-interactive install \
     krb5-server \
     lcov \
     libacl-devel \
-    libaio-devel \
     libarchive-devel \
     libattr-devel \
     libblkid-devel \
@@ -83,7 +83,6 @@ zypper --non-interactive install \
     python3-devel \
     python3-dnspython \
     python3-gpg \
-    python3-pycrypto \
     readline-devel \
     rng-tools \
     rpcgen \
diff --git a/bootstrap/generated-dists/opensuse150/packages.yml b/bootstrap/generated-dists/opensuse150/packages.yml
index 62a4270600a..0eb19244677 100644
--- a/bootstrap/generated-dists/opensuse150/packages.yml
+++ b/bootstrap/generated-dists/opensuse150/packages.yml
@@ -7,6 +7,7 @@ packages:
   - bind-utils
   - binutils
   - bison
+  - chrpath
   - cups-devel
   - curl
   - dbus-1-devel
@@ -30,7 +31,6 @@ packages:
   - krb5-server
   - lcov
   - libacl-devel
-  - libaio-devel
   - libarchive-devel
   - libattr-devel
   - libblkid-devel
@@ -71,7 +71,6 @@ packages:
   - python3-devel
   - python3-dnspython
   - python3-gpg
-  - python3-pycrypto
   - readline-devel
   - rng-tools
   - rpcgen
diff --git a/bootstrap/generated-dists/opensuse151/bootstrap.sh b/bootstrap/generated-dists/opensuse151/bootstrap.sh
index a970cde7679..3fbcaacb24f 100755
--- a/bootstrap/generated-dists/opensuse151/bootstrap.sh
+++ b/bootstrap/generated-dists/opensuse151/bootstrap.sh
@@ -19,6 +19,7 @@ zypper --non-interactive install \
     bind-utils \
     binutils \
     bison \
+    chrpath \
     cups-devel \
     curl \
     dbus-1-devel \
@@ -42,7 +43,6 @@ zypper --non-interactive install \
     krb5-server \
     lcov \
     libacl-devel \
-    libaio-devel \
     libarchive-devel \
     libattr-devel \
     libblkid-devel \
@@ -83,7 +83,6 @@ zypper --non-interactive install \
     python3-devel \
     python3-dnspython \
     python3-gpg \
-    python3-pycrypto \
     readline-devel \
     rng-tools \
     rpcgen \
diff --git a/bootstrap/generated-dists/opensuse151/packages.yml b/bootstrap/generated-dists/opensuse151/packages.yml
index 62a4270600a..0eb19244677 100644
--- a/bootstrap/generated-dists/opensuse151/packages.yml
+++ b/bootstrap/generated-dists/opensuse151/packages.yml
@@ -7,6 +7,7 @@ packages:
   - bind-utils
   - binutils
   - bison
+  - chrpath
   - cups-devel
   - curl
   - dbus-1-devel
@@ -30,7 +31,6 @@ packages:
   - krb5-server
   - lcov
   - libacl-devel
-  - libaio-devel
   - libarchive-devel
   - libattr-devel
   - libblkid-devel
@@ -71,7 +71,6 @@ packages:
   - python3-devel
   - python3-dnspython
   - python3-gpg
-  - python3-pycrypto
   - readline-devel
   - rng-tools
   - rpcgen
diff --git a/bootstrap/generated-dists/ubuntu1404/bootstrap.sh b/bootstrap/generated-dists/ubuntu1404/bootstrap.sh
index e671c7a50c0..78c8969ac69 100755
--- a/bootstrap/generated-dists/ubuntu1404/bootstrap.sh
+++ b/bootstrap/generated-dists/ubuntu1404/bootstrap.sh
@@ -19,6 +19,7 @@ apt-get -y install \
     binutils \
     bison \
     build-essential \
+    chrpath \
     curl \
     debhelper \
     dnsutils \
@@ -38,7 +39,6 @@ apt-get -y install \
     language-pack-en \
     lcov \
     libacl1-dev \
-    libaio-dev \
     libarchive-dev \
     libattr1-dev \
     libavahi-common-dev \
@@ -79,7 +79,6 @@ apt-get -y install \
     procps \
     psmisc \
     python3 \
-    python3-crypto \
     python3-dbg \
     python3-dev \
     python3-dnspython \
diff --git a/bootstrap/generated-dists/ubuntu1404/packages.yml b/bootstrap/generated-dists/ubuntu1404/packages.yml
index af577b3a329..f6c8a0aaa00 100644
--- a/bootstrap/generated-dists/ubuntu1404/packages.yml
+++ b/bootstrap/generated-dists/ubuntu1404/packages.yml
@@ -8,6 +8,7 @@ packages:
   - binutils
   - bison
   - build-essential
+  - chrpath
   - curl
   - debhelper
   - dnsutils
@@ -27,7 +28,6 @@ packages:
   - language-pack-en
   - lcov
   - libacl1-dev
-  - libaio-dev
   - libarchive-dev
   - libattr1-dev
   - libavahi-common-dev
@@ -68,7 +68,6 @@ packages:
   - procps
   - psmisc
   - python3
-  - python3-crypto
   - python3-dbg
   - python3-dev
   - python3-dnspython
diff --git a/bootstrap/generated-dists/ubuntu1604/bootstrap.sh b/bootstrap/generated-dists/ubuntu1604/bootstrap.sh
index cfac3a06211..a8f47762ded 100755
--- a/bootstrap/generated-dists/ubuntu1604/bootstrap.sh
+++ b/bootstrap/generated-dists/ubuntu1604/bootstrap.sh
@@ -19,6 +19,7 @@ apt-get -y install \
     binutils \
     bison \
     build-essential \
+    chrpath \
     curl \
     debhelper \
     dnsutils \
@@ -38,7 +39,6 @@ apt-get -y install \
     language-pack-en \
     lcov \
     libacl1-dev \
-    libaio-dev \
     libarchive-dev \
     libattr1-dev \
     libavahi-common-dev \
@@ -80,7 +80,6 @@ apt-get -y install \
     procps \
     psmisc \
     python3 \
-    python3-crypto \
     python3-dbg \
     python3-dev \
     python3-dnspython \
diff --git a/bootstrap/generated-dists/ubuntu1604/packages.yml b/bootstrap/generated-dists/ubuntu1604/packages.yml
index 7efddb7bbbd..c3cd9af9c3e 100644
--- a/bootstrap/generated-dists/ubuntu1604/packages.yml
+++ b/bootstrap/generated-dists/ubuntu1604/packages.yml
@@ -8,6 +8,7 @@ packages:
   - binutils
   - bison
   - build-essential
+  - chrpath
   - curl
   - debhelper
   - dnsutils
@@ -27,7 +28,6 @@ packages:
   - language-pack-en
   - lcov
   - libacl1-dev
-  - libaio-dev
   - libarchive-dev
   - libattr1-dev
   - libavahi-common-dev
@@ -69,7 +69,6 @@ packages:
   - procps
   - psmisc
   - python3
-  - python3-crypto
   - python3-dbg
   - python3-dev
   - python3-dnspython
diff --git a/bootstrap/generated-dists/ubuntu1804/bootstrap.sh b/bootstrap/generated-dists/ubuntu1804/bootstrap.sh
index 0e5c611665b..97d32815d72 100755
--- a/bootstrap/generated-dists/ubuntu1804/bootstrap.sh
+++ b/bootstrap/generated-dists/ubuntu1804/bootstrap.sh
@@ -19,6 +19,7 @@ apt-get -y install \
     binutils \
     bison \
     build-essential \
+    chrpath \
     curl \
     debhelper \
     dnsutils \
@@ -39,7 +40,6 @@ apt-get -y install \
     language-pack-en \
     lcov \
     libacl1-dev \
-    libaio-dev \
     libarchive-dev \
     libattr1-dev \
     libavahi-common-dev \
@@ -82,7 +82,6 @@ apt-get -y install \
     procps \
     psmisc \
     python3 \
-    python3-crypto \
     python3-dbg \
     python3-dev \
     python3-dnspython \
diff --git a/bootstrap/generated-dists/ubuntu1804/packages.yml b/bootstrap/generated-dists/ubuntu1804/packages.yml
index 2045f092f16..f45deb2c808 100644
--- a/bootstrap/generated-dists/ubuntu1804/packages.yml
+++ b/bootstrap/generated-dists/ubuntu1804/packages.yml
@@ -8,6 +8,7 @@ packages:
   - binutils
   - bison
   - build-essential
+  - chrpath
   - curl
   - debhelper
   - dnsutils
@@ -28,7 +29,6 @@ packages:
   - language-pack-en
   - lcov
   - libacl1-dev
-  - libaio-dev
   - libarchive-dev
   - libattr1-dev
   - libavahi-common-dev
@@ -71,7 +71,6 @@ packages:
   - procps
   - psmisc
   - python3
-  - python3-crypto
   - python3-dbg
   - python3-dev
   - python3-dnspython
diff --git a/bootstrap/sha1sum.txt b/bootstrap/sha1sum.txt
index b220ebdde0c..62c2245564e 100644
--- a/bootstrap/sha1sum.txt
+++ b/bootstrap/sha1sum.txt
@@ -1 +1 @@
-187702e2a9c65f874aa13e5eb1c8b68703e72299
+41319f2580c026f66b2750604a0eb15d6b6f7b50
diff --git a/buildtools/wafsamba/samba3.py b/buildtools/wafsamba/samba3.py
index 818bfc041c5..7b42075d1ab 100644
--- a/buildtools/wafsamba/samba3.py
+++ b/buildtools/wafsamba/samba3.py
@@ -40,7 +40,8 @@ def s3_fix_kwargs(bld, kwargs):
         extra_includes += [ '../source4/heimdal/lib/com_err',
                             '../source4/heimdal/lib/krb5',
                             '../source4/heimdal/lib/gssapi',
-                            '../source4/heimdal_build',
+                            '../source4/heimdal/lib/gssapi/gssapi',
+                            '../source4/heimdal_build/include',
                             '../bin/default/source4/heimdal/lib/asn1' ]
 
     if bld.CONFIG_SET('USING_SYSTEM_TDB'):
diff --git a/buildtools/wafsamba/samba_autoconf.py b/buildtools/wafsamba/samba_autoconf.py
index 1ccee54bb63..4615e201422 100644
--- a/buildtools/wafsamba/samba_autoconf.py
+++ b/buildtools/wafsamba/samba_autoconf.py
@@ -725,6 +725,9 @@ def SAMBA_CONFIG_H(conf, path=None):
     if Options.options.debug:
         conf.ADD_CFLAGS('-g', testflags=True)
 
+    if Options.options.pidl_developer:
+        conf.env.PIDL_DEVELOPER_MODE = True
+
     if Options.options.developer:
         conf.env.DEVELOPER_MODE = True
 
diff --git a/buildtools/wafsamba/samba_pidl.py b/buildtools/wafsamba/samba_pidl.py
index 3fecfa90eb9..d7e1247aa20 100644
--- a/buildtools/wafsamba/samba_pidl.py
+++ b/buildtools/wafsamba/samba_pidl.py
@@ -69,6 +69,10 @@ def SAMBA_PIDL(bld, pname, source,
     if cpp == "CPP=xlc_r":
         cpp = ""
 
+    if bld.env['PIDL_DEVELOPER_MODE']:
+        pidl_dev = 'PIDL_DEVELOPER=1 '
+    else:
+        pidl_dev = ''
 
     if bld.CONFIG_SET("CC"):
         if isinstance(bld.CONFIG_GET("CC"), list):
@@ -76,7 +80,7 @@ def SAMBA_PIDL(bld, pname, source,
         else:
             cc = 'CC="%s"' % bld.CONFIG_GET("CC")
 
-    t = bld(rule='cd ${PIDL_LAUNCH_DIR} && %s %s ${PERL} ${PIDL} --quiet ${OPTIONS} --outputdir ${OUTPUTDIR} -- "${IDLSRC}"' % (cpp, cc),
+    t = bld(rule='cd ${PIDL_LAUNCH_DIR} && %s%s %s ${PERL} ${PIDL} --quiet ${OPTIONS} --outputdir ${OUTPUTDIR} -- "${IDLSRC}"' % (pidl_dev, cpp, cc),
             ext_out    = '.c',
             before     = 'c',
             update_outputs = True,
@@ -104,14 +108,34 @@ def SAMBA_PIDL(bld, pname, source,
     t.more_includes = '#' + bld.path.path_from(bld.srcnode)
 Build.BuildContext.SAMBA_PIDL = SAMBA_PIDL
 
-
 def SAMBA_PIDL_LIST(bld, name, source,
                     options='',
                     output_dir='.',
-                    generate_tables=True):
+                    generate_tables=True,
+                    generate_fuzzers=True):
     '''A wrapper for building a set of IDL files'''
     for p in TO_LIST(source):
         bld.SAMBA_PIDL(name, p, options=options, output_dir=output_dir, generate_tables=generate_tables)
+
+        # Some IDL files don't exactly match between name and
+        # "interface" so we need a way to skip those, while other IDL
+        # files have the table generation skipped entirely, on which
+        # the fuzzers rely
+        if generate_tables and generate_fuzzers:
+            interface = p[0:-4] # strip off the .idl suffix
+            bld.SAMBA_NDR_FUZZ(interface,
+                               auto_deps=True,
+                               fuzz_type="TYPE_STRUCT")
+
+            # Only generate the TYPE_STRUCT fuzzer if this isn't
+            # really DCE/RPC
+            if '--client' in options:
+                bld.SAMBA_NDR_FUZZ(interface,
+                                   auto_deps=True,
+                                   fuzz_type="TYPE_IN")
+                bld.SAMBA_NDR_FUZZ(interface,
+                                   auto_deps=True,
+                                   fuzz_type="TYPE_OUT")
 Build.BuildContext.SAMBA_PIDL_LIST = SAMBA_PIDL_LIST
 
 
diff --git a/buildtools/wafsamba/samba_python.py b/buildtools/wafsamba/samba_python.py
index cb726cf0bcc..0b96a81ff41 100644
--- a/buildtools/wafsamba/samba_python.py
+++ b/buildtools/wafsamba/samba_python.py
@@ -104,6 +104,10 @@ def SAMBA_PYTHON(bld, name,
     if not bld.PYTHON_BUILD_IS_ENABLED():
         enabled = False
 
+    # Save time, no need to build python bindings when fuzzing
+    if bld.env.enable_fuzzing:
+        enabled = False
+
     # when we support static python modules we'll need to gather
     # the list from all the SAMBA_PYTHON() targets
     if init_function_sentinel is not None:
diff --git a/buildtools/wafsamba/samba_utils.py b/buildtools/wafsamba/samba_utils.py
index 4a5a34abae7..f9eae73ae44 100644
--- a/buildtools/wafsamba/samba_utils.py
+++ b/buildtools/wafsamba/samba_utils.py
@@ -682,7 +682,7 @@ def PROCESS_SEPARATE_RULE(self, rule):
             cache[node] = True
             self.pre_recurse(node)
             try:
-                function_code = node.read('rU', None)
+                function_code = node.read('r', None)
                 exec(compile(function_code, node.abspath(), 'exec'), self.exec_dict)
             finally:
                 self.post_recurse(node)
diff --git a/buildtools/wafsamba/wafsamba.py b/buildtools/wafsamba/wafsamba.py
index 7081f382eaa..7827d374654 100644
--- a/buildtools/wafsamba/wafsamba.py
+++ b/buildtools/wafsamba/wafsamba.py
@@ -360,13 +360,30 @@ def SAMBA_BINARY(bld, binname, source,
                  subdir=None,
                  install=True,
                  install_path=None,
-                 enabled=True):
+                 enabled=True,
+                 fuzzer=False,
+                 for_selftest=False):
     '''define a Samba binary'''
 
+    if for_selftest and not bld.CONFIG_GET('ENABLE_SELFTEST'):
+        enabled=False
+
     if not enabled:
         SET_TARGET_TYPE(bld, binname, 'DISABLED')
         return
 
+    # Fuzzing builds do not build normal binaries
+    # however we must build asn1compile etc
+
+    if not use_hostcc and bld.env.enable_fuzzing != fuzzer:
+        SET_TARGET_TYPE(bld, binname, 'DISABLED')
+        return
+
+    if fuzzer:
+        install = False
+        if ldflags is None:
+            ldflags = bld.env['FUZZ_TARGET_LDFLAGS']
+
     if not SET_TARGET_TYPE(bld, binname, 'BINARY'):
         return
 
diff --git a/buildtools/wafsamba/wscript b/buildtools/wafsamba/wscript
index b601dd2596d..f0b679257b7 100644
--- a/buildtools/wafsamba/wscript
+++ b/buildtools/wafsamba/wscript
@@ -102,6 +102,9 @@ def options(opt):
     gr.add_option('--enable-developer',
                    help=("Turn on developer warnings and debugging"),
                    action="store_true", dest='developer', default=False)
+    gr.add_option('--pidl-developer',
+                   help=("annotate PIDL-generated code for developers"),
+                   action="store_true", dest='pidl_developer', default=False)
     gr.add_option('--disable-warnings-as-errors',
                    help=("Do not treat all warnings as errors (disable -Werror)"),
                    action="store_true", dest='disable_warnings_as_errors', default=False)
@@ -130,8 +133,18 @@ def options(opt):
         dest='undefined_sanitizer',
         default=False)
     gr.add_option('--enable-libfuzzer',
-                  help=("Build fuzzing binaries (requires compiler options for libFuzzer or compiler wrapper such as honggfuzz/hfuzz-cc)"),
+                  help=("Build fuzzing binaries (use ADDITIONAL_CFLAGS to specify compiler options for libFuzzer or use CC=honggfuzz/hfuzz-cc)"),
                   action="store_true", dest='enable_libfuzzer', default=False)
+    gr.add_option('--enable-afl-fuzzer',
+                  help=("Build fuzzing binaries AFL-style (typically use with CC=afl-gcc)"),
+                  action="store_true", dest='enable_afl_fuzzer', default=False)
+
+    # Fuzz targets may need additional LDFLAGS that we can't use on
+    # internal binaries like asn1_compile
+
+    gr.add_option('--fuzz-target-ldflags',
+                  help=("Linker flags to be used when building fuzz targets"),
+                  action="store", dest='FUZZ_TARGET_LDFLAGS', default='')
 
     gr.add_option('--abi-check',
 		   help=("Check ABI signatures for libraries"),
@@ -593,9 +606,14 @@ struct foo bar = { .y = 'X', .x = 1 };
                     eprintf("bla", "bar")
                     ''', define='HAVE__VA_ARGS__MACRO')
 
+    conf.env.enable_fuzzing = False
+
     conf.env.enable_libfuzzer = Options.options.enable_libfuzzer
-    if conf.env.enable_libfuzzer:
-        conf.DEFINE('ENABLE_LIBFUZZER', 1)
+    conf.env.enable_afl_fuzzer = Options.options.enable_afl_fuzzer
+    if conf.env.enable_libfuzzer or conf.env.enable_afl_fuzzer:
+        conf.env.enable_fuzzing = True
+        conf.DEFINE('FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION', 1)
+        conf.env.FUZZ_TARGET_LDFLAGS = Options.options.FUZZ_TARGET_LDFLAGS
 
     conf.load('clang_compilation_database')
 
diff --git a/ctdb/config/functions b/ctdb/config/functions
index 994a30162fe..2395d8d4dc8 100755
--- a/ctdb/config/functions
+++ b/ctdb/config/functions
@@ -975,10 +975,16 @@ update_tickles ()
 	_my_connections="${tickledir}/${_port}.connections.$$"
 	# Parentheses are needed around the filters for precedence but
 	# the parentheses can't be empty!
+	#
+	# Recent versions of ss print square brackets around IPv6
+	# addresses.  While it is desirable to update CTDB's address
+	# parsing and printing code, something needs to be done here
+	# for backward compatibility, so just delete the brackets.
 	ss -tn state established \
 	   "${_ip_filter:+( ${_ip_filter} )}" \
 	   "${_port_filter:+( ${_port_filter} )}" |
 	awk 'NR > 1 {print $4, $3}' |
+	tr -d '][' |
 	sort >"$_my_connections"
 
 	# Record our current tickles in a temporary file
diff --git a/ctdb/server/ctdb_daemon.c b/ctdb/server/ctdb_daemon.c
index d9a6bf6d741..cc688b07e9c 100644
--- a/ctdb/server/ctdb_daemon.c
+++ b/ctdb/server/ctdb_daemon.c
@@ -1173,7 +1173,7 @@ static void ctdb_accept_client(struct tevent_context *ev,
 */
 static int ux_socket_bind(struct ctdb_context *ctdb)
 {
-	struct sockaddr_un addr;
+	struct sockaddr_un addr = { .sun_family = AF_UNIX };
 	int ret;
 
 	ctdb->daemon.sd = socket(AF_UNIX, SOCK_STREAM, 0);
@@ -1181,8 +1181,6 @@ static int ux_socket_bind(struct ctdb_context *ctdb)
 		return -1;
 	}
 
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_UNIX;
 	strncpy(addr.sun_path, ctdb->daemon.name, sizeof(addr.sun_path)-1);
 
 	if (! sock_clean(ctdb->daemon.name)) {
diff --git a/ctdb/server/ctdb_mutex_fcntl_helper.c b/ctdb/server/ctdb_mutex_fcntl_helper.c
index 1448a9062a0..51c46ce733f 100644
--- a/ctdb/server/ctdb_mutex_fcntl_helper.c
+++ b/ctdb/server/ctdb_mutex_fcntl_helper.c
@@ -398,7 +398,7 @@ int main(int argc, char *argv[])
 
 	file = argv[1];
 
-	recheck_time = 60;
+	recheck_time = 5;
 	if (argc == 3) {
 		recheck_time = smb_strtoul(argv[2],
 					   NULL,
diff --git a/ctdb/tcp/tcp_connect.c b/ctdb/tcp/tcp_connect.c
index f54086fcd3c..559442f14bf 100644
--- a/ctdb/tcp/tcp_connect.c
+++ b/ctdb/tcp/tcp_connect.c
@@ -181,16 +181,14 @@ void ctdb_tcp_node_connect(struct tevent_context *ev, struct tevent_timer *te,
 	tnode->out_fd = socket(sock_out.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
 	if (tnode->out_fd == -1) {
 		DBG_ERR("Failed to create socket\n");
-		return;
+		goto failed;
 	}
 
 	ret = set_blocking(tnode->out_fd, false);
 	if (ret != 0) {
 		DBG_ERR("Failed to set socket non-blocking (%s)\n",
 			strerror(errno));
-		close(tnode->out_fd);
-		tnode->out_fd = -1;
-		return;
+		goto failed;
 	}
 
 	set_close_on_exec(tnode->out_fd);
@@ -222,32 +220,22 @@ void ctdb_tcp_node_connect(struct tevent_context *ev, struct tevent_timer *te,
 		sockout_size = sizeof(sock_out.ip6);
 		break;
 	default:
-		DEBUG(DEBUG_ERR, (__location__ " unknown family %u\n",
-			sock_in.sa.sa_family));
-		close(tnode->out_fd);
-		tnode->out_fd = -1;
-		return;
+		DBG_ERR("Unknown address family %u\n", sock_in.sa.sa_family);
+		/* Can't happen to due to address parsing restrictions */
+		goto failed;
 	}
 
 	ret = bind(tnode->out_fd, (struct sockaddr *)&sock_in, sockin_size);
 	if (ret == -1) {
 		DBG_ERR("Failed to bind socket (%s)\n", strerror(errno));
-		close(tnode->out_fd);
-		tnode->out_fd = -1;
-		return;
+		goto failed;
 	}
 
 	ret = connect(tnode->out_fd,
 		      (struct sockaddr *)&sock_out,
 		      sockout_size);
 	if (ret != 0 && errno != EINPROGRESS) {
-		ctdb_tcp_stop_connection(node);
-		tnode->connect_te = tevent_add_timer(ctdb->ev,
-						     tnode,
-						     timeval_current_ofs(1, 0),
-						     ctdb_tcp_node_connect,
-						     node);
-		return;
+		goto failed;
 	}
 
 	/* non-blocking connect - wait for write event */
@@ -266,6 +254,16 @@ void ctdb_tcp_node_connect(struct tevent_context *ev, struct tevent_timer *te,
 					     timeval_current_ofs(1, 0),
 					     ctdb_tcp_node_connect,
 					     node);
+
+	return;
+
+failed:
+	ctdb_tcp_stop_connection(node);
+	tnode->connect_te = tevent_add_timer(ctdb->ev,
+					     tnode,
+					     timeval_current_ofs(1, 0),
+					     ctdb_tcp_node_connect,
+					     node);
 }
 
 /*
diff --git a/ctdb/tests/CLUSTER/complex/60_rogueip_releaseip.sh b/ctdb/tests/CLUSTER/complex/60_rogueip_releaseip.sh
index d168cf22216..efa9ef2b6a1 100755
--- a/ctdb/tests/CLUSTER/complex/60_rogueip_releaseip.sh
+++ b/ctdb/tests/CLUSTER/complex/60_rogueip_releaseip.sh
@@ -14,6 +14,13 @@ select_test_node_and_ips
 
 echo "Using $test_ip, which is onnode $test_node"
 
+# This test depends on being able to assign a duplicate address on a
+# 2nd node.  However, IPv6 guards against this and causes the test to
+# fail.
+case "$test_ip" in
+*:*) ctdb_test_skip "This test is not supported for IPv6 addresses" ;;
+esac
+
 get_test_ip_mask_and_iface
 
 echo "Finding another node that knows about $test_ip"
diff --git a/ctdb/tests/CLUSTER/complex/61_rogueip_takeip.sh b/ctdb/tests/CLUSTER/complex/61_rogueip_takeip.sh
index d4fee69c96d..5ee4e544eeb 100755
--- a/ctdb/tests/CLUSTER/complex/61_rogueip_takeip.sh
+++ b/ctdb/tests/CLUSTER/complex/61_rogueip_takeip.sh
@@ -14,6 +14,17 @@ select_test_node_and_ips
 
 echo "Running test against node $test_node and IP $test_ip"
 
+# This test puts an address on an interface and then needs to quickly
+# configure that address and cause an IP takeover.  However, an IPv6
+# address will be tentative for a while so "quickly" is not possible".
+# When ctdb_control_takeover_ip() calls ctdb_sys_have_ip() it will
+# decide that the address is not present.  It then attempts a takeip,
+# which can fail if the address is suddenly present because it is no
+# longer tentative.
+case "$test_ip" in
+*:*) ctdb_test_skip "This test is not supported for IPv6 addresses" ;;
+esac
+
 get_test_ip_mask_and_iface
 
 echo "Deleting IP $test_ip from all nodes"
diff --git a/ctdb/tests/INTEGRATION/simple/cluster.015.reclock_remove_lock.sh b/ctdb/tests/INTEGRATION/simple/cluster.015.reclock_remove_lock.sh
new file mode 100755
index 00000000000..d74bcf819b4
--- /dev/null
+++ b/ctdb/tests/INTEGRATION/simple/cluster.015.reclock_remove_lock.sh
@@ -0,0 +1,90 @@
+#!/bin/bash
+
+# Verify that the cluster recovers if the recovery lock is removed.
+
+. "${TEST_SCRIPTS_DIR}/integration.bash"
+
+set -e
+
+ctdb_test_skip_on_cluster
+
+ctdb_test_init -r 5
+
+generation_has_changed ()
+{
+	local node="$1"
+	local generation_init="$2"
+
+	# Leak this so it can be printed by test
+	generation_new=""
+
+	ctdb_onnode "$node" status
+	# shellcheck disable=SC2154
+	# $outfile set by ctdb_onnode() above
+	generation_new=$(sed -n -e 's/^Generation:\([0-9]*\)/\1/p' "$outfile")
+
+	[ "$generation_new" != "$generation_init" ]
+}
+
+select_test_node
+
+echo "Get recovery lock setting"
+# shellcheck disable=SC2154
+# $test_node set by select_test_node() above
+ctdb_onnode "$test_node" getreclock
+# shellcheck disable=SC2154
+# $out set by ctdb_onnode() above
+reclock_setting="$out"
+
+if [ -z "$reclock_setting" ] ; then
+	ctdb_test_skip "Recovery lock is not set"
+fi
+
+t="${reclock_setting% 5}"
+reclock="${t##* }"
+
+if [ ! -f "$reclock" ] ; then
+	ctdb_test_error "Recovery lock file \"${reclock}\" is missing"
+fi
+
+echo "Recovery lock setting is \"${reclock_setting}\""
+echo "Recovery lock file is \"${reclock}\""
+echo
+
+echo "Get current recovery master"
+ctdb_onnode "$test_node" recmaster
+recmaster="$out"
+echo "Recovery master is node ${recmaster}"
+echo
+
+echo "Get initial generation"
+ctdb_onnode "$test_node" status
+# shellcheck disable=SC2154
+# $outfile set by ctdb_onnode() above
+generation_init=$(sed -n -e 's/^Generation:\([0-9]*\)/\1/p' "$outfile")
+echo "Initial generation is ${generation_init}"
+echo
+
+echo "Remove recovery lock"
+rm "$reclock"
+echo
+
+# This will mean an election has taken place and a recovery has occured
+echo "Wait until generation changes"
+wait_until 30 generation_has_changed "$test_node" "$generation_init"
+echo
+echo "Generation changed to ${generation_new}"
+echo
+
+echo "Get current recovery master"
+ctdb_onnode "$test_node" recmaster
+recmaster_new="$out"
+
+if [ "$recmaster" != "$recmaster_new" ] ; then
+	ctdb_test_fail \
+		"BAD: Recovery master has changed to node ${recmaster_new}"
+fi
+echo "GOOD: Recovery master is still node ${recmaster_new}"
+echo
+
+cluster_is_healthy
diff --git a/ctdb/tests/INTEGRATION/simple/cluster.016.reclock_move_lock_dir.sh b/ctdb/tests/INTEGRATION/simple/cluster.016.reclock_move_lock_dir.sh
new file mode 100755
index 00000000000..cd193f05a49
--- /dev/null
+++ b/ctdb/tests/INTEGRATION/simple/cluster.016.reclock_move_lock_dir.sh
@@ -0,0 +1,74 @@
+#!/bin/bash
+
+# Verify that if the directory containing the recovery lock is moved
+# then all nodes are banned (because they can't take the lock).
+# Confirm that if the directory is moved back and the bans time out
+# then the cluster returns to good health.
+
+# This simulates the cluster filesystem containing the recovery lock
+# being unmounted and remounted.
+
+. "${TEST_SCRIPTS_DIR}/integration.bash"
+
+set -e
+
+ctdb_test_skip_on_cluster
+
+ctdb_test_init -r 5
+
+all_nodes_are_banned ()
+{
+	node="$1"
+
+	ctdb_onnode "$node" nodestatus
+	[ $? -eq 1 ]
+
+	# shellcheck disable=SC2154
+	# $out set by ctdb_onnode() above
+	[ "$out" = "Warning: All nodes are banned." ]
+}
+
+select_test_node
+
+echo "Get recovery lock setting"
+# shellcheck disable=SC2154
+# $test_node set by select_test_node() above
+ctdb_onnode "$test_node" getreclock
+# shellcheck disable=SC2154
+# $out set by ctdb_onnode() above
+reclock_setting="$out"
+
+if [ -z "$reclock_setting" ] ; then
+	ctdb_test_skip "Recovery lock is not set"
+fi
+
+t="${reclock_setting% 5}"
+reclock="${t##* }"
+
+if [ ! -f "$reclock" ] ; then
+	ctdb_test_error "Recovery lock file \"${reclock}\" is missing"
+fi
+
+echo "Recovery lock setting is \"${reclock_setting}\""
+echo "Recovery lock file is \"${reclock}\""
+echo
+
+echo "Set ban period to 30s"
+ctdb_onnode all setvar RecoveryBanPeriod 30
+echo
+
+dir=$(dirname "$reclock")
+
+echo "Rename recovery lock directory"
+mv "$dir" "${dir}.$$"
+echo
+
+echo "Wait until all nodes are banned"
+wait_until 60 all_nodes_are_banned "$test_node"
+echo
+
+echo "Restore recovery lock directory"
+mv "${dir}.$$" "$dir"
+echo
+
+wait_until_ready 60
diff --git a/ctdb/tests/local_daemons.sh b/ctdb/tests/local_daemons.sh
index 3f5729b5a24..e45a79c3e82 100755
--- a/ctdb/tests/local_daemons.sh
+++ b/ctdb/tests/local_daemons.sh
@@ -128,6 +128,7 @@ Options:
   -n <num>      Number of nodes (default: 3)
   -P <file>     Public addresses file (default: automatically generated)
   -R            Use a command for the recovery lock (default: use a file)
+  -r <time>     Like -R and set recheck interval to <time> (default: use a file)
   -S <library>  Socket wrapper shared library to preload (default: none)
   -6            Generate IPv6 IPs for nodes, public addresses (default: IPv4)
 EOF
@@ -142,18 +143,22 @@ local_daemons_setup ()
 	_num_nodes=3
 	_public_addresses_file=""
 	_recovery_lock_use_command=false
+	_recovery_lock_recheck_interval=""
 	_socket_wrapper=""
 	_use_ipv6=false
 
 	set -e
 
-	while getopts "FN:n:P:RS:6h?" _opt ; do
+	while getopts "FN:n:P:Rr:S:6h?" _opt ; do
 		case "$_opt" in
 		F) _disable_failover=true ;;
 		N) _nodes_file="$OPTARG" ;;
 		n) _num_nodes="$OPTARG" ;;
 		P) _public_addresses_file="$OPTARG" ;;
 		R) _recovery_lock_use_command=true ;;
+		r) _recovery_lock_use_command=true
+		   _recovery_lock_recheck_interval="$OPTARG"
+		   ;;
 		S) _socket_wrapper="$OPTARG" ;;
 		6) _use_ipv6=true ;;
 		\?|h) local_daemons_setup_usage ;;
@@ -186,10 +191,16 @@ local_daemons_setup ()
 				       $_use_ipv6 >"$_public_addresses_all"
 	fi
 
-	_recovery_lock="${directory}/rec.lock"
+	_recovery_lock_dir="${directory}/shared/.ctdb"
+	mkdir -p "$_recovery_lock_dir"
+	_recovery_lock="${_recovery_lock_dir}/rec.lock"
 	if $_recovery_lock_use_command ; then
 		_helper="${CTDB_SCRIPTS_HELPER_BINDIR}/ctdb_mutex_fcntl_helper"
-		_recovery_lock="! ${_helper} ${_recovery_lock}"
+		_t="! ${_helper} ${_recovery_lock}"
+		if [ -n "$_recovery_lock_recheck_interval" ] ; then
+			_t="${_t} ${_recovery_lock_recheck_interval}"
+		fi
+		_recovery_lock="$_t"
 	fi
 
 	if [ -n "$_socket_wrapper" ] ; then
diff --git a/docs-xml/Samba-Developers-Guide/vfs.xml b/docs-xml/Samba-Developers-Guide/vfs.xml
index 8275d313ed1..948b98936a2 100644
--- a/docs-xml/Samba-Developers-Guide/vfs.xml
+++ b/docs-xml/Samba-Developers-Guide/vfs.xml
@@ -235,14 +235,14 @@ DO NOT ACCESS conn-&gt;vfs.ops.* directly !!!
 #define SMB_VFS_CLOSE(fsp, fd) \
 	((fsp)-&gt;conn-&gt;vfs.ops.close(\
 	(fsp)-&gt;conn-&gt;vfs.handles.close, (fsp), (fd)))
-#define SMB_VFS_READ(fsp, fd, data, n) \
+#define SMB_VFS_PREAD(fsp, fd, data, n, off) \
 	((fsp)-&gt;conn-&gt;vfs.ops.read(\
 	(fsp)-&gt;conn-&gt;vfs.handles.read,\
-	 (fsp), (fd), (data), (n)))
-#define SMB_VFS_WRITE(fsp, fd, data, n) \
+	 (fsp), (fd), (data), (n), (off)))
+#define SMB_VFS_PWRITE(fsp, fd, data, n, off) \
 	((fsp)-&gt;conn-&gt;vfs.ops.write(\
 	(fsp)-&gt;conn-&gt;vfs.handles.write,\
-	 (fsp), (fd), (data), (n)))
+	 (fsp), (fd), (data), (n), (off)))
 #define SMB_VFS_LSEEK(fsp, fd, offset, whence) \
 	((fsp)-&gt;conn-&gt;vfs.ops.lseek(\
 	(fsp)-&gt;conn-&gt;vfs.handles.lseek,\
diff --git a/docs-xml/manpages/samba-tool.8.xml b/docs-xml/manpages/samba-tool.8.xml
index 9664bb9cd56..ef55d72e714 100644
--- a/docs-xml/manpages/samba-tool.8.xml
+++ b/docs-xml/manpages/samba-tool.8.xml
@@ -1192,6 +1192,16 @@
 	<para>List all users.</para>
 </refsect3>
 
+<refsect3>
+	<title>user setprimarygroup <replaceable>username</replaceable> <replaceable>primarygroupname</replaceable></title>
+	<para>Set the primary group a user account.</para>
+</refsect3>
+
+<refsect3>
+	<title>user getgroups <replaceable>username</replaceable></title>
+	<para>Get the direct group memberships of a user account.</para>
+</refsect3>
+
 <refsect3>
 	<title>user show <replaceable>username</replaceable> [options]</title>
 	<para>Display a user AD object.</para>
diff --git a/docs-xml/manpages/smbclient.1.xml b/docs-xml/manpages/smbclient.1.xml
index ab62c12f36e..0f556a874db 100644
--- a/docs-xml/manpages/smbclient.1.xml
+++ b/docs-xml/manpages/smbclient.1.xml
@@ -69,7 +69,7 @@
 		<arg choice="opt">-R &lt;name resolve order&gt;</arg>
 		<arg choice="opt">-s &lt;smb config file&gt;</arg>
 		<arg choice="opt">-t &lt;per-operation timeout in seconds&gt;</arg>
-		<arg choice="opt">-T&lt;c|x&gt;IXFqgbNan</arg>
+		<arg choice="opt">-T&lt;c|x&gt;IXFvgbNan</arg>
 		<arg choice="opt">-k</arg>
 	</cmdsynopsis>
 </refsynopsisdiv>
@@ -413,8 +413,9 @@
 			files that have the archive bit set. Useful only with the
 			<parameter>c</parameter> flag. </para></listitem>
 
-			<listitem><para><parameter>q</parameter> - Quiet. Keeps tar from printing
-			diagnostics as it works.  This is the same as tarmode quiet.
+			<listitem><para><parameter>v</parameter> - Verbose. Makes tar
+			print out the files being processed. By default tar is not verbose.
+			This is the same as tarmode verbose.
 			</para></listitem>
 
 			<listitem><para><parameter>r</parameter> - Use wildcard
@@ -1102,7 +1103,7 @@
 		</varlistentry>
 
 		<varlistentry>
-		<term>tarmode &lt;full|inc|reset|noreset|system|nosystem|hidden|nohidden&gt;</term>
+		<term>tarmode &lt;full|inc|reset|noreset|system|nosystem|hidden|nohidden|verbose|noverbose&gt;</term>
 		<listitem><para>Changes tar's behavior with regard to DOS
 		attributes. There are 4 modes which can be turned on or
 		off.</para>
diff --git a/docs-xml/manpages/smbcontrol.1.xml b/docs-xml/manpages/smbcontrol.1.xml
index 77a2054c449..935713b46a0 100644
--- a/docs-xml/manpages/smbcontrol.1.xml
+++ b/docs-xml/manpages/smbcontrol.1.xml
@@ -119,6 +119,16 @@
 	</listitem>
 	</varlistentry>
 
+	<varlistentry><term>close-denied-share</term>
+	<listitem><para>Behave like <constant>close-share</constant>,
+	but don't disconnect users that are still allowed to access
+	the share. It can safely be sent to all smbds after changing
+	share access controls. It will only affect users who have been
+	denied access since having connected initially. This message
+	can only be sent to <constant>smbd</constant>.</para>
+	</listitem>
+	</varlistentry>
+
 	<varlistentry>
 	<term>debug</term>
 	<listitem><para>Set debug level to the value specified by the 
diff --git a/docs-xml/manpages/vfs_io_uring.8.xml b/docs-xml/manpages/vfs_io_uring.8.xml
new file mode 100644
index 00000000000..f47a5041ec0
--- /dev/null
+++ b/docs-xml/manpages/vfs_io_uring.8.xml
@@ -0,0 +1,107 @@
+<?xml version="1.0" encoding="iso-8859-1"?>
+<!DOCTYPE refentry PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
+<refentry id="vfs_io_uring.8">
+
+<refmeta>
+	<refentrytitle>vfs_io_uring</refentrytitle>
+	<manvolnum>8</manvolnum>
+	<refmiscinfo class="source">Samba</refmiscinfo>
+	<refmiscinfo class="manual">System Administration tools</refmiscinfo>
+	<refmiscinfo class="version">&doc.version;</refmiscinfo>
+</refmeta>
+
+<refnamediv>
+	<refname>vfs_io_uring</refname>
+	<refpurpose>Implement async io in Samba vfs using io_uring of Linux (>= 5.1).</refpurpose>
+</refnamediv>
+
+<refsynopsisdiv>
+	<cmdsynopsis>
+		<command>vfs objects = io_uring</command>
+	</cmdsynopsis>
+</refsynopsisdiv>
+
+<refsect1>
+	<title>DESCRIPTION</title>
+
+	<para>This VFS module is part of the
+	<citerefentry><refentrytitle>samba</refentrytitle>
+	<manvolnum>7</manvolnum></citerefentry> suite.</para>
+
+	<para>The <command>io_uring</command> VFS module enables asynchronous
+	pread, pwrite and fsync using the io_uring infrastructure of Linux (>= 5.1).
+	This provides much less overhead compared to the usage of the pthreadpool for
+	async io.</para>
+
+	<para>This module SHOULD be listed last in any module stack as
+	it requires real kernel file descriptors.</para>
+
+</refsect1>
+
+
+<refsect1>
+	<title>EXAMPLES</title>
+
+	<para>Straight forward use:</para>
+
+<programlisting>
+        <smbconfsection name="[cooldata]"/>
+	<smbconfoption name="path">/data/ice</smbconfoption>
+	<smbconfoption name="vfs objects">io_uring</smbconfoption>
+</programlisting>
+
+</refsect1>
+
+<refsect1>
+	<title>OPTIONS</title>
+
+	<variablelist>
+
+		<varlistentry>
+		<term>io_uring:num_entries = NUMBER_OF_QUEUE_ENTRIES</term>
+		<listitem>
+		<para>The number of entries in the submission queue.
+		The maximum allowed value depends on the kernel version
+		and the kernel will roundup the value to a power of 2.
+		</para>
+		<para>The default is '128'.</para>
+		</listitem>
+		</varlistentry>
+
+		<varlistentry>
+		<term>io_uring:sqpoll = BOOL</term>
+		<listitem>
+		<para>Use the IORING_SETUP_SQPOLL feature.
+		</para>
+		<para>The default is 'no'.</para>
+		</listitem>
+		</varlistentry>
+
+	</variablelist>
+</refsect1>
+
+<refsect1>
+	<title>SEE ALSO</title>
+	<para>
+	<citerefentry><refentrytitle>io_uring_setup</refentrytitle><manvolnum>2</manvolnum></citerefentry>.
+	</para>
+</refsect1>
+
+<refsect1>
+	<title>VERSION</title>
+
+	<para>This man page is part of version &doc.version; of the Samba suite.
+	</para>
+</refsect1>
+
+<refsect1>
+	<title>AUTHOR</title>
+
+	<para>The original Samba software and related utilities
+	were created by Andrew Tridgell. Samba is now developed
+	by the Samba Team as an Open Source project similar
+	to the way the Linux kernel is developed.</para>
+
+</refsect1>
+
+</refentry>
diff --git a/docs-xml/manpages/vfs_zfsacl.8.xml b/docs-xml/manpages/vfs_zfsacl.8.xml
index 56d1d06cce1..ae583409fe1 100644
--- a/docs-xml/manpages/vfs_zfsacl.8.xml
+++ b/docs-xml/manpages/vfs_zfsacl.8.xml
@@ -125,6 +125,40 @@
 		</listitem>
 		</varlistentry>
 
+		<varlistentry>
+		<term>zfsacl:denymissingspecial = [yes|no]</term>
+		<listitem>
+		<para>Prevent users from setting an ACL that lacks NFSv4 special entries
+		(owner@, group@, everyone@). ZFS will automatically generate these these entries
+		when calculating the inherited ACL of new files if the ACL of the parent directory
+		lacks an inheriting special entry. This may result in user confusion and unexpected
+		change in permissions of files and directories as the inherited ACL is generated.</para>
+		<itemizedlist>
+		<listitem><para><command>yes</command></para></listitem>
+		<listitem><para><command>no (default)</command></para></listitem>
+		</itemizedlist>
+		</listitem>
+		</varlistentry>
+
+		<varlistentry>
+		<term>zfsacl:map_dacl_protected = [yes|no]</term>
+		<listitem>
+		<para>If enabled and the ZFS ACL on the underlying filesystem does not contain
+		any inherited access control entires, then set the SEC_DESC_DACL_PROTECTED flag
+		on the Security Descriptor returned to SMB clients.
+		This ensures correct Windows client behavior when disabling inheritance on
+		directories.</para>
+
+		<para>Following is the behaviour of Samba for different values : </para>
+		<itemizedlist>
+		<listitem><para><command>yes</command> - Enable mapping to
+		SEC_DESC_DACL_PROTECTED</para></listitem>
+		<listitem><para><command>no (default)</command></para></listitem>
+		</itemizedlist>
+		</listitem>
+		</varlistentry>
+
+
 	</variablelist>
 </refsect1>
 
diff --git a/docs-xml/smbdotconf/base/comment.xml b/docs-xml/smbdotconf/base/comment.xml
index b0dd91c8839..c5aba83451a 100644
--- a/docs-xml/smbdotconf/base/comment.xml
+++ b/docs-xml/smbdotconf/base/comment.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="comment"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This is a text field that is seen next to a share 
diff --git a/docs-xml/smbdotconf/base/doscharset.xml b/docs-xml/smbdotconf/base/doscharset.xml
index c99b8403ccf..ebd7586158c 100644
--- a/docs-xml/smbdotconf/base/doscharset.xml
+++ b/docs-xml/smbdotconf/base/doscharset.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="dos charset"
                  type="string"
                  context="G"
-                 constant="1"
                  handler="handle_dos_charset"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
diff --git a/docs-xml/smbdotconf/base/netbiosname.xml b/docs-xml/smbdotconf/base/netbiosname.xml
index 89cf73add31..e9e05382d44 100644
--- a/docs-xml/smbdotconf/base/netbiosname.xml
+++ b/docs-xml/smbdotconf/base/netbiosname.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="netbios name"
                  context="G"
                  type="ustring"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
         <para>
diff --git a/docs-xml/smbdotconf/base/netbiosscope.xml b/docs-xml/smbdotconf/base/netbiosscope.xml
index c5be02825a1..078697f4805 100644
--- a/docs-xml/smbdotconf/base/netbiosscope.xml
+++ b/docs-xml/smbdotconf/base/netbiosscope.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="netbios scope"
                  context="G"
                  type="ustring"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
         <para>This sets the NetBIOS scope that Samba will 
diff --git a/docs-xml/smbdotconf/base/path.xml b/docs-xml/smbdotconf/base/path.xml
index c84e039875a..669c20d2a8b 100644
--- a/docs-xml/smbdotconf/base/path.xml
+++ b/docs-xml/smbdotconf/base/path.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="path"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>directory</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/base/realm.xml b/docs-xml/smbdotconf/base/realm.xml
index 8499c786d4f..dd39c1bb0d4 100644
--- a/docs-xml/smbdotconf/base/realm.xml
+++ b/docs-xml/smbdotconf/base/realm.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="realm"
                  context="G"
                  type="string"
-                 constant="1"
                  handler="handle_realm"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
diff --git a/docs-xml/smbdotconf/base/serverstring.xml b/docs-xml/smbdotconf/base/serverstring.xml
index f6bc8089f6e..40882957e9d 100644
--- a/docs-xml/smbdotconf/base/serverstring.xml
+++ b/docs-xml/smbdotconf/base/serverstring.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="server string"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
         <para>This controls what string will show up in the printer comment box in print 
diff --git a/docs-xml/smbdotconf/base/sharebackend.xml b/docs-xml/smbdotconf/base/sharebackend.xml
index 08124cd21dc..4da8b177da1 100644
--- a/docs-xml/smbdotconf/base/sharebackend.xml
+++ b/docs-xml/smbdotconf/base/sharebackend.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="share backend"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/base/unixcharset.xml b/docs-xml/smbdotconf/base/unixcharset.xml
index 06754a419f0..23c4f1edf43 100644
--- a/docs-xml/smbdotconf/base/unixcharset.xml
+++ b/docs-xml/smbdotconf/base/unixcharset.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="unix charset"
                  context="G"
                  type="string"
-                 constant="1"
                  handler="handle_charset"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
diff --git a/docs-xml/smbdotconf/base/workgroup.xml b/docs-xml/smbdotconf/base/workgroup.xml
index eb8ca182c94..1408147810e 100644
--- a/docs-xml/smbdotconf/base/workgroup.xml
+++ b/docs-xml/smbdotconf/base/workgroup.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="workgroup"
                  context="G"
                  type="ustring"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
         <para>This controls what workgroup your server will 
diff --git a/docs-xml/smbdotconf/domain/gpoupdatecommand.xml b/docs-xml/smbdotconf/domain/gpoupdatecommand.xml
index 6bf88f8e68a..fd0e7bf9c43 100644
--- a/docs-xml/smbdotconf/domain/gpoupdatecommand.xml
+++ b/docs-xml/smbdotconf/domain/gpoupdatecommand.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="gpo update command"
                  context="G"
                  type="list"
-                 advanced="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This option sets the command that is called to apply GPO policies.
diff --git a/docs-xml/smbdotconf/filename/hidefiles.xml b/docs-xml/smbdotconf/filename/hidefiles.xml
index 0b475053ee1..d4e3da39ee6 100644
--- a/docs-xml/smbdotconf/filename/hidefiles.xml
+++ b/docs-xml/smbdotconf/filename/hidefiles.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="hide files"
-				 type="string"
+                 type="string"
                  context="S"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This is a list of files or directories that are not 
diff --git a/docs-xml/smbdotconf/filename/manglednames.xml b/docs-xml/smbdotconf/filename/manglednames.xml
index d6a5cf0ac15..aac0a6dbe00 100644
--- a/docs-xml/smbdotconf/filename/manglednames.xml
+++ b/docs-xml/smbdotconf/filename/manglednames.xml
@@ -15,14 +15,14 @@
 	<para>Possible option settings are</para>
 
 	<itemizedlist>
-		<listitem><para><emphasis>yes (default)</emphasis> -
+		<listitem><para><emphasis>yes</emphasis> -
 		enables name mangling for all not DOS 8.3 conforming
 		names.</para></listitem>
 
 		<listitem><para><emphasis>no</emphasis> - disables any
 		name mangling.</para></listitem>
 
-		<listitem><para><emphasis>illegal</emphasis> - does
+		<listitem><para><emphasis>illegal (default)</emphasis> - does
 		mangling for names with illegal NTFS characters. This
 		is the most sensible setting for modern clients that
 		don't use the shortname anymore.</para></listitem>
diff --git a/docs-xml/smbdotconf/filename/vetofiles.xml b/docs-xml/smbdotconf/filename/vetofiles.xml
index acbc3dcffb3..11bb51e6c76 100644
--- a/docs-xml/smbdotconf/filename/vetofiles.xml
+++ b/docs-xml/smbdotconf/filename/vetofiles.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="veto files"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
 	<para>
diff --git a/docs-xml/smbdotconf/filename/vetooplockfiles.xml b/docs-xml/smbdotconf/filename/vetooplockfiles.xml
index dde3705a1c1..8d6a9224953 100644
--- a/docs-xml/smbdotconf/filename/vetooplockfiles.xml
+++ b/docs-xml/smbdotconf/filename/vetooplockfiles.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="veto oplock files"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
 	<para>
diff --git a/docs-xml/smbdotconf/logging/logfile.xml b/docs-xml/smbdotconf/logging/logfile.xml
index eb751cb9732..07762ee06e0 100644
--- a/docs-xml/smbdotconf/logging/logfile.xml
+++ b/docs-xml/smbdotconf/logging/logfile.xml
@@ -3,6 +3,7 @@
                  type="string"
                  function="logfile"
                  handler="handle_logfile"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>
diff --git a/docs-xml/smbdotconf/logging/logging.xml b/docs-xml/smbdotconf/logging/logging.xml
index b152d0c469e..0ab2c1f131b 100644
--- a/docs-xml/smbdotconf/logging/logging.xml
+++ b/docs-xml/smbdotconf/logging/logging.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="logging"
                  type="string"
                  context="G"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 
diff --git a/docs-xml/smbdotconf/logging/loglevel.xml b/docs-xml/smbdotconf/logging/loglevel.xml
index d3bed8a939b..273765c6fbe 100644
--- a/docs-xml/smbdotconf/logging/loglevel.xml
+++ b/docs-xml/smbdotconf/logging/loglevel.xml
@@ -2,6 +2,7 @@
                  type="string"
                  context="G"
                  handler="handle_debug_list"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>debuglevel</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/logon/abortshutdownscript.xml b/docs-xml/smbdotconf/logon/abortshutdownscript.xml
index d5f714202fe..7ce0f1fa7e5 100644
--- a/docs-xml/smbdotconf/logon/abortshutdownscript.xml
+++ b/docs-xml/smbdotconf/logon/abortshutdownscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="abort shutdown script"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This a full path name to a script called by <citerefentry><refentrytitle>smbd</refentrytitle>
diff --git a/docs-xml/smbdotconf/logon/addgroupscript.xml b/docs-xml/smbdotconf/logon/addgroupscript.xml
index 18d7230d32c..3b347d010b8 100644
--- a/docs-xml/smbdotconf/logon/addgroupscript.xml
+++ b/docs-xml/smbdotconf/logon/addgroupscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="add group script"
 		context="G"
 		type="string"
+		substitution="1"
 		xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/logon/addmachinescript.xml b/docs-xml/smbdotconf/logon/addmachinescript.xml
index 5d88170fc28..db1f5bc98e0 100644
--- a/docs-xml/smbdotconf/logon/addmachinescript.xml
+++ b/docs-xml/smbdotconf/logon/addmachinescript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="add machine script"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/logon/adduserscript.xml b/docs-xml/smbdotconf/logon/adduserscript.xml
index 981d6702c15..4be1146f4e7 100644
--- a/docs-xml/smbdotconf/logon/adduserscript.xml
+++ b/docs-xml/smbdotconf/logon/adduserscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="add user script"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/logon/addusertogroupscript.xml b/docs-xml/smbdotconf/logon/addusertogroupscript.xml
index d871ead05d2..f6e9cc2d967 100644
--- a/docs-xml/smbdotconf/logon/addusertogroupscript.xml
+++ b/docs-xml/smbdotconf/logon/addusertogroupscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="add user to group script"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/logon/deletegroupscript.xml b/docs-xml/smbdotconf/logon/deletegroupscript.xml
index cad0c2a8665..be8bb0d9227 100644
--- a/docs-xml/smbdotconf/logon/deletegroupscript.xml
+++ b/docs-xml/smbdotconf/logon/deletegroupscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="delete group script"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This is the full pathname to a script that will 
diff --git a/docs-xml/smbdotconf/logon/deleteuserfromgroupscript.xml b/docs-xml/smbdotconf/logon/deleteuserfromgroupscript.xml
index 07a21a732d1..1654a0909df 100644
--- a/docs-xml/smbdotconf/logon/deleteuserfromgroupscript.xml
+++ b/docs-xml/smbdotconf/logon/deleteuserfromgroupscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="delete user from group script"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>Full path to the script that will be called when 
diff --git a/docs-xml/smbdotconf/logon/deleteuserscript.xml b/docs-xml/smbdotconf/logon/deleteuserscript.xml
index 128fa899120..22897cbef77 100644
--- a/docs-xml/smbdotconf/logon/deleteuserscript.xml
+++ b/docs-xml/smbdotconf/logon/deleteuserscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="delete user script"
-			     type="string"
+                 type="string"
                  context="G"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This is the full pathname to a script that will 
diff --git a/docs-xml/smbdotconf/logon/logondrive.xml b/docs-xml/smbdotconf/logon/logondrive.xml
index 9f615986c4f..9767693244c 100644
--- a/docs-xml/smbdotconf/logon/logondrive.xml
+++ b/docs-xml/smbdotconf/logon/logondrive.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="logon drive"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/logon/logonhome.xml b/docs-xml/smbdotconf/logon/logonhome.xml
index d2116740d2a..cb5f5d5060b 100644
--- a/docs-xml/smbdotconf/logon/logonhome.xml
+++ b/docs-xml/smbdotconf/logon/logonhome.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="logon home"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/logon/logonpath.xml b/docs-xml/smbdotconf/logon/logonpath.xml
index 106bb59453d..440ebc4284e 100644
--- a/docs-xml/smbdotconf/logon/logonpath.xml
+++ b/docs-xml/smbdotconf/logon/logonpath.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="logon path"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/logon/logonscript.xml b/docs-xml/smbdotconf/logon/logonscript.xml
index 3142a6c84aa..cf024662214 100644
--- a/docs-xml/smbdotconf/logon/logonscript.xml
+++ b/docs-xml/smbdotconf/logon/logonscript.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="logon script"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/logon/setprimarygroupscript.xml b/docs-xml/smbdotconf/logon/setprimarygroupscript.xml
index 60d2cae1325..8d1ae366f44 100644
--- a/docs-xml/smbdotconf/logon/setprimarygroupscript.xml
+++ b/docs-xml/smbdotconf/logon/setprimarygroupscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="set primary group script"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 
diff --git a/docs-xml/smbdotconf/logon/shutdownscript.xml b/docs-xml/smbdotconf/logon/shutdownscript.xml
index e66ed92193f..ea5b65fda81 100644
--- a/docs-xml/smbdotconf/logon/shutdownscript.xml
+++ b/docs-xml/smbdotconf/logon/shutdownscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="shutdown script"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This a full path name to a script called by 
diff --git a/docs-xml/smbdotconf/misc/addsharecommand.xml b/docs-xml/smbdotconf/misc/addsharecommand.xml
index 6bbdef61967..484b591c439 100644
--- a/docs-xml/smbdotconf/misc/addsharecommand.xml
+++ b/docs-xml/smbdotconf/misc/addsharecommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="add share command"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/afsusernamemap.xml b/docs-xml/smbdotconf/misc/afsusernamemap.xml
index 4dc3d465744..f3f7390f4c5 100644
--- a/docs-xml/smbdotconf/misc/afsusernamemap.xml
+++ b/docs-xml/smbdotconf/misc/afsusernamemap.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="afs username map"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
 	<para>If you are using the fake kaserver AFS feature, you might
diff --git a/docs-xml/smbdotconf/misc/auto_services.xml b/docs-xml/smbdotconf/misc/auto_services.xml
index a7d7f13ffcd..d843d889972 100644
--- a/docs-xml/smbdotconf/misc/auto_services.xml
+++ b/docs-xml/smbdotconf/misc/auto_services.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="auto services"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>preload</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/misc/cachedirectory.xml b/docs-xml/smbdotconf/misc/cachedirectory.xml
index 21d7d9461d8..480f31b63cf 100644
--- a/docs-xml/smbdotconf/misc/cachedirectory.xml
+++ b/docs-xml/smbdotconf/misc/cachedirectory.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="cache directory"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>Usually, most of the TDB files are stored in the <parameter
diff --git a/docs-xml/smbdotconf/misc/changesharecommand.xml b/docs-xml/smbdotconf/misc/changesharecommand.xml
index 9f805b138a7..4cc74515376 100644
--- a/docs-xml/smbdotconf/misc/changesharecommand.xml
+++ b/docs-xml/smbdotconf/misc/changesharecommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="change share command"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/configfile.xml b/docs-xml/smbdotconf/misc/configfile.xml
index 566d4306b37..3b67fb00459 100644
--- a/docs-xml/smbdotconf/misc/configfile.xml
+++ b/docs-xml/smbdotconf/misc/configfile.xml
@@ -2,6 +2,7 @@
                  context="G"
                  type="string"
                  function="next_configfile"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This allows you to override the config file 
diff --git a/docs-xml/smbdotconf/misc/ctdbdsocket.xml b/docs-xml/smbdotconf/misc/ctdbdsocket.xml
index f852f593c82..2bc118bd7a7 100644
--- a/docs-xml/smbdotconf/misc/ctdbdsocket.xml
+++ b/docs-xml/smbdotconf/misc/ctdbdsocket.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="ctdbd socket"
                  context="G"
                  type="string"
-                 constant="1"
                  function="_ctdbd_socket"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
diff --git a/docs-xml/smbdotconf/misc/defaultservice.xml b/docs-xml/smbdotconf/misc/defaultservice.xml
index 788506f4de9..2da968b9c2f 100644
--- a/docs-xml/smbdotconf/misc/defaultservice.xml
+++ b/docs-xml/smbdotconf/misc/defaultservice.xml
@@ -2,6 +2,7 @@
                  context="G"
                  type="string"
                  function="defaultservice"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>default</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/misc/deletesharecommand.xml b/docs-xml/smbdotconf/misc/deletesharecommand.xml
index b5942b69e12..f569cd2eac4 100644
--- a/docs-xml/smbdotconf/misc/deletesharecommand.xml
+++ b/docs-xml/smbdotconf/misc/deletesharecommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="delete share command"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/dfreecommand.xml b/docs-xml/smbdotconf/misc/dfreecommand.xml
index a1eed4948a6..b12ee0f2923 100644
--- a/docs-xml/smbdotconf/misc/dfreecommand.xml
+++ b/docs-xml/smbdotconf/misc/dfreecommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="dfree command"
 	         context="S"
-			 type="string"
+		 type="string"
+		 substitution="1"
 		 xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 
diff --git a/docs-xml/smbdotconf/misc/dontdescend.xml b/docs-xml/smbdotconf/misc/dontdescend.xml
index fe6686b7f0c..ca9c75f191e 100644
--- a/docs-xml/smbdotconf/misc/dontdescend.xml
+++ b/docs-xml/smbdotconf/misc/dontdescend.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="dont descend"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>There are certain directories on some systems 
diff --git a/docs-xml/smbdotconf/misc/fstype.xml b/docs-xml/smbdotconf/misc/fstype.xml
index 822b451c5e4..437bd5ca0d8 100644
--- a/docs-xml/smbdotconf/misc/fstype.xml
+++ b/docs-xml/smbdotconf/misc/fstype.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="fstype"
                  context="S"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/homedirmap.xml b/docs-xml/smbdotconf/misc/homedirmap.xml
index 279b0b6e52e..ba70730860a 100644
--- a/docs-xml/smbdotconf/misc/homedirmap.xml
+++ b/docs-xml/smbdotconf/misc/homedirmap.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="homedir map"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/lockdirectory.xml b/docs-xml/smbdotconf/misc/lockdirectory.xml
index f8f64ff9fef..cf0ea2be40c 100644
--- a/docs-xml/smbdotconf/misc/lockdirectory.xml
+++ b/docs-xml/smbdotconf/misc/lockdirectory.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="lock directory"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>lock dir</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/misc/magicoutput.xml b/docs-xml/smbdotconf/misc/magicoutput.xml
index 784d09016ac..17b3c6737c3 100644
--- a/docs-xml/smbdotconf/misc/magicoutput.xml
+++ b/docs-xml/smbdotconf/misc/magicoutput.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="magic output"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/magicscript.xml b/docs-xml/smbdotconf/misc/magicscript.xml
index cbc4209f0c8..614f5ae8fad 100644
--- a/docs-xml/smbdotconf/misc/magicscript.xml
+++ b/docs-xml/smbdotconf/misc/magicscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="magic script"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This parameter specifies the name of a file which, 
diff --git a/docs-xml/smbdotconf/misc/messagecommand.xml b/docs-xml/smbdotconf/misc/messagecommand.xml
index 10254527e22..ba39b9f2827 100644
--- a/docs-xml/smbdotconf/misc/messagecommand.xml
+++ b/docs-xml/smbdotconf/misc/messagecommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="message command"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This specifies what command to run when the 
diff --git a/docs-xml/smbdotconf/misc/nbtclientsocketaddress.xml b/docs-xml/smbdotconf/misc/nbtclientsocketaddress.xml
index 0833c63d682..12815dcfa22 100644
--- a/docs-xml/smbdotconf/misc/nbtclientsocketaddress.xml
+++ b/docs-xml/smbdotconf/misc/nbtclientsocketaddress.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="nbt client socket address"
                  context="G"
                  type="string"
-                 constant="1"
                  deprecated="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>socket address</synonym>
diff --git a/docs-xml/smbdotconf/misc/ncalrpcdir.xml b/docs-xml/smbdotconf/misc/ncalrpcdir.xml
index 2fa1019309a..4bbd22249b0 100644
--- a/docs-xml/smbdotconf/misc/ncalrpcdir.xml
+++ b/docs-xml/smbdotconf/misc/ncalrpcdir.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="ncalrpc dir"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This directory will hold a series of named pipes to allow RPC over inter-process communication.</para>
diff --git a/docs-xml/smbdotconf/misc/panicaction.xml b/docs-xml/smbdotconf/misc/panicaction.xml
index 7b7df256388..01a97c3dba4 100644
--- a/docs-xml/smbdotconf/misc/panicaction.xml
+++ b/docs-xml/smbdotconf/misc/panicaction.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="panic action"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This is a Samba developer option that allows a 
diff --git a/docs-xml/smbdotconf/misc/perfcountmodule.xml b/docs-xml/smbdotconf/misc/perfcountmodule.xml
index e1c09488624..e25105fdb42 100644
--- a/docs-xml/smbdotconf/misc/perfcountmodule.xml
+++ b/docs-xml/smbdotconf/misc/perfcountmodule.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="perfcount module"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This parameter specifies the perfcount backend to be used when monitoring SMB
diff --git a/docs-xml/smbdotconf/misc/piddirectory.xml b/docs-xml/smbdotconf/misc/piddirectory.xml
index b53730d52c0..d006372a2b9 100644
--- a/docs-xml/smbdotconf/misc/piddirectory.xml
+++ b/docs-xml/smbdotconf/misc/piddirectory.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="pid directory"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/postexec.xml b/docs-xml/smbdotconf/misc/postexec.xml
index c65ee1b2bca..ca1522123ce 100644
--- a/docs-xml/smbdotconf/misc/postexec.xml
+++ b/docs-xml/smbdotconf/misc/postexec.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="postexec"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This option specifies a command to be run 
diff --git a/docs-xml/smbdotconf/misc/preexec.xml b/docs-xml/smbdotconf/misc/preexec.xml
index e5d07ef1346..7faf89a4f35 100644
--- a/docs-xml/smbdotconf/misc/preexec.xml
+++ b/docs-xml/smbdotconf/misc/preexec.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="preexec"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>exec</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/misc/remoteannounce.xml b/docs-xml/smbdotconf/misc/remoteannounce.xml
index ad537c8b41f..04368987e06 100644
--- a/docs-xml/smbdotconf/misc/remoteannounce.xml
+++ b/docs-xml/smbdotconf/misc/remoteannounce.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="remote announce"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/remotebrowsesync.xml b/docs-xml/smbdotconf/misc/remotebrowsesync.xml
index 91a8c8f8829..c0b106ee7cd 100644
--- a/docs-xml/smbdotconf/misc/remotebrowsesync.xml
+++ b/docs-xml/smbdotconf/misc/remotebrowsesync.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="remote browse sync"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/rootpostexec.xml b/docs-xml/smbdotconf/misc/rootpostexec.xml
index d50ca7f48bb..4e74fc8e00a 100644
--- a/docs-xml/smbdotconf/misc/rootpostexec.xml
+++ b/docs-xml/smbdotconf/misc/rootpostexec.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="root postexec"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/rootpreexec.xml b/docs-xml/smbdotconf/misc/rootpreexec.xml
index 32bfe442bde..32c4ef7b6fe 100644
--- a/docs-xml/smbdotconf/misc/rootpreexec.xml
+++ b/docs-xml/smbdotconf/misc/rootpreexec.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="root preexec"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/misc/statedirectory.xml b/docs-xml/smbdotconf/misc/statedirectory.xml
index 2f2b0642ea9..12481fc8d34 100644
--- a/docs-xml/smbdotconf/misc/statedirectory.xml
+++ b/docs-xml/smbdotconf/misc/statedirectory.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="state directory"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>Usually, most of the TDB files are stored in the
diff --git a/docs-xml/smbdotconf/misc/usersharepath.xml b/docs-xml/smbdotconf/misc/usersharepath.xml
index 446b1fdef61..99fea946c00 100644
--- a/docs-xml/smbdotconf/misc/usersharepath.xml
+++ b/docs-xml/smbdotconf/misc/usersharepath.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="usershare path"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This parameter specifies the absolute path of the directory on the
diff --git a/docs-xml/smbdotconf/misc/utmpdirectory.xml b/docs-xml/smbdotconf/misc/utmpdirectory.xml
index 82c8f10fd71..96b45dbec56 100644
--- a/docs-xml/smbdotconf/misc/utmpdirectory.xml
+++ b/docs-xml/smbdotconf/misc/utmpdirectory.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="utmp directory"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This parameter is only available if Samba has 
diff --git a/docs-xml/smbdotconf/misc/volume.xml b/docs-xml/smbdotconf/misc/volume.xml
index 02129f11a54..4f1be6a1b59 100644
--- a/docs-xml/smbdotconf/misc/volume.xml
+++ b/docs-xml/smbdotconf/misc/volume.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="volume"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This allows you to override the volume label 
diff --git a/docs-xml/smbdotconf/misc/wtmpdirectory.xml b/docs-xml/smbdotconf/misc/wtmpdirectory.xml
index eb9d8767241..f1b53592a47 100644
--- a/docs-xml/smbdotconf/misc/wtmpdirectory.xml
+++ b/docs-xml/smbdotconf/misc/wtmpdirectory.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="wtmp directory"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/printing/addportcommand.xml b/docs-xml/smbdotconf/printing/addportcommand.xml
index 7a35c5266d9..c25794ba794 100644
--- a/docs-xml/smbdotconf/printing/addportcommand.xml
+++ b/docs-xml/smbdotconf/printing/addportcommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="addport command"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>Samba 3.0.23 introduced support for adding printer ports
diff --git a/docs-xml/smbdotconf/printing/addprintercommand.xml b/docs-xml/smbdotconf/printing/addprintercommand.xml
index c39296df601..954b43740e1 100644
--- a/docs-xml/smbdotconf/printing/addprintercommand.xml
+++ b/docs-xml/smbdotconf/printing/addprintercommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="addprinter command"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>With the introduction of MS-RPC based printing
diff --git a/docs-xml/smbdotconf/printing/cupsoptions.xml b/docs-xml/smbdotconf/printing/cupsoptions.xml
index 7e6b07db9f5..833ba30a0d3 100644
--- a/docs-xml/smbdotconf/printing/cupsoptions.xml
+++ b/docs-xml/smbdotconf/printing/cupsoptions.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="cups options"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>
diff --git a/docs-xml/smbdotconf/printing/cupsserver.xml b/docs-xml/smbdotconf/printing/cupsserver.xml
index 19bb769808f..c18c115723b 100644
--- a/docs-xml/smbdotconf/printing/cupsserver.xml
+++ b/docs-xml/smbdotconf/printing/cupsserver.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="cups server"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>
diff --git a/docs-xml/smbdotconf/printing/deleteprintercommand.xml b/docs-xml/smbdotconf/printing/deleteprintercommand.xml
index f9a9a47d673..6d70ddc4bf4 100644
--- a/docs-xml/smbdotconf/printing/deleteprintercommand.xml
+++ b/docs-xml/smbdotconf/printing/deleteprintercommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="deleteprinter command"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>With the introduction of MS-RPC based printer
diff --git a/docs-xml/smbdotconf/printing/enumportscommand.xml b/docs-xml/smbdotconf/printing/enumportscommand.xml
index cb85cd0bcc8..12580420d72 100644
--- a/docs-xml/smbdotconf/printing/enumportscommand.xml
+++ b/docs-xml/smbdotconf/printing/enumportscommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="enumports command"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>The concept of a &quot;port&quot; is fairly foreign
diff --git a/docs-xml/smbdotconf/printing/iprintserver.xml b/docs-xml/smbdotconf/printing/iprintserver.xml
index 82bf9e93120..16e36238513 100644
--- a/docs-xml/smbdotconf/printing/iprintserver.xml
+++ b/docs-xml/smbdotconf/printing/iprintserver.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="iprint server"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>
diff --git a/docs-xml/smbdotconf/printing/lppausecommand.xml b/docs-xml/smbdotconf/printing/lppausecommand.xml
index f2518d3def0..3aa134c4377 100644
--- a/docs-xml/smbdotconf/printing/lppausecommand.xml
+++ b/docs-xml/smbdotconf/printing/lppausecommand.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="lppause command"
                  context="S"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This parameter specifies the command to be 
diff --git a/docs-xml/smbdotconf/printing/lpqcommand.xml b/docs-xml/smbdotconf/printing/lpqcommand.xml
index f0161f3448d..f3c17f286d1 100644
--- a/docs-xml/smbdotconf/printing/lpqcommand.xml
+++ b/docs-xml/smbdotconf/printing/lpqcommand.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="lpq command"
                  context="S"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
     <para>This parameter specifies the command to be 
diff --git a/docs-xml/smbdotconf/printing/lpresumecommand.xml b/docs-xml/smbdotconf/printing/lpresumecommand.xml
index 2cee574bd73..153ba76a693 100644
--- a/docs-xml/smbdotconf/printing/lpresumecommand.xml
+++ b/docs-xml/smbdotconf/printing/lpresumecommand.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="lpresume command"
                  context="S"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This parameter specifies the command to be 
diff --git a/docs-xml/smbdotconf/printing/lprmcommand.xml b/docs-xml/smbdotconf/printing/lprmcommand.xml
index a595c1225c0..4b7f3dd75c3 100644
--- a/docs-xml/smbdotconf/printing/lprmcommand.xml
+++ b/docs-xml/smbdotconf/printing/lprmcommand.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="lprm command"
                  context="S"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This parameter specifies the command to be 
diff --git a/docs-xml/smbdotconf/printing/os2drivermap.xml b/docs-xml/smbdotconf/printing/os2drivermap.xml
index 166cec23773..c845f334743 100644
--- a/docs-xml/smbdotconf/printing/os2drivermap.xml
+++ b/docs-xml/smbdotconf/printing/os2drivermap.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="os2 driver map"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>The parameter is used to define the absolute
diff --git a/docs-xml/smbdotconf/printing/printcapname.xml b/docs-xml/smbdotconf/printing/printcapname.xml
index 64acc265aef..3a65d23b905 100644
--- a/docs-xml/smbdotconf/printing/printcapname.xml
+++ b/docs-xml/smbdotconf/printing/printcapname.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="printcap name"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>printcap</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/printing/printcommand.xml b/docs-xml/smbdotconf/printing/printcommand.xml
index 42a7188cb9a..c84e45f404d 100644
--- a/docs-xml/smbdotconf/printing/printcommand.xml
+++ b/docs-xml/smbdotconf/printing/printcommand.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="print command"
                  context="S"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>After a print job has finished spooling to 
diff --git a/docs-xml/smbdotconf/printing/printername.xml b/docs-xml/smbdotconf/printing/printername.xml
index abe2b2483dc..6b82ef29de1 100644
--- a/docs-xml/smbdotconf/printing/printername.xml
+++ b/docs-xml/smbdotconf/printing/printername.xml
@@ -2,6 +2,7 @@
                  context="S"
                  type="string"
                  function="_printername"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <synonym>printer</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/printing/printjobusername.xml b/docs-xml/smbdotconf/printing/printjobusername.xml
index 872a2e592ed..06209f74c6a 100644
--- a/docs-xml/smbdotconf/printing/printjobusername.xml
+++ b/docs-xml/smbdotconf/printing/printjobusername.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="printjob username"
                  context="S"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This parameter specifies which user information will be 
diff --git a/docs-xml/smbdotconf/printing/queuepausecommand.xml b/docs-xml/smbdotconf/printing/queuepausecommand.xml
index 600a2baa621..5dca45657cc 100644
--- a/docs-xml/smbdotconf/printing/queuepausecommand.xml
+++ b/docs-xml/smbdotconf/printing/queuepausecommand.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="queuepause command"
                  context="S"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This parameter specifies the command to be 
diff --git a/docs-xml/smbdotconf/printing/queueresumecommand.xml b/docs-xml/smbdotconf/printing/queueresumecommand.xml
index 431295a804e..4a573330048 100644
--- a/docs-xml/smbdotconf/printing/queueresumecommand.xml
+++ b/docs-xml/smbdotconf/printing/queueresumecommand.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="queueresume command"
                  context="S"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This parameter specifies the command to be 
diff --git a/docs-xml/smbdotconf/security/binddnsdir.xml b/docs-xml/smbdotconf/security/binddnsdir.xml
index c296a0ef81d..a948cb59234 100644
--- a/docs-xml/smbdotconf/security/binddnsdir.xml
+++ b/docs-xml/smbdotconf/security/binddnsdir.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="binddns dir"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>bind dns directory</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/security/checkpasswordscript.xml b/docs-xml/smbdotconf/security/checkpasswordscript.xml
index 1e9031fda42..18aa2c6d290 100644
--- a/docs-xml/smbdotconf/security/checkpasswordscript.xml
+++ b/docs-xml/smbdotconf/security/checkpasswordscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="check password script"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>The name of a program that can be used to check password
diff --git a/docs-xml/smbdotconf/security/dedicatedkeytabfile.xml b/docs-xml/smbdotconf/security/dedicatedkeytabfile.xml
index 8405b48028d..b7c26806b6e 100644
--- a/docs-xml/smbdotconf/security/dedicatedkeytabfile.xml
+++ b/docs-xml/smbdotconf/security/dedicatedkeytabfile.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="dedicated keytab file"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>
diff --git a/docs-xml/smbdotconf/security/forcegroup.xml b/docs-xml/smbdotconf/security/forcegroup.xml
index d101f1c1b86..646f5505981 100644
--- a/docs-xml/smbdotconf/security/forcegroup.xml
+++ b/docs-xml/smbdotconf/security/forcegroup.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="force group"
                  context="S"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>group</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/security/forceuser.xml b/docs-xml/smbdotconf/security/forceuser.xml
index ff5c7a2f3f1..f3010a95298 100644
--- a/docs-xml/smbdotconf/security/forceuser.xml
+++ b/docs-xml/smbdotconf/security/forceuser.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="force user"
                  type="string"
                  context="S"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This specifies a UNIX user name that will be 
diff --git a/docs-xml/smbdotconf/security/guestaccount.xml b/docs-xml/smbdotconf/security/guestaccount.xml
index c5dbbd9e1ce..2914630072a 100644
--- a/docs-xml/smbdotconf/security/guestaccount.xml
+++ b/docs-xml/smbdotconf/security/guestaccount.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="guest account"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This is a username which will be used for access 
diff --git a/docs-xml/smbdotconf/security/lognttokencommand.xml b/docs-xml/smbdotconf/security/lognttokencommand.xml
index 66ec6c9e132..0ea269e92a1 100644
--- a/docs-xml/smbdotconf/security/lognttokencommand.xml
+++ b/docs-xml/smbdotconf/security/lognttokencommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="log nt token command"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This option can be set to a command that will be called when new nt
diff --git a/docs-xml/smbdotconf/security/mitkdccommand.xml b/docs-xml/smbdotconf/security/mitkdccommand.xml
index c8272de7908..602f27dd693 100644
--- a/docs-xml/smbdotconf/security/mitkdccommand.xml
+++ b/docs-xml/smbdotconf/security/mitkdccommand.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="mit kdc command"
                  context="G"
                  type="list"
-                 advanced="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This option specifies the path to the MIT kdc binary.</para>
diff --git a/docs-xml/smbdotconf/security/ntpsigndsocketdirectory.xml b/docs-xml/smbdotconf/security/ntpsigndsocketdirectory.xml
index a2c92a4aa31..18d70cf41e1 100644
--- a/docs-xml/smbdotconf/security/ntpsigndsocketdirectory.xml
+++ b/docs-xml/smbdotconf/security/ntpsigndsocketdirectory.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="ntp signd socket directory"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This setting controls the location of the socket that
diff --git a/docs-xml/smbdotconf/security/passdbbackend.xml b/docs-xml/smbdotconf/security/passdbbackend.xml
index 3e378bd07c5..8265b3ed547 100644
--- a/docs-xml/smbdotconf/security/passdbbackend.xml
+++ b/docs-xml/smbdotconf/security/passdbbackend.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="passdb backend"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 
diff --git a/docs-xml/smbdotconf/security/passwdchat.xml b/docs-xml/smbdotconf/security/passwdchat.xml
index c9434b00098..23f8e6e1570 100644
--- a/docs-xml/smbdotconf/security/passwdchat.xml
+++ b/docs-xml/smbdotconf/security/passwdchat.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="passwd chat"
                  context="G"
 		 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This string controls the <emphasis>&quot;chat&quot;</emphasis> 
diff --git a/docs-xml/smbdotconf/security/passwdprogram.xml b/docs-xml/smbdotconf/security/passwdprogram.xml
index 81410489b01..e12cc8e2d8c 100644
--- a/docs-xml/smbdotconf/security/passwdprogram.xml
+++ b/docs-xml/smbdotconf/security/passwdprogram.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="passwd program"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
     <para>The name of a program that can be used to set 
diff --git a/docs-xml/smbdotconf/security/passwordserver.xml b/docs-xml/smbdotconf/security/passwordserver.xml
index a62494b9b48..8bc2ecb8502 100644
--- a/docs-xml/smbdotconf/security/passwordserver.xml
+++ b/docs-xml/smbdotconf/security/passwordserver.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="password server"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>By specifying the name of a domain controller with this option,
diff --git a/docs-xml/smbdotconf/security/privatedir.xml b/docs-xml/smbdotconf/security/privatedir.xml
index 58be37281d9..9abcb7e01d7 100644
--- a/docs-xml/smbdotconf/security/privatedir.xml
+++ b/docs-xml/smbdotconf/security/privatedir.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="private dir"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>private directory</synonym>
 <description>
diff --git a/docs-xml/smbdotconf/security/renameuserscript.xml b/docs-xml/smbdotconf/security/renameuserscript.xml
index 1a15ebabfef..2bfbea44c5a 100644
--- a/docs-xml/smbdotconf/security/renameuserscript.xml
+++ b/docs-xml/smbdotconf/security/renameuserscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="rename user script"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>
diff --git a/docs-xml/smbdotconf/security/rootdirectory.xml b/docs-xml/smbdotconf/security/rootdirectory.xml
index e795af26bf8..008ec5086fc 100644
--- a/docs-xml/smbdotconf/security/rootdirectory.xml
+++ b/docs-xml/smbdotconf/security/rootdirectory.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="root directory"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <synonym>root</synonym>
 <synonym>root dir</synonym>
diff --git a/docs-xml/smbdotconf/security/smbpasswdfile.xml b/docs-xml/smbdotconf/security/smbpasswdfile.xml
index a906403473f..fab70378c4f 100644
--- a/docs-xml/smbdotconf/security/smbpasswdfile.xml
+++ b/docs-xml/smbdotconf/security/smbpasswdfile.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="smb passwd file"
                  type="string"
                  context="G"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>This option sets the path to the encrypted smbpasswd file. By
diff --git a/docs-xml/smbdotconf/security/tlscafile.xml b/docs-xml/smbdotconf/security/tlscafile.xml
index 149891342c8..bcbac62a417 100644
--- a/docs-xml/smbdotconf/security/tlscafile.xml
+++ b/docs-xml/smbdotconf/security/tlscafile.xml
@@ -2,7 +2,6 @@
                  type="string"
                  context="G"
                  function="_tls_cafile"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
 	 <para>This option can be set to a file (PEM format)
diff --git a/docs-xml/smbdotconf/security/tlscertfile.xml b/docs-xml/smbdotconf/security/tlscertfile.xml
index 0d06936a041..cf7095475f3 100644
--- a/docs-xml/smbdotconf/security/tlscertfile.xml
+++ b/docs-xml/smbdotconf/security/tlscertfile.xml
@@ -2,7 +2,6 @@
                  type="string"
                  context="G"
                  function="_tls_certfile"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
 	 <para>This option can be set to a file (PEM format)
diff --git a/docs-xml/smbdotconf/security/tlscrlfile.xml b/docs-xml/smbdotconf/security/tlscrlfile.xml
index c0f1cfb5b8b..1f42b859a11 100644
--- a/docs-xml/smbdotconf/security/tlscrlfile.xml
+++ b/docs-xml/smbdotconf/security/tlscrlfile.xml
@@ -2,7 +2,6 @@
                  type="string"
                  context="G"
                  function="_tls_crlfile"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
 	 <para>This option can be set to a file containing a certificate
diff --git a/docs-xml/smbdotconf/security/tlsdhparamsfile.xml b/docs-xml/smbdotconf/security/tlsdhparamsfile.xml
index 4a5361c8c23..5bf59aacd1a 100644
--- a/docs-xml/smbdotconf/security/tlsdhparamsfile.xml
+++ b/docs-xml/smbdotconf/security/tlsdhparamsfile.xml
@@ -2,7 +2,6 @@
                  type="string"
                  context="G"
                  function="_tls_dhpfile"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
 	 <para>This option can be set to a file with Diffie-Hellman parameters
diff --git a/docs-xml/smbdotconf/security/tlskeyfile.xml b/docs-xml/smbdotconf/security/tlskeyfile.xml
index e6b4a544cae..9caa8241fa8 100644
--- a/docs-xml/smbdotconf/security/tlskeyfile.xml
+++ b/docs-xml/smbdotconf/security/tlskeyfile.xml
@@ -2,7 +2,6 @@
                  type="string"
                  context="G"
                  function="_tls_keyfile"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
 	 <para>This option can be set to a file (PEM format)
diff --git a/docs-xml/smbdotconf/security/tlspriority.xml b/docs-xml/smbdotconf/security/tlspriority.xml
index d399eef8eef..d7214a4c1ea 100644
--- a/docs-xml/smbdotconf/security/tlspriority.xml
+++ b/docs-xml/smbdotconf/security/tlspriority.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="tls priority"
                  type="string"
                  context="G"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
  <description>
    <para>This option can be set to a string describing the TLS protocols
diff --git a/docs-xml/smbdotconf/security/usernamemap.xml b/docs-xml/smbdotconf/security/usernamemap.xml
index 8867ea6bdec..809a54c1e2f 100644
--- a/docs-xml/smbdotconf/security/usernamemap.xml
+++ b/docs-xml/smbdotconf/security/usernamemap.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="username map"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>
diff --git a/docs-xml/smbdotconf/security/usernamemapscript.xml b/docs-xml/smbdotconf/security/usernamemapscript.xml
index 0edd4eb25c3..86118f305bc 100644
--- a/docs-xml/smbdotconf/security/usernamemapscript.xml
+++ b/docs-xml/smbdotconf/security/usernamemapscript.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="username map script"
                  context="G"
                  type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This script is a mutually exclusive alternative to the 
diff --git a/docs-xml/smbdotconf/tuning/aiowritebehind.xml b/docs-xml/smbdotconf/tuning/aiowritebehind.xml
index c88cd97fa97..d60af7154fd 100644
--- a/docs-xml/smbdotconf/tuning/aiowritebehind.xml
+++ b/docs-xml/smbdotconf/tuning/aiowritebehind.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="aio write behind"
                  context="S"
 		 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>If Samba has been built with asynchronous I/O support,
diff --git a/docs-xml/smbdotconf/tuning/socketoptions.xml b/docs-xml/smbdotconf/tuning/socketoptions.xml
index fd61163661a..c0bd785cb78 100644
--- a/docs-xml/smbdotconf/tuning/socketoptions.xml
+++ b/docs-xml/smbdotconf/tuning/socketoptions.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="socket options"
                  context="G"
 				 type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
     <para>
diff --git a/docs-xml/smbdotconf/vfs/getquotacommand.xml b/docs-xml/smbdotconf/vfs/getquotacommand.xml
index 7fcd829f50c..9422b7efd92 100644
--- a/docs-xml/smbdotconf/vfs/getquotacommand.xml
+++ b/docs-xml/smbdotconf/vfs/getquotacommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="get quota command"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>The <command>get quota command</command> should only be used 
diff --git a/docs-xml/smbdotconf/vfs/msdfsproxy.xml b/docs-xml/smbdotconf/vfs/msdfsproxy.xml
index 566dcd7d691..55a410fe49e 100644
--- a/docs-xml/smbdotconf/vfs/msdfsproxy.xml
+++ b/docs-xml/smbdotconf/vfs/msdfsproxy.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="msdfs proxy"
                  context="S"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This parameter indicates that the share is a
diff --git a/docs-xml/smbdotconf/vfs/setquotacommand.xml b/docs-xml/smbdotconf/vfs/setquotacommand.xml
index 2a779d4a50f..6ae6ef11409 100644
--- a/docs-xml/smbdotconf/vfs/setquotacommand.xml
+++ b/docs-xml/smbdotconf/vfs/setquotacommand.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="set quota command"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>The <command>set quota command</command> should only be used 
diff --git a/docs-xml/smbdotconf/winbind/templatehomedir.xml b/docs-xml/smbdotconf/winbind/templatehomedir.xml
index cbf391ce199..2801edf47e3 100644
--- a/docs-xml/smbdotconf/winbind/templatehomedir.xml
+++ b/docs-xml/smbdotconf/winbind/templatehomedir.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="template homedir"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>When filling out the user information for a Windows NT 
diff --git a/docs-xml/smbdotconf/winbind/templateshell.xml b/docs-xml/smbdotconf/winbind/templateshell.xml
index 21e44e6cb5e..891c4242e8f 100644
--- a/docs-xml/smbdotconf/winbind/templateshell.xml
+++ b/docs-xml/smbdotconf/winbind/templateshell.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="template shell"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>When filling out the user information for a Windows NT 
diff --git a/docs-xml/smbdotconf/winbind/winbinddsocketdirectory.xml b/docs-xml/smbdotconf/winbind/winbinddsocketdirectory.xml
index 842cff12b2b..7827d36d6a5 100644
--- a/docs-xml/smbdotconf/winbind/winbinddsocketdirectory.xml
+++ b/docs-xml/smbdotconf/winbind/winbinddsocketdirectory.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="winbindd socket directory"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This setting controls the location of the winbind daemon's socket.</para>
diff --git a/docs-xml/smbdotconf/winbind/winbindnssinfo.xml b/docs-xml/smbdotconf/winbind/winbindnssinfo.xml
index d8347442a8d..e6d17c256a1 100644
--- a/docs-xml/smbdotconf/winbind/winbindnssinfo.xml
+++ b/docs-xml/smbdotconf/winbind/winbindnssinfo.xml
@@ -22,11 +22,10 @@
 			Domain Controller does support the Microsoft "Services for Unix" (SFU)
 			LDAP schema, winbind can retrieve the login shell and the home
 			directory attributes directly from your Directory Server. For SFU 3.0 or 3.5 simply choose
-			"sfu", if you use SFU 2.0 please choose "sfu20". Note that
-			retrieving UID and GID from your ADS-Server requires to
-			use <parameter moreinfo="none">idmap config DOMAIN:backend</parameter> = ad
-			as well. The primary group membership is currently
-			always calculated via the "primaryGroupID" LDAP attribute.
+			"sfu", if you use SFU 2.0 please choose "sfu20".</para>
+			<para>Note that for the idmap backend <refentrytitle>idmap_ad</refentrytitle>
+			you need to configure those settings in the idmap configuration section.
+			Make sure to consult the documentation of the idmap backend that you are using.
 			</para>
 		</listitem>
 	</itemizedlist>
diff --git a/docs-xml/smbdotconf/winbind/winbindseparator.xml b/docs-xml/smbdotconf/winbind/winbindseparator.xml
index 1c1632fbdff..eda14f4e03a 100644
--- a/docs-xml/smbdotconf/winbind/winbindseparator.xml
+++ b/docs-xml/smbdotconf/winbind/winbindseparator.xml
@@ -1,7 +1,6 @@
 <samba:parameter name="winbind separator"
                  context="G"
                  type="string"
-                 constant="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>This parameter allows an admin to define the character 
diff --git a/docs-xml/smbdotconf/wins/winshook.xml b/docs-xml/smbdotconf/wins/winshook.xml
index 748e8b8f239..3dcf5d7cca5 100644
--- a/docs-xml/smbdotconf/wins/winshook.xml
+++ b/docs-xml/smbdotconf/wins/winshook.xml
@@ -1,6 +1,7 @@
 <samba:parameter name="wins hook"
                  context="G"
-				 type="string"
+                 type="string"
+                 substitution="1"
                  xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
 <description>
 	<para>When Samba is running as a WINS server this 
diff --git a/docs-xml/wscript_build b/docs-xml/wscript_build
index 70f5b43dd33..21158e11fe7 100644
--- a/docs-xml/wscript_build
+++ b/docs-xml/wscript_build
@@ -68,6 +68,7 @@ vfs_module_manpages = ['vfs_acl_tdb',
                        'vfs_acl_xattr',
                        'vfs_aio_fork',
                        'vfs_aio_pthread',
+                       'vfs_io_uring',
                        'vfs_audit',
                        'vfs_btrfs',
                        'vfs_cacheprime',
diff --git a/examples/VFS/skel_opaque.c b/examples/VFS/skel_opaque.c
index 4f0622bccc6..c1b5923b752 100644
--- a/examples/VFS/skel_opaque.c
+++ b/examples/VFS/skel_opaque.c
@@ -103,6 +103,25 @@ static NTSTATUS skel_get_dfs_referrals(struct vfs_handle_struct *handle,
 	return NT_STATUS_NOT_IMPLEMENTED;
 }
 
+static NTSTATUS skel_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	return NT_STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS skel_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count)
+{
+	return NT_STATUS_NOT_IMPLEMENTED;
+}
+
 static DIR *skel_opendir(vfs_handle_struct *handle,
 			const struct smb_filename *smb_fname,
 			const char *mask,
@@ -1032,6 +1051,8 @@ static struct vfs_fn_pointers skel_opaque_fns = {
 	.statvfs_fn = skel_statvfs,
 	.fs_capabilities_fn = skel_fs_capabilities,
 	.get_dfs_referrals_fn = skel_get_dfs_referrals,
+	.create_dfs_pathat_fn = skel_create_dfs_pathat,
+	.read_dfs_pathat_fn = skel_read_dfs_pathat,
 	.snap_check_path_fn = skel_snap_check_path,
 	.snap_create_fn = skel_snap_create,
 	.snap_delete_fn = skel_snap_delete,
diff --git a/examples/VFS/skel_transparent.c b/examples/VFS/skel_transparent.c
index f7f7be98bb4..d2d05673fb4 100644
--- a/examples/VFS/skel_transparent.c
+++ b/examples/VFS/skel_transparent.c
@@ -100,6 +100,34 @@ static NTSTATUS skel_get_dfs_referrals(struct vfs_handle_struct *handle,
 	return SMB_VFS_NEXT_GET_DFS_REFERRALS(handle, r);
 }
 
+static NTSTATUS skel_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	return SMB_VFS_NEXT_CREATE_DFS_PATHAT(handle,
+					dirfsp,
+					smb_fname,
+					reflist,
+					referral_count);
+}
+
+static NTSTATUS skel_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count)
+{
+	return SMB_VFS_NEXT_READ_DFS_PATHAT(handle,
+					mem_ctx,
+					dirfsp,
+					smb_fname,
+					ppreflist,
+					preferral_count);
+}
+
 static DIR *skel_opendir(vfs_handle_struct *handle,
 			const struct smb_filename *smb_fname,
 			const char *mask,
@@ -1330,6 +1358,8 @@ static struct vfs_fn_pointers skel_transparent_fns = {
 	.statvfs_fn = skel_statvfs,
 	.fs_capabilities_fn = skel_fs_capabilities,
 	.get_dfs_referrals_fn = skel_get_dfs_referrals,
+	.create_dfs_pathat_fn = skel_create_dfs_pathat,
+	.read_dfs_pathat_fn = skel_read_dfs_pathat,
 	.snap_check_path_fn = skel_snap_check_path,
 	.snap_create_fn = skel_snap_create,
 	.snap_delete_fn = skel_snap_delete,
diff --git a/examples/auth/auth_skel.c b/examples/auth/auth_skel.c
index 6abd5ad4f7a..8734383aeeb 100644
--- a/examples/auth/auth_skel.c
+++ b/examples/auth/auth_skel.c
@@ -42,7 +42,10 @@ static NTSTATUS check_skel_security(const struct auth_context *auth_context,
 }
 
 /* module initialisation */
-static NTSTATUS auth_init_skel(struct auth_context *auth_context, const char *param, auth_methods **auth_method)
+static NTSTATUS auth_init_skel(
+	struct auth_context *auth_context,
+	const char *param,
+	struct auth_methods **auth_method)
 {
 	struct auth_methods *result;
 
@@ -56,7 +59,7 @@ static NTSTATUS auth_init_skel(struct auth_context *auth_context, const char *pa
 	if (param && *param) {
 		/* we load the 'fallback' module - if skel isn't here, call this
 		   module */
-		auth_methods *priv;
+		struct auth_methods *priv;
 		if (!load_auth_module(auth_context, param, &priv)) {
 			return NT_STATUS_UNSUCCESSFUL;
 		}
diff --git a/lib/afs/afs_funcs.c b/lib/afs/afs_funcs.c
index 66451665462..c7b263c7e73 100644
--- a/lib/afs/afs_funcs.c
+++ b/lib/afs/afs_funcs.c
@@ -221,6 +221,8 @@ char *afs_createtoken_str(const char *username, const char *cell)
 
 bool afs_login(connection_struct *conn)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	DATA_BLOB ticket;
 	char *afs_username = NULL;
 	char *cell = NULL;
@@ -239,7 +241,7 @@ bool afs_login(connection_struct *conn)
 	}
 
 	afs_username = talloc_sub_advanced(ctx,
-				lp_servicename(ctx, SNUM(conn)),
+				lp_servicename(ctx, lp_sub, SNUM(conn)),
 				conn->session_info->unix_info->unix_name,
 				conn->connectpath,
 				conn->session_info->unix_token->gid,
diff --git a/lib/async_req/wscript_build b/lib/async_req/wscript_build
index bf79fdd24d1..4486a5b2f06 100644
--- a/lib/async_req/wscript_build
+++ b/lib/async_req/wscript_build
@@ -10,5 +10,5 @@ bld.SAMBA_SUBSYSTEM('LIBASYNC_REQ',
 bld.SAMBA_BINARY('async_connect_send_test',
                  source='async_connect_send_test.c',
                  deps='LIBASYNC_REQ',
-                 install=False
+                 for_selftest=True
 )
diff --git a/lib/audit_logging/wscript_build b/lib/audit_logging/wscript_build
index 4811e056b72..125c94bad90 100644
--- a/lib/audit_logging/wscript_build
+++ b/lib/audit_logging/wscript_build
@@ -9,7 +9,7 @@ bld.SAMBA_SUBSYSTEM(
     source='audit_logging.c'
 )
 
-if bld.AD_DC_BUILD_IS_ENABLED() and bld.CONFIG_GET('ENABLE_SELFTEST'):
+if bld.AD_DC_BUILD_IS_ENABLED():
     bld.SAMBA_BINARY(
         'audit_logging_test',
         source='tests/audit_logging_test.c',
@@ -21,10 +21,10 @@ if bld.AD_DC_BUILD_IS_ENABLED() and bld.CONFIG_GET('ENABLE_SELFTEST'):
              samba-util
              LIBTSOCKET
         ''',
-        install=False
+        for_selftest=True
     )
 
-if bld.AD_DC_BUILD_IS_ENABLED() and bld.CONFIG_GET('ENABLE_SELFTEST'):
+if bld.AD_DC_BUILD_IS_ENABLED():
     bld.SAMBA_BINARY(
         'audit_logging_error_test',
         source='tests/audit_logging_error_test.c',
@@ -36,7 +36,7 @@ if bld.AD_DC_BUILD_IS_ENABLED() and bld.CONFIG_GET('ENABLE_SELFTEST'):
              samba-util
              LIBTSOCKET
         ''',
-        install=False,
+        for_selftest=True,
         ldflags='''
             -Wl,--wrap,json_object_set_new
             -Wl,--wrap,json_object_update
diff --git a/lib/crypto/aes_ccm_128.c b/lib/crypto/aes_ccm_128.c
deleted file mode 100644
index 0cbc05567a8..00000000000
--- a/lib/crypto/aes_ccm_128.c
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
-   AES-CCM-128 (rfc 3610)
-
-   Copyright (C) Stefan Metzmacher 2012
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "replace.h"
-#include "lib/crypto/aes.h"
-#include "lib/crypto/aes_ccm_128.h"
-#include "lib/util/byteorder.h"
-
-#define M_ ((AES_CCM_128_M - 2) / 2)
-#define L_ (AES_CCM_128_L - 1)
-
-void aes_ccm_128_init(struct aes_ccm_128_context *ctx,
-		      const uint8_t K[AES_BLOCK_SIZE],
-		      const uint8_t N[AES_CCM_128_NONCE_SIZE],
-		      size_t a_total, size_t m_total)
-{
-	ZERO_STRUCTP(ctx);
-
-	AES_set_encrypt_key(K, 128, &ctx->aes_key);
-	memcpy(ctx->nonce, N, AES_CCM_128_NONCE_SIZE);
-	ctx->a_remain = a_total;
-	ctx->m_remain = m_total;
-
-	/*
-	 * prepare B_0
-	 */
-	ctx->B_i[0]  = L_;
-	ctx->B_i[0] += 8 * M_;
-	if (a_total > 0) {
-		ctx->B_i[0] += 64;
-	}
-	memcpy(&ctx->B_i[1], ctx->nonce, AES_CCM_128_NONCE_SIZE);
-	RSIVAL(ctx->B_i, (AES_BLOCK_SIZE - AES_CCM_128_L), m_total);
-
-	/*
-	 * prepare X_1
-	 */
-	AES_encrypt(ctx->B_i, ctx->X_i, &ctx->aes_key);
-
-	/*
-	 * prepare B_1
-	 */
-	ZERO_STRUCT(ctx->B_i);
-	if (a_total >= UINT32_MAX) {
-		RSSVAL(ctx->B_i, 0, 0xFFFF);
-		RSBVAL(ctx->B_i, 2, (uint64_t)a_total);
-		ctx->B_i_ofs = 10;
-	} else if (a_total >= 0xFF00) {
-		RSSVAL(ctx->B_i, 0, 0xFFFE);
-		RSIVAL(ctx->B_i, 2, a_total);
-		ctx->B_i_ofs = 6;
-	} else if (a_total > 0) {
-		RSSVAL(ctx->B_i, 0, a_total);
-		ctx->B_i_ofs = 2;
-	}
-
-	/*
-	 * prepare A_i
-	 */
-	ctx->A_i[0]  = L_;
-	memcpy(&ctx->A_i[1], ctx->nonce, AES_CCM_128_NONCE_SIZE);
-
-	ctx->S_i_ofs = AES_BLOCK_SIZE;
-}
-
-void aes_ccm_128_update(struct aes_ccm_128_context *ctx,
-			const uint8_t *v, size_t v_len)
-{
-	size_t *remain;
-
-	if (v_len == 0) {
-		return;
-	}
-
-	if (ctx->a_remain > 0) {
-		remain = &ctx->a_remain;
-	} else {
-		remain = &ctx->m_remain;
-	}
-
-	if (unlikely(v_len > *remain)) {
-		abort();
-	}
-
-	if (ctx->B_i_ofs > 0) {
-		size_t n = MIN(AES_BLOCK_SIZE - ctx->B_i_ofs, v_len);
-
-		memcpy(&ctx->B_i[ctx->B_i_ofs], v, n);
-		v += n;
-		v_len -= n;
-		ctx->B_i_ofs += n;
-		*remain -= n;
-	}
-
-	if ((ctx->B_i_ofs == AES_BLOCK_SIZE) || (*remain == 0)) {
-		aes_block_xor(ctx->X_i, ctx->B_i, ctx->B_i);
-		AES_encrypt(ctx->B_i, ctx->X_i, &ctx->aes_key);
-		ctx->B_i_ofs = 0;
-	}
-
-	while (v_len >= AES_BLOCK_SIZE) {
-		aes_block_xor(ctx->X_i, v, ctx->B_i);
-		AES_encrypt(ctx->B_i, ctx->X_i, &ctx->aes_key);
-		v += AES_BLOCK_SIZE;
-		v_len -= AES_BLOCK_SIZE;
-		*remain -= AES_BLOCK_SIZE;
-	}
-
-	if (v_len > 0) {
-		ZERO_STRUCT(ctx->B_i);
-		memcpy(ctx->B_i, v, v_len);
-		ctx->B_i_ofs += v_len;
-		*remain -= v_len;
-		v = NULL;
-		v_len = 0;
-	}
-
-	if (*remain > 0) {
-		return;
-	}
-
-	if (ctx->B_i_ofs > 0) {
-		aes_block_xor(ctx->X_i, ctx->B_i, ctx->B_i);
-		AES_encrypt(ctx->B_i, ctx->X_i, &ctx->aes_key);
-		ctx->B_i_ofs = 0;
-	}
-}
-
-static inline void aes_ccm_128_S_i(struct aes_ccm_128_context *ctx,
-				   uint8_t S_i[AES_BLOCK_SIZE],
-				   size_t i)
-{
-	RSIVAL(ctx->A_i, (AES_BLOCK_SIZE - AES_CCM_128_L), i);
-	AES_encrypt(ctx->A_i, S_i, &ctx->aes_key);
-}
-
-void aes_ccm_128_crypt(struct aes_ccm_128_context *ctx,
-		       uint8_t *m, size_t m_len)
-{
-	while (m_len > 0) {
-		if (ctx->S_i_ofs == AES_BLOCK_SIZE) {
-			ctx->S_i_ctr += 1;
-			aes_ccm_128_S_i(ctx, ctx->S_i, ctx->S_i_ctr);
-			ctx->S_i_ofs = 0;
-		}
-
-		if (likely(ctx->S_i_ofs == 0 && m_len >= AES_BLOCK_SIZE)) {
-			aes_block_xor(m, ctx->S_i, m);
-			m += AES_BLOCK_SIZE;
-			m_len -= AES_BLOCK_SIZE;
-			ctx->S_i_ctr += 1;
-			aes_ccm_128_S_i(ctx, ctx->S_i, ctx->S_i_ctr);
-			continue;
-		}
-
-		m[0] ^= ctx->S_i[ctx->S_i_ofs];
-		m += 1;
-		m_len -= 1;
-		ctx->S_i_ofs += 1;
-	}
-}
-
-void aes_ccm_128_digest(struct aes_ccm_128_context *ctx,
-			uint8_t digest[AES_BLOCK_SIZE])
-{
-	if (unlikely(ctx->a_remain != 0)) {
-		abort();
-	}
-	if (unlikely(ctx->m_remain != 0)) {
-		abort();
-	}
-
-	/* prepare S_0 */
-	aes_ccm_128_S_i(ctx, ctx->S_i, 0);
-
-	/*
-	 * note X_i is T here
-	 */
-	aes_block_xor(ctx->X_i, ctx->S_i, digest);
-
-	ZERO_STRUCTP(ctx);
-}
diff --git a/lib/crypto/aes_ccm_128.h b/lib/crypto/aes_ccm_128.h
deleted file mode 100644
index 1382ee704b9..00000000000
--- a/lib/crypto/aes_ccm_128.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
-   AES-CCM-128 (rfc 3610)
-
-   Copyright (C) Stefan Metzmacher 2012
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef LIB_CRYPTO_AES_CCM_128_H
-#define LIB_CRYPTO_AES_CCM_128_H
-
-#define AES_CCM_128_M 16
-#define AES_CCM_128_L 4
-#define AES_CCM_128_NONCE_SIZE (15 - AES_CCM_128_L)
-
-struct aes_ccm_128_context {
-	AES_KEY aes_key;
-
-	uint8_t nonce[AES_CCM_128_NONCE_SIZE];
-
-	size_t a_remain;
-	size_t m_remain;
-
-	uint64_t __align;
-
-	uint8_t X_i[AES_BLOCK_SIZE];
-	uint8_t B_i[AES_BLOCK_SIZE];
-	uint8_t A_i[AES_BLOCK_SIZE];
-	uint8_t S_i[AES_BLOCK_SIZE];
-
-	size_t B_i_ofs;
-	size_t S_i_ofs;
-	size_t S_i_ctr;
-};
-
-void aes_ccm_128_init(struct aes_ccm_128_context *ctx,
-		      const uint8_t K[AES_BLOCK_SIZE],
-		      const uint8_t N[AES_CCM_128_NONCE_SIZE],
-		      size_t a_total, size_t m_total);
-void aes_ccm_128_update(struct aes_ccm_128_context *ctx,
-			const uint8_t *v, size_t v_len);
-void aes_ccm_128_crypt(struct aes_ccm_128_context *ctx,
-			 uint8_t *m, size_t m_len);
-void aes_ccm_128_digest(struct aes_ccm_128_context *ctx,
-			uint8_t digest[AES_BLOCK_SIZE]);
-
-#endif /* LIB_CRYPTO_AES_CCM_128_H */
diff --git a/lib/crypto/aes_ccm_128_test.c b/lib/crypto/aes_ccm_128_test.c
deleted file mode 100644
index 67745e3e1ae..00000000000
--- a/lib/crypto/aes_ccm_128_test.c
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
-   AES-CCM-128 tests
-
-   Copyright (C) Stefan Metzmacher 2015
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-#include "replace.h"
-#include "../lib/util/samba_util.h"
-#include "lib/crypto/aes.h"
-#include "lib/crypto/aes_ccm_128.h"
-#include "lib/crypto/aes_test.h"
-
-#ifndef AES_CCM_128_ONLY_TESTVECTORS
-struct torture_context;
-bool torture_local_crypto_aes_ccm_128(struct torture_context *torture);
-
-/*
- This uses our own test values as we rely on a 11 byte nonce
- and the values from rfc rfc3610 use 13 byte nonce.
-*/
-bool torture_local_crypto_aes_ccm_128(struct torture_context *tctx)
-{
-	bool ret = true;
-	uint32_t i;
-	struct aes_mode_testvector testarray[] = {
-#endif /* AES_CCM_128_ONLY_TESTVECTORS */
-#define AES_CCM_128_TESTVECTOR(_k, _n, _a, _p, _c, _t) \
-	AES_MODE_TESTVECTOR(aes_ccm_128, _k, _n, _a, _p, _c, _t)
-
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"8BF9FBC2B8149484FF11AB1F3A544FF6",
-		/* N */
-		"010000000000000077F7A8",
-		/* A */
-		"010000000000000077F7A80000000000"
-		"A8000000000001004100002C00980000",
-		/* P */
-		"FE534D4240000100000000000B00811F"
-		"00000000000000000600000000000000"
-		"00000000010000004100002C00980000"
-		"00000000000000000000000000000000"
-		"3900000094010600FFFFFFFFFFFFFFFF"
-		"FFFFFFFFFFFFFFFF7800000030000000"
-		"000000007800000000000000FFFF0000"
-		"0100000000000000"
-		"03005C003100370032002E0033003100"
-		"2E0039002E003100380033005C006E00"
-		"650074006C006F0067006F006E000000",
-		/* C */
-		"25985364BF9AF90EB0B9C8FB55B7C446"
-		"780F310F1EC4677726BFBF34E38E6408"
-		"057EE228814F11CBAAB794A79F7A1F78"
-		"2DE73B7477985360A02D35A7A347ABF7"
-		"9F18DD8687767423BB08F18642B6EFEE"
-		"8B1543D83091AF5952F58BB4BD89FF6B"
-		"0206E7170481C7BC61F06653D0CF10F7"
-		"C78380389382C276"
-		"7B8BF34D687A5C3D4F783F926F7755C0"
-		"2D44C30848C69CFDD8E54395F1881611"
-		"E5502285870A7179068923105190C837",
-		/* T */
-		"3C11F652F8EA5600C8607D2E0FEAFD42"
-	),
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"f9fdca4ac64fe7f014de0f43039c7571",
-		/* N */
-		"5a8aa485c316e947125478",
-		/* A */
-		"3796cf51b8726652a4204733b8fbb047"
-		"cf00fb91a9837e22ec22b1a268f88e2c",
-		/* P */
-		"a265480ca88d5f536db0dc6abc40faf0"
-		"d05be7a9669777682345647586786983",
-		/* C */
-		"65F8D8422006FB77FB7CCEFDFFF93729"
-		"B3EFCB06A0FAF3A2ABAB485723373F53",
-		/* T */
-		"2C62BD82AD231887A7B326E1E045BC91"
-	),
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"197afb02ffbd8f699dacae87094d5243",
-		/* N */
-		"5a8aa485c316e947125478",
-		/* A */
-		"",
-		/* P */
-		"3796cf51b8726652a4204733b8fbb047"
-		"cf00fb91a9837e22",
-		/* C */
-		"CA53910394115C5DAB5D7250F04D6A27"
-		"2BCFA4329528F3AC",
-		/* T */
-		"38E3A318F9BA88D4DD2FAF3521820001"
-	),
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"90929a4b0ac65b350ad1591611fe4829",
-		/* N */
-		"5a8aa485c316e9403aff85",
-		/* A */
-		"",
-		/* P */
-		"a16a2e741f1cd9717285b6d882c1fc53"
-		"655e9773761ad697",
-		/* C */
-		"ACA5E98D2784D131AE76E3C8BF9C3988"
-		"35C0206C71893F26",
-		/* T */
-		"AE67C0EA38C5383BFDC7967F4E9D1678"
-	),
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"f9fdca4ac64fe7f014de0f43039c7571",
-		/* N */
-		"5a8aa485c316e947125478",
-		/* A */
-		"3796cf51b8726652a4204733b8fbb047"
-		"cf00fb91a9837e22ec22b1a268f88e2c",
-		/* P */
-		"a265480ca88d5f536db0dc6abc40faf0"
-		"d05be7a966977768",
-		/* C */
-		"65F8D8422006FB77FB7CCEFDFFF93729"
-		"B3EFCB06A0FAF3A2",
-		/* T */
-		"03C6E244586AFAB9B60D9F6DBDF7EB1A"
-	),
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"26511fb51fcfa75cb4b44da75a6e5a0e",
-		/* N */
-		"5a8aa485c316e9403aff85",
-		/* A */
-		"a16a2e741f1cd9717285b6d882c1fc53"
-		"655e9773761ad697a7ee6410184c7982",
-		/* P */
-		"8739b4bea1a099fe547499cbc6d1b13d"
-		"849b8084c9b6acc5",
-		/* C */
-		"D31F9FC23674D5272125375E0A2F5365"
-		"41B1FAF1DD68C819",
-		/* T */
-		"4F315233A76C4DD99972561C5158AB3B"
-	),
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"f9fdca4ac64fe7f014de0f43039c7571",
-		/* N */
-		"5a8aa485c316e947125478",
-		/* A */
-		"3796cf51b8726652a4204733b8fbb047"
-		"cf00fb91a9837e22ec22b1a268",
-		/* P */
-		"a265480ca88d5f536db0dc6abc40faf0"
-		"d05be7a9669777682376345745",
-		/* C */
-		"65F8D8422006FB77FB7CCEFDFFF93729"
-		"B3EFCB06A0FAF3A2AB981875E0",
-		/* T */
-		"EA93AAEDA607226E9E79D2EE5C4B62F8"
-	),
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"26511fb51fcfa75cb4b44da75a6e5a0e",
-		/* N */
-		"5a8aa485c316e9403aff85",
-		/* A */
-		"a16a2e741f1cd9717285b6d882c1fc53"
-		"65",
-		/* P */
-		"8739b4bea1a099fe547499cbc6d1b13d"
-		"84",
-		/* C */
-		"D31F9FC23674D5272125375E0A2F5365"
-		"41",
-		/* T */
-		"036F58DA2372B29BD0E01C58A0E7F9EE"
-	),
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"00000000000000000000000000000000",
-		/* N */
-		"0000000000000000000000",
-		/* A */
-		"",
-		/* P */
-		"00",
-		/* C */
-		"2E",
-		/* T */
-		"61787D2C432A58293B73D01154E61B6B"
-	),
-	AES_CCM_128_TESTVECTOR(
-		/* K */
-		"00000000000000000000000000000000",
-		/* N */
-		"0000000000000000000000",
-		/* A */
-		"00",
-		/* P */
-		"00",
-		/* C */
-		"2E",
-		/* T */
-		"E4284A0E813F0FFA146CF59F9ADAFBD7"
-	),
-#ifndef AES_CCM_128_ONLY_TESTVECTORS
-	};
-
-	for (i=0; i < ARRAY_SIZE(testarray); i++) {
-		struct aes_ccm_128_context ctx;
-		uint8_t T[AES_BLOCK_SIZE];
-		DATA_BLOB _T = data_blob_const(T, sizeof(T));
-		DATA_BLOB C;
-		int e;
-
-		C = data_blob_dup_talloc(tctx, testarray[i].P);
-
-		aes_ccm_128_init(&ctx, testarray[i].K.data, testarray[i].N.data,
-				 testarray[i].A.length, testarray[i].P.length);
-		aes_ccm_128_update(&ctx,
-				   testarray[i].A.data,
-				   testarray[i].A.length);
-		aes_ccm_128_update(&ctx, C.data, C.length);
-		aes_ccm_128_crypt(&ctx, C.data, C.length);
-		aes_ccm_128_digest(&ctx, T);
-
-		e = memcmp(testarray[i].T.data, T, sizeof(T));
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], NULL, &C, &_T);
-			ret = false;
-			goto fail;
-		}
-
-		e = memcmp(testarray[i].C.data, C.data, C.length);
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], NULL, &C, &_T);
-			ret = false;
-			goto fail;
-		}
-	}
-
-	for (i=0; i < ARRAY_SIZE(testarray); i++) {
-		struct aes_ccm_128_context ctx;
-		uint8_t T[AES_BLOCK_SIZE];
-		DATA_BLOB _T = data_blob_const(T, sizeof(T));
-		DATA_BLOB C;
-		int e;
-		size_t j;
-
-		C = data_blob_dup_talloc(tctx, testarray[i].P);
-
-		aes_ccm_128_init(&ctx, testarray[i].K.data, testarray[i].N.data,
-				 testarray[i].A.length, testarray[i].P.length);
-		for (j=0; j < testarray[i].A.length; j++) {
-			aes_ccm_128_update(&ctx, NULL, 0);
-			aes_ccm_128_update(&ctx, &testarray[i].A.data[j], 1);
-			aes_ccm_128_update(&ctx, NULL, 0);
-		}
-		for (j=0; j < C.length; j++) {
-			aes_ccm_128_crypt(&ctx, NULL, 0);
-			aes_ccm_128_update(&ctx, NULL, 0);
-			aes_ccm_128_update(&ctx, &C.data[j], 1);
-			aes_ccm_128_crypt(&ctx, &C.data[j], 1);
-			aes_ccm_128_crypt(&ctx, NULL, 0);
-			aes_ccm_128_update(&ctx, NULL, 0);
-		}
-		aes_ccm_128_digest(&ctx, T);
-
-		e = memcmp(testarray[i].T.data, T, sizeof(T));
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], NULL, &C, &_T);
-			ret = false;
-			goto fail;
-		}
-
-		e = memcmp(testarray[i].C.data, C.data, C.length);
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], NULL, &C, &_T);
-			ret = false;
-			goto fail;
-		}
-	}
-
-	for (i=0; i < ARRAY_SIZE(testarray); i++) {
-		struct aes_ccm_128_context ctx;
-		uint8_t T[AES_BLOCK_SIZE];
-		DATA_BLOB _T = data_blob_const(T, sizeof(T));
-		DATA_BLOB P;
-		int e;
-		size_t j;
-
-		P = data_blob_dup_talloc(tctx, testarray[i].C);
-
-		aes_ccm_128_init(&ctx, testarray[i].K.data, testarray[i].N.data,
-				 testarray[i].A.length, testarray[i].P.length);
-		for (j=0; j < testarray[i].A.length; j++) {
-			aes_ccm_128_update(&ctx, NULL, 0);
-			aes_ccm_128_update(&ctx, &testarray[i].A.data[j], 1);
-			aes_ccm_128_update(&ctx, NULL, 0);
-		}
-		for (j=0; j < P.length; j++) {
-			aes_ccm_128_crypt(&ctx, NULL, 0);
-			aes_ccm_128_update(&ctx, NULL, 0);
-			aes_ccm_128_crypt(&ctx, &P.data[j], 1);
-			aes_ccm_128_update(&ctx, &P.data[j], 1);
-			aes_ccm_128_crypt(&ctx, NULL, 0);
-			aes_ccm_128_update(&ctx, NULL, 0);
-		}
-		aes_ccm_128_digest(&ctx, T);
-
-		e = memcmp(testarray[i].T.data, T, sizeof(T));
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], &P, NULL, &_T);
-			ret = false;
-			goto fail;
-		}
-
-		e = memcmp(testarray[i].P.data, P.data, P.length);
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], &P, NULL, &_T);
-			ret = false;
-			goto fail;
-		}
-	}
-
-	for (i=0; i < ARRAY_SIZE(testarray); i++) {
-		struct aes_ccm_128_context ctx;
-		uint8_t T[AES_BLOCK_SIZE];
-		DATA_BLOB _T = data_blob_const(T, sizeof(T));
-		DATA_BLOB P;
-		int e;
-
-		P = data_blob_dup_talloc(tctx, testarray[i].C);
-
-		aes_ccm_128_init(&ctx, testarray[i].K.data, testarray[i].N.data,
-				 testarray[i].A.length, testarray[i].P.length);
-		aes_ccm_128_update(&ctx, testarray[i].A.data, testarray[i].A.length);
-		aes_ccm_128_crypt(&ctx, P.data, P.length);
-		aes_ccm_128_update(&ctx, P.data, P.length);
-		aes_ccm_128_digest(&ctx, T);
-
-		e = memcmp(testarray[i].T.data, T, sizeof(T));
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], &P, NULL, &_T);
-			ret = false;
-			goto fail;
-		}
-
-		e = memcmp(testarray[i].P.data, P.data, P.length);
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], &P, NULL, &_T);
-			ret = false;
-			goto fail;
-		}
-	}
-
- fail:
-	return ret;
-}
-
-#endif /* AES_CCM_128_ONLY_TESTVECTORS */
diff --git a/lib/crypto/aes_gcm_128.c b/lib/crypto/aes_gcm_128.c
deleted file mode 100644
index 6b5a385cbd8..00000000000
--- a/lib/crypto/aes_gcm_128.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
-   AES-GCM-128
-
-   Copyright (C) Stefan Metzmacher 2014
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "replace.h"
-#include "lib/crypto/aes.h"
-#include "lib/crypto/aes_gcm_128.h"
-#include "lib/util/byteorder.h"
-
-static inline void aes_gcm_128_inc32(uint8_t inout[AES_BLOCK_SIZE])
-{
-	uint32_t v;
-
-	v = RIVAL(inout, AES_BLOCK_SIZE - 4);
-	v += 1;
-	RSIVAL(inout, AES_BLOCK_SIZE - 4, v);
-}
-
-static inline void aes_gcm_128_mul(const uint8_t x[AES_BLOCK_SIZE],
-				   const uint8_t y[AES_BLOCK_SIZE],
-				   uint8_t v[AES_BLOCK_SIZE],
-				   uint8_t z[AES_BLOCK_SIZE])
-{
-	uint8_t i;
-	/* 11100001 || 0^120 */
-	static const uint8_t r[AES_BLOCK_SIZE] = {
-		0xE1, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00,
-	};
-
-	memset(z, 0, AES_BLOCK_SIZE);
-	memcpy(v, y, AES_BLOCK_SIZE);
-
-	for (i = 0; i < AES_BLOCK_SIZE; i++) {
-		uint8_t mask;
-		for (mask = 0x80; mask != 0 ; mask >>= 1) {
-			uint8_t v_lsb = v[AES_BLOCK_SIZE-1] & 1;
-			if (x[i] & mask) {
-				aes_block_xor(z, v, z);
-			}
-
-			aes_block_rshift(v, v);
-			if (v_lsb != 0) {
-				aes_block_xor(v, r, v);
-			}
-		}
-	}
-}
-
-static inline void aes_gcm_128_ghash_block(struct aes_gcm_128_context *ctx,
-					   const uint8_t in[AES_BLOCK_SIZE])
-{
-	aes_block_xor(ctx->Y, in, ctx->y.block);
-	aes_gcm_128_mul(ctx->y.block, ctx->H, ctx->v.block, ctx->Y);
-}
-
-void aes_gcm_128_init(struct aes_gcm_128_context *ctx,
-		      const uint8_t K[AES_BLOCK_SIZE],
-		      const uint8_t IV[AES_GCM_128_IV_SIZE])
-{
-	ZERO_STRUCTP(ctx);
-
-	AES_set_encrypt_key(K, 128, &ctx->aes_key);
-
-	/*
-	 * Step 1: generate H (ctx->Y is the zero block here)
-	 */
-	AES_encrypt(ctx->Y, ctx->H, &ctx->aes_key);
-
-	/*
-	 * Step 2: generate J0
-	 */
-	memcpy(ctx->J0, IV, AES_GCM_128_IV_SIZE);
-	aes_gcm_128_inc32(ctx->J0);
-
-	/*
-	 * We need to prepare CB with J0.
-	 */
-	memcpy(ctx->CB, ctx->J0, AES_BLOCK_SIZE);
-	ctx->c.ofs = AES_BLOCK_SIZE;
-}
-
-static inline void aes_gcm_128_update_tmp(struct aes_gcm_128_context *ctx,
-					  struct aes_gcm_128_tmp *tmp,
-					  const uint8_t *v, size_t v_len)
-{
-	tmp->total += v_len;
-
-	if (tmp->ofs > 0) {
-		size_t copy = MIN(AES_BLOCK_SIZE - tmp->ofs, v_len);
-
-		memcpy(tmp->block + tmp->ofs, v, copy);
-		tmp->ofs += copy;
-		v += copy;
-		v_len -= copy;
-	}
-
-	if (tmp->ofs == AES_BLOCK_SIZE) {
-		aes_gcm_128_ghash_block(ctx, tmp->block);
-		tmp->ofs = 0;
-	}
-
-	while (v_len >= AES_BLOCK_SIZE) {
-		aes_gcm_128_ghash_block(ctx, v);
-		v += AES_BLOCK_SIZE;
-		v_len -= AES_BLOCK_SIZE;
-	}
-
-	if (v_len == 0) {
-		return;
-	}
-
-	ZERO_STRUCT(tmp->block);
-	memcpy(tmp->block, v, v_len);
-	tmp->ofs = v_len;
-}
-
-void aes_gcm_128_updateA(struct aes_gcm_128_context *ctx,
-			 const uint8_t *a, size_t a_len)
-{
-	aes_gcm_128_update_tmp(ctx, &ctx->A, a, a_len);
-}
-
-void aes_gcm_128_updateC(struct aes_gcm_128_context *ctx,
-			 const uint8_t *c, size_t c_len)
-{
-	if (ctx->A.ofs > 0) {
-		aes_gcm_128_ghash_block(ctx, ctx->A.block);
-		ctx->A.ofs = 0;
-	}
-
-	aes_gcm_128_update_tmp(ctx, &ctx->C, c, c_len);
-}
-
-static inline void aes_gcm_128_crypt_tmp(struct aes_gcm_128_context *ctx,
-					 struct aes_gcm_128_tmp *tmp,
-					 uint8_t *m, size_t m_len)
-{
-	tmp->total += m_len;
-
-	while (m_len > 0) {
-		if (tmp->ofs == AES_BLOCK_SIZE) {
-			aes_gcm_128_inc32(ctx->CB);
-			AES_encrypt(ctx->CB, tmp->block, &ctx->aes_key);
-			tmp->ofs = 0;
-		}
-
-		if (likely(tmp->ofs == 0 && m_len >= AES_BLOCK_SIZE)) {
-			aes_block_xor(m, tmp->block, m);
-			m += AES_BLOCK_SIZE;
-			m_len -= AES_BLOCK_SIZE;
-			aes_gcm_128_inc32(ctx->CB);
-			AES_encrypt(ctx->CB, tmp->block, &ctx->aes_key);
-			continue;
-		}
-
-		m[0] ^= tmp->block[tmp->ofs];
-		m += 1;
-		m_len -= 1;
-		tmp->ofs += 1;
-	}
-}
-
-void aes_gcm_128_crypt(struct aes_gcm_128_context *ctx,
-		       uint8_t *m, size_t m_len)
-{
-	aes_gcm_128_crypt_tmp(ctx, &ctx->c, m, m_len);
-}
-
-void aes_gcm_128_digest(struct aes_gcm_128_context *ctx,
-			uint8_t T[AES_BLOCK_SIZE])
-{
-	if (ctx->A.ofs > 0) {
-		aes_gcm_128_ghash_block(ctx, ctx->A.block);
-		ctx->A.ofs = 0;
-	}
-
-	if (ctx->C.ofs > 0) {
-		aes_gcm_128_ghash_block(ctx, ctx->C.block);
-		ctx->C.ofs = 0;
-	}
-
-	RSBVAL(ctx->AC, 0, ctx->A.total * 8);
-	RSBVAL(ctx->AC, 8, ctx->C.total * 8);
-	aes_gcm_128_ghash_block(ctx, ctx->AC);
-
-	AES_encrypt(ctx->J0, ctx->c.block, &ctx->aes_key);
-	aes_block_xor(ctx->c.block, ctx->Y, T);
-
-	ZERO_STRUCTP(ctx);
-}
diff --git a/lib/crypto/aes_gcm_128.h b/lib/crypto/aes_gcm_128.h
deleted file mode 100644
index 8df11c2f6bd..00000000000
--- a/lib/crypto/aes_gcm_128.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-   AES-GCM-128
-
-   Copyright (C) Stefan Metzmacher 2014
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef LIB_CRYPTO_AES_GCM_128_H
-#define LIB_CRYPTO_AES_GCM_128_H
-
-#define AES_GCM_128_IV_SIZE (12)
-
-struct aes_gcm_128_context {
-	AES_KEY aes_key;
-
-	uint64_t __align;
-
-	struct aes_gcm_128_tmp {
-		size_t ofs;
-		size_t total;
-		uint8_t block[AES_BLOCK_SIZE];
-	} A, C, c, v, y;
-
-	uint8_t H[AES_BLOCK_SIZE];
-	uint8_t J0[AES_BLOCK_SIZE];
-	uint8_t CB[AES_BLOCK_SIZE];
-	uint8_t Y[AES_BLOCK_SIZE];
-	uint8_t AC[AES_BLOCK_SIZE];
-};
-
-void aes_gcm_128_init(struct aes_gcm_128_context *ctx,
-		      const uint8_t K[AES_BLOCK_SIZE],
-		      const uint8_t IV[AES_GCM_128_IV_SIZE]);
-void aes_gcm_128_updateA(struct aes_gcm_128_context *ctx,
-			 const uint8_t *a, size_t a_len);
-void aes_gcm_128_updateC(struct aes_gcm_128_context *ctx,
-			 const uint8_t *c, size_t c_len);
-void aes_gcm_128_crypt(struct aes_gcm_128_context *ctx,
-		       uint8_t *m, size_t m_len);
-void aes_gcm_128_digest(struct aes_gcm_128_context *ctx,
-			uint8_t T[AES_BLOCK_SIZE]);
-
-#endif /* LIB_CRYPTO_AES_GCM_128_H */
diff --git a/lib/crypto/aes_gcm_128_test.c b/lib/crypto/aes_gcm_128_test.c
deleted file mode 100644
index fdd87ff532d..00000000000
--- a/lib/crypto/aes_gcm_128_test.c
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
-   AES-GCM-128 tests
-
-   Copyright (C) Stefan Metzmacher 2014
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-#include "replace.h"
-#include "../lib/util/samba_util.h"
-#include "lib/crypto/aes.h"
-#include "lib/crypto/aes_gcm_128.h"
-#include "lib/crypto/aes_test.h"
-
-#ifndef AES_GCM_128_ONLY_TESTVECTORS
-struct torture_context;
-bool torture_local_crypto_aes_gcm_128(struct torture_context *tctx);
-
-/*
- This uses the test values from ...
-*/
-bool torture_local_crypto_aes_gcm_128(struct torture_context *tctx)
-{
-	bool ret = true;
-	uint32_t i;
-	struct aes_mode_testvector testarray[] = {
-#endif /* AES_GCM_128_ONLY_TESTVECTORS */
-#define AES_GCM_128_TESTVECTOR(_k, _n, _a, _p, _c, _t) \
-	AES_MODE_TESTVECTOR(aes_gcm_128, _k, _n, _a, _p, _c, _t)
-
-	AES_GCM_128_TESTVECTOR(
-		/* K */
-		"8BF9FBC2B8149484FF11AB1F3A544FF6",
-		/* N */
-		"010000000000000077F7A8FF",
-		/* A */
-		"010000000000000077F7A80000000000"
-		"A8000000000001004100002C00980000",
-		/* P */
-		"FE534D4240000100000000000B00811F"
-		"00000000000000000600000000000000"
-		"00000000010000004100002C00980000"
-		"00000000000000000000000000000000"
-		"3900000094010600FFFFFFFFFFFFFFFF"
-		"FFFFFFFFFFFFFFFF7800000030000000"
-		"000000007800000000000000FFFF0000"
-		"0100000000000000"
-		"03005C003100370032002E0033003100"
-		"2E0039002E003100380033005C006E00"
-		"650074006C006F0067006F006E000000",
-		/* C */
-		"863C07C1FBFA82D741A080C97DF52CFF"
-		"432A63A37E5ACFA3865AE4E6E422D502"
-		"FA7C6FBB9A7418F28C43F00A3869F687"
-		"257CA665E25E62A0F458C42AA9E95DC4"
-		"6CB351A0A497FABB7DCE58FEE5B20B08"
-		"522E0E701B112FB93B36E7A0FB084D35"
-		"62C0F3FDF0421079DD96BBCCA40949B3"
-		"A7FC1AA635A72384"
-		"2037DE3CA6385465D1884B29D7140790"
-		"88AD3E770E2528D527B302536B7E5B1B"
-		"430E048230AFE785DB89F4D87FC1F816",
-		/* T */
-		"BC9B5871EBFA89ADE21439ACDCD65D22"
-	),
-	AES_GCM_128_TESTVECTOR(
-		/* K */
-		"00000000000000000000000000000000",
-		/* N */
-		"000000000000000000000000",
-		/* A */
-		"",
-		/* P */
-		"",
-		/* C */
-		"",
-		/* T */
-		"58e2fccefa7e3061367f1d57a4e7455a"
-	),
-	AES_GCM_128_TESTVECTOR(
-		/* K */
-		"00000000000000000000000000000000",
-		/* N */
-		"000000000000000000000000",
-		/* A */
-		"",
-		/* P */
-		"00000000000000000000000000000000",
-		/* C */
-		"0388dace60b6a392f328c2b971b2fe78",
-		/* T */
-		"ab6e47d42cec13bdf53a67b21257bddf"
-	),
-	AES_GCM_128_TESTVECTOR(
-		/* K */
-		"feffe9928665731c6d6a8f9467308308",
-		/* N */
-		"cafebabefacedbaddecaf888",
-		/* A */
-		"",
-		/* P */
-		"d9313225f88406e5a55909c5aff5269a"
-		"86a7a9531534f7da2e4c303d8a318a72"
-		"1c3c0c95956809532fcf0e2449a6b525"
-		"b16aedf5aa0de657ba637b391aafd255",
-		/* C */
-		"42831ec2217774244b7221b784d0d49c"
-		"e3aa212f2c02a4e035c17e2329aca12e"
-		"21d514b25466931c7d8f6a5aac84aa05"
-		"1ba30b396a0aac973d58e091473f5985",
-		/* T */
-		"4d5c2af327cd64a62cf35abd2ba6fab4"
-	),
-	AES_GCM_128_TESTVECTOR(
-		/* K */
-		"feffe9928665731c6d6a8f9467308308",
-		/* N */
-		"cafebabefacedbaddecaf888",
-		/* A */
-		"feedfacedeadbeeffeedfacedeadbeef"
-		"abaddad2",
-		/* P */
-		"d9313225f88406e5a55909c5aff5269a"
-		"86a7a9531534f7da2e4c303d8a318a72"
-		"1c3c0c95956809532fcf0e2449a6b525"
-		"b16aedf5aa0de657ba637b39",
-		/* C */
-		"42831ec2217774244b7221b784d0d49c"
-		"e3aa212f2c02a4e035c17e2329aca12e"
-		"21d514b25466931c7d8f6a5aac84aa05"
-		"1ba30b396a0aac973d58e091",
-		/* T */
-		"5bc94fbc3221a5db94fae95ae7121a47"
-	),
-#ifndef AES_GCM_128_ONLY_TESTVECTORS
-	};
-
-	for (i=0; i < ARRAY_SIZE(testarray); i++) {
-		struct aes_gcm_128_context ctx;
-		uint8_t T[AES_BLOCK_SIZE];
-		DATA_BLOB _T = data_blob_const(T, sizeof(T));
-		DATA_BLOB C;
-		int e;
-
-		C = data_blob_dup_talloc(tctx, testarray[i].P);
-
-		aes_gcm_128_init(&ctx, testarray[i].K.data, testarray[i].N.data);
-		aes_gcm_128_updateA(&ctx,
-				    testarray[i].A.data,
-				    testarray[i].A.length);
-		aes_gcm_128_crypt(&ctx, C.data, C.length);
-		aes_gcm_128_updateC(&ctx, C.data, C.length);
-		aes_gcm_128_digest(&ctx, T);
-
-		e = memcmp(testarray[i].T.data, T, sizeof(T));
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], NULL, &C, &_T);
-			ret = false;
-			goto fail;
-		}
-
-		e = memcmp(testarray[i].C.data, C.data, C.length);
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], NULL, &C, &_T);
-			ret = false;
-			goto fail;
-		}
-	}
-
-	for (i=0; i < ARRAY_SIZE(testarray); i++) {
-		struct aes_gcm_128_context ctx;
-		uint8_t T[AES_BLOCK_SIZE];
-		DATA_BLOB _T = data_blob_const(T, sizeof(T));
-		DATA_BLOB C;
-		int e;
-		size_t j;
-
-		C = data_blob_dup_talloc(tctx, testarray[i].P);
-
-		aes_gcm_128_init(&ctx, testarray[i].K.data, testarray[i].N.data);
-		for (j=0; j < testarray[i].A.length; j++) {
-			aes_gcm_128_updateA(&ctx, NULL, 0);
-			aes_gcm_128_updateA(&ctx, &testarray[i].A.data[j], 1);
-			aes_gcm_128_updateA(&ctx, NULL, 0);
-		}
-		for (j=0; j < C.length; j++) {
-			aes_gcm_128_crypt(&ctx, NULL, 0);
-			aes_gcm_128_updateC(&ctx, NULL, 0);
-			aes_gcm_128_crypt(&ctx, &C.data[j], 1);
-			aes_gcm_128_updateC(&ctx, &C.data[j], 1);
-			aes_gcm_128_crypt(&ctx, NULL, 0);
-			aes_gcm_128_updateC(&ctx, NULL, 0);
-		}
-		aes_gcm_128_digest(&ctx, T);
-
-		e = memcmp(testarray[i].T.data, T, sizeof(T));
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], NULL, &C, &_T);
-			ret = false;
-			goto fail;
-		}
-
-		e = memcmp(testarray[i].C.data, C.data, C.length);
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], NULL, &C, &_T);
-			ret = false;
-			goto fail;
-		}
-	}
-
-	for (i=0; i < ARRAY_SIZE(testarray); i++) {
-		struct aes_gcm_128_context ctx;
-		uint8_t T[AES_BLOCK_SIZE];
-		DATA_BLOB _T = data_blob_const(T, sizeof(T));
-		DATA_BLOB P;
-		int e;
-		size_t j;
-
-		P = data_blob_dup_talloc(tctx, testarray[i].C);
-
-		aes_gcm_128_init(&ctx, testarray[i].K.data, testarray[i].N.data);
-		for (j=0; j < testarray[i].A.length; j++) {
-			aes_gcm_128_updateA(&ctx, NULL, 0);
-			aes_gcm_128_updateA(&ctx, &testarray[i].A.data[j], 1);
-			aes_gcm_128_updateA(&ctx, NULL, 0);
-		}
-		for (j=0; j < P.length; j++) {
-			aes_gcm_128_updateC(&ctx, NULL, 0);
-			aes_gcm_128_crypt(&ctx, NULL, 0);
-			aes_gcm_128_updateC(&ctx, &P.data[j], 1);
-			aes_gcm_128_crypt(&ctx, &P.data[j], 1);
-			aes_gcm_128_updateC(&ctx, NULL, 0);
-			aes_gcm_128_crypt(&ctx, NULL, 0);
-		}
-		aes_gcm_128_digest(&ctx, T);
-
-		e = memcmp(testarray[i].T.data, T, sizeof(T));
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], &P, NULL, &_T);
-			ret = false;
-			goto fail;
-		}
-
-		e = memcmp(testarray[i].P.data, P.data, P.length);
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], &P, NULL, &_T);
-			ret = false;
-			goto fail;
-		}
-	}
-
-	for (i=0; i < ARRAY_SIZE(testarray); i++) {
-		struct aes_gcm_128_context ctx;
-		uint8_t T[AES_BLOCK_SIZE];
-		DATA_BLOB _T = data_blob_const(T, sizeof(T));
-		DATA_BLOB P;
-		int e;
-
-		P = data_blob_dup_talloc(tctx, testarray[i].C);
-
-		aes_gcm_128_init(&ctx, testarray[i].K.data, testarray[i].N.data);
-		aes_gcm_128_updateA(&ctx, testarray[i].A.data, testarray[i].A.length);
-		aes_gcm_128_updateC(&ctx, P.data, P.length);
-		aes_gcm_128_crypt(&ctx, P.data, P.length);
-		aes_gcm_128_digest(&ctx, T);
-
-		e = memcmp(testarray[i].T.data, T, sizeof(T));
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], &P, NULL, &_T);
-			ret = false;
-			goto fail;
-		}
-
-		e = memcmp(testarray[i].P.data, P.data, P.length);
-		if (e != 0) {
-			aes_mode_testvector_debug(&testarray[i], &P, NULL, &_T);
-			ret = false;
-			goto fail;
-		}
-	}
-
- fail:
-	return ret;
-}
-#endif /* AES_GCM_128_ONLY_TESTVECTORS */
diff --git a/lib/crypto/crypto.h b/lib/crypto/crypto.h
index d7409f9a46d..d8f13f8fadd 100644
--- a/lib/crypto/crypto.h
+++ b/lib/crypto/crypto.h
@@ -23,7 +23,5 @@
 #include "../lib/crypto/md4.h"
 #include "../lib/crypto/aes.h"
 #include "../lib/crypto/aes_cmac_128.h"
-#include "../lib/crypto/aes_ccm_128.h"
-#include "../lib/crypto/aes_gcm_128.h"
 
 #endif /* _SAMBA_CRYPTO_H_ */
diff --git a/lib/crypto/wscript_build b/lib/crypto/wscript_build
index 4f1665a7fd9..eb67af63f26 100644
--- a/lib/crypto/wscript_build
+++ b/lib/crypto/wscript_build
@@ -2,7 +2,8 @@
 
 extra_deps = ''
 
-if bld.CONFIG_SET("HAVE_AESNI_INTEL"):
+if (bld.CONFIG_SET("HAVE_AESNI_INTEL") and
+    not bld.CONFIG_SET('HAVE_GNUTLS_AES_CMAC')):
         extra_deps += ' aesni-intel'
 
 bld.SAMBA_SUBSYSTEM('GNUTLS_HELPERS',
@@ -12,17 +13,10 @@ bld.SAMBA_SUBSYSTEM('GNUTLS_HELPERS',
                     ''',
                     deps='gnutls samba-errors');
 
-bld.SAMBA_SUBSYSTEM('LIBCRYPTO_AES_CCM',
-                    source='aes_ccm_128.c',
-                    deps='talloc')
-
-bld.SAMBA_SUBSYSTEM('LIBCRYPTO_AES_GCM',
-                    source='aes_gcm_128.c',
-                    deps='talloc')
-
 bld.SAMBA_SUBSYSTEM('LIBCRYPTO_AES',
                     source='aes.c rijndael-alg-fst.c',
-                    deps='talloc')
+                    deps='talloc',
+                    enabled=not bld.CONFIG_SET('HAVE_GNUTLS_AES_CMAC'))
 
 bld.SAMBA_SUBSYSTEM('LIBCRYPTO_AES_CMAC',
                     source='aes_cmac_128.c',
@@ -36,21 +30,9 @@ bld.SAMBA_SUBSYSTEM('LIBCRYPTO',
         deps='''
              talloc
              LIBCRYPTO_AES
-             LIBCRYPTO_AES_CCM
-             LIBCRYPTO_AES_GCM
              LIBCRYPTO_AES_CMAC
              ''' + extra_deps)
 
-bld.SAMBA_SUBSYSTEM('TORTURE_LIBCRYPTO_AES_CCM',
-                    source='aes_ccm_128_test.c',
-                    autoproto='aes_ccm_test_proto.h',
-                    deps='talloc')
-
-bld.SAMBA_SUBSYSTEM('TORTURE_LIBCRYPTO_AES_GCM',
-                    source='aes_gcm_128_test.c',
-                    autoproto='aes_gcm_test_proto.h',
-                    deps='talloc')
-
 bld.SAMBA_SUBSYSTEM('TORTURE_LIBCRYPTO_AES_CMAC',
                     source='aes_cmac_128_test.c',
                     autoproto='aes_cmac_test_proto.h',
@@ -62,8 +44,6 @@ bld.SAMBA_SUBSYSTEM('TORTURE_LIBCRYPTO',
         autoproto='test_proto.h',
         deps='''
              LIBCRYPTO
-             TORTURE_LIBCRYPTO_AES_CCM
-             TORTURE_LIBCRYPTO_AES_GCM
              TORTURE_LIBCRYPTO_AES_CMAC
              ''')
 
diff --git a/lib/dbwrap/dbwrap.c b/lib/dbwrap/dbwrap.c
index 3d8d2ae78d7..baab0338088 100644
--- a/lib/dbwrap/dbwrap.c
+++ b/lib/dbwrap/dbwrap.c
@@ -79,6 +79,7 @@ TDB_DATA dbwrap_record_get_key(const struct db_record *rec)
 
 TDB_DATA dbwrap_record_get_value(const struct db_record *rec)
 {
+	SMB_ASSERT(rec->value_valid);
 	return rec->value;
 }
 
@@ -87,6 +88,12 @@ NTSTATUS dbwrap_record_storev(struct db_record *rec,
 {
 	NTSTATUS status;
 
+	/*
+	 * Invalidate before rec->storev() is called, give
+	 * rec->storev() the chance to re-validate rec->value.
+	 */
+	rec->value_valid = false;
+
 	status = rec->storev(rec, dbufs, num_dbufs, flags);
 	if (!NT_STATUS_IS_OK(status)) {
 		return status;
@@ -103,6 +110,12 @@ NTSTATUS dbwrap_record_delete(struct db_record *rec)
 {
 	NTSTATUS status;
 
+	/*
+	 * Invalidate before rec->delete_rec() is called, give
+	 * rec->delete_rec() the chance to re-validate rec->value.
+	 */
+	rec->value_valid = false;
+
 	status = rec->delete_rec(rec);
 	if (!NT_STATUS_IS_OK(status)) {
 		return status;
@@ -307,7 +320,10 @@ struct dbwrap_store_state {
 	NTSTATUS status;
 };
 
-static void dbwrap_store_fn(struct db_record *rec, void *private_data)
+static void dbwrap_store_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
 	struct dbwrap_store_state *state = private_data;
 	state->status = dbwrap_record_store(rec, state->data, state->flags);
@@ -331,7 +347,10 @@ struct dbwrap_delete_state {
 	NTSTATUS status;
 };
 
-static void dbwrap_delete_fn(struct db_record *rec, void *private_data)
+static void dbwrap_delete_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
 	struct dbwrap_delete_state *state = private_data;
 	state->status = dbwrap_record_delete(rec);
@@ -514,6 +533,7 @@ NTSTATUS dbwrap_parse_record_recv(struct tevent_req *req)
 
 NTSTATUS dbwrap_do_locked(struct db_context *db, TDB_DATA key,
 			  void (*fn)(struct db_record *rec,
+				     TDB_DATA value,
 				     void *private_data),
 			  void *private_data)
 {
@@ -542,7 +562,13 @@ NTSTATUS dbwrap_do_locked(struct db_context *db, TDB_DATA key,
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	fn(rec, private_data);
+	/*
+	 * Invalidate rec->value, nobody shall assume it's set from
+	 * within dbwrap_do_locked().
+	 */
+	rec->value_valid = false;
+
+	fn(rec, rec->value, private_data);
 
 	TALLOC_FREE(rec);
 
diff --git a/lib/dbwrap/dbwrap.h b/lib/dbwrap/dbwrap.h
index 591eac5c63a..b5a7fb315c7 100644
--- a/lib/dbwrap/dbwrap.h
+++ b/lib/dbwrap/dbwrap.h
@@ -81,6 +81,7 @@ struct db_context *dbwrap_record_get_db(struct db_record *rec);
 
 NTSTATUS dbwrap_do_locked(struct db_context *db, TDB_DATA key,
 			  void (*fn)(struct db_record *rec,
+				     TDB_DATA value,
 				     void *private_data),
 			  void *private_data);
 
diff --git a/lib/dbwrap/dbwrap_private.h b/lib/dbwrap/dbwrap_private.h
index b548168b9a9..8a1f03c7bec 100644
--- a/lib/dbwrap/dbwrap_private.h
+++ b/lib/dbwrap/dbwrap_private.h
@@ -29,6 +29,7 @@ struct tevent_req;
 struct db_record {
 	struct db_context *db;
 	TDB_DATA key, value;
+	bool value_valid;
 	NTSTATUS (*storev)(struct db_record *rec, const TDB_DATA *dbufs,
 			   int num_dbufs, int flag);
 	NTSTATUS (*delete_rec)(struct db_record *rec);
@@ -70,6 +71,7 @@ struct db_context {
 	NTSTATUS (*parse_record_recv)(struct tevent_req *req);
 	NTSTATUS (*do_locked)(struct db_context *db, TDB_DATA key,
 			      void (*fn)(struct db_record *rec,
+					 TDB_DATA value,
 					 void *private_data),
 			      void *private_data);
 	int (*exists)(struct db_context *db,TDB_DATA key);
diff --git a/lib/dbwrap/dbwrap_rbt.c b/lib/dbwrap/dbwrap_rbt.c
index 145cfccf082..d988ca776de 100644
--- a/lib/dbwrap/dbwrap_rbt.c
+++ b/lib/dbwrap/dbwrap_rbt.c
@@ -375,6 +375,7 @@ static struct db_record *db_rbt_fetch_locked(struct db_context *db_ctx,
 
 	rec_priv->node = res.node;
 	result->value  = res.val;
+	result->value_valid = true;
 
 	if (found) {
 		result->key = res.key;
@@ -447,6 +448,7 @@ static int db_rbt_traverse_internal(struct db_context *db,
 		rec.storev = db_rbt_storev;
 		rec.delete_rec = db_rbt_delete;
 		db_rbt_parse_node(rec_priv.node, &rec.key, &rec.value);
+		rec.value_valid = true;
 
 		if (rw) {
 			ctx->traverse_nextp = &next;
diff --git a/lib/dbwrap/dbwrap_tdb.c b/lib/dbwrap/dbwrap_tdb.c
index 1ac7dc9ed7a..74b895a7736 100644
--- a/lib/dbwrap/dbwrap_tdb.c
+++ b/lib/dbwrap/dbwrap_tdb.c
@@ -17,12 +17,14 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
-#include "includes.h"
+#include "replace.h"
 #include "dbwrap/dbwrap.h"
 #include "dbwrap/dbwrap_private.h"
 #include "dbwrap/dbwrap_tdb.h"
 #include "lib/tdb_wrap/tdb_wrap.h"
 #include "lib/util/util_tdb.h"
+#include "lib/util/debug.h"
+#include "lib/util/samba_util.h"
 #include "system/filesys.h"
 #include "lib/param/param.h"
 #include "libcli/util/error.h"
@@ -106,6 +108,7 @@ static int db_tdb_fetchlock_parse(TDB_DATA key, TDB_DATA data,
 	else {
 		result->value.dptr = NULL;
 	}
+	result->value_valid = true;
 
 	return 0;
 }
@@ -182,6 +185,7 @@ static struct db_record *db_tdb_try_fetch_locked(
 
 static NTSTATUS db_tdb_do_locked(struct db_context *db, TDB_DATA key,
 				 void (*fn)(struct db_record *rec,
+					    TDB_DATA value,
 					    void *private_data),
 				 void *private_data)
 {
@@ -210,13 +214,14 @@ static NTSTATUS db_tdb_do_locked(struct db_context *db, TDB_DATA key,
 
 	rec = (struct db_record) {
 		.db = db, .key = key,
-		.value = (struct TDB_DATA) { .dptr = buf,
-					     .dsize = talloc_get_size(buf) },
+		.value_valid = false,
 		.storev = db_tdb_storev, .delete_rec = db_tdb_delete,
 		.private_data = ctx
 	};
 
-	fn(&rec, private_data);
+	fn(&rec,
+	   (TDB_DATA) { .dptr = buf, .dsize = talloc_get_size(buf) },
+	   private_data);
 
 	tdb_chainunlock(ctx->wtdb->tdb, key);
 
@@ -292,6 +297,8 @@ static NTSTATUS db_tdb_storev(struct db_record *rec,
 {
 	struct db_tdb_ctx *ctx = talloc_get_type_abort(rec->private_data,
 						       struct db_tdb_ctx);
+	struct tdb_context *tdb = ctx->wtdb->tdb;
+	NTSTATUS status = NT_STATUS_OK;
 	int ret;
 
 	/*
@@ -300,8 +307,12 @@ static NTSTATUS db_tdb_storev(struct db_record *rec,
 	 * anymore after it was stored.
 	 */
 
-	ret = tdb_storev(ctx->wtdb->tdb, rec->key, dbufs, num_dbufs, flag);
-	return (ret == 0) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
+	ret = tdb_storev(tdb, rec->key, dbufs, num_dbufs, flag);
+	if (ret == -1) {
+		enum TDB_ERROR err = tdb_error(tdb);
+		status = map_nt_error_from_tdb(err);
+	}
+	return status;
 }
 
 static NTSTATUS db_tdb_delete(struct db_record *rec)
@@ -335,6 +346,7 @@ static int db_tdb_traverse_func(TDB_CONTEXT *tdb, TDB_DATA kbuf, TDB_DATA dbuf,
 
 	rec.key = kbuf;
 	rec.value = dbuf;
+	rec.value_valid = true;
 	rec.storev = db_tdb_storev;
 	rec.delete_rec = db_tdb_delete;
 	rec.private_data = ctx->db->private_data;
@@ -378,6 +390,7 @@ static int db_tdb_traverse_read_func(TDB_CONTEXT *tdb, TDB_DATA kbuf, TDB_DATA d
 
 	rec.key = kbuf;
 	rec.value = dbuf;
+	rec.value_valid = true;
 	rec.storev = db_tdb_storev_deny;
 	rec.delete_rec = db_tdb_delete_deny;
 	rec.private_data = ctx->db->private_data;
diff --git a/lib/fuzzing/README.md b/lib/fuzzing/README.md
index 3848838ba02..5a248241248 100644
--- a/lib/fuzzing/README.md
+++ b/lib/fuzzing/README.md
@@ -7,6 +7,7 @@ exceptions such as crashes, assertions or memory corruption.
 See [Wikipedia article on fuzzing](https://en.wikipedia.org/wiki/Fuzzing) for
 more information.
 
+# Hongfuzz
 
 ## Configure with fuzzing
 
@@ -15,7 +16,7 @@ Example command line to build binaries for use with
 
 ```sh
 buildtools/bin/waf -C --without-gettext --enable-debug --enable-developer \
-	--address-sanitizer --enable-libfuzzer \
+	--address-sanitizer --enable-libfuzzer --abi-check-disable \
 	CC=.../honggfuzz/hfuzz_cc/hfuzz-clang configure \
 	LINK_CC=.../honggfuzz/hfuzz_cc/hfuzz-clang
 ```
@@ -32,4 +33,53 @@ buildtools/bin/waf --targets=fuzz_tiniparser build && \
   --rlimit_rss 100 -f .../tiniparser-corpus -- bin/fuzz_tiniparser
 ```
 
+# AFL (american fuzzy lop)
+
+## Configure with fuzzing
+
+Example command line to build binaries for use with
+[afl](http://lcamtuf.coredump.cx/afl/)
+
+```sh
+buildtools/bin/waf -C --without-gettext --enable-debug --enable-developer \
+	--enable-afl-fuzzer --abi-check-disable \
+	CC=afl-gcc configure
+```
+
+## Fuzzing tiniparser
+
+Example for fuzzing `tiniparser` using `afl-fuzz` (see `--help` for more
+options):
+
+```sh
+buildtools/bin/waf --targets=fuzz_tiniparser build && \
+afl-fuzz -m 200 -i inputdir -o outputdir -- bin/fuzz_tiniparser
+```
+
+# oss-fuzz
+
+Samba can be fuzzed by Google's oss-fuzz system.  Assuming you have an
+oss-fuzz checkout from https://github.com/google/oss-fuzz with Samba's
+metadata in projects/samba, the following guides will help:
+
+## Testing locally
+
+https://google.github.io/oss-fuzz/getting-started/new-project-guide/#testing-locally
+
+## Debugging oss-fuzz
+
+See https://google.github.io/oss-fuzz/advanced-topics/debugging/
+
+## Samba-specific hints
+
+A typical debugging workflow is:
+
+oss-fuzz$ python infra/helper.py shell samba
+git fetch $REMOTE $BRANCH
+git checkout FETCH_HEAD
+lib/fuzzing/oss-fuzz/build_image.sh
+compile
+
+This will pull in any new Samba deps and build Samba's fuzzers.
+
 # vim: set sw=8 sts=8 ts=8 tw=79 :
diff --git a/lib/fuzzing/afl-fuzz-main.c b/lib/fuzzing/afl-fuzz-main.c
new file mode 100644
index 00000000000..9f677557867
--- /dev/null
+++ b/lib/fuzzing/afl-fuzz-main.c
@@ -0,0 +1,56 @@
+/*
+   Unix SMB/CIFS implementation.
+
+   Fuzz driver (AFL style)
+
+   Copyright (C) Andrew Bartlett 2019
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "includes.h"
+#include "lib/util/samba_util.h"
+#include "fuzzing.h"
+
+int main(int argc, char *argv[]) {
+	int ret;
+	size_t size = 0;
+#ifdef __AFL_LOOP
+	while (__AFL_LOOP(1000))
+#else
+	int i;
+	for (i = 0; i < argc; i++) {
+		uint8_t *buf = (uint8_t *)file_load(argv[i],
+						    &size,
+						    0,
+						    NULL);
+		ret = LLVMFuzzerTestOneInput(buf, size);
+		TALLOC_FREE(buf);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+	if (i == 0)
+#endif
+	{
+		uint8_t *buf = (uint8_t *)fd_load(0, &size, 0, NULL);
+		if (buf == NULL) {
+			exit(1);
+		}
+
+		ret = LLVMFuzzerTestOneInput(buf, size);
+		TALLOC_FREE(buf);
+	}
+	return ret;
+}
diff --git a/lib/fuzzing/decode_ndr_X_crash b/lib/fuzzing/decode_ndr_X_crash
new file mode 100755
index 00000000000..63c3cd747d7
--- /dev/null
+++ b/lib/fuzzing/decode_ndr_X_crash
@@ -0,0 +1,137 @@
+#!/usr/bin/env python3
+#
+# Interpret a file that crashes an fuzz_ndr_X binary.
+#
+# Copyright (C) Catalyst IT Ltd. 2019
+
+
+import sys
+import os
+from base64 import b64encode
+import struct
+import argparse
+import re
+
+TYPE_MASK = 3
+TYPES = ['struct', 'in', 'out']
+
+FLAGS = [
+    (4, 'ndr64', '--ndr64'),
+]
+
+
+def print_if_verbose(*args, **kwargs):
+    if verbose:
+        print(*args, **kwargs)
+
+
+def process_one_file(f):
+    print_if_verbose(f.name)
+    print_if_verbose('-' * len(f.name))
+
+    b = f.read()
+    flags, function = struct.unpack('<HH', b[:4])
+    if opnum is not None and opnum != function:
+        return
+
+    t = TYPES[flags & TYPE_MASK]
+    if ndr_type and ndr_type != t:
+        return
+
+    payload = b[4:]
+    data64 = b64encode(payload).decode('utf-8')
+
+    cmd = ['bin/ndrdump',
+           pipe,
+           str(function),
+           t,
+           '--base64-input',
+           '--input', data64,
+    ]
+
+    for flag, name, option in FLAGS:
+        if flags & flag:
+            print_if_verbose("flag: %s" % name)
+            cmd.append(option)
+
+    print_if_verbose("length: %d\n" % len(payload))
+    print(' '.join(cmd))
+    print_if_verbose()
+
+
+def main():
+    parser = argparse.ArgumentParser()
+    parser.add_argument('-p', '--pipe', default='$PIPE',
+                        help='pipe name (for output command line)')
+    parser.add_argument('-t', '--type', default=None, choices=TYPES,
+                        help='restrict to this type')
+    parser.add_argument('-o', '--opnum', default=None, type=int,
+                        help='restrict to this function/struct number')
+    parser.add_argument('FILES', nargs='*', default=(),
+                        help="read from these files")
+    parser.add_argument('-k', '--ignore-errors', action='store_true',
+                        help='do not stop on errors')
+    parser.add_argument('-v', '--verbose', action='store_true',
+                        help='say more')
+    parser.add_argument('-H', '--honggfuzz-file',
+                        help="extract crashes from this honggfuzz report")
+    parser.add_argument('-f', '--crash-filter',
+                        help="only print crashes matching this rexexp")
+
+    args = parser.parse_args()
+
+    global pipe, opnum, ndr_type, verbose
+    pipe = args.pipe
+    opnum = args.opnum
+    ndr_type = args.type
+    verbose = args.verbose
+
+    if not args.FILES and not args.honggfuzz_file:
+        parser.print_usage()
+        sys.exit(1)
+
+    for fn in args.FILES:
+        if args.crash_filter is not None:
+            if not re.search(args.crash_filter, fn):
+                print_if_verbose(f"skipping {fn}")
+                continue
+        try:
+            if fn == '-':
+                process_one_file(sys.stdin)
+            else:
+                with open(fn, 'rb') as f:
+                    process_one_file(f)
+        except Exception:
+            print_if_verbose("Error processing %s\n" % fn)
+            if args.ignore_errors:
+                continue
+            raise
+
+    if args.honggfuzz_file:
+        print_if_verbose(f"looking at {args.honggfuzz_file}")
+        with open(args.honggfuzz_file) as f:
+            pipe = None
+            crash = None
+            for line in f:
+                m = re.match(r'^\s*fuzzTarget\s*:\s*bin/fuzz_ndr_(\w+)\s*$', line)
+                if m:
+                    pipe = m.group(1).split('_TYPE_', 1)[0]
+                    print_if_verbose(f"found pipe {pipe}")
+                m = re.match(r'^FUZZ_FNAME: (\S+)$', line)
+                if m:
+                    crash = m.group(1)
+                    if args.crash_filter is not None:
+                        if not re.search(args.crash_filter, crash):
+                            print_if_verbose(f"skipping {crash}")
+                            pipe = None
+                            crash = None
+                            continue
+                    print_if_verbose(f"found crash {crash}")
+                if pipe is not None and crash is not None:
+                    with open(crash, 'rb') as f:
+                        process_one_file(f)
+                    pipe = None
+                    crash = None
+
+
+main()
diff --git a/lib/fuzzing/fuzz_ldap_decode.c b/lib/fuzzing/fuzz_ldap_decode.c
index 85e0e38983e..659169aca96 100644
--- a/lib/fuzzing/fuzz_ldap_decode.c
+++ b/lib/fuzzing/fuzz_ldap_decode.c
@@ -47,7 +47,6 @@ int LLVMFuzzerTestOneInput(uint8_t *buf, size_t len)
 	}
 
 	status = ldap_decode(asn1, samba_ldap_control_handlers(), ldap_msg);
-	printf("%s\n", nt_errstr(status));
 
 out:
 	talloc_free(mem_ctx);
diff --git a/lib/fuzzing/fuzz_ldb_dn_explode.c b/lib/fuzzing/fuzz_ldb_dn_explode.c
new file mode 100644
index 00000000000..29747178e3e
--- /dev/null
+++ b/lib/fuzzing/fuzz_ldb_dn_explode.c
@@ -0,0 +1,47 @@
+/*
+   Fuzzing ldb_parse_control_from_string
+   Copyright (C) Catalyst IT 2020
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "includes.h"
+#include "fuzzing/fuzzing.h"
+#include "ldb.h"
+
+
+#define MAX_LENGTH (2 * 1024 * 1024 - 1)
+char buf[MAX_LENGTH + 1] = {0};
+
+int LLVMFuzzerTestOneInput(uint8_t *input, size_t len)
+{
+	struct ldb_dn *dn = NULL;
+	struct ldb_context *ldb = ldb_init(NULL, NULL);
+	if (ldb == NULL) {
+		return 0;
+	}
+	/*
+	 * We copy the buffer in order to NUL-terminate, because running off
+	 *  the end of the string would be an uninteresting crash.
+	 */
+	if (len > MAX_LENGTH) {
+		len = MAX_LENGTH;
+	}
+	memcpy(buf, input, len);
+	buf[len] = 0;
+
+	dn = ldb_dn_new(ldb, ldb, buf);
+	ldb_dn_validate(dn);
+	TALLOC_FREE(ldb);
+	return 0;
+}
diff --git a/lib/fuzzing/fuzz_ldb_ldif_read.c b/lib/fuzzing/fuzz_ldb_ldif_read.c
new file mode 100644
index 00000000000..4eee1701836
--- /dev/null
+++ b/lib/fuzzing/fuzz_ldb_ldif_read.c
@@ -0,0 +1,50 @@
+/*
+   Fuzzing ldb_parse_control_from_string
+   Copyright (C) Catalyst IT 2020
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "includes.h"
+#include "fuzzing/fuzzing.h"
+#include "ldb_private.h"
+
+
+#define MAX_LENGTH (2 * 1024 * 1024 - 1)
+char buf[MAX_LENGTH + 1] = {0};
+
+int LLVMFuzzerTestOneInput(uint8_t *input, size_t len)
+{
+	struct ldb_ldif *ldif = NULL;
+	const char *s = NULL;
+	struct ldb_context *ldb = ldb_init(NULL, NULL);
+	if (ldb == NULL) {
+		return 0;
+	}
+	
+	if (len > MAX_LENGTH) {
+		len = MAX_LENGTH;
+	}
+	memcpy(buf, input, len);
+	buf[len] = 0;
+	s = buf;
+
+	ldif = ldb_ldif_read_string(ldb, &s);
+
+	if(ldif != NULL) {
+		ldb_ldif_write_string(ldb, ldb, ldif);
+		ldb_ldif_write_redacted_trace_string(ldb, ldb, ldif);
+	}
+	TALLOC_FREE(ldb);
+	return 0;
+}
diff --git a/lib/fuzzing/fuzz_ldb_parse_binary_decode.c b/lib/fuzzing/fuzz_ldb_parse_binary_decode.c
new file mode 100644
index 00000000000..6b79a34a027
--- /dev/null
+++ b/lib/fuzzing/fuzz_ldb_parse_binary_decode.c
@@ -0,0 +1,49 @@
+/*
+   Fuzzing ldb_parse_control_from_string
+   Copyright (C) Catalyst IT 2020
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "includes.h"
+#include "fuzzing/fuzzing.h"
+#include "ldb_private.h"
+
+
+#define MAX_LENGTH (2 * 1024 * 1024 - 1)
+char buf[MAX_LENGTH + 1] = {0};
+
+static char * possibly_truncate(uint8_t *input, size_t len)
+{
+	if (len > MAX_LENGTH) {
+		len = MAX_LENGTH;
+	}
+	memcpy(buf, input, len);
+	buf[len] = 0;
+	return buf;
+}
+
+
+int LLVMFuzzerTestOneInput(uint8_t *input, size_t len)
+{
+	TALLOC_CTX *mem_ctx = talloc_init(__FUNCTION__);
+	struct ldb_val val = {0};
+	const char *s = possibly_truncate(input, len);
+
+	/* we treat the same string to encoding and decoding, not
+	 * round-tripping. */
+	val = ldb_binary_decode(mem_ctx, s);
+	ldb_binary_encode_string(mem_ctx, s);
+	TALLOC_FREE(mem_ctx);
+	return 0;
+}
diff --git a/lib/fuzzing/fuzz_ldb_parse_control.c b/lib/fuzzing/fuzz_ldb_parse_control.c
new file mode 100644
index 00000000000..98af24a8000
--- /dev/null
+++ b/lib/fuzzing/fuzz_ldb_parse_control.c
@@ -0,0 +1,49 @@
+/*
+   Fuzzing ldb_parse_control_from_string
+   Copyright (C) Catalyst IT 2020
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "includes.h"
+#include "fuzzing/fuzzing.h"
+#include "ldb_private.h"
+
+
+#define MAX_LENGTH (2 * 1024 * 1024 - 1)
+char buf[MAX_LENGTH + 1] = {0};
+
+int LLVMFuzzerTestOneInput(uint8_t *input, size_t len)
+{
+	struct ldb_control *control = NULL;
+	struct ldb_context *ldb = ldb_init(NULL, NULL);
+	if (ldb == NULL) {
+		return 0;
+	}
+	/*
+	 * We copy the buffer in order to NUL-terminate, because running off
+	 *  the end of the string would be an uninteresting crash.
+	 */
+	if (len > MAX_LENGTH) {
+		len = MAX_LENGTH;
+	}
+	memcpy(buf, input, len);
+	buf[len] = 0;
+
+	control = ldb_parse_control_from_string(ldb, ldb, buf);
+	if (control != NULL) {
+		ldb_control_to_string(ldb, control);
+	}
+	TALLOC_FREE(ldb);
+	return 0;
+}
diff --git a/lib/fuzzing/fuzz_ldb_parse_tree.c b/lib/fuzzing/fuzz_ldb_parse_tree.c
index f0f02148142..e22dd776110 100644
--- a/lib/fuzzing/fuzz_ldb_parse_tree.c
+++ b/lib/fuzzing/fuzz_ldb_parse_tree.c
@@ -33,17 +33,20 @@ int LLVMFuzzerTestOneInput(uint8_t *buf, size_t len)
 	char *filter;
 
 	if (len < 1) {
-		return 0;
+		goto out;
 	}
 
 	filter = talloc_strndup(mem_ctx, (const char*)buf, len);
 
 	if (filter == NULL) {
-		return 0;
+		goto out;
 	}
 
 	tree = ldb_parse_tree(mem_ctx, filter);
 
+	(void)ldb_filter_from_tree(mem_ctx, tree);
+
+out:
 	talloc_free(mem_ctx);
 
 	return 0;
diff --git a/lib/fuzzing/fuzz_ndr_X.c b/lib/fuzzing/fuzz_ndr_X.c
new file mode 100644
index 00000000000..e8c3bb4cf76
--- /dev/null
+++ b/lib/fuzzing/fuzz_ndr_X.c
@@ -0,0 +1,330 @@
+/*
+   Unix SMB/CIFS implementation.
+   SMB torture tester
+   Copyright (C) Andrew Tridgell 2003
+   Copyright (C) Jelmer Vernooij 2006
+   Copyright (C) Andrew Bartlett 2019
+   Copyright (C) Catalyst.NET Ltd 2019
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "includes.h"
+#include "system/filesys.h"
+#include "system/locale.h"
+#include "librpc/ndr/libndr.h"
+#include "librpc/gen_ndr/ndr_dcerpc.h"
+#include "util/byteorder.h"
+#include "fuzzing/fuzzing.h"
+
+extern const struct ndr_interface_table FUZZ_PIPE_TABLE;
+
+#define FLAG_NDR64 4
+
+enum {
+	TYPE_STRUCT = 0,
+	TYPE_IN,
+	TYPE_OUT
+};
+
+/*
+ * header design (little endian):
+ *
+ * struct {
+ *   uint16_t flags;
+ *   uint16_t function_or_struct_no;
+ * };
+ */
+
+/*
+ * We want an even number here to ensure 4-byte alignment later
+ * not just for efficieny but because the fuzzers are known to guess
+ * that numbers will be 4-byte aligned
+ */
+#define HEADER_SIZE 4
+
+#define INVALID_FLAGS (~(FLAG_NDR64 | 3))
+
+static const struct ndr_interface_call *find_function(
+	const struct ndr_interface_table *p,
+	unsigned int function_no)
+{
+	if (function_no >= p->num_calls) {
+		return NULL;
+	}
+	return &p->calls[function_no];
+}
+
+/*
+ * Get a public structure by number and return it as if it were
+ * a function.
+ */
+static const struct ndr_interface_call *find_struct(
+	const struct ndr_interface_table *p,
+	unsigned int struct_no,
+	struct ndr_interface_call *out_buffer)
+{
+	const struct ndr_interface_public_struct *s = NULL;
+
+	if (struct_no >= p->num_public_structs) {
+		return NULL;
+	}
+
+	s = &p->public_structs[struct_no];
+
+	*out_buffer = (struct ndr_interface_call) {
+		.name = s->name,
+		.struct_size = s->struct_size,
+		.ndr_pull = s->ndr_pull,
+		.ndr_push = s->ndr_push,
+		.ndr_print = s->ndr_print
+	};
+	return out_buffer;
+}
+
+
+static NTSTATUS pull_chunks(struct ndr_pull *ndr_pull,
+			    const struct ndr_interface_call_pipes *pipes)
+{
+	enum ndr_err_code ndr_err;
+	uint32_t i;
+
+	for (i=0; i < pipes->num_pipes; i++) {
+		while (true) {
+			void *saved_mem_ctx;
+			uint32_t *count;
+			void *c;
+
+			c = talloc_zero_size(ndr_pull, pipes->pipes[i].chunk_struct_size);
+			if (c == NULL) {
+				return NT_STATUS_NO_MEMORY;
+			}
+			/*
+			 * Note: the first struct member is always
+			 * 'uint32_t count;'
+			 */
+			count = (uint32_t *)c;
+
+			saved_mem_ctx = ndr_pull->current_mem_ctx;
+			ndr_pull->current_mem_ctx = c;
+			ndr_err = pipes->pipes[i].ndr_pull(ndr_pull, NDR_SCALARS, c);
+			ndr_pull->current_mem_ctx = saved_mem_ctx;
+
+			if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+				talloc_free(c);
+				return ndr_map_error2ntstatus(ndr_err);
+			}
+			if (*count == 0) {
+				talloc_free(c);
+				break;
+			}
+			talloc_free(c);
+		}
+	}
+
+	return NT_STATUS_OK;
+}
+
+static void ndr_print_nothing(struct ndr_print *ndr, const char *format, ...)
+{
+	/*
+	 * This is here so that we walk the tree but don't output anything.
+	 * This helps find buggy ndr_print routines
+	 */
+
+	/*
+	 * TODO: consider calling snprinf() to find strings without NULL
+	 * terminators (for example)
+	 */
+}
+
+
+int LLVMFuzzerTestOneInput(uint8_t *data, size_t size) {
+	uint8_t type;
+	int pull_push_print_flags;
+	uint16_t fuzz_packet_flags, function;
+	TALLOC_CTX *mem_ctx = NULL;
+	uint32_t ndr_flags = 0;
+	struct ndr_push *ndr_push;
+	enum ndr_err_code ndr_err;
+	struct ndr_interface_call f_buffer;
+	const struct ndr_interface_call *f = NULL;
+	NTSTATUS status;
+
+/*
+ * This allows us to build binaries to fuzz just one target function
+ *
+ * In this mode the input becomes the 'stub data', there is no prefix.
+ *
+ * There is no NDR64 support in this mode at this time.
+ */
+#if defined(FUZZ_TYPE) && defined(FUZZ_FUNCTION)
+#undef HEADER_SIZE
+#define HEADER_SIZE 0
+	fuzz_packet_flags = 0;
+	type = FUZZ_TYPE;
+	function = FUZZ_FUNCTION;
+#else
+	if (size < HEADER_SIZE) {
+		/*
+		 * the first few bytes decide what is being fuzzed --
+		 * if they aren't all there we do nothing.
+		 */
+		return 0;
+	}
+
+	fuzz_packet_flags = SVAL(data, 0);
+	if (fuzz_packet_flags & INVALID_FLAGS) {
+		return 0;
+	}
+
+	function = SVAL(data, 2);
+
+	type = fuzz_packet_flags & 3;
+
+#ifdef FUZZ_TYPE
+	/*
+	 * Fuzz targets should have as small an interface as possible.
+	 * This allows us to create 3 binaries for most pipes,
+	 * TYPE_IN, TYPE_OUT and TYPE_STRUCT
+	 *
+	 * We keep the header format, and just exit early if it does
+	 * not match.
+	 */
+	if (type != FUZZ_TYPE) {
+		return 0;
+	}
+#endif
+#endif
+
+	switch (type) {
+	case TYPE_STRUCT:
+		pull_push_print_flags = NDR_SCALARS|NDR_BUFFERS;
+		f = find_struct(&FUZZ_PIPE_TABLE, function, &f_buffer);
+		break;
+	case TYPE_IN:
+		pull_push_print_flags = NDR_IN;
+		f = find_function(&FUZZ_PIPE_TABLE, function);
+		break;
+	case TYPE_OUT:
+		pull_push_print_flags = NDR_OUT;
+		f = find_function(&FUZZ_PIPE_TABLE, function);
+		break;
+	default:
+		return 0;
+	}
+
+	if (f == NULL) {
+		return 0;
+	}
+	if (fuzz_packet_flags & FLAG_NDR64) {
+		ndr_flags |= LIBNDR_FLAG_NDR64;
+	}
+
+	mem_ctx = talloc_init("ndrfuzz");
+
+	{
+		/*
+		 * f->struct_size is well-controlled, it is essentially
+		 * defined in the IDL
+		 */
+		uint8_t st[f->struct_size];
+
+		DATA_BLOB blob = data_blob_const(data + HEADER_SIZE,
+						 size - HEADER_SIZE);
+		struct ndr_pull *ndr_pull = ndr_pull_init_blob(&blob,
+							       mem_ctx);
+
+		if (ndr_pull == NULL) {
+			perror("ndr_pull_init_blob");
+			TALLOC_FREE(mem_ctx);
+			return 0;
+		}
+
+		/*
+		 * We must initialise the buffer (even if we would
+		 * prefer not to for the sake of eg valgrind) as
+		 * otherwise the special handler for 'out pointer with
+		 * [size_is()] refers to in value with [ref]' fails to
+		 * trigger
+		 */
+		memset(st, '\0', sizeof(st));
+
+		ndr_pull->flags |= LIBNDR_FLAG_REF_ALLOC;
+
+		if (type == TYPE_OUT) {
+			status = pull_chunks(ndr_pull,
+					     &f->out_pipes);
+			if (!NT_STATUS_IS_OK(status)) {
+				TALLOC_FREE(mem_ctx);
+				return 0;
+			}
+		}
+
+		ndr_err = f->ndr_pull(ndr_pull,
+				      pull_push_print_flags,
+				      st);
+		if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+			TALLOC_FREE(mem_ctx);
+			return 0;
+		}
+
+		if (type == TYPE_IN) {
+			status = pull_chunks(ndr_pull,
+					     &f->in_pipes);
+			if (!NT_STATUS_IS_OK(status)) {
+				TALLOC_FREE(mem_ctx);
+				return 0;
+			}
+		}
+
+		ndr_push = ndr_push_init_ctx(mem_ctx);
+		if (ndr_push == NULL) {
+			TALLOC_FREE(mem_ctx);
+			return 0;
+		}
+
+		ndr_push->flags |= ndr_flags;
+
+		/*
+		 * Now push what was pulled, just in case we generated an
+		 * invalid structure in memory, this should notice
+		 */
+		ndr_err = f->ndr_push(ndr_push,
+				      pull_push_print_flags,
+				      st);
+		if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+			TALLOC_FREE(mem_ctx);
+			return 0;
+		}
+
+		{
+			struct ndr_print *ndr_print = talloc_zero(mem_ctx, struct ndr_print);
+			ndr_print->print = ndr_print_nothing;
+			ndr_print->depth = 1;
+
+			/*
+			 * Finally print (to nowhere) the structure, this may also
+			 * notice invalid memory
+			 */
+			f->ndr_print(ndr_print,
+				     f->name,
+				     pull_push_print_flags,
+				     st);
+		}
+	}
+	TALLOC_FREE(mem_ctx);
+
+	return 0;
+}
diff --git a/lib/fuzzing/fuzz_nmblib_parse_packet.c b/lib/fuzzing/fuzz_nmblib_parse_packet.c
new file mode 100644
index 00000000000..7b35abe9f97
--- /dev/null
+++ b/lib/fuzzing/fuzz_nmblib_parse_packet.c
@@ -0,0 +1,56 @@
+/*
+  Fuzz NMB parse_packet
+  Copyright (C) Catalyst IT 2020
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "../../source3/include/includes.h"
+#include "libsmb/libsmb.h"
+#include "libsmb/nmblib.h"
+#include "fuzzing/fuzzing.h"
+
+#define PORT 138
+#define MAX_LENGTH (1024 * 1024)
+char buf[MAX_LENGTH + 1];
+
+
+int LLVMFuzzerTestOneInput(uint8_t *input, size_t len)
+{
+	struct packet_struct *p = NULL;
+	struct in_addr ip = {
+		0x0100007f /* 127.0.0.1 */
+	};
+
+	p = parse_packet((char *)input,
+			 len,
+			 NMB_PACKET,
+			 ip,
+			 PORT);
+	/*
+	 * We expect NULL (parse failure) most of the time.
+	 *
+	 * When it is not NULL we want to ensure the parsed packet is
+	 * reasonably sound.
+	 */
+
+	if (p != NULL) {
+		struct nmb_packet *nmb = &p->packet.nmb;
+		pull_ascii_nstring(buf, MAX_LENGTH,
+				   nmb->question.question_name.name);
+		build_packet(buf, MAX_LENGTH, p);
+		free_packet(p);
+	}
+	return 0;
+}
diff --git a/lib/fuzzing/fuzz_oLschema2ldif.c b/lib/fuzzing/fuzz_oLschema2ldif.c
index a983f48d660..873e8f1ccc7 100644
--- a/lib/fuzzing/fuzz_oLschema2ldif.c
+++ b/lib/fuzzing/fuzz_oLschema2ldif.c
@@ -43,12 +43,23 @@ int LLVMFuzzerTestOneInput(uint8_t *buf, size_t len)
 	}
 
 	mem_ctx = talloc_init(__FUNCTION__);
+	if (mem_ctx == NULL) {
+		return 0;
+	}
 
 	opt.in = fmemopen(buf, len, "r");
 	opt.out = devnull;
 	opt.ldb_ctx = ldb_init(mem_ctx, NULL);
+	if (opt.ldb_ctx == NULL || opt.in == NULL) {
+		talloc_free(mem_ctx);
+		return 0;
+	}
 
 	opt.basedn = ldb_dn_new(mem_ctx, opt.ldb_ctx, "");
+	if (opt.basedn == NULL) {
+		talloc_free(mem_ctx);
+		return 0;
+	}
 
 	process_file(mem_ctx, &opt);
 
diff --git a/lib/fuzzing/fuzz_reg_parse.c b/lib/fuzzing/fuzz_reg_parse.c
index 36b1b6f84ac..a061cd6294b 100644
--- a/lib/fuzzing/fuzz_reg_parse.c
+++ b/lib/fuzzing/fuzz_reg_parse.c
@@ -34,14 +34,13 @@ int LLVMFuzzerInitialize(int *argc, char ***argv)
 int LLVMFuzzerTestOneInput(uint8_t *buf, size_t len)
 {
 	const reg_parse_callback cb = {0};
-	int ret;
 
 	rewind(fp);
 	(void)fwrite(buf, len, 1, fp);
 	(void)fflush(fp);
 	rewind(fp);
 
-	ret = reg_parse_fd(fileno(fp), &cb, "");
+	(void)reg_parse_fd(fileno(fp), &cb, "");
 
 	return 0;
 }
diff --git a/lib/fuzzing/oss-fuzz/build_image.sh b/lib/fuzzing/oss-fuzz/build_image.sh
new file mode 100755
index 00000000000..5df07dc43be
--- /dev/null
+++ b/lib/fuzzing/oss-fuzz/build_image.sh
@@ -0,0 +1,7 @@
+#!/bin/sh -e
+
+DIST=ubuntu1604
+SCRIPT_DIR=`dirname $0`
+
+$SCRIPT_DIR/../../../bootstrap/generated-dists/$DIST/bootstrap.sh
+$SCRIPT_DIR/../../../bootstrap/generated-dists/$DIST/locale.sh
diff --git a/lib/fuzzing/oss-fuzz/build_samba.sh b/lib/fuzzing/oss-fuzz/build_samba.sh
new file mode 100755
index 00000000000..93039e4dbe0
--- /dev/null
+++ b/lib/fuzzing/oss-fuzz/build_samba.sh
@@ -0,0 +1,78 @@
+#!/bin/sh -eux
+#
+# This is not a general-purpose build script, but instead one specific to the Google oss-fuzz compile environment.
+#
+# https://google.github.io/oss-fuzz/getting-started/new-project-guide/#Requirements
+#
+# https://github.com/google/oss-fuzz/blob/master/infra/base-images/base-builder/README.md#provided-environment-variables
+#
+# We have to push to oss-fuzz CFLAGS into the waf ADDITIONAL_CFLAGS
+# as otherwise waf's configure fails linking the first test binary
+#
+# CFLAGS are supplied by the caller, eg the oss-fuzz compile command
+#
+# Additional arguments are passed to configure, to allow this to be
+# tested in autobuild.py
+#
+ADDITIONAL_CFLAGS="$CFLAGS"
+export ADDITIONAL_CFLAGS
+CFLAGS=""
+export CFLAGS
+LD="$CXX"
+export LD
+
+# $SANITIZER is provided by the oss-fuzz "compile" command
+#
+# We need to add the waf configure option as otherwise when we also
+# get (eg) -fsanitize=address via the CFLAGS we will fail to link
+# correctly
+
+case "$SANITIZER" in
+    address)
+	SANITIZER_ARG='--address-sanitizer'
+	;;
+    undefined)
+	SANITIZER_ARG='--undefined-sanitizer'
+	;;
+    coverage)
+       SANITIZER_ARG=''
+       ;;
+esac
+
+# $LIB_FUZZING_ENGINE is provided by the oss-fuzz "compile" command
+#
+
+./configure -C --without-gettext --enable-debug --enable-developer \
+            --enable-libfuzzer \
+	    $SANITIZER_ARG \
+	    --disable-warnings-as-errors \
+	    --abi-check-disable \
+	    --fuzz-target-ldflags="$LIB_FUZZING_ENGINE" \
+	    --nonshared-binary=ALL \
+	    "$@" \
+	    LINK_CC="$CXX"
+
+make -j
+
+# Make a directory for the system shared libraries to be copied into
+mkdir -p $OUT/lib
+
+# We can't static link to all the system libs with waf, so copy them
+# to $OUT/lib and set the rpath to point there.  This is similar to how
+# firefox handles this.
+
+for x in bin/fuzz_*
+do
+    cp $x $OUT/
+    bin=`basename $x`
+
+    # Copy any system libraries needed by this fuzzer to $OUT/lib
+    ldd $OUT/$bin | cut -f 2 -d '>' | cut -f 1 -d \( | cut -f 2 -d  ' ' | xargs -i cp \{\} $OUT/lib/
+
+    # Change RUNPATH so that the copied libraries are found on the
+    # runner
+    chrpath -r '$ORIGIN/lib' $OUT/$bin
+
+    # Truncate the original binary to save space
+    echo -n > $x
+done
diff --git a/lib/fuzzing/oss-fuzz/check_build.sh b/lib/fuzzing/oss-fuzz/check_build.sh
new file mode 100755
index 00000000000..cc69cf26418
--- /dev/null
+++ b/lib/fuzzing/oss-fuzz/check_build.sh
@@ -0,0 +1,25 @@
+#!/bin/sh -eux
+#
+# A very simple check script to confirm we still provide binaries
+# that look like the targets oss-fuzz wants.
+#
+# A much stronger check is availble in oss-fuzz via
+# infra/helper.py check_build samba
+#
+
+# oss-fuzz provides an OUT variable, so for clarity this script
+# uses the same.  See build_samba.sh
+OUT=$1
+
+# build_samba.sh will have put a non-zero number of fuzzers here.  If
+# there are none, this will fail as it becomes literally fuzz_*
+for bin in $OUT/fuzz_*
+do
+    # Confirm that the chrpath was reset to lib/ in the same directory
+    # as the binary
+    chrpath -l $bin | grep 'RUNPATH=$ORIGIN/lib'
+
+    # Confirm that we link to at least some libraries in this
+    # directory (shows that the libraries were found and copied).
+    ldd $bin | grep "$OUT/lib"
+done
diff --git a/lib/fuzzing/wscript_build b/lib/fuzzing/wscript_build
index 7305ce41262..f8b3886d3da 100644
--- a/lib/fuzzing/wscript_build
+++ b/lib/fuzzing/wscript_build
@@ -1,55 +1,172 @@
 #!/usr/bin/env python
 
+from waflib import Build
+
 bld.SAMBA_SUBSYSTEM('fuzzing',
-    source='fuzzing.c',
-    deps='talloc',
-    enabled=bld.env.enable_libfuzzer,
+                    source='fuzzing.c',
+                    deps='talloc')
+
+bld.SAMBA_SUBSYSTEM('afl-fuzz-main',
+    source='afl-fuzz-main.c',
+    deps='samba-util',
+    enabled=bld.env.enable_afl_fuzzer
     )
 
 bld.SAMBA_BINARY('fuzz_tiniparser',
                  source='fuzz_tiniparser.c',
-                 deps='fuzzing tiniparser talloc',
-                 install=False,
-                 enabled=bld.env.enable_libfuzzer)
+                 deps='fuzzing tiniparser talloc afl-fuzz-main',
+                 fuzzer=True)
 
 bld.SAMBA_BINARY('fuzz_oLschema2ldif',
                  source='fuzz_oLschema2ldif.c',
-                 deps='fuzzing oLschema2ldif-lib',
-                 install=False,
-                 enabled=bld.env.enable_libfuzzer,
-                 )
+                 deps='fuzzing oLschema2ldif-lib afl-fuzz-main',
+                 fuzzer=True)
 
 bld.SAMBA_BINARY('fuzz_reg_parse',
                  source='fuzz_reg_parse.c',
-                 deps='fuzzing samba3-util smbconf REGFIO',
-                 install=False,
-                 enabled=bld.env.enable_libfuzzer,
-                 )
+                 deps='fuzzing samba3-util smbconf REGFIO afl-fuzz-main',
+                 fuzzer=True)
+
+bld.SAMBA_BINARY('fuzz_nmblib_parse_packet',
+                 source='fuzz_nmblib_parse_packet.c',
+                 deps='fuzzing libsmb afl-fuzz-main',
+                 fuzzer=True)
 
 bld.SAMBA_BINARY('fuzz_regfio',
                  source='fuzz_regfio.c',
-                 deps='fuzzing samba3-util smbconf REGFIO',
-                 install=False,
-                 enabled=bld.env.enable_libfuzzer,
-                 )
+                 deps='fuzzing samba3-util smbconf REGFIO afl-fuzz-main',
+                 fuzzer=True)
 
 bld.SAMBA_BINARY('fuzz_lzxpress',
                  source='fuzz_lzxpress.c',
-                 deps='fuzzing LZXPRESS',
-                 install=False,
-                 enabled=bld.env.enable_libfuzzer,
-                 )
+                 deps='fuzzing LZXPRESS afl-fuzz-main',
+                 fuzzer=True)
 
 bld.SAMBA_BINARY('fuzz_ldap_decode',
                  source='fuzz_ldap_decode.c',
-                 deps='fuzzing cli-ldap',
-                 install=False,
-                 enabled=bld.env.enable_libfuzzer,
-                 )
+                 deps='fuzzing cli-ldap afl-fuzz-main',
+                 fuzzer=True)
+
+bld.SAMBA_BINARY('fuzz_ldb_parse_control',
+                 source='fuzz_ldb_parse_control.c',
+                 deps='fuzzing ldb afl-fuzz-main',
+                 fuzzer=True)
+
+bld.SAMBA_BINARY('fuzz_ldb_dn_explode',
+                 source='fuzz_ldb_dn_explode.c',
+                 deps='fuzzing ldb afl-fuzz-main',
+                 fuzzer=True)
+
+bld.SAMBA_BINARY('fuzz_ldb_ldif_read',
+                 source='fuzz_ldb_ldif_read.c',
+                 deps='fuzzing ldb afl-fuzz-main',
+                 fuzzer=True)
+
+bld.SAMBA_BINARY('fuzz_ldb_parse_binary_decode',
+                 source='fuzz_ldb_parse_binary_decode.c',
+                 deps='fuzzing ldb afl-fuzz-main',
+                 fuzzer=True)
 
 bld.SAMBA_BINARY('fuzz_ldb_parse_tree',
                  source='fuzz_ldb_parse_tree.c',
-                 deps='fuzzing ldb',
-                 install=False,
-                 enabled=bld.env.enable_libfuzzer
-                 )
+                 deps='fuzzing ldb afl-fuzz-main',
+                 fuzzer=True)
+
+# The fuzz_type and fuzz_function parameters make the built
+# fuzzer take the same input as ndrdump and so the same that
+# could be sent to the client or server as the stub data.
+
+def SAMBA_NDR_FUZZ(bld, interface, auto_deps=False,
+                   fuzz_type=None, fuzz_function=None):
+    name = "fuzz_ndr_%s" % (interface.lower())
+    fuzz_dir = os.path.join(bld.env.srcdir, 'lib/fuzzing')
+    fuzz_reldir = os.path.relpath(fuzz_dir, bld.path.abspath())
+    fuzz_src = os.path.join(fuzz_reldir, 'fuzz_ndr_X.c')
+
+    cflags = "-D FUZZ_PIPE_TABLE=ndr_table_%s" % interface
+    if fuzz_type:
+        name += "_%s" % (fuzz_type)
+        cflags += " -D FUZZ_TYPE=%s " % (fuzz_type)
+    if fuzz_type and fuzz_function:
+        name += "_%d" % (fuzz_function)
+        cflags += " -D FUZZ_FUNCTION=%d" % (fuzz_function)
+
+    fuzz_named_src = os.path.join(fuzz_reldir,
+                                  '%s.c' % (name))
+    # Work around an issue that WAF is invoked from up to 3 different
+    # directories so doesn't create a unique name for the multiple .o
+    # files like it would if called from just one place.
+    bld.SAMBA_GENERATOR(fuzz_named_src,
+                        source=fuzz_src,
+                        target=fuzz_named_src,
+                        rule='cp ${SRC} ${TGT}')
+
+    if auto_deps:
+        deps = "afl-fuzz-main talloc ndr NDR_%s" % interface.upper()
+    else:
+        deps = "afl-fuzz-main ndr-table NDR_DCERPC"
+
+    bld.SAMBA_BINARY(name, source=fuzz_named_src,
+                     cflags = cflags,
+                     deps = deps,
+                     fuzzer=True)
+
+Build.BuildContext.SAMBA_NDR_FUZZ = SAMBA_NDR_FUZZ
+
+# fuzz_ndr_X is generated from the list if IDL fed to PIDL
+# however there are exceptions to the normal pattern
+bld.SAMBA_NDR_FUZZ('IOXIDResolver') # oxidresolver.idl
+bld.SAMBA_NDR_FUZZ('IRemoteActivation') # remact.idl
+bld.SAMBA_NDR_FUZZ('iremotewinspool') # winspool.idl
+bld.SAMBA_NDR_FUZZ('FileServerVssAgent') # fsvrp.idl
+bld.SAMBA_NDR_FUZZ('lsarpc') # lsa.idl
+bld.SAMBA_NDR_FUZZ('netdfs') # dfs.idl
+bld.SAMBA_NDR_FUZZ('nfs4acl_interface') # nfs4acl.idl
+bld.SAMBA_NDR_FUZZ('rpcecho') # echo.idl
+
+# quota.idl
+bld.SAMBA_NDR_FUZZ('file_quota')
+bld.SAMBA_NDR_FUZZ('smb2_query_quota')
+bld.SAMBA_NDR_FUZZ('smb1_nt_transact_query_quota')
+
+# ioctl.idl
+bld.SAMBA_NDR_FUZZ('copychunk')
+bld.SAMBA_NDR_FUZZ('compression')
+bld.SAMBA_NDR_FUZZ('netinterface')
+bld.SAMBA_NDR_FUZZ('sparse')
+bld.SAMBA_NDR_FUZZ('resiliency')
+bld.SAMBA_NDR_FUZZ('trim')
+
+# WMI tables
+bld.SAMBA_NDR_FUZZ('IWbemClassObject')
+bld.SAMBA_NDR_FUZZ('IWbemServices')
+bld.SAMBA_NDR_FUZZ('IEnumWbemClassObject')
+bld.SAMBA_NDR_FUZZ('IWbemContext')
+bld.SAMBA_NDR_FUZZ('IWbemLevel1Login')
+bld.SAMBA_NDR_FUZZ('IWbemWCOSmartEnum')
+bld.SAMBA_NDR_FUZZ('IWbemFetchSmartEnum')
+bld.SAMBA_NDR_FUZZ('IWbemCallResult')
+bld.SAMBA_NDR_FUZZ('IWbemObjectSink')
+
+# DCOM tables
+bld.SAMBA_NDR_FUZZ('dcom_Unknown')
+bld.SAMBA_NDR_FUZZ('IUnknown')
+bld.SAMBA_NDR_FUZZ('IClassFactory')
+bld.SAMBA_NDR_FUZZ('IRemUnknown')
+bld.SAMBA_NDR_FUZZ('IClassActivator')
+bld.SAMBA_NDR_FUZZ('ISCMLocalActivator')
+bld.SAMBA_NDR_FUZZ('IMachineLocalActivator')
+bld.SAMBA_NDR_FUZZ('ILocalObjectExporter')
+bld.SAMBA_NDR_FUZZ('ISystemActivator')
+bld.SAMBA_NDR_FUZZ('IRemUnknown2')
+bld.SAMBA_NDR_FUZZ('IDispatch')
+bld.SAMBA_NDR_FUZZ('IMarshal')
+bld.SAMBA_NDR_FUZZ('ICoffeeMachine')
+bld.SAMBA_NDR_FUZZ('IStream')
+
+# Specific struct or function on the interface
+
+bld.SAMBA_NDR_FUZZ('spoolss',
+                   auto_deps=True,
+                   fuzz_type="TYPE_IN",
+                   fuzz_function=65)
diff --git a/lib/krb5_wrap/krb5_samba.c b/lib/krb5_wrap/krb5_samba.c
index 5aceae44eec..ee7055ea7b8 100644
--- a/lib/krb5_wrap/krb5_samba.c
+++ b/lib/krb5_wrap/krb5_samba.c
@@ -2979,56 +2979,6 @@ char *smb_get_krb5_error_message(krb5_context context,
 	return ret;
 }
 
-
-/**
- * @brief Return the kerberos library setting for: libdefaults:allow_weak_crypto
- *
- * @param[in]  context  The library context
- *
- * @return True if weak crypto is allowed, false if not.
- */
-krb5_boolean smb_krb5_get_allowed_weak_crypto(krb5_context context)
-#if defined(HAVE_KRB5_CONFIG_GET_BOOL_DEFAULT)
-{
-	return krb5_config_get_bool_default(context,
-					    NULL,
-					    FALSE,
-					    "libdefaults",
-					    "allow_weak_crypto",
-					    NULL);
-}
-#elif defined(HAVE_PROFILE_H) && defined(HAVE_KRB5_GET_PROFILE)
-{
-#include <profile.h>
-	krb5_error_code ret;
-	krb5_boolean ret_default = false;
-	profile_t profile;
-	int ret_profile;
-
-	ret = krb5_get_profile(context,
-			       &profile);
-	if (ret) {
-		return ret_default;
-	}
-
-	ret = profile_get_boolean(profile,
-				  "libdefaults",
-				  "allow_weak_crypto",
-				  NULL, /* subsubname */
-				  ret_default, /* def_val */
-				  &ret_profile /* *ret_default */);
-	if (ret) {
-		return ret_default;
-	}
-
-	profile_release(profile);
-
-	return ret_profile;
-}
-#else
-#error UNKNOWN_KRB5_CONFIG_ROUTINES
-#endif
-
 /**
  * @brief Return the type of a krb5_principal
  *
@@ -3611,6 +3561,12 @@ krb5_error_code smb_krb5_init_context_common(krb5_context *_krb5_context)
 			error_message(ret));
 	}
 #endif
+
+#ifdef SAMBA4_USES_HEIMDAL
+	/* Set options in kerberos */
+	krb5_set_dns_canonicalize_hostname(krb5_ctx, false);
+#endif
+
 	*_krb5_context = krb5_ctx;
 	return 0;
 }
diff --git a/lib/krb5_wrap/krb5_samba.h b/lib/krb5_wrap/krb5_samba.h
index b6ee04f60fe..64ae0275dbd 100644
--- a/lib/krb5_wrap/krb5_samba.h
+++ b/lib/krb5_wrap/krb5_samba.h
@@ -368,8 +368,6 @@ int smb_krb5_create_key_from_string(krb5_context context,
 				    krb5_enctype enctype,
 				    krb5_keyblock *key);
 
-krb5_boolean smb_krb5_get_allowed_weak_crypto(krb5_context context);
-
 #ifndef krb5_princ_size
 #if defined(HAVE_KRB5_PRINCIPAL_GET_NUM_COMP)
 #define krb5_princ_size krb5_principal_get_num_comp
diff --git a/lib/ldb/ABI/ldb-2.1.1.sigs b/lib/ldb/ABI/ldb-2.1.1.sigs
new file mode 100644
index 00000000000..5049dc64ce1
--- /dev/null
+++ b/lib/ldb/ABI/ldb-2.1.1.sigs
@@ -0,0 +1,283 @@
+ldb_add: int (struct ldb_context *, const struct ldb_message *)
+ldb_any_comparison: int (struct ldb_context *, void *, ldb_attr_handler_t, const struct ldb_val *, const struct ldb_val *)
+ldb_asprintf_errstring: void (struct ldb_context *, const char *, ...)
+ldb_attr_casefold: char *(TALLOC_CTX *, const char *)
+ldb_attr_dn: int (const char *)
+ldb_attr_in_list: int (const char * const *, const char *)
+ldb_attr_list_copy: const char **(TALLOC_CTX *, const char * const *)
+ldb_attr_list_copy_add: const char **(TALLOC_CTX *, const char * const *, const char *)
+ldb_base64_decode: int (char *)
+ldb_base64_encode: char *(TALLOC_CTX *, const char *, int)
+ldb_binary_decode: struct ldb_val (TALLOC_CTX *, const char *)
+ldb_binary_encode: char *(TALLOC_CTX *, struct ldb_val)
+ldb_binary_encode_string: char *(TALLOC_CTX *, const char *)
+ldb_build_add_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, const struct ldb_message *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_del_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, struct ldb_dn *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_extended_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, const char *, void *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_mod_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, const struct ldb_message *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_rename_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, struct ldb_dn *, struct ldb_dn *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_search_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, struct ldb_dn *, enum ldb_scope, const char *, const char * const *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_search_req_ex: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, struct ldb_dn *, enum ldb_scope, struct ldb_parse_tree *, const char * const *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_casefold: char *(struct ldb_context *, TALLOC_CTX *, const char *, size_t)
+ldb_casefold_default: char *(void *, TALLOC_CTX *, const char *, size_t)
+ldb_check_critical_controls: int (struct ldb_control **)
+ldb_comparison_binary: int (struct ldb_context *, void *, const struct ldb_val *, const struct ldb_val *)
+ldb_comparison_fold: int (struct ldb_context *, void *, const struct ldb_val *, const struct ldb_val *)
+ldb_connect: int (struct ldb_context *, const char *, unsigned int, const char **)
+ldb_control_to_string: char *(TALLOC_CTX *, const struct ldb_control *)
+ldb_controls_except_specified: struct ldb_control **(struct ldb_control **, TALLOC_CTX *, struct ldb_control *)
+ldb_debug: void (struct ldb_context *, enum ldb_debug_level, const char *, ...)
+ldb_debug_add: void (struct ldb_context *, const char *, ...)
+ldb_debug_end: void (struct ldb_context *, enum ldb_debug_level)
+ldb_debug_set: void (struct ldb_context *, enum ldb_debug_level, const char *, ...)
+ldb_delete: int (struct ldb_context *, struct ldb_dn *)
+ldb_dn_add_base: bool (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_add_base_fmt: bool (struct ldb_dn *, const char *, ...)
+ldb_dn_add_child: bool (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_add_child_fmt: bool (struct ldb_dn *, const char *, ...)
+ldb_dn_add_child_val: bool (struct ldb_dn *, const char *, struct ldb_val)
+ldb_dn_alloc_casefold: char *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_alloc_linearized: char *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_canonical_ex_string: char *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_canonical_string: char *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_check_local: bool (struct ldb_module *, struct ldb_dn *)
+ldb_dn_check_special: bool (struct ldb_dn *, const char *)
+ldb_dn_compare: int (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_compare_base: int (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_copy: struct ldb_dn *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_escape_value: char *(TALLOC_CTX *, struct ldb_val)
+ldb_dn_extended_add_syntax: int (struct ldb_context *, unsigned int, const struct ldb_dn_extended_syntax *)
+ldb_dn_extended_filter: void (struct ldb_dn *, const char * const *)
+ldb_dn_extended_syntax_by_name: const struct ldb_dn_extended_syntax *(struct ldb_context *, const char *)
+ldb_dn_from_ldb_val: struct ldb_dn *(TALLOC_CTX *, struct ldb_context *, const struct ldb_val *)
+ldb_dn_get_casefold: const char *(struct ldb_dn *)
+ldb_dn_get_comp_num: int (struct ldb_dn *)
+ldb_dn_get_component_name: const char *(struct ldb_dn *, unsigned int)
+ldb_dn_get_component_val: const struct ldb_val *(struct ldb_dn *, unsigned int)
+ldb_dn_get_extended_comp_num: int (struct ldb_dn *)
+ldb_dn_get_extended_component: const struct ldb_val *(struct ldb_dn *, const char *)
+ldb_dn_get_extended_linearized: char *(TALLOC_CTX *, struct ldb_dn *, int)
+ldb_dn_get_ldb_context: struct ldb_context *(struct ldb_dn *)
+ldb_dn_get_linearized: const char *(struct ldb_dn *)
+ldb_dn_get_parent: struct ldb_dn *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_get_rdn_name: const char *(struct ldb_dn *)
+ldb_dn_get_rdn_val: const struct ldb_val *(struct ldb_dn *)
+ldb_dn_has_extended: bool (struct ldb_dn *)
+ldb_dn_is_null: bool (struct ldb_dn *)
+ldb_dn_is_special: bool (struct ldb_dn *)
+ldb_dn_is_valid: bool (struct ldb_dn *)
+ldb_dn_map_local: struct ldb_dn *(struct ldb_module *, void *, struct ldb_dn *)
+ldb_dn_map_rebase_remote: struct ldb_dn *(struct ldb_module *, void *, struct ldb_dn *)
+ldb_dn_map_remote: struct ldb_dn *(struct ldb_module *, void *, struct ldb_dn *)
+ldb_dn_minimise: bool (struct ldb_dn *)
+ldb_dn_new: struct ldb_dn *(TALLOC_CTX *, struct ldb_context *, const char *)
+ldb_dn_new_fmt: struct ldb_dn *(TALLOC_CTX *, struct ldb_context *, const char *, ...)
+ldb_dn_remove_base_components: bool (struct ldb_dn *, unsigned int)
+ldb_dn_remove_child_components: bool (struct ldb_dn *, unsigned int)
+ldb_dn_remove_extended_components: void (struct ldb_dn *)
+ldb_dn_replace_components: bool (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_set_component: int (struct ldb_dn *, int, const char *, const struct ldb_val)
+ldb_dn_set_extended_component: int (struct ldb_dn *, const char *, const struct ldb_val *)
+ldb_dn_update_components: int (struct ldb_dn *, const struct ldb_dn *)
+ldb_dn_validate: bool (struct ldb_dn *)
+ldb_dump_results: void (struct ldb_context *, struct ldb_result *, FILE *)
+ldb_error_at: int (struct ldb_context *, int, const char *, const char *, int)
+ldb_errstring: const char *(struct ldb_context *)
+ldb_extended: int (struct ldb_context *, const char *, void *, struct ldb_result **)
+ldb_extended_default_callback: int (struct ldb_request *, struct ldb_reply *)
+ldb_filter_attrs: int (struct ldb_context *, const struct ldb_message *, const char * const *, struct ldb_message *)
+ldb_filter_from_tree: char *(TALLOC_CTX *, const struct ldb_parse_tree *)
+ldb_get_config_basedn: struct ldb_dn *(struct ldb_context *)
+ldb_get_create_perms: unsigned int (struct ldb_context *)
+ldb_get_default_basedn: struct ldb_dn *(struct ldb_context *)
+ldb_get_event_context: struct tevent_context *(struct ldb_context *)
+ldb_get_flags: unsigned int (struct ldb_context *)
+ldb_get_opaque: void *(struct ldb_context *, const char *)
+ldb_get_root_basedn: struct ldb_dn *(struct ldb_context *)
+ldb_get_schema_basedn: struct ldb_dn *(struct ldb_context *)
+ldb_global_init: int (void)
+ldb_handle_get_event_context: struct tevent_context *(struct ldb_handle *)
+ldb_handle_new: struct ldb_handle *(TALLOC_CTX *, struct ldb_context *)
+ldb_handle_use_global_event_context: void (struct ldb_handle *)
+ldb_handler_copy: int (struct ldb_context *, void *, const struct ldb_val *, struct ldb_val *)
+ldb_handler_fold: int (struct ldb_context *, void *, const struct ldb_val *, struct ldb_val *)
+ldb_init: struct ldb_context *(TALLOC_CTX *, struct tevent_context *)
+ldb_ldif_message_redacted_string: char *(struct ldb_context *, TALLOC_CTX *, enum ldb_changetype, const struct ldb_message *)
+ldb_ldif_message_string: char *(struct ldb_context *, TALLOC_CTX *, enum ldb_changetype, const struct ldb_message *)
+ldb_ldif_parse_modrdn: int (struct ldb_context *, const struct ldb_ldif *, TALLOC_CTX *, struct ldb_dn **, struct ldb_dn **, bool *, struct ldb_dn **, struct ldb_dn **)
+ldb_ldif_read: struct ldb_ldif *(struct ldb_context *, int (*)(void *), void *)
+ldb_ldif_read_file: struct ldb_ldif *(struct ldb_context *, FILE *)
+ldb_ldif_read_file_state: struct ldb_ldif *(struct ldb_context *, struct ldif_read_file_state *)
+ldb_ldif_read_free: void (struct ldb_context *, struct ldb_ldif *)
+ldb_ldif_read_string: struct ldb_ldif *(struct ldb_context *, const char **)
+ldb_ldif_write: int (struct ldb_context *, int (*)(void *, const char *, ...), void *, const struct ldb_ldif *)
+ldb_ldif_write_file: int (struct ldb_context *, FILE *, const struct ldb_ldif *)
+ldb_ldif_write_redacted_trace_string: char *(struct ldb_context *, TALLOC_CTX *, const struct ldb_ldif *)
+ldb_ldif_write_string: char *(struct ldb_context *, TALLOC_CTX *, const struct ldb_ldif *)
+ldb_load_modules: int (struct ldb_context *, const char **)
+ldb_map_add: int (struct ldb_module *, struct ldb_request *)
+ldb_map_delete: int (struct ldb_module *, struct ldb_request *)
+ldb_map_init: int (struct ldb_module *, const struct ldb_map_attribute *, const struct ldb_map_objectclass *, const char * const *, const char *, const char *)
+ldb_map_modify: int (struct ldb_module *, struct ldb_request *)
+ldb_map_rename: int (struct ldb_module *, struct ldb_request *)
+ldb_map_search: int (struct ldb_module *, struct ldb_request *)
+ldb_match_message: int (struct ldb_context *, const struct ldb_message *, const struct ldb_parse_tree *, enum ldb_scope, bool *)
+ldb_match_msg: int (struct ldb_context *, const struct ldb_message *, const struct ldb_parse_tree *, struct ldb_dn *, enum ldb_scope)
+ldb_match_msg_error: int (struct ldb_context *, const struct ldb_message *, const struct ldb_parse_tree *, struct ldb_dn *, enum ldb_scope, bool *)
+ldb_match_msg_objectclass: int (const struct ldb_message *, const char *)
+ldb_mod_register_control: int (struct ldb_module *, const char *)
+ldb_modify: int (struct ldb_context *, const struct ldb_message *)
+ldb_modify_default_callback: int (struct ldb_request *, struct ldb_reply *)
+ldb_module_call_chain: char *(struct ldb_request *, TALLOC_CTX *)
+ldb_module_connect_backend: int (struct ldb_context *, const char *, const char **, struct ldb_module **)
+ldb_module_done: int (struct ldb_request *, struct ldb_control **, struct ldb_extended *, int)
+ldb_module_flags: uint32_t (struct ldb_context *)
+ldb_module_get_ctx: struct ldb_context *(struct ldb_module *)
+ldb_module_get_name: const char *(struct ldb_module *)
+ldb_module_get_ops: const struct ldb_module_ops *(struct ldb_module *)
+ldb_module_get_private: void *(struct ldb_module *)
+ldb_module_init_chain: int (struct ldb_context *, struct ldb_module *)
+ldb_module_load_list: int (struct ldb_context *, const char **, struct ldb_module *, struct ldb_module **)
+ldb_module_new: struct ldb_module *(TALLOC_CTX *, struct ldb_context *, const char *, const struct ldb_module_ops *)
+ldb_module_next: struct ldb_module *(struct ldb_module *)
+ldb_module_popt_options: struct poptOption **(struct ldb_context *)
+ldb_module_send_entry: int (struct ldb_request *, struct ldb_message *, struct ldb_control **)
+ldb_module_send_referral: int (struct ldb_request *, char *)
+ldb_module_set_next: void (struct ldb_module *, struct ldb_module *)
+ldb_module_set_private: void (struct ldb_module *, void *)
+ldb_modules_hook: int (struct ldb_context *, enum ldb_module_hook_type)
+ldb_modules_list_from_string: const char **(struct ldb_context *, TALLOC_CTX *, const char *)
+ldb_modules_load: int (const char *, const char *)
+ldb_msg_add: int (struct ldb_message *, const struct ldb_message_element *, int)
+ldb_msg_add_empty: int (struct ldb_message *, const char *, int, struct ldb_message_element **)
+ldb_msg_add_fmt: int (struct ldb_message *, const char *, const char *, ...)
+ldb_msg_add_linearized_dn: int (struct ldb_message *, const char *, struct ldb_dn *)
+ldb_msg_add_steal_string: int (struct ldb_message *, const char *, char *)
+ldb_msg_add_steal_value: int (struct ldb_message *, const char *, struct ldb_val *)
+ldb_msg_add_string: int (struct ldb_message *, const char *, const char *)
+ldb_msg_add_value: int (struct ldb_message *, const char *, const struct ldb_val *, struct ldb_message_element **)
+ldb_msg_canonicalize: struct ldb_message *(struct ldb_context *, const struct ldb_message *)
+ldb_msg_check_string_attribute: int (const struct ldb_message *, const char *, const char *)
+ldb_msg_copy: struct ldb_message *(TALLOC_CTX *, const struct ldb_message *)
+ldb_msg_copy_attr: int (struct ldb_message *, const char *, const char *)
+ldb_msg_copy_shallow: struct ldb_message *(TALLOC_CTX *, const struct ldb_message *)
+ldb_msg_diff: struct ldb_message *(struct ldb_context *, struct ldb_message *, struct ldb_message *)
+ldb_msg_difference: int (struct ldb_context *, TALLOC_CTX *, struct ldb_message *, struct ldb_message *, struct ldb_message **)
+ldb_msg_element_compare: int (struct ldb_message_element *, struct ldb_message_element *)
+ldb_msg_element_compare_name: int (struct ldb_message_element *, struct ldb_message_element *)
+ldb_msg_element_equal_ordered: bool (const struct ldb_message_element *, const struct ldb_message_element *)
+ldb_msg_find_attr_as_bool: int (const struct ldb_message *, const char *, int)
+ldb_msg_find_attr_as_dn: struct ldb_dn *(struct ldb_context *, TALLOC_CTX *, const struct ldb_message *, const char *)
+ldb_msg_find_attr_as_double: double (const struct ldb_message *, const char *, double)
+ldb_msg_find_attr_as_int: int (const struct ldb_message *, const char *, int)
+ldb_msg_find_attr_as_int64: int64_t (const struct ldb_message *, const char *, int64_t)
+ldb_msg_find_attr_as_string: const char *(const struct ldb_message *, const char *, const char *)
+ldb_msg_find_attr_as_uint: unsigned int (const struct ldb_message *, const char *, unsigned int)
+ldb_msg_find_attr_as_uint64: uint64_t (const struct ldb_message *, const char *, uint64_t)
+ldb_msg_find_common_values: int (struct ldb_context *, TALLOC_CTX *, struct ldb_message_element *, struct ldb_message_element *, uint32_t)
+ldb_msg_find_duplicate_val: int (struct ldb_context *, TALLOC_CTX *, const struct ldb_message_element *, struct ldb_val **, uint32_t)
+ldb_msg_find_element: struct ldb_message_element *(const struct ldb_message *, const char *)
+ldb_msg_find_ldb_val: const struct ldb_val *(const struct ldb_message *, const char *)
+ldb_msg_find_val: struct ldb_val *(const struct ldb_message_element *, struct ldb_val *)
+ldb_msg_new: struct ldb_message *(TALLOC_CTX *)
+ldb_msg_normalize: int (struct ldb_context *, TALLOC_CTX *, const struct ldb_message *, struct ldb_message **)
+ldb_msg_remove_attr: void (struct ldb_message *, const char *)
+ldb_msg_remove_element: void (struct ldb_message *, struct ldb_message_element *)
+ldb_msg_rename_attr: int (struct ldb_message *, const char *, const char *)
+ldb_msg_sanity_check: int (struct ldb_context *, const struct ldb_message *)
+ldb_msg_sort_elements: void (struct ldb_message *)
+ldb_next_del_trans: int (struct ldb_module *)
+ldb_next_end_trans: int (struct ldb_module *)
+ldb_next_init: int (struct ldb_module *)
+ldb_next_prepare_commit: int (struct ldb_module *)
+ldb_next_read_lock: int (struct ldb_module *)
+ldb_next_read_unlock: int (struct ldb_module *)
+ldb_next_remote_request: int (struct ldb_module *, struct ldb_request *)
+ldb_next_request: int (struct ldb_module *, struct ldb_request *)
+ldb_next_start_trans: int (struct ldb_module *)
+ldb_op_default_callback: int (struct ldb_request *, struct ldb_reply *)
+ldb_options_copy: const char **(TALLOC_CTX *, const char **)
+ldb_options_find: const char *(struct ldb_context *, const char **, const char *)
+ldb_options_get: const char **(struct ldb_context *)
+ldb_pack_data: int (struct ldb_context *, const struct ldb_message *, struct ldb_val *, uint32_t)
+ldb_parse_control_from_string: struct ldb_control *(struct ldb_context *, TALLOC_CTX *, const char *)
+ldb_parse_control_strings: struct ldb_control **(struct ldb_context *, TALLOC_CTX *, const char **)
+ldb_parse_tree: struct ldb_parse_tree *(TALLOC_CTX *, const char *)
+ldb_parse_tree_attr_replace: void (struct ldb_parse_tree *, const char *, const char *)
+ldb_parse_tree_copy_shallow: struct ldb_parse_tree *(TALLOC_CTX *, const struct ldb_parse_tree *)
+ldb_parse_tree_walk: int (struct ldb_parse_tree *, int (*)(struct ldb_parse_tree *, void *), void *)
+ldb_qsort: void (void * const, size_t, size_t, void *, ldb_qsort_cmp_fn_t)
+ldb_register_backend: int (const char *, ldb_connect_fn, bool)
+ldb_register_extended_match_rule: int (struct ldb_context *, const struct ldb_extended_match_rule *)
+ldb_register_hook: int (ldb_hook_fn)
+ldb_register_module: int (const struct ldb_module_ops *)
+ldb_rename: int (struct ldb_context *, struct ldb_dn *, struct ldb_dn *)
+ldb_reply_add_control: int (struct ldb_reply *, const char *, bool, void *)
+ldb_reply_get_control: struct ldb_control *(struct ldb_reply *, const char *)
+ldb_req_get_custom_flags: uint32_t (struct ldb_request *)
+ldb_req_is_untrusted: bool (struct ldb_request *)
+ldb_req_location: const char *(struct ldb_request *)
+ldb_req_mark_trusted: void (struct ldb_request *)
+ldb_req_mark_untrusted: void (struct ldb_request *)
+ldb_req_set_custom_flags: void (struct ldb_request *, uint32_t)
+ldb_req_set_location: void (struct ldb_request *, const char *)
+ldb_request: int (struct ldb_context *, struct ldb_request *)
+ldb_request_add_control: int (struct ldb_request *, const char *, bool, void *)
+ldb_request_done: int (struct ldb_request *, int)
+ldb_request_get_control: struct ldb_control *(struct ldb_request *, const char *)
+ldb_request_get_status: int (struct ldb_request *)
+ldb_request_replace_control: int (struct ldb_request *, const char *, bool, void *)
+ldb_request_set_state: void (struct ldb_request *, int)
+ldb_reset_err_string: void (struct ldb_context *)
+ldb_save_controls: int (struct ldb_control *, struct ldb_request *, struct ldb_control ***)
+ldb_schema_attribute_add: int (struct ldb_context *, const char *, unsigned int, const char *)
+ldb_schema_attribute_add_with_syntax: int (struct ldb_context *, const char *, unsigned int, const struct ldb_schema_syntax *)
+ldb_schema_attribute_by_name: const struct ldb_schema_attribute *(struct ldb_context *, const char *)
+ldb_schema_attribute_fill_with_syntax: int (struct ldb_context *, TALLOC_CTX *, const char *, unsigned int, const struct ldb_schema_syntax *, struct ldb_schema_attribute *)
+ldb_schema_attribute_remove: void (struct ldb_context *, const char *)
+ldb_schema_attribute_remove_flagged: void (struct ldb_context *, unsigned int)
+ldb_schema_attribute_set_override_handler: void (struct ldb_context *, ldb_attribute_handler_override_fn_t, void *)
+ldb_schema_set_override_GUID_index: void (struct ldb_context *, const char *, const char *)
+ldb_schema_set_override_indexlist: void (struct ldb_context *, bool)
+ldb_search: int (struct ldb_context *, TALLOC_CTX *, struct ldb_result **, struct ldb_dn *, enum ldb_scope, const char * const *, const char *, ...)
+ldb_search_default_callback: int (struct ldb_request *, struct ldb_reply *)
+ldb_sequence_number: int (struct ldb_context *, enum ldb_sequence_type, uint64_t *)
+ldb_set_create_perms: void (struct ldb_context *, unsigned int)
+ldb_set_debug: int (struct ldb_context *, void (*)(void *, enum ldb_debug_level, const char *, va_list), void *)
+ldb_set_debug_stderr: int (struct ldb_context *)
+ldb_set_default_dns: void (struct ldb_context *)
+ldb_set_errstring: void (struct ldb_context *, const char *)
+ldb_set_event_context: void (struct ldb_context *, struct tevent_context *)
+ldb_set_flags: void (struct ldb_context *, unsigned int)
+ldb_set_modules_dir: void (struct ldb_context *, const char *)
+ldb_set_opaque: int (struct ldb_context *, const char *, void *)
+ldb_set_require_private_event_context: void (struct ldb_context *)
+ldb_set_timeout: int (struct ldb_context *, struct ldb_request *, int)
+ldb_set_timeout_from_prev_req: int (struct ldb_context *, struct ldb_request *, struct ldb_request *)
+ldb_set_utf8_default: void (struct ldb_context *)
+ldb_set_utf8_fns: void (struct ldb_context *, void *, char *(*)(void *, void *, const char *, size_t))
+ldb_setup_wellknown_attributes: int (struct ldb_context *)
+ldb_should_b64_encode: int (struct ldb_context *, const struct ldb_val *)
+ldb_standard_syntax_by_name: const struct ldb_schema_syntax *(struct ldb_context *, const char *)
+ldb_strerror: const char *(int)
+ldb_string_to_time: time_t (const char *)
+ldb_string_utc_to_time: time_t (const char *)
+ldb_timestring: char *(TALLOC_CTX *, time_t)
+ldb_timestring_utc: char *(TALLOC_CTX *, time_t)
+ldb_transaction_cancel: int (struct ldb_context *)
+ldb_transaction_cancel_noerr: int (struct ldb_context *)
+ldb_transaction_commit: int (struct ldb_context *)
+ldb_transaction_prepare_commit: int (struct ldb_context *)
+ldb_transaction_start: int (struct ldb_context *)
+ldb_unpack_data: int (struct ldb_context *, const struct ldb_val *, struct ldb_message *)
+ldb_unpack_data_flags: int (struct ldb_context *, const struct ldb_val *, struct ldb_message *, unsigned int)
+ldb_unpack_get_format: int (const struct ldb_val *, uint32_t *)
+ldb_val_dup: struct ldb_val (TALLOC_CTX *, const struct ldb_val *)
+ldb_val_equal_exact: int (const struct ldb_val *, const struct ldb_val *)
+ldb_val_map_local: struct ldb_val (struct ldb_module *, void *, const struct ldb_map_attribute *, const struct ldb_val *)
+ldb_val_map_remote: struct ldb_val (struct ldb_module *, void *, const struct ldb_map_attribute *, const struct ldb_val *)
+ldb_val_string_cmp: int (const struct ldb_val *, const char *)
+ldb_val_to_time: int (const struct ldb_val *, time_t *)
+ldb_valid_attr_name: int (const char *)
+ldb_vdebug: void (struct ldb_context *, enum ldb_debug_level, const char *, va_list)
+ldb_wait: int (struct ldb_handle *, enum ldb_wait_type)
diff --git a/lib/ldb/ABI/pyldb-util-2.1.1.sigs b/lib/ldb/ABI/pyldb-util-2.1.1.sigs
new file mode 100644
index 00000000000..164a806b2ff
--- /dev/null
+++ b/lib/ldb/ABI/pyldb-util-2.1.1.sigs
@@ -0,0 +1,3 @@
+pyldb_Dn_FromDn: PyObject *(struct ldb_dn *)
+pyldb_Object_AsDn: bool (TALLOC_CTX *, PyObject *, struct ldb_context *, struct ldb_dn **)
+pyldb_check_type: bool (PyObject *, const char *)
diff --git a/lib/ldb/common/ldb.c b/lib/ldb/common/ldb.c
index 95e9138a56b..8c86dca45a1 100644
--- a/lib/ldb/common/ldb.c
+++ b/lib/ldb/common/ldb.c
@@ -1392,8 +1392,8 @@ int ldb_op_default_callback(struct ldb_request *req, struct ldb_reply *ares)
 	}
 
 	if (ares->type != LDB_REPLY_DONE) {
-		talloc_free(ares);
 		ldb_asprintf_errstring(req->handle->ldb, "Invalid LDB reply type %d", ares->type);
+		TALLOC_FREE(ares);
 		return ldb_request_done(req, LDB_ERR_OPERATIONS_ERROR);
 	}
 
diff --git a/lib/ldb/common/ldb_controls.c b/lib/ldb/common/ldb_controls.c
index e0f0eb48f3a..4af06a436ab 100644
--- a/lib/ldb/common/ldb_controls.c
+++ b/lib/ldb/common/ldb_controls.c
@@ -814,7 +814,7 @@ struct ldb_control *ldb_parse_control_from_string(struct ldb_context *ldb, TALLO
 		ret = sscanf(p, "%d", &crit);
 		if ((ret != 1) || (crit < 0) || (crit > 1)) {
 			ldb_set_errstring(ldb,
-					  "invalid bypassopreational control syntax\n"
+					  "invalid bypassoperational control syntax\n"
 					  " syntax: crit(b)\n"
 					  "   note: b = boolean");
 			talloc_free(ctrl);
@@ -1282,6 +1282,7 @@ struct ldb_control *ldb_parse_control_from_string(struct ldb_context *ldb, TALLO
 	/*
 	 * When no matching control has been found.
 	 */
+	TALLOC_FREE(ctrl);
 	return NULL;
 }
 
diff --git a/lib/ldb/ldb_key_value/ldb_kv_index.c b/lib/ldb/ldb_key_value/ldb_kv_index.c
index 0853b28fe40..a7e341552ea 100644
--- a/lib/ldb/ldb_key_value/ldb_kv_index.c
+++ b/lib/ldb/ldb_key_value/ldb_kv_index.c
@@ -1175,7 +1175,7 @@ static struct ldb_dn *ldb_kv_index_key(struct ldb_context *ldb,
 		}
 	}
 
-	if (v.data != value->data && !empty_val) {
+	if (value != NULL && v.data != value->data && !empty_val) {
 		talloc_free(v.data);
 	}
 	talloc_free(attr_folded);
@@ -2113,16 +2113,19 @@ static int ldb_kv_index_dn_one(struct ldb_module *module,
 			       struct dn_list *list,
 			       enum key_truncation *truncation)
 {
-	/*
-	 * Ensure we do not shortcut on intersection for this list.
-	 * We must never be lazy and return an entry not in this
-	 * list.  This allows the index for
-	 * SCOPE_ONELEVEL to be trusted.
-	 */
-
-	list->strict = true;
-	return ldb_kv_index_dn_attr(
+	int ret = ldb_kv_index_dn_attr(
 	    module, ldb_kv, LDB_KV_IDXONE, parent_dn, list, truncation);
+	if (ret == LDB_SUCCESS) {
+		/*
+		 * Ensure we do not shortcut on intersection for this
+		 * list.  We must never be lazy and return an entry
+		 * not in this list.  This allows the index for
+		 * SCOPE_ONELEVEL to be trusted.
+		 */
+
+		list->strict = true;
+	}
+	return ret;
 }
 
 /*
diff --git a/lib/ldb/tests/ldb_key_value_sub_txn_test.c b/lib/ldb/tests/ldb_key_value_sub_txn_test.c
index e71f81b866e..1eafd2d79e9 100644
--- a/lib/ldb/tests/ldb_key_value_sub_txn_test.c
+++ b/lib/ldb/tests/ldb_key_value_sub_txn_test.c
@@ -37,6 +37,7 @@
  */
 #include <stdarg.h>
 #include <stddef.h>
+#include <stdint.h>
 #include <setjmp.h>
 #include <cmocka.h>
 
diff --git a/lib/ldb/tests/ldb_key_value_test.c b/lib/ldb/tests/ldb_key_value_test.c
index 3f31bb98350..458452e5dc4 100644
--- a/lib/ldb/tests/ldb_key_value_test.c
+++ b/lib/ldb/tests/ldb_key_value_test.c
@@ -39,6 +39,7 @@
  */
 #include <stdarg.h>
 #include <stddef.h>
+#include <stdint.h>
 #include <setjmp.h>
 #include <cmocka.h>
 
diff --git a/lib/ldb/tests/ldb_kv_ops_test.c b/lib/ldb/tests/ldb_kv_ops_test.c
index 98b5a433f1a..30adebf1952 100644
--- a/lib/ldb/tests/ldb_kv_ops_test.c
+++ b/lib/ldb/tests/ldb_kv_ops_test.c
@@ -818,7 +818,7 @@ static void do_iterate_range_test(void **state, int range_start,
 	int ret;
 	struct test_ctx *test_ctx = talloc_get_type_abort(*state,
 							  struct test_ctx);
-	struct ldb_kv_private *ldb_kv = get_ldb_kv(test_ctx->ldb);
+	struct ldb_kv_private *ldb_kv = NULL;
 	int i;
 	int num_recs = 1024;
 	int skip_recs = 10;
@@ -827,6 +827,9 @@ static void do_iterate_range_test(void **state, int range_start,
 
 	TALLOC_CTX *tmp_ctx;
 
+	ldb_kv = get_ldb_kv(test_ctx->ldb);
+	assert_non_null(ldb_kv);
+
 	for (i = 0; i < num_recs; i++){
 		visits[i] = 0;
 	}
@@ -1715,7 +1718,7 @@ static void test_get_size(void **state)
 	 * The tdb implementation of get_size over estimates for sparse files
 	 * which is perfectly acceptable for it's intended use.
 	 */
-	assert_true( size > 2500);
+	assert_in_range(size, 2500, 5000);
 #endif
 
 	/*
@@ -1739,6 +1742,12 @@ static void test_get_size(void **state)
 	size = ldb_kv->kv_ops->get_size(ldb_kv);
 #ifdef TEST_LMDB
 	assert_int_equal(3, size);
+#else
+	/*
+	 * The tdb implementation of get_size over estimates for sparse files
+	 * which is perfectly acceptable for it's intended use.
+	 */
+	assert_in_range(size, 2500, 5000);
 #endif
 	talloc_free(tmp_ctx);
 }
diff --git a/lib/ldb/tests/ldb_lmdb_size_test.c b/lib/ldb/tests/ldb_lmdb_size_test.c
index c0c4fe87204..95eba878ba7 100644
--- a/lib/ldb/tests/ldb_lmdb_size_test.c
+++ b/lib/ldb/tests/ldb_lmdb_size_test.c
@@ -43,6 +43,7 @@
  */
 #include <stdarg.h>
 #include <stddef.h>
+#include <stdint.h>
 #include <setjmp.h>
 #include <cmocka.h>
 
diff --git a/lib/ldb/tests/ldb_lmdb_test.c b/lib/ldb/tests/ldb_lmdb_test.c
index 78758bbbe16..798a1916281 100644
--- a/lib/ldb/tests/ldb_lmdb_test.c
+++ b/lib/ldb/tests/ldb_lmdb_test.c
@@ -40,6 +40,7 @@
  */
 #include <stdarg.h>
 #include <stddef.h>
+#include <stdint.h>
 #include <setjmp.h>
 #include <cmocka.h>
 
diff --git a/lib/ldb/tests/ldb_mod_op_test.c b/lib/ldb/tests/ldb_mod_op_test.c
index b6a0d1e4f57..0aa9ac2ce27 100644
--- a/lib/ldb/tests/ldb_mod_op_test.c
+++ b/lib/ldb/tests/ldb_mod_op_test.c
@@ -53,6 +53,7 @@ struct ldbtest_ctx {
 	const char *lockfile;   /* lockfile is separate */
 
 	const char *dbpath;
+	char *debug_string;
 };
 
 static void unlink_old_db(struct ldbtest_ctx *test_ctx)
@@ -3747,9 +3748,11 @@ static void test_ldb_add_to_index_unique_values_required(void **state)
 static void ldb_debug_string(void *context, enum ldb_debug_level level,
 			     const char *fmt, va_list ap)
 {
+	struct ldbtest_ctx *test_ctx =
+		talloc_get_type_abort(context, struct ldbtest_ctx);
 
 	if (level <= LDB_DEBUG_WARNING) {
-		*((char **)context) = talloc_vasprintf(NULL, fmt, ap);
+		test_ctx->debug_string = talloc_vasprintf(test_ctx, fmt, ap);
 	}
 }
 
@@ -3761,7 +3764,6 @@ static void test_ldb_unique_index_duplicate_logging(void **state)
 	struct ldbtest_ctx *test_ctx = talloc_get_type_abort(*state,
 							struct ldbtest_ctx);
 	TALLOC_CTX *tmp_ctx;
-	char *debug_string = NULL;
 	char *p = NULL;
 
 	/* The GUID mode is not compatible with this test */
@@ -3769,7 +3771,7 @@ static void test_ldb_unique_index_duplicate_logging(void **state)
 	return;
 #endif
 
-	ldb_set_debug(test_ctx->ldb, ldb_debug_string, &debug_string);
+	ldb_set_debug(test_ctx->ldb, ldb_debug_string, test_ctx);
 	tmp_ctx = talloc_new(test_ctx);
 	assert_non_null(tmp_ctx);
 
@@ -3803,14 +3805,14 @@ static void test_ldb_unique_index_duplicate_logging(void **state)
 	ret = ldb_add(test_ctx->ldb, msg02);
 	assert_int_equal(ret, LDB_ERR_CONSTRAINT_VIOLATION);
 
-	assert_non_null(debug_string);
+	assert_non_null(test_ctx->debug_string);
 	p = strstr(
-		debug_string,
+		test_ctx->debug_string,
 		"unique index violation on cn "
 		"in dc=test02, conflicts with dc=test01 in "
 		"@INDEX:CN:test_unique_index");
 	assert_non_null(p);
-	TALLOC_FREE(debug_string);
+	TALLOC_FREE(test_ctx->debug_string);
 	talloc_free(tmp_ctx);
 }
 
@@ -3822,14 +3824,13 @@ static void test_ldb_duplicate_dn_logging(void **state)
 	struct ldbtest_ctx *test_ctx = talloc_get_type_abort(*state,
 							struct ldbtest_ctx);
 	TALLOC_CTX *tmp_ctx;
-	char *debug_string = NULL;
 
 	/* The GUID mode is not compatible with this test */
 #ifdef GUID_IDX
 	return;
 #endif
 
-	ldb_set_debug(test_ctx->ldb, ldb_debug_string, &debug_string);
+	ldb_set_debug(test_ctx->ldb, ldb_debug_string, test_ctx);
 	tmp_ctx = talloc_new(test_ctx);
 	assert_non_null(tmp_ctx);
 
@@ -3863,7 +3864,7 @@ static void test_ldb_duplicate_dn_logging(void **state)
 	ret = ldb_add(test_ctx->ldb, msg02);
 	assert_int_equal(ret, LDB_ERR_ENTRY_ALREADY_EXISTS);
 
-	assert_null(debug_string);
+	assert_null(test_ctx->debug_string);
 	talloc_free(tmp_ctx);
 }
 
@@ -3951,10 +3952,9 @@ static void test_ldb_unique_index_duplicate_with_guid(void **state)
 	struct ldbtest_ctx *test_ctx = talloc_get_type_abort(*state,
 							struct ldbtest_ctx);
 	TALLOC_CTX *tmp_ctx;
-	char *debug_string = NULL;
 	char *p = NULL;
 
-	ldb_set_debug(test_ctx->ldb, ldb_debug_string, &debug_string);
+	ldb_set_debug(test_ctx->ldb, ldb_debug_string, test_ctx);
 	tmp_ctx = talloc_new(test_ctx);
 	assert_non_null(tmp_ctx);
 
@@ -3988,15 +3988,14 @@ static void test_ldb_unique_index_duplicate_with_guid(void **state)
 	ret = ldb_add(test_ctx->ldb, msg02);
 	assert_int_equal(ret, LDB_ERR_CONSTRAINT_VIOLATION);
 
-	assert_non_null(debug_string);
+	assert_non_null(test_ctx->debug_string);
 	p = strstr(
-		debug_string,
+		test_ctx->debug_string,
 		"unique index violation on cn in dc=test02, conflicts with "
 		"objectUUID 0123456789abcdef in @INDEX:CN:test_unique_index");
 	assert_non_null(p);
-	TALLOC_FREE(debug_string);
+	TALLOC_FREE(test_ctx->debug_string);
 	talloc_free(tmp_ctx);
-	ldb_set_debug(test_ctx->ldb, NULL, NULL);
 }
 
 static void test_ldb_guid_index_duplicate_dn_logging(void **state)
@@ -4007,9 +4006,8 @@ static void test_ldb_guid_index_duplicate_dn_logging(void **state)
 	struct ldbtest_ctx *test_ctx = talloc_get_type_abort(*state,
 							struct ldbtest_ctx);
 	TALLOC_CTX *tmp_ctx;
-	char *debug_string = NULL;
 
-	ldb_set_debug(test_ctx->ldb, ldb_debug_string, &debug_string);
+	ldb_set_debug(test_ctx->ldb, ldb_debug_string, test_ctx);
 	tmp_ctx = talloc_new(test_ctx);
 	assert_non_null(tmp_ctx);
 
@@ -4043,9 +4041,8 @@ static void test_ldb_guid_index_duplicate_dn_logging(void **state)
 	ret = ldb_add(test_ctx->ldb, msg02);
 	assert_int_equal(ret, LDB_ERR_ENTRY_ALREADY_EXISTS);
 
-	assert_null(debug_string);
+	assert_null(test_ctx->debug_string);
 	talloc_free(tmp_ctx);
-	ldb_set_debug(test_ctx->ldb, NULL, NULL);
 }
 
 static void test_ldb_talloc_destructor_transaction_cleanup(void **state)
@@ -4717,5 +4714,9 @@ int main(int argc, const char **argv)
 			ldbtest_teardown),
 	};
 
+	if (argc > 1) {
+		cmocka_set_test_filter(argv[1]);
+	}
+
 	return cmocka_run_group_tests(tests, NULL, NULL);
 }
diff --git a/lib/ldb/tests/ldb_no_lmdb_test.c b/lib/ldb/tests/ldb_no_lmdb_test.c
index 8e5a6eee8d2..be23d744004 100644
--- a/lib/ldb/tests/ldb_no_lmdb_test.c
+++ b/lib/ldb/tests/ldb_no_lmdb_test.c
@@ -40,6 +40,7 @@
  */
 #include <stdarg.h>
 #include <stddef.h>
+#include <stdint.h>
 #include <setjmp.h>
 #include <cmocka.h>
 
diff --git a/lib/ldb/tests/python/api.py b/lib/ldb/tests/python/api.py
index 4d55566a4ac..1d3d765e607 100755
--- a/lib/ldb/tests/python/api.py
+++ b/lib/ldb/tests/python/api.py
@@ -774,6 +774,60 @@ class SearchTests(LdbBaseTest):
         # instead use just the 16 bytes raw, which we just keep
         # to printable chars here for ease of handling.
 
+        self.l.add({"dn": "DC=ORG",
+                    "name": b"org",
+                    "objectUUID": b"0000000000abcdef"})
+        self.l.add({"dn": "DC=EXAMPLE,DC=ORG",
+                    "name": b"org",
+                    "objectUUID": b"0000000001abcdef"})
+        self.l.add({"dn": "OU=OU1,DC=EXAMPLE,DC=ORG",
+                    "name": b"OU #1",
+                    "x": "y", "y": "a",
+                    "objectUUID": b"0023456789abcde3"})
+        self.l.add({"dn": "OU=OU2,DC=EXAMPLE,DC=ORG",
+                    "name": b"OU #2",
+                    "x": "y", "y": "a",
+                    "objectUUID": b"0023456789abcde4"})
+        self.l.add({"dn": "OU=OU3,DC=EXAMPLE,DC=ORG",
+                    "name": b"OU #3",
+                    "x": "y", "y": "a",
+                    "objectUUID": b"0023456789abcde5"})
+        self.l.add({"dn": "OU=OU4,DC=EXAMPLE,DC=ORG",
+                    "name": b"OU #4",
+                    "x": "z", "y": "b",
+                    "objectUUID": b"0023456789abcde6"})
+        self.l.add({"dn": "OU=OU5,DC=EXAMPLE,DC=ORG",
+                    "name": b"OU #5",
+                    "x": "y", "y": "a",
+                    "objectUUID": b"0023456789abcde7"})
+        self.l.add({"dn": "OU=OU6,DC=EXAMPLE,DC=ORG",
+                    "name": b"OU #6",
+                    "x": "y", "y": "a",
+                    "objectUUID": b"0023456789abcde8"})
+        self.l.add({"dn": "OU=OU7,DC=EXAMPLE,DC=ORG",
+                    "name": b"OU #7",
+                    "x": "y", "y": "c",
+                    "objectUUID": b"0023456789abcde9"})
+        self.l.add({"dn": "OU=OU8,DC=EXAMPLE,DC=ORG",
+                    "name": b"OU #8",
+                    "x": "y", "y": "b",
+                    "objectUUID": b"0023456789abcde0"})
+        self.l.add({"dn": "OU=OU9,DC=EXAMPLE,DC=ORG",
+                    "name": b"OU #9",
+                    "x": "y", "y": "a",
+                    "objectUUID": b"0023456789abcdea"})
+
+        self.l.add({"dn": "DC=EXAMPLE,DC=COM",
+                    "name": b"org",
+                    "objectUUID": b"0000000011abcdef"})
+
+        self.l.add({"dn": "DC=EXAMPLE,DC=NET",
+                    "name": b"org",
+                    "objectUUID": b"0000000021abcdef"})
+
+        self.l.add({"dn": "OU=UNIQUE,DC=EXAMPLE,DC=NET",
+                    "objectUUID": b"0000000022abcdef"})
+
         self.l.add({"dn": "DC=SAMBA,DC=ORG",
                     "name": b"samba.org",
                     "objectUUID": b"0123456789abcdef"})
@@ -957,6 +1011,38 @@ class SearchTests(LdbBaseTest):
             enum = err.args[0]
             self.assertEqual(enum, ldb.ERR_NO_SUCH_OBJECT)
 
+    def test_subtree(self):
+        """Testing a search"""
+
+        try:
+            res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                                  scope=ldb.SCOPE_SUBTREE)
+            if hasattr(self, 'IDXCHECK'):
+                self.fail()
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            estr = err.args[1]
+            self.assertEqual(enum, ldb.ERR_INAPPROPRIATE_MATCHING)
+            self.assertIn(estr, "ldb FULL SEARCH disabled")
+        else:
+            self.assertEqual(len(res11), 25)
+
+    def test_subtree2(self):
+        """Testing a search"""
+
+        try:
+            res11 = self.l.search(base="DC=ORG",
+                                  scope=ldb.SCOPE_SUBTREE)
+            if hasattr(self, 'IDXCHECK'):
+                self.fail()
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            estr = err.args[1]
+            self.assertEqual(enum, ldb.ERR_INAPPROPRIATE_MATCHING)
+            self.assertIn(estr, "ldb FULL SEARCH disabled")
+        else:
+            self.assertEqual(len(res11), 36)
+
     def test_subtree_and(self):
         """Testing a search"""
 
@@ -1141,6 +1227,86 @@ class SearchTests(LdbBaseTest):
                               expression="(&(ou=ou10)(y=a))")
         self.assertEqual(len(res11), 1)
 
+    def test_subtree_unique(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=ou10)")
+        self.assertEqual(len(res11), 1)
+
+    def test_subtree_unique_elsewhere(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=ou10)")
+        self.assertEqual(len(res11), 0)
+
+    def test_subtree_unique_elsewhere2(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=COM",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=ou10)")
+        self.assertEqual(len(res11), 0)
+
+    def test_subtree_unique_elsewhere2(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=NET",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 1)
+
+    def test_subtree_unique_elsewhere3(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 0)
+
+    def test_subtree_unique_elsewhere4(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 0)
+
+    def test_subtree_unique_elsewhere5(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=COM",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 0)
+
+    def test_subtree_unique_elsewhere6(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 0)
+
+    def test_subtree_unique_here(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="OU=UNIQUE,DC=EXAMPLE,DC=NET",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 1)
+
+    def test_subtree_unique(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_SUBTREE,
+                              expression="(ou=ou10)")
+        self.assertEqual(len(res11), 1)
+
     def test_subtree_and_none(self):
         """Testing a search"""
 
@@ -1165,6 +1331,185 @@ class SearchTests(LdbBaseTest):
                               expression="(@IDXONE=DC=SAMBA,DC=ORG)")
         self.assertEqual(len(res11), 0)
 
+    def test_onelevel(self):
+        """Testing a search"""
+
+        try:
+            res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                                  scope=ldb.SCOPE_ONELEVEL)
+            if hasattr(self, 'IDXCHECK') \
+               and not hasattr(self, 'IDXONE'):
+                self.fail()
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            estr = err.args[1]
+            self.assertEqual(enum, ldb.ERR_INAPPROPRIATE_MATCHING)
+            self.assertIn(estr, "ldb FULL SEARCH disabled")
+        else:
+            self.assertEqual(len(res11), 24)
+
+    def test_onelevel2(self):
+        """Testing a search"""
+
+        try:
+            res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                                  scope=ldb.SCOPE_ONELEVEL)
+            if hasattr(self, 'IDXCHECK') \
+               and not hasattr(self, 'IDXONE'):
+                self.fail()
+                self.fail()
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            estr = err.args[1]
+            self.assertEqual(enum, ldb.ERR_INAPPROPRIATE_MATCHING)
+            self.assertIn(estr, "ldb FULL SEARCH disabled")
+        else:
+            self.assertEqual(len(res11), 9)
+
+    def test_onelevel_and_or(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(x=z)(y=b))(x=x)(y=c))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_and_or2(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(x=x)(y=c)(|(x=z)(y=b)))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_and_or3(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(ou=ou11)(ou=ou10))(|(x=y)(y=b)(y=c)))")
+        self.assertEqual(len(res11), 2)
+
+    def test_onelevel_and_or4(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(x=y)(y=b)(y=c))(|(ou=ou11)(ou=ou10)))")
+        self.assertEqual(len(res11), 2)
+
+    def test_onelevel_and_or5(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(x=y)(y=b)(y=c))(ou=ou11))")
+        self.assertEqual(len(res11), 1)
+
+    def test_onelevel_or_and(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(|(x=x)(y=c)(&(x=z)(y=b)))")
+        self.assertEqual(len(res11), 10)
+
+    def test_onelevel_large_and_unique(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(ou=ou10)(y=a))")
+        self.assertEqual(len(res11), 1)
+
+    def test_onelevel_unique(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=ou10)")
+        self.assertEqual(len(res11), 1)
+
+    def test_onelevel_unique_elsewhere(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=ou10)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_unique_elsewhere2(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=COM",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=ou10)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_unique_elsewhere2(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=NET",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 1)
+
+    def test_onelevel_unique_elsewhere3(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_unique_elsewhere4(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_unique_elsewhere5(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=COM",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_unique_here(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="OU=UNIQUE,DC=EXAMPLE,DC=NET",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_and_none(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(ou=ouX)(y=a))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_and_idx_record(self):
+        """Testing a search against the index record"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(@IDXDN=DC=SAMBA,DC=ORG)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_and_idxone_record(self):
+        """Testing a search against the index record"""
+
+        res11 = self.l.search(base="DC=SAMBA,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(@IDXONE=DC=SAMBA,DC=ORG)")
+        self.assertEqual(len(res11), 0)
+
     def test_subtree_unindexable(self):
         """Testing a search"""
 
@@ -1184,6 +1529,158 @@ class SearchTests(LdbBaseTest):
             self.assertEqual(enum, ldb.ERR_INAPPROPRIATE_MATCHING)
             self.assertIn(estr, "ldb FULL SEARCH disabled")
 
+    def test_onelevel_only_and_or(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(x=z)(y=b))(x=x)(y=c))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_only_and_or2(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(x=x)(y=c)(|(x=z)(y=b)))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_only_and_or3(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(ou=ou11)(ou=ou10))(|(x=y)(y=b)(y=c)))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_only_and_or4(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(x=y)(y=b)(y=c))(|(ou=ou11)(ou=ou10)))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_only_and_or5(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(x=y)(y=b)(y=c))(ou=ou11))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_only_or_and(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(|(x=x)(y=c)(&(x=z)(y=b)))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_only_large_and_unique(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(ou=ou10)(y=a))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_only_unique(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=ou10)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_only_unique2(self):
+        """Testing a search"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=unique)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_only_and_none(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(ou=ouX)(y=a))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_small_and_or(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(x=z)(y=b))(x=x)(y=c))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_small_and_or2(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(x=x)(y=c)(|(x=z)(y=b)))")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_small_and_or3(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(ou=ou1)(ou=ou2))(|(x=y)(y=b)(y=c)))")
+        self.assertEqual(len(res11), 2)
+
+    def test_onelevel_small_and_or4(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(x=y)(y=b)(y=c))(|(ou=ou1)(ou=ou2)))")
+        self.assertEqual(len(res11), 2)
+
+    def test_onelevel_small_and_or5(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(|(x=y)(y=b)(y=c))(ou=ou1))")
+        self.assertEqual(len(res11), 1)
+
+    def test_onelevel_small_or_and(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(|(x=x)(y=c)(&(x=z)(y=b)))")
+        self.assertEqual(len(res11), 2)
+
+    def test_onelevel_small_large_and_unique(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(ou=ou9)(y=a))")
+        self.assertEqual(len(res11), 1)
+
+    def test_onelevel_small_unique_elsewhere(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(ou=ou10)")
+        self.assertEqual(len(res11), 0)
+
+    def test_onelevel_small_and_none(self):
+        """Testing a search (showing that onelevel is not subtree)"""
+
+        res11 = self.l.search(base="DC=EXAMPLE,DC=ORG",
+                              scope=ldb.SCOPE_ONELEVEL,
+                              expression="(&(ou=ouX)(y=a))")
+        self.assertEqual(len(res11), 0)
+
     def test_subtree_unindexable_presence(self):
         """Testing a search"""
 
@@ -1492,7 +1989,6 @@ class GUIDIndexedSearchTests(SearchTests):
         super(GUIDIndexedSearchTests, self).setUp()
 
         self.IDXGUID = True
-        self.IDXONE = True
 
 
 class GUIDIndexedDNFilterSearchTests(SearchTests):
@@ -1521,6 +2017,7 @@ class GUIDAndOneLevelIndexedSearchTests(SearchTests):
     def setUp(self):
         self.index = {"dn": "@INDEXLIST",
                       "@IDXATTR": [b"x", b"y", b"ou"],
+                      "@IDXONE": [b"1"],
                       "@IDXGUID": [b"objectUUID"],
                       "@IDX_DN_GUID": [b"GUID"]}
         super(GUIDAndOneLevelIndexedSearchTests, self).setUp()
diff --git a/lib/ldb/tests/test_ldb_dn.c b/lib/ldb/tests/test_ldb_dn.c
index 109ee53c8ab..6faff9b7de7 100644
--- a/lib/ldb/tests/test_ldb_dn.c
+++ b/lib/ldb/tests/test_ldb_dn.c
@@ -19,6 +19,7 @@
 
 #include <stdarg.h>
 #include <stddef.h>
+#include <stdint.h>
 #include <setjmp.h>
 #include <cmocka.h>
 
diff --git a/lib/ldb/wscript b/lib/ldb/wscript
index 4c906d2aa77..06c8922aa8d 100644
--- a/lib/ldb/wscript
+++ b/lib/ldb/wscript
@@ -1,7 +1,7 @@
 #!/usr/bin/env python
 
 APPNAME = 'ldb'
-VERSION = '2.1.0'
+VERSION = '2.1.1'
 
 import sys, os
 
diff --git a/lib/param/loadparm.c b/lib/param/loadparm.c
index 5334e9c4e5d..611c1b240af 100644
--- a/lib/param/loadparm.c
+++ b/lib/param/loadparm.c
@@ -61,6 +61,7 @@
 #include "system/network.h" /* needed for TCP_NODELAY */
 #include "../lib/util/dlinklist.h"
 #include "lib/param/param.h"
+#define LOADPARM_SUBSTITUTION_INTERNALS 1
 #include "lib/param/loadparm.h"
 #include "auth/gensec/gensec.h"
 #include "lib/param/s3_param.h"
@@ -157,13 +158,13 @@ static const char *lpcfg_string(const char *s)
 /* this global context supports the lp_*() function varients */
 static struct loadparm_context *global_loadparm_context;
 
-#define FN_GLOBAL_STRING(fn_name,var_name) \
- _PUBLIC_ char *lpcfg_ ## fn_name(struct loadparm_context *lp_ctx, TALLOC_CTX *ctx) {\
+#define FN_GLOBAL_SUBSTITUTED_STRING(fn_name,var_name) \
+ _PUBLIC_ char *lpcfg_ ## fn_name(struct loadparm_context *lp_ctx, \
+		 const struct loadparm_substitution *lp_sub, TALLOC_CTX *mem_ctx) \
+{ \
 	 if (lp_ctx == NULL) return NULL;				\
-	 if (lp_ctx->s3_fns) {						\
-		 return lp_ctx->globals->var_name ? lp_ctx->s3_fns->lp_string(ctx, lp_ctx->globals->var_name) : talloc_strdup(ctx, ""); \
-	 }								\
-	 return lp_ctx->globals->var_name ? talloc_strdup(ctx, lpcfg_string(lp_ctx->globals->var_name)) : talloc_strdup(ctx, ""); \
+	 return lpcfg_substituted_string(mem_ctx, lp_sub, \
+			 lp_ctx->globals->var_name ? lp_ctx->globals->var_name : ""); \
 }
 
 #define FN_GLOBAL_CONST_STRING(fn_name,var_name)				\
@@ -192,7 +193,7 @@ static struct loadparm_context *global_loadparm_context;
 /* Local parameters don't need the ->s3_fns because the struct
  * loadparm_service is shared and lpcfg_service() checks the ->s3_fns
  * hook */
-#define FN_LOCAL_STRING(fn_name,val) \
+#define FN_LOCAL_SUBSTITUTED_STRING(fn_name,val) \
  _PUBLIC_ char *lpcfg_ ## fn_name(struct loadparm_service *service, \
 					struct loadparm_service *sDefault, TALLOC_CTX *ctx) { \
 	 return(talloc_strdup(ctx, lpcfg_string((const char *)((service != NULL && service->val != NULL) ? service->val : sDefault->val)))); \
@@ -3119,13 +3120,15 @@ static bool lpcfg_update(struct loadparm_context *lp_ctx)
 	struct debug_settings settings;
 	int max_protocol, min_protocol;
 	TALLOC_CTX *tmp_ctx;
+	const struct loadparm_substitution *lp_sub =
+		lpcfg_noop_substitution();
 
 	tmp_ctx = talloc_new(lp_ctx);
 	if (tmp_ctx == NULL) {
 		return false;
 	}
 
-	lpcfg_add_auto_services(lp_ctx, lpcfg_auto_services(lp_ctx, tmp_ctx));
+	lpcfg_add_auto_services(lp_ctx, lpcfg_auto_services(lp_ctx, lp_sub, tmp_ctx));
 
 	if (!lp_ctx->globals->wins_server_list && lp_ctx->globals->we_are_a_wins_server) {
 		lpcfg_do_global_parameter(lp_ctx, "wins server", "127.0.0.1");
@@ -3598,3 +3601,31 @@ bool lpcfg_lanman_auth(struct loadparm_context *lp_ctx)
 		return false;
 	}
 }
+
+static char *lpcfg_noop_substitution_fn(
+			TALLOC_CTX *mem_ctx,
+			const struct loadparm_substitution *lp_sub,
+			const char *raw_value,
+			void *private_data)
+{
+	return talloc_strdup(mem_ctx, raw_value);
+}
+
+static const struct loadparm_substitution global_noop_substitution = {
+	.substituted_string_fn = lpcfg_noop_substitution_fn,
+};
+
+const struct loadparm_substitution *lpcfg_noop_substitution(void)
+{
+	return &global_noop_substitution;
+}
+
+char *lpcfg_substituted_string(TALLOC_CTX *mem_ctx,
+			       const struct loadparm_substitution *lp_sub,
+			       const char *raw_value)
+{
+	return lp_sub->substituted_string_fn(mem_ctx,
+					     lp_sub,
+					     raw_value,
+					     lp_sub->private_data);
+}
diff --git a/lib/param/loadparm.h b/lib/param/loadparm.h
index d0ce3d312e1..65ff62cc3b9 100644
--- a/lib/param/loadparm.h
+++ b/lib/param/loadparm.h
@@ -301,7 +301,6 @@ bool lp_is_security_and_server_role_valid(int server_role, int security);
 
 struct loadparm_global * get_globals(void);
 unsigned int * get_flags(void);
-char * lp_string(TALLOC_CTX *, const char *);
 int getservicebyname(const char *, struct loadparm_service *);
 bool lp_include(struct loadparm_context *, struct loadparm_service *,
 	       	const char *, char **);
@@ -310,4 +309,21 @@ bool store_lp_set_cmdline(const char *pszParmName, const char *pszParmValue);
 
 int num_parameters(void);
 
+struct loadparm_substitution;
+#ifdef LOADPARM_SUBSTITUTION_INTERNALS
+struct loadparm_substitution {
+	char *(*substituted_string_fn)(
+			TALLOC_CTX *mem_ctx,
+			const struct loadparm_substitution *lp_sub,
+			const char *raw_value,
+			void *private_data);
+	void *private_data;
+};
+#endif /* LOADPARM_SUBSTITUTION_INTERNALS */
+
+const struct loadparm_substitution *lpcfg_noop_substitution(void);
+char *lpcfg_substituted_string(TALLOC_CTX *mem_ctx,
+			       const struct loadparm_substitution *lp_sub,
+			       const char *raw_value);
+
 #endif /* _LOADPARM_H */
diff --git a/lib/param/param.h b/lib/param/param.h
index 0a3bde6c5cb..762a8270481 100644
--- a/lib/param/param.h
+++ b/lib/param/param.h
@@ -21,6 +21,7 @@
 #define _PARAM_H 
 
 struct loadparm_s3_helpers;
+struct loadparm_substitution;
 
 struct parmlist_entry;
 
diff --git a/lib/param/s3_param.h b/lib/param/s3_param.h
index f31c5bcbaa9..7bbadfd196a 100644
--- a/lib/param/s3_param.h
+++ b/lib/param/s3_param.h
@@ -11,7 +11,6 @@ struct loadparm_s3_helpers
 	bool (*load)(const char *filename);
 	bool (*store_cmdline)(const char *pszParmName, const char *pszParmValue);
 	void (*dump)(FILE *f, bool show_defaults, int maxtoprint);
-	char * (*lp_string)(TALLOC_CTX *ctx, const char *in);
 	bool (*lp_include)(struct loadparm_context*, struct loadparm_service *,
 		       	const char *, char **);
 	void (*init_ldap_debugging)(void);
diff --git a/lib/pthreadpool/wscript_build b/lib/pthreadpool/wscript_build
index 70aa7cbf041..e270f90333f 100644
--- a/lib/pthreadpool/wscript_build
+++ b/lib/pthreadpool/wscript_build
@@ -25,11 +25,11 @@ bld.SAMBA_BINARY('pthreadpooltest',
                   source='tests.c',
                   deps='PTHREADPOOL',
                   enabled=bld.env.WITH_PTHREADPOOL,
-                  install=False)
+                  for_selftest=True)
 
 bld.SAMBA_BINARY('pthreadpooltest_cmocka',
                   source='tests_cmocka.c',
                   deps='PTHREADPOOL cmocka',
                   ldflags='-Wl,--wrap=pthread_create',
                   enabled=bld.env.WITH_PTHREADPOOL and bld.env['HAVE_LDWRAP'],
-                  install=False)
+                  for_selftest=True)
diff --git a/lib/replace/system/filesys.h b/lib/replace/system/filesys.h
index 1a8cb68103d..976b2aeec5e 100644
--- a/lib/replace/system/filesys.h
+++ b/lib/replace/system/filesys.h
@@ -107,19 +107,17 @@
 #include <sys/uio.h>
 #endif
 
-#if defined(HAVE_SYS_ATTRIBUTES_H)
+/* mutually exclusive (SuSE 8.2) */
+#if defined(HAVE_SYS_XATTR_H)
+#include <sys/xattr.h>
+#elif defined(HAVE_ATTR_XATTR_H)
+#include <attr/xattr.h>
+#elif defined(HAVE_SYS_ATTRIBUTES_H)
 #include <sys/attributes.h>
 #elif defined(HAVE_ATTR_ATTRIBUTES_H)
 #include <attr/attributes.h>
 #endif
 
-/* mutually exclusive (SuSE 8.2) */
-#if defined(HAVE_ATTR_XATTR_H)
-#include <attr/xattr.h>
-#elif defined(HAVE_SYS_XATTR_H)
-#include <sys/xattr.h>
-#endif
-
 #ifdef HAVE_SYS_EA_H
 #include <sys/ea.h>
 #endif
diff --git a/lib/replace/system/time.h b/lib/replace/system/time.h
index 00f0d7f99e6..272fe84fc93 100644
--- a/lib/replace/system/time.h
+++ b/lib/replace/system/time.h
@@ -96,4 +96,11 @@ int rep_clock_gettime(clockid_t clk_id, struct timespec *tp);
 #define CUSTOM_CLOCK_MONOTONIC_IS_REALTIME
 #endif
 
+#ifndef UTIME_NOW
+#define UTIME_NOW ((1l << 30) - 1l)
+#endif
+#ifndef UTIME_OMIT
+#define UTIME_OMIT ((1l << 30) - 2l)
+#endif
+
 #endif
diff --git a/lib/replace/wscript b/lib/replace/wscript
index a2bc60478ad..ab2b3c043af 100644
--- a/lib/replace/wscript
+++ b/lib/replace/wscript
@@ -67,7 +67,7 @@ def configure(conf):
                         headers='sys/inotify.h')
 
     conf.CHECK_HEADERS('security/pam_appl.h zlib.h asm/unistd.h')
-    conf.CHECK_HEADERS('aio.h sys/unistd.h alloca.h float.h')
+    conf.CHECK_HEADERS('sys/unistd.h alloca.h float.h')
 
     conf.SET_TARGET_TYPE('tirpc', 'EMPTY')
 
diff --git a/lib/texpect/texpect.c b/lib/texpect/texpect.c
index 32b2fded410..8c9431e366e 100644
--- a/lib/texpect/texpect.c
+++ b/lib/texpect/texpect.c
@@ -34,6 +34,7 @@
 #include "replace.h"
 #include "system/filesys.h"
 #include "system/wait.h"
+#include "lib/util/sys_rw.h"
 
 #ifdef HAVE_PTY_H
 #include <pty.h>
@@ -176,24 +177,6 @@ static char *iscmd(const char *buf, const char *s)
 	return strdup(buf + len);
 }
 
-/*******************************************************************
-A write wrapper that will deal with EINTR.
-********************************************************************/
-
-static ssize_t sys_write(int fd, const void *buf, size_t count)
-{
-	ssize_t ret;
-
-	do {
-		ret = write(fd, buf, count);
-#if defined(EWOULDBLOCK)
-	} while (ret == -1 && (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));
-#else
-	} while (ret == -1 && (errno == EINTR || errno == EAGAIN));
-#endif
-	return ret;
-}
-
 static void parse_configuration(const char *fn)
 {
 	struct command *c;
@@ -235,23 +218,6 @@ static void parse_configuration(const char *fn)
 	fclose(cmd);
 }
 
-/* A wrapper to close als file descriptors above the given fd */
-static int sys_closefrom(int fd)
-{
-	int num = getdtablesize();
-
-	if (num < 0) {
-		num = 1024;
-	}
-
-	for (; fd <= num; fd++) {
-		close(fd);
-	}
-
-	return 0;
-}
-
-
 /*
  *
  */
@@ -463,7 +429,7 @@ int main(int argc, const char **argv)
 			dup2(slave, STDOUT_FILENO);
 			dup2(slave, STDERR_FILENO);
 
-			sys_closefrom(STDERR_FILENO + 1);
+			closefrom(STDERR_FILENO + 1);
 
 			/* texpect <expect_instructions> <progname> [<args>] */
 			execvp(program, program_args);
diff --git a/lib/texpect/wscript b/lib/texpect/wscript
index e14c048483f..44f92a85136 100644
--- a/lib/texpect/wscript
+++ b/lib/texpect/wscript
@@ -4,4 +4,7 @@ def configure(conf):
     conf.CHECK_FUNCS_IN('openpty', 'util', checklibc=True, headers='pty.h util.h bsd/libutil.h libutil.h')
 
 def build(bld):
-    bld.SAMBA_BINARY('texpect', 'texpect.c', deps='popt util replace', install=False)
+    bld.SAMBA_BINARY('texpect',
+                     'texpect.c',
+                     deps='popt util replace sys_rw',
+                     for_selftest=True)
diff --git a/lib/util/charset/convert_string.c b/lib/util/charset/convert_string.c
index d274e305a0c..b725b53cb5a 100644
--- a/lib/util/charset/convert_string.c
+++ b/lib/util/charset/convert_string.c
@@ -293,31 +293,31 @@ bool convert_string_handle(struct smb_iconv_handle *ic,
 		switch(errno) {
 			case EINVAL:
 				reason="Incomplete multibyte sequence";
-				DEBUG(3,("convert_string_internal: Conversion error: %s(%s)\n",
-					 reason, (const char *)src));
+				DBG_NOTICE("Conversion error: %s\n",
+					 reason);
 				break;
 			case E2BIG:
 			{
 				reason="No more room";
 				if (from == CH_UNIX) {
-					DEBUG(3,("E2BIG: convert_string(%s,%s): srclen=%u destlen=%u - '%s' error: %s\n",
-						 charset_name(ic, from), charset_name(ic, to),
-						 (unsigned int)srclen, (unsigned int)destlen, (const char *)src, reason));
+					DBG_NOTICE("E2BIG: convert_string(%s,%s): srclen=%u destlen=%u error: %s\n",
+						   charset_name(ic, from), charset_name(ic, to),
+						   (unsigned int)srclen, (unsigned int)destlen, reason);
 				} else {
-					DEBUG(3,("E2BIG: convert_string(%s,%s): srclen=%u destlen=%u error: %s\n",
-						 charset_name(ic, from), charset_name(ic, to),
-						 (unsigned int)srclen, (unsigned int)destlen, reason));
+					DBG_NOTICE("E2BIG: convert_string(%s,%s): srclen=%u destlen=%u error: %s\n",
+						   charset_name(ic, from), charset_name(ic, to),
+						   (unsigned int)srclen, (unsigned int)destlen, reason);
 				}
 				break;
 			}
 			case EILSEQ:
 				reason="Illegal multibyte sequence";
-				DEBUG(3,("convert_string_internal: Conversion error: %s(%s)\n",
-					 reason, (const char *)src));
+				DBG_NOTICE("convert_string_internal: Conversion error: %s\n",
+					   reason);
 				break;
 			default:
-				DEBUG(0,("convert_string_internal: Conversion error: %s(%s)\n",
-					 reason, (const char *)src));
+				DBG_ERR("convert_string_internal: Conversion error: %s\n",
+					reason);
 				break;
 		}
 		/* smb_panic(reason); */
@@ -427,20 +427,22 @@ bool convert_string_talloc_handle(TALLOC_CTX *ctx, struct smb_iconv_handle *ic,
 		switch(errno) {
 			case EINVAL:
 				reason="Incomplete multibyte sequence";
-				DEBUG(3,("convert_string_talloc: Conversion error: %s(%s)\n",reason,inbuf));
+				DBG_NOTICE("Conversion error: %s\n",
+					   reason);
 				break;
 			case E2BIG:
 				reason = "output buffer is too small";
-				DBG_NOTICE("convert_string_talloc: "
-					   "Conversion error: %s(%s)\n",
-					   reason, inbuf);
+				DBG_NOTICE("Conversion error: %s\n",
+					   reason);
 				break;
 			case EILSEQ:
 				reason="Illegal multibyte sequence";
-				DEBUG(3,("convert_string_talloc: Conversion error: %s(%s)\n",reason,inbuf));
+				DBG_NOTICE("Conversion error: %s\n",
+					   reason);
 				break;
 			default:
-				DEBUG(0,("Conversion error: %s(%s)\n",reason,inbuf));
+				DBG_ERR("Conversion error: %s\n",
+					reason);
 				break;
 		}
 		/* smb_panic(reason); */
diff --git a/lib/util/debug_s3.c b/lib/util/debug_s3.c
index 5384ac1718a..151227c3419 100644
--- a/lib/util/debug_s3.c
+++ b/lib/util/debug_s3.c
@@ -40,11 +40,13 @@ bool reopen_logs(void)
 			.debug_uid = lp_debug_uid(),
 			.debug_class = lp_debug_class(),
 		};
+		const struct loadparm_substitution *lp_sub =
+			loadparm_s3_global_substitution();
 
-		debug_set_logfile(lp_logfile(talloc_tos()));
-		debug_parse_levels(lp_log_level(talloc_tos()));
+		debug_set_logfile(lp_logfile(talloc_tos(), lp_sub));
+		debug_parse_levels(lp_log_level(talloc_tos(), lp_sub));
 		debug_set_settings(&settings,
-				   lp_logging(talloc_tos()),
+				   lp_logging(talloc_tos(), lp_sub),
 				   lp_syslog(),
 				   lp_syslog_only());
 	} else {
diff --git a/lib/util/time.c b/lib/util/time.c
index 3a6043025f4..0fac5e2e397 100644
--- a/lib/util/time.c
+++ b/lib/util/time.c
@@ -326,6 +326,11 @@ _PUBLIC_ time_t pull_dos_date2(const uint8_t *date_ptr, int zone_offset)
 _PUBLIC_ time_t pull_dos_date3(const uint8_t *date_ptr, int zone_offset)
 {
 	time_t t = (time_t)IVAL(date_ptr,0);
+
+	if (t == (time_t)0xFFFFFFFF) {
+		t = (time_t)-1;
+	}
+
 	if (!null_time(t)) {
 		t += zone_offset;
 	}
@@ -359,6 +364,62 @@ char *timeval_string(TALLOC_CTX *ctx, const struct timeval *tp, bool hires)
 	return result;
 }
 
+/****************************************************************************
+ Return the date and time as a string
+****************************************************************************/
+
+const char *timespec_string_buf(const struct timespec *tp,
+				bool hires,
+				struct timeval_buf *buf)
+{
+	time_t t;
+	struct tm *tm = NULL;
+	size_t len;
+
+	if (is_omit_timespec(tp)) {
+		strlcpy(buf->buf, "SAMBA_UTIME_OMIT", sizeof(buf->buf));
+		return buf->buf;
+	}
+
+	t = (time_t)tp->tv_sec;
+	tm = localtime(&t);
+
+	if (tm == NULL) {
+		if (hires) {
+			len = snprintf(buf->buf, sizeof(buf->buf),
+				       "%ld.%09ld seconds since the Epoch",
+				       (long)tp->tv_sec, (long)tp->tv_nsec);
+		} else {
+			len = snprintf(buf->buf, sizeof(buf->buf),
+				       "%ld seconds since the Epoch", (long)t);
+		}
+	} else if (!hires) {
+		len = snprintf(buf->buf, sizeof(buf->buf),
+			       "%04d/%02d/%02d %02d:%02d:%02d",
+			       1900 + tm->tm_year,
+			       tm->tm_mon + 1,
+			       tm->tm_mday,
+			       tm->tm_hour,
+			       tm->tm_min,
+			       tm->tm_sec);
+	} else {
+		len = snprintf(buf->buf, sizeof(buf->buf),
+			       "%04d/%02d/%02d %02d:%02d:%02d.%09ld",
+			       1900 + tm->tm_year,
+			       tm->tm_mon + 1,
+			       tm->tm_mday,
+			       tm->tm_hour,
+			       tm->tm_min,
+			       tm->tm_sec,
+			       (long)tp->tv_nsec);
+	}
+	if (len == -1) {
+		return "";
+	}
+
+	return buf->buf;
+}
+
 char *current_timestring(TALLOC_CTX *ctx, bool hires)
 {
 	struct timeval tv;
@@ -496,7 +557,7 @@ _PUBLIC_ const char *nt_time_string(TALLOC_CTX *mem_ctx, NTTIME nt)
 	if (nt == 0) {
 		return "NTTIME(0)";
 	}
-	t = nt_time_to_unix(nt);
+	t = nt_time_to_full_time_t(nt);
 	return timestring(mem_ctx, t);
 }
 
@@ -991,3 +1052,183 @@ _PUBLIC_ NTTIME unix_timespec_to_nt_time(struct timespec ts)
 
 	return d;
 }
+
+/*
+ * Functions supporting the full range of time_t and struct timespec values,
+ * including 0, -1 and all other negative values. These functions don't use 0 or
+ * -1 values as sentinel to denote "unset" variables, but use the POSIX 2008
+ * define UTIME_OMIT from utimensat(2).
+ */
+
+/**
+ * Check if it's a to be omitted timespec.
+ **/
+bool is_omit_timespec(const struct timespec *ts)
+{
+	return ts->tv_nsec == SAMBA_UTIME_OMIT;
+}
+
+/**
+ * Return a to be omitted timespec.
+ **/
+struct timespec make_omit_timespec(void)
+{
+	return (struct timespec){.tv_nsec = SAMBA_UTIME_OMIT};
+}
+
+/**
+ * Like unix_timespec_to_nt_time() but without the special casing of tv_sec=0
+ * and -1. Also dealing with SAMBA_UTIME_OMIT.
+ **/
+NTTIME full_timespec_to_nt_time(const struct timespec *_ts)
+{
+	struct timespec ts = *_ts;
+	uint64_t d;
+
+	if (is_omit_timespec(_ts)) {
+		return NTTIME_OMIT;
+	}
+
+	/* Ensure tv_nsec is less than 1 sec. */
+	while (ts.tv_nsec > 1000000000) {
+		if (ts.tv_sec > TIME_T_MAX) {
+			return NTTIME_MAX;
+		}
+		ts.tv_sec += 1;
+		ts.tv_nsec -= 1000000000;
+	}
+
+	if (ts.tv_sec >= TIME_T_MAX) {
+		return NTTIME_MAX;
+	}
+	if ((ts.tv_sec + TIME_FIXUP_CONSTANT_INT) <= 0) {
+		return NTTIME_MIN;
+	}
+
+	d = TIME_FIXUP_CONSTANT_INT;
+	d += ts.tv_sec;
+
+	d *= 1000*1000*10;
+	/* d is now in 100ns units. */
+	d += (ts.tv_nsec / 100);
+
+	return d;
+}
+
+/**
+ * Like nt_time_to_unix_timespec() but allowing negative tv_sec values and
+ * returning NTTIME=0 and -1 as struct timespec {.tv_nsec = SAMBA_UTIME_OMIT}.
+ *
+ * See also: is_omit_timespec().
+ **/
+struct timespec nt_time_to_full_timespec(NTTIME nt)
+{
+	int64_t d;
+	struct timespec ret;
+
+	if (nt == NTTIME_OMIT) {
+		return make_omit_timespec();
+	}
+	if (nt == NTTIME_FREEZE) {
+		/*
+		 * This should be returned as SAMBA_UTIME_FREEZE in the
+		 * future.
+		 */
+		return make_omit_timespec();
+	}
+	if (nt > NTTIME_MAX) {
+		nt = NTTIME_MAX;
+	}
+
+	d = (int64_t)nt;
+	/* d is now in 100ns units, since jan 1st 1601".
+	   Save off the ns fraction. */
+
+	/*
+	 * Take the last seven decimal digits and multiply by 100.
+	 * to convert from 100ns units to 1ns units.
+	 */
+        ret.tv_nsec = (long) ((d % (1000 * 1000 * 10)) * 100);
+
+	/* Convert to seconds */
+	d /= 1000*1000*10;
+
+	/* Now adjust by 369 years to make the secs since 1970 */
+	d -= TIME_FIXUP_CONSTANT_INT;
+
+	if (d >= (int64_t)TIME_T_MAX) {
+		ret.tv_sec = TIME_T_MAX;
+		ret.tv_nsec = 0;
+		return ret;
+	}
+
+	ret.tv_sec = (time_t)d;
+	return ret;
+}
+
+/**
+ * Note: this function uses the full time_t range as valid date values including
+ * (time_t)0 and -1. That means that struct timespec sentinel values (cf
+ * is_omit_timespec()) can't be converted to sentinel values in a time_t
+ * representation. Callers should therefor check the NTTIME value with
+ * null_nttime() before calling this function.
+ **/
+time_t full_timespec_to_time_t(const struct timespec *_ts)
+{
+	struct timespec ts = *_ts;
+
+	if (is_omit_timespec(_ts)) {
+		/*
+		 * Unfortunately there's no sensible sentinel value in the
+		 * time_t range that is not conflicting with a valid time value
+		 * ((time_t)0 and -1 are valid time values). Bite the bullit and
+		 * return 0.
+		 */
+		return 0;
+	}
+
+	/* Ensure tv_nsec is less than 1sec. */
+	while (ts.tv_nsec > 1000000000) {
+		ts.tv_sec += 1;
+		ts.tv_nsec -= 1000000000;
+	}
+
+	/* 1 ns == 1,000,000,000 - one thousand millionths of a second.
+	   increment if it's greater than 500 millionth of a second. */
+
+	if (ts.tv_nsec > 500000000) {
+		return ts.tv_sec + 1;
+	}
+	return ts.tv_sec;
+}
+
+/**
+ * Like nt_time_to_unix() but supports negative time_t values.
+ *
+ * Note: this function uses the full time_t range as valid date values including
+ * (time_t)0 and -1. That means that NTTIME sentinel values of 0 and -1 which
+ * represent a "not-set" value, can't be converted to sentinel values in a
+ * time_t representation. Callers should therefor check the NTTIME value with
+ * null_nttime() before calling this function.
+ **/
+time_t nt_time_to_full_time_t(NTTIME nt)
+{
+	struct timespec ts;
+
+	ts = nt_time_to_full_timespec(nt);
+	return full_timespec_to_time_t(&ts);
+}
+
+/**
+ * Like time_t_to_unix_timespec() but supports negative time_t values.
+ *
+ * This version converts (time_t)0 and -1 to an is_omit_timespec(), so 0 and -1
+ * can't be used as valid date values. The function supports values < -1 though.
+ **/
+struct timespec time_t_to_full_timespec(time_t t)
+{
+	if (null_time(t)) {
+		return (struct timespec){.tv_nsec = SAMBA_UTIME_OMIT};
+	}
+	return (struct timespec){.tv_sec = t};
+}
diff --git a/lib/util/time.h b/lib/util/time.h
index 7a8f8af35d9..4a90b40d5ce 100644
--- a/lib/util/time.h
+++ b/lib/util/time.h
@@ -41,6 +41,31 @@
 #define TIME_T_MAX MIN(INT32_MAX,_TYPE_MAXIMUM(time_t))
 #endif
 
+/*
+ * According to Windows API FileTimeToSystemTime() documentation the highest
+ * allowed value " ... must be less than 0x8000000000000000.".
+ */
+#define NTTIME_MAX INT64_MAX
+
+/*
+ * The lowest possible value when NTTIME=0 is used as sentinel value.
+ */
+#define NTTIME_MIN 1
+
+/*
+ * NTTIME_OMIT in a setinfo tells us to not modify the corresponding on-disk
+ * timestamp value.
+ */
+#define NTTIME_OMIT 0
+
+/*
+ * Disable automatic timestamp updates, as described in MS-FSA. Samba doesn't
+ * implement this yet.
+ */
+#define NTTIME_FREEZE UINT64_MAX
+
+#define SAMBA_UTIME_NOW UTIME_NOW
+#define SAMBA_UTIME_OMIT UTIME_OMIT
 
 /* 64 bit time (100 nanosec) 1601 - cifs6.txt, section 3.5, page 30, 4 byte aligned */
 typedef uint64_t NTTIME;
@@ -131,6 +156,11 @@ time_t pull_dos_date3(const uint8_t *date_ptr, int zone_offset);
 
 char *timeval_string(TALLOC_CTX *ctx, const struct timeval *tp, bool hires);
 
+struct timeval_buf;
+const char *timespec_string_buf(const struct timespec *tp,
+				bool hires,
+				struct timeval_buf *buf);
+
 /**
  Return the current date and time as a string (optionally with microseconds)
 
@@ -331,4 +361,18 @@ void round_timespec_to_usec(struct timespec *ts);
 void round_timespec_to_nttime(struct timespec *ts);
 NTTIME unix_timespec_to_nt_time(struct timespec ts);
 
+/*
+ * Functions supporting the full range of time_t and struct timespec values,
+ * including 0, -1 and all other negative values. These functions don't use 0 or
+ * -1 values as sentinel to denote "unset" variables, but use the POSIX 2008
+ * define UTIME_OMIT from utimensat(2).
+ */
+bool is_omit_timespec(const struct timespec *ts);
+struct timespec make_omit_timespec(void);
+NTTIME full_timespec_to_nt_time(const struct timespec *ts);
+struct timespec nt_time_to_full_timespec(NTTIME nt);
+time_t full_timespec_to_time_t(const struct timespec *ts);
+time_t nt_time_to_full_time_t(NTTIME nt);
+struct timespec time_t_to_full_timespec(time_t t);
+
 #endif /* _SAMBA_TIME_H_ */
diff --git a/lib/util/util.c b/lib/util/util.c
index 3bdeded5c1b..0d9ffe5cb7b 100644
--- a/lib/util/util.c
+++ b/lib/util/util.c
@@ -353,9 +353,12 @@ _PUBLIC_ bool directory_create_or_exist(const char *dname,
 	old_umask = umask(0);
 	ret = mkdir(dname, dir_perms);
 	if (ret == -1 && errno != EEXIST) {
-		DBG_WARNING("mkdir failed on directory %s: %s\n",
+		int dbg_level = geteuid() == 0 ? DBGLVL_ERR : DBGLVL_NOTICE;
+
+		DBG_PREFIX(dbg_level,
+			   ("mkdir failed on directory %s: %s\n",
 			    dname,
-			    strerror(errno));
+			    strerror(errno)));
 		umask(old_umask);
 		return false;
 	}
diff --git a/lib/util/wscript_build b/lib/util/wscript_build
index 7d446d810d1..a827eea3ed9 100644
--- a/lib/util/wscript_build
+++ b/lib/util/wscript_build
@@ -82,7 +82,7 @@ bld.SAMBA_SUBSYSTEM('samba-util-core',
                               become_daemon.c mkdir_p.c''',
                     deps='''time-basic samba-debug socket-blocking talloc
                             tevent execinfo pthread strv tini''',
-                    public_deps='systemd systemd-daemon sys_rw',
+                    public_deps='systemd systemd-daemon sys_rw LIBUNWIND',
                     local_include=False)
 
 bld.SAMBA_LIBRARY('iov_buf',
@@ -269,22 +269,22 @@ else:
                      source='tests/rfc1738.c',
                      deps='cmocka replace samba-util',
                      local_include=False,
-                     install=False)
+                     for_selftest=True)
 
     bld.SAMBA_BINARY('test_ms_fnmatch',
                      source='tests/test_ms_fnmatch.c',
                      deps='cmocka replace samba-util',
                      local_include=False,
-                     install=False)
+                     for_selftest=True)
 
     bld.SAMBA_BINARY('test_talloc_keep_secret',
                      source='tests/test_talloc_keep_secret.c',
                      deps='cmocka replace samba-util',
                      local_include=False,
-                     install=False)
+                     for_selftest=True)
 
     bld.SAMBA_BINARY('test_byteorder',
                      source='tests/test_byteorder.c',
                      deps='cmocka replace samba-util',
                      local_include=False,
-                     install=False)
+                     for_selftest=True)
diff --git a/lib/util/wscript_configure b/lib/util/wscript_configure
index 93853511575..4f57184f515 100644
--- a/lib/util/wscript_configure
+++ b/lib/util/wscript_configure
@@ -8,7 +8,16 @@ if Options.options.disable_fault_handling:
 
 # backtrace could be in libexecinfo or in libc
 conf.CHECK_FUNCS_IN('backtrace backtrace_symbols', 'execinfo', checklibc=True, headers='execinfo.h')
-conf.CHECK_HEADERS('execinfo.h libunwind.h')
+conf.CHECK_HEADERS('execinfo.h')
+
+conf.SET_TARGET_TYPE('LIBUNWIND', 'EMPTY')
+if conf.check_cfg(package='libunwind-generic',
+                  args='--cflags --libs',
+                  msg='Checking for libunwind',
+                  uselib_store='LIBUNWIND',
+                  mandatory=False):
+    if conf.CHECK_HEADERS('libunwind.h'):
+        conf.SET_TARGET_TYPE('LIBUNWIND', 'SYSLIB')
 
 conf.CHECK_STRUCTURE_MEMBER('struct statvfs', 'f_frsize', define='HAVE_FRSIZE', headers='sys/statvfs.h')
 
diff --git a/libcli/auth/credentials.c b/libcli/auth/credentials.c
index f1088a1d8e0..c541eeff470 100644
--- a/libcli/auth/credentials.c
+++ b/libcli/auth/credentials.c
@@ -38,6 +38,8 @@ static NTSTATUS netlogon_creds_step_crypt(struct netlogon_creds_CredentialState
 					  struct netr_Credential *out)
 {
 	NTSTATUS status;
+	int rc;
+
 	if (creds->negotiate_flags & NETLOGON_NEG_SUPPORTS_AES) {
 		memcpy(out->data, in->data, sizeof(out->data));
 
@@ -48,7 +50,11 @@ static NTSTATUS netlogon_creds_step_crypt(struct netlogon_creds_CredentialState
 			return status;
 		}
 	} else {
-		des_crypt112(out->data, in->data, creds->session_key, 1);
+		rc = des_crypt112(out->data, in->data, creds->session_key, SAMBA_GNUTLS_ENCRYPT);
+		if (rc != 0) {
+			return gnutls_error_to_ntstatus(rc,
+							NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 	}
 
 	return NT_STATUS_OK;
@@ -66,6 +72,7 @@ static NTSTATUS netlogon_creds_init_64bit(struct netlogon_creds_CredentialState
 {
 	uint32_t sum[2];
 	uint8_t sum2[8];
+	int rc;
 
 	sum[0] = IVAL(client_challenge->data, 0) + IVAL(server_challenge->data, 0);
 	sum[1] = IVAL(client_challenge->data, 4) + IVAL(server_challenge->data, 4);
@@ -75,7 +82,10 @@ static NTSTATUS netlogon_creds_init_64bit(struct netlogon_creds_CredentialState
 
 	ZERO_ARRAY(creds->session_key);
 
-	des_crypt128(creds->session_key, sum2, machine_password->hash);
+	rc = des_crypt128(creds->session_key, sum2, machine_password->hash);
+	if (rc != 0) {
+		return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+	}
 
 	return NT_STATUS_OK;
 }
@@ -253,45 +263,76 @@ static NTSTATUS netlogon_creds_step(struct netlogon_creds_CredentialState *creds
 	return NT_STATUS_OK;
 }
 
-
 /*
   DES encrypt a 8 byte LMSessionKey buffer using the Netlogon session key
 */
-void netlogon_creds_des_encrypt_LMKey(struct netlogon_creds_CredentialState *creds, struct netr_LMSessionKey *key)
+NTSTATUS netlogon_creds_des_encrypt_LMKey(struct netlogon_creds_CredentialState *creds,
+					  struct netr_LMSessionKey *key)
 {
+	int rc;
 	struct netr_LMSessionKey tmp;
-	des_crypt56(tmp.key, key->key, creds->session_key, 1);
+
+	rc = des_crypt56_gnutls(tmp.key, key->key, creds->session_key, SAMBA_GNUTLS_ENCRYPT);
+	if (rc < 0) {
+		return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+	}
 	*key = tmp;
+
+	return NT_STATUS_OK;
 }
 
 /*
   DES decrypt a 8 byte LMSessionKey buffer using the Netlogon session key
 */
-void netlogon_creds_des_decrypt_LMKey(struct netlogon_creds_CredentialState *creds, struct netr_LMSessionKey *key)
+NTSTATUS netlogon_creds_des_decrypt_LMKey(struct netlogon_creds_CredentialState *creds,
+					  struct netr_LMSessionKey *key)
 {
+	int rc;
 	struct netr_LMSessionKey tmp;
-	des_crypt56(tmp.key, key->key, creds->session_key, 0);
+
+	rc = des_crypt56_gnutls(tmp.key, key->key, creds->session_key, SAMBA_GNUTLS_DECRYPT);
+	if (rc < 0) {
+		return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+	}
 	*key = tmp;
+
+	return NT_STATUS_OK;
 }
 
 /*
   DES encrypt a 16 byte password buffer using the session key
 */
-void netlogon_creds_des_encrypt(struct netlogon_creds_CredentialState *creds, struct samr_Password *pass)
+NTSTATUS netlogon_creds_des_encrypt(struct netlogon_creds_CredentialState *creds,
+				    struct samr_Password *pass)
 {
 	struct samr_Password tmp;
-	des_crypt112_16(tmp.hash, pass->hash, creds->session_key, 1);
+	int rc;
+
+	rc = des_crypt112_16(tmp.hash, pass->hash, creds->session_key, SAMBA_GNUTLS_ENCRYPT);
+	if (rc < 0) {
+		return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+	}
 	*pass = tmp;
+
+	return NT_STATUS_OK;
 }
 
 /*
   DES decrypt a 16 byte password buffer using the session key
 */
-void netlogon_creds_des_decrypt(struct netlogon_creds_CredentialState *creds, struct samr_Password *pass)
+NTSTATUS netlogon_creds_des_decrypt(struct netlogon_creds_CredentialState *creds,
+				    struct samr_Password *pass)
 {
 	struct samr_Password tmp;
-	des_crypt112_16(tmp.hash, pass->hash, creds->session_key, 0);
+	int rc;
+
+	rc = des_crypt112_16(tmp.hash, pass->hash, creds->session_key, SAMBA_GNUTLS_DECRYPT);
+	if (rc < 0) {
+		return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+	}
 	*pass = tmp;
+
+	return NT_STATUS_OK;
 }
 
 /*
@@ -849,11 +890,14 @@ static NTSTATUS netlogon_creds_crypt_samlogon_validation(struct netlogon_creds_C
 		if (!all_zero(base->LMSessKey.key,
 			      sizeof(base->LMSessKey.key))) {
 			if (do_encrypt) {
-				netlogon_creds_des_encrypt_LMKey(creds,
-						&base->LMSessKey);
+				status = netlogon_creds_des_encrypt_LMKey(creds,
+									  &base->LMSessKey);
 			} else {
-				netlogon_creds_des_decrypt_LMKey(creds,
-						&base->LMSessKey);
+				status = netlogon_creds_des_decrypt_LMKey(creds,
+									  &base->LMSessKey);
+			}
+			if (!NT_STATUS_IS_OK(status)) {
+				return status;
 			}
 		}
 	}
@@ -965,17 +1009,23 @@ static NTSTATUS netlogon_creds_crypt_samlogon_logon(struct netlogon_creds_Creden
 			p = &logon->password->lmpassword;
 			if (!all_zero(p->hash, 16)) {
 				if (do_encrypt) {
-					netlogon_creds_des_encrypt(creds, p);
+					status = netlogon_creds_des_encrypt(creds, p);
 				} else {
-					netlogon_creds_des_decrypt(creds, p);
+					status = netlogon_creds_des_decrypt(creds, p);
+				}
+				if (!NT_STATUS_IS_OK(status)) {
+					return status;
 				}
 			}
 			p = &logon->password->ntpassword;
 			if (!all_zero(p->hash, 16)) {
 				if (do_encrypt) {
-					netlogon_creds_des_encrypt(creds, p);
+					status = netlogon_creds_des_encrypt(creds, p);
 				} else {
-					netlogon_creds_des_decrypt(creds, p);
+					status = netlogon_creds_des_decrypt(creds, p);
+				}
+				if (!NT_STATUS_IS_OK(status)) {
+					return status;
 				}
 			}
 		}
diff --git a/libcli/auth/netlogon_creds_cli.c b/libcli/auth/netlogon_creds_cli.c
index 6f043d774cd..407cb471cbc 100644
--- a/libcli/auth/netlogon_creds_cli.c
+++ b/libcli/auth/netlogon_creds_cli.c
@@ -2032,8 +2032,12 @@ static void netlogon_creds_cli_ServerPasswordSet_locked(struct tevent_req *subre
 			return;
 		}
 	} else {
-		netlogon_creds_des_encrypt(&state->tmp_creds,
-					   &state->samr_password);
+		status = netlogon_creds_des_encrypt(&state->tmp_creds,
+						    &state->samr_password);
+		if (tevent_req_nterror(req, status)) {
+			netlogon_creds_cli_ServerPasswordSet_cleanup(req, status);
+			return;
+		}
 
 		subreq = dcerpc_netr_ServerPasswordSet_send(state, state->ev,
 					state->binding_handle,
@@ -3187,14 +3191,22 @@ static void netlogon_creds_cli_ServerGetTrustInfo_done(struct tevent_req *subreq
 	cmp = memcmp(state->new_owf_password.hash,
 		     zero.hash, sizeof(zero.hash));
 	if (cmp != 0) {
-		netlogon_creds_des_decrypt(&state->tmp_creds,
-					   &state->new_owf_password);
+		status = netlogon_creds_des_decrypt(&state->tmp_creds,
+						    &state->new_owf_password);
+		if (tevent_req_nterror(req, status)) {
+			netlogon_creds_cli_ServerGetTrustInfo_cleanup(req, status);
+			return;
+		}
 	}
 	cmp = memcmp(state->old_owf_password.hash,
 		     zero.hash, sizeof(zero.hash));
 	if (cmp != 0) {
-		netlogon_creds_des_decrypt(&state->tmp_creds,
-					   &state->old_owf_password);
+		status = netlogon_creds_des_decrypt(&state->tmp_creds,
+						    &state->old_owf_password);
+		if (tevent_req_nterror(req, status)) {
+			netlogon_creds_cli_ServerGetTrustInfo_cleanup(req, status);
+			return;
+		}
 	}
 
 	*state->creds = state->tmp_creds;
diff --git a/libcli/auth/ntlm_check.c b/libcli/auth/ntlm_check.c
index 5058add3811..846e0c07cd5 100644
--- a/libcli/auth/ntlm_check.c
+++ b/libcli/auth/ntlm_check.c
@@ -36,6 +36,8 @@ static bool smb_pwd_check_ntlmv1(TALLOC_CTX *mem_ctx,
 {
 	/* Finish the encryption of part_passwd. */
 	uint8_t p24[24];
+	int rc;
+	bool ok;
 
 	if (part_passwd == NULL) {
 		DEBUG(10,("No password set - DISALLOWING access\n"));
@@ -44,18 +46,20 @@ static bool smb_pwd_check_ntlmv1(TALLOC_CTX *mem_ctx,
 	}
 
 	if (sec_blob->length != 8) {
-		DEBUG(0, ("smb_pwd_check_ntlmv1: incorrect challenge size (%lu)\n", 
-			  (unsigned long)sec_blob->length));
+		DBG_ERR("incorrect challenge size (%zu)\n", sec_blob->length);
 		return false;
 	}
 
 	if (nt_response->length != 24) {
-		DEBUG(0, ("smb_pwd_check_ntlmv1: incorrect password length (%lu)\n", 
-			  (unsigned long)nt_response->length));
+		DBG_ERR("incorrect password length (%zu)\n",
+			nt_response->length);
 		return false;
 	}
 
-	SMBOWFencrypt(part_passwd, sec_blob->data, p24);
+	rc = SMBOWFencrypt(part_passwd, sec_blob->data, p24);
+	if (rc != 0) {
+		return false;
+	}
 
 #if DEBUG_PASSWORD
 	DEBUG(100,("Part password (P16) was |\n"));
@@ -67,14 +71,19 @@ static bool smb_pwd_check_ntlmv1(TALLOC_CTX *mem_ctx,
 	DEBUGADD(100,("Value from encryption was |\n"));
 	dump_data(100, p24, 24);
 #endif
-	if (memcmp(p24, nt_response->data, 24) == 0) {
-		if (user_sess_key != NULL) {
-			*user_sess_key = data_blob_talloc(mem_ctx, NULL, 16);
-			SMBsesskeygen_ntv1(part_passwd, user_sess_key->data);
+	ok = (memcmp(p24, nt_response->data, 24) == 0);
+	if (!ok) {
+		return false;
+	}
+	if (user_sess_key != NULL) {
+		*user_sess_key = data_blob_talloc(mem_ctx, NULL, 16);
+		if (user_sess_key->data == NULL) {
+			DBG_ERR("data_blob_talloc failed\n");
+			return false;
 		}
-		return true;
-	} 
-	return false;
+		SMBsesskeygen_ntv1(part_passwd, user_sess_key->data);
+	}
+	return true;
 }
 
 /****************************************************************************
@@ -94,6 +103,7 @@ static bool smb_pwd_check_ntlmv2(TALLOC_CTX *mem_ctx,
 	uint8_t value_from_encryption[16];
 	DATA_BLOB client_key_data;
 	NTSTATUS status;
+	bool ok;
 
 	if (part_passwd == NULL) {
 		DEBUG(10,("No password set - DISALLOWING access\n"));
@@ -102,8 +112,7 @@ static bool smb_pwd_check_ntlmv2(TALLOC_CTX *mem_ctx,
 	}
 
 	if (sec_blob->length != 8) {
-		DEBUG(0, ("smb_pwd_check_ntlmv2: incorrect challenge size (%lu)\n", 
-			  (unsigned long)sec_blob->length));
+		DBG_ERR("incorrect challenge size (%zu)\n", sec_blob->length);
 		return false;
 	}
 
@@ -111,8 +120,8 @@ static bool smb_pwd_check_ntlmv2(TALLOC_CTX *mem_ctx,
 		/* We MUST have more than 16 bytes, or the stuff below will go
 		   crazy.  No known implementation sends less than the 24 bytes
 		   for LMv2, let alone NTLMv2. */
-		DEBUG(0, ("smb_pwd_check_ntlmv2: incorrect password length (%lu)\n", 
-			  (unsigned long)ntv2_response->length));
+		DBG_ERR("incorrect password length (%zu)\n",
+			ntv2_response->length);
 		return false;
 	}
 
@@ -147,20 +156,25 @@ static bool smb_pwd_check_ntlmv2(TALLOC_CTX *mem_ctx,
 	dump_data(100, value_from_encryption, 16);
 #endif
 	data_blob_clear_free(&client_key_data);
-	if (memcmp(value_from_encryption, ntv2_response->data, 16) == 0) { 
-		if (user_sess_key != NULL) {
-			*user_sess_key = data_blob_talloc(mem_ctx, NULL, 16);
-
-			status = SMBsesskeygen_ntv2(kr,
-						    value_from_encryption,
-						    user_sess_key->data);
-			if (!NT_STATUS_IS_OK(status)) {
-				return false;
-			}
+
+	ok = (memcmp(value_from_encryption, ntv2_response->data, 16) == 0);
+	if (!ok) {
+		return false;
+	}
+	if (user_sess_key != NULL) {
+		*user_sess_key = data_blob_talloc(mem_ctx, NULL, 16);
+		if (user_sess_key->data == NULL) {
+			DBG_ERR("data_blob_talloc failed\n");
+			return false;
+		}
+
+		status = SMBsesskeygen_ntv2(
+			kr, value_from_encryption, user_sess_key->data);
+		if (!NT_STATUS_IS_OK(status)) {
+			return false;
 		}
-		return true;
 	}
-	return false;
+	return true;
 }
 
 /****************************************************************************
@@ -188,8 +202,7 @@ static bool smb_sess_key_ntlmv2(TALLOC_CTX *mem_ctx,
 	}
 
 	if (sec_blob->length != 8) {
-		DEBUG(0, ("smb_sess_key_ntlmv2: incorrect challenge size (%lu)\n", 
-			  (unsigned long)sec_blob->length));
+		DBG_ERR("incorrect challenge size (%zu)\n", sec_blob->length);
 		return false;
 	}
 
@@ -197,8 +210,8 @@ static bool smb_sess_key_ntlmv2(TALLOC_CTX *mem_ctx,
 		/* We MUST have more than 16 bytes, or the stuff below will go
 		   crazy.  No known implementation sends less than the 24 bytes
 		   for LMv2, let alone NTLMv2. */
-		DEBUG(0, ("smb_sess_key_ntlmv2: incorrect password length (%lu)\n", 
-			  (unsigned long)ntv2_response->length));
+		DBG_ERR("incorrect password length (%zu)\n",
+			ntv2_response->length);
 		return false;
 	}
 
@@ -216,6 +229,10 @@ static bool smb_sess_key_ntlmv2(TALLOC_CTX *mem_ctx,
 		return false;
 	}
 	*user_sess_key = data_blob_talloc(mem_ctx, NULL, 16);
+	if (user_sess_key->data == NULL) {
+		DBG_ERR("data_blob_talloc failed\n");
+		return false;
+	}
 	status = SMBsesskeygen_ntv2(kr,
 				    value_from_encryption,
 				    user_sess_key->data);
@@ -377,8 +394,9 @@ NTSTATUS ntlm_password_check(TALLOC_CTX *mem_ctx,
 	}
 
 	if (nt_response->length != 0 && nt_response->length < 24) {
-		DEBUG(2,("ntlm_password_check: invalid NT password length (%lu) for user %s\n", 
-			 (unsigned long)nt_response->length, username));		
+		DBG_NOTICE("invalid NT password length (%zu) for user %s\n",
+			   nt_response->length,
+			   username);
 	}
 
 	if (nt_response->length > 24 && stored_nt) {
@@ -464,8 +482,9 @@ NTSTATUS ntlm_password_check(TALLOC_CTX *mem_ctx,
 	}
 
 	if (lm_response->length < 24) {
-		DEBUG(2,("ntlm_password_check: invalid LanMan password length (%lu) for user %s\n", 
-			 (unsigned long)nt_response->length, username));		
+		DBG_NOTICE("invalid LanMan password length (%zu) for "
+			   "user %s\n",
+			   nt_response->length, username);
 		return NT_STATUS_WRONG_PASSWORD;
 	}
 
diff --git a/libcli/auth/proto.h b/libcli/auth/proto.h
index eb725c83d15..88f4a7c6c50 100644
--- a/libcli/auth/proto.h
+++ b/libcli/auth/proto.h
@@ -4,6 +4,8 @@
 #undef _PRINTF_ATTRIBUTE
 #define _PRINTF_ATTRIBUTE(a1, a2) PRINTF_ATTRIBUTE(a1, a2)
 
+#include "lib/crypto/gnutls_helpers.h"
+
 /* this file contains prototypes for functions that are private 
  * to this subsystem or library. These functions should not be 
  * used outside this particular subsystem! */
@@ -11,10 +13,14 @@
 
 /* The following definitions come from /home/jeremy/src/samba/git/master/source3/../source4/../libcli/auth/credentials.c  */
 
-void netlogon_creds_des_encrypt_LMKey(struct netlogon_creds_CredentialState *creds, struct netr_LMSessionKey *key);
-void netlogon_creds_des_decrypt_LMKey(struct netlogon_creds_CredentialState *creds, struct netr_LMSessionKey *key);
-void netlogon_creds_des_encrypt(struct netlogon_creds_CredentialState *creds, struct samr_Password *pass);
-void netlogon_creds_des_decrypt(struct netlogon_creds_CredentialState *creds, struct samr_Password *pass);
+NTSTATUS netlogon_creds_des_encrypt_LMKey(struct netlogon_creds_CredentialState *creds,
+					  struct netr_LMSessionKey *key);
+NTSTATUS netlogon_creds_des_decrypt_LMKey(struct netlogon_creds_CredentialState *creds,
+					  struct netr_LMSessionKey *key);
+NTSTATUS netlogon_creds_des_encrypt(struct netlogon_creds_CredentialState *creds,
+				    struct samr_Password *pass);
+NTSTATUS netlogon_creds_des_decrypt(struct netlogon_creds_CredentialState *creds,
+				    struct samr_Password *pass);
 NTSTATUS netlogon_creds_arcfour_crypt(struct netlogon_creds_CredentialState *creds,
 				      uint8_t *data,
 				      size_t len);
@@ -84,8 +90,8 @@ union netr_LogonLevel *netlogon_creds_shallow_copy_logon(TALLOC_CTX *mem_ctx,
 
 /* The following definitions come from /home/jeremy/src/samba/git/master/source3/../source4/../libcli/auth/session.c  */
 
-void sess_crypt_blob(DATA_BLOB *out, const DATA_BLOB *in, const DATA_BLOB *session_key,
-		     bool forward);
+int sess_crypt_blob(DATA_BLOB *out, const DATA_BLOB *in, const DATA_BLOB *session_key,
+		    enum samba_gnutls_direction encrypt);
 DATA_BLOB sess_encrypt_string(const char *str, const DATA_BLOB *session_key);
 char *sess_decrypt_string(TALLOC_CTX *mem_ctx, 
 			  DATA_BLOB *blob, const DATA_BLOB *session_key);
@@ -95,7 +101,7 @@ NTSTATUS sess_decrypt_blob(TALLOC_CTX *mem_ctx, const DATA_BLOB *blob, const DAT
 
 /* The following definitions come from /home/jeremy/src/samba/git/master/source3/../source4/../libcli/auth/smbencrypt.c  */
 
-void SMBencrypt_hash(const uint8_t lm_hash[16], const uint8_t *c8, uint8_t p24[24]);
+int SMBencrypt_hash(const uint8_t lm_hash[16], const uint8_t *c8, uint8_t p24[24]);
 bool SMBencrypt(const char *passwd, const uint8_t *c8, uint8_t p24[24]);
 
 /**
@@ -125,9 +131,9 @@ void nt_lm_owf_gen(const char *pwd, uint8_t nt_p16[16], uint8_t p16[16]);
 bool ntv2_owf_gen(const uint8_t owf[16],
 		  const char *user_in, const char *domain_in,
 		  uint8_t kr_buf[16]);
-void SMBOWFencrypt(const uint8_t passwd[16], const uint8_t *c8, uint8_t p24[24]);
-void SMBNTencrypt_hash(const uint8_t nt_hash[16], const uint8_t *c8, uint8_t *p24);
-void SMBNTencrypt(const char *passwd, const uint8_t *c8, uint8_t *p24);
+int SMBOWFencrypt(const uint8_t passwd[16], const uint8_t *c8, uint8_t p24[24]);
+int SMBNTencrypt_hash(const uint8_t nt_hash[16], const uint8_t *c8, uint8_t *p24);
+int SMBNTencrypt(const char *passwd, const uint8_t *c8, uint8_t *p24);
 NTSTATUS SMBOWFencrypt_ntv2(const uint8_t kr[16],
 			    const DATA_BLOB *srv_chal,
 			    const DATA_BLOB *smbcli_chal,
@@ -136,9 +142,9 @@ NTSTATUS SMBsesskeygen_ntv2(const uint8_t kr[16],
 			    const uint8_t *nt_resp,
 			    uint8_t sess_key[16]);
 void SMBsesskeygen_ntv1(const uint8_t kr[16], uint8_t sess_key[16]);
-void SMBsesskeygen_lm_sess_key(const uint8_t lm_hash[16],
-			       const uint8_t lm_resp[24], /* only uses 8 */ 
-			       uint8_t sess_key[16]);
+NTSTATUS SMBsesskeygen_lm_sess_key(const uint8_t lm_hash[16],
+				   const uint8_t lm_resp[24], /* only uses 8 */
+				   uint8_t sess_key[16]);
 DATA_BLOB NTLMv2_generate_names_blob(TALLOC_CTX *mem_ctx, 
 				     const char *hostname, 
 				     const char *domain);
@@ -216,15 +222,18 @@ WERROR decode_wkssvc_join_password_buffer(TALLOC_CTX *mem_ctx,
 
 /* The following definitions come from /home/jeremy/src/samba/git/master/source3/../source4/../libcli/auth/smbdes.c  */
 
-void des_crypt56(uint8_t out[8], const uint8_t in[8], const uint8_t key[7], int forw);
-void E_P16(const uint8_t *p14,uint8_t *p16);
-void E_P24(const uint8_t *p21, const uint8_t *c8, uint8_t *p24);
-void D_P16(const uint8_t *p14, const uint8_t *in, uint8_t *out);
-void E_old_pw_hash( uint8_t *p14, const uint8_t *in, uint8_t *out);
-void des_crypt128(uint8_t out[8], const uint8_t in[8], const uint8_t key[16]);
-void des_crypt112(uint8_t out[8], const uint8_t in[8], const uint8_t key[14], int forw);
-void des_crypt112_16(uint8_t out[16], const uint8_t in[16], const uint8_t key[14], int forw);
-void sam_rid_crypt(unsigned int rid, const uint8_t *in, uint8_t *out, int forw);
+int des_crypt56_gnutls(uint8_t out[8], const uint8_t in[8], const uint8_t key[7],
+		       enum samba_gnutls_direction encrypt);
+int E_P16(const uint8_t *p14,uint8_t *p16);
+int E_P24(const uint8_t *p21, const uint8_t *c8, uint8_t *p24);
+int E_old_pw_hash( uint8_t *p14, const uint8_t *in, uint8_t *out);
+int des_crypt128(uint8_t out[8], const uint8_t in[8], const uint8_t key[16]);
+int des_crypt112(uint8_t out[8], const uint8_t in[8], const uint8_t key[14],
+		 enum samba_gnutls_direction encrypt);
+int des_crypt112_16(uint8_t out[16], const uint8_t in[16], const uint8_t key[14],
+		    enum samba_gnutls_direction encrypt);
+int sam_rid_crypt(unsigned int rid, const uint8_t *in, uint8_t *out,
+		  enum samba_gnutls_direction encrypt);
 #undef _PRINTF_ATTRIBUTE
 #define _PRINTF_ATTRIBUTE(a1, a2)
 
diff --git a/libcli/auth/session.c b/libcli/auth/session.c
index 10c728662db..43ce9d54fdc 100644
--- a/libcli/auth/session.c
+++ b/libcli/auth/session.c
@@ -29,28 +29,35 @@
   before calling, the out blob must be initialised to be the same size
   as the in blob
 */
-void sess_crypt_blob(DATA_BLOB *out, const DATA_BLOB *in, const DATA_BLOB *session_key,
-		     bool forward)
+int sess_crypt_blob(DATA_BLOB *out, const DATA_BLOB *in, const DATA_BLOB *session_key,
+		    enum samba_gnutls_direction encrypt)
 {
-	int i, k;
+	int i, k, rc;
+
+	if (in->length % 8 != 0) {
+		return GNUTLS_E_INVALID_REQUEST;
+	}
 
 	for (i=0,k=0;
 	     i<in->length;
 	     i += 8, k += 7) {
 		uint8_t bin[8], bout[8], key[7];
 
-		memset(bin, 0, 8);
-		memcpy(bin,  &in->data[i], MIN(8, in->length-i));
+		memcpy(bin,  &in->data[i], 8);
 
 		if (k + 7 > session_key->length) {
 			k = (session_key->length - k);
 		}
 		memcpy(key, &session_key->data[k], 7);
 
-		des_crypt56(bout, bin, key, forward?1:0);
+		rc = des_crypt56_gnutls(bout, bin, key, encrypt);
+		if (rc != 0) {
+			return rc;
+		}
 
-		memcpy(&out->data[i], bout, MIN(8, in->length-i));
+		memcpy(&out->data[i], bout, 8);
 	}
+	return 0;
 }
 
 
@@ -67,6 +74,7 @@ DATA_BLOB sess_encrypt_string(const char *str, const DATA_BLOB *session_key)
 	DATA_BLOB ret, src;
 	int slen = strlen(str);
 	int dlen = (slen+7) & ~7;
+	int rc;
 
 	src = data_blob(NULL, 8+dlen);
 	if (!src.data) {
@@ -84,9 +92,13 @@ DATA_BLOB sess_encrypt_string(const char *str, const DATA_BLOB *session_key)
 	memset(src.data+8, 0,   dlen);
 	memcpy(src.data+8, str, slen);
 
-	sess_crypt_blob(&ret, &src, session_key, true);
+	rc = sess_crypt_blob(&ret, &src, session_key, SAMBA_GNUTLS_ENCRYPT);
 	
 	data_blob_free(&src);
+	if (rc != 0) {
+		data_blob_free(&ret);
+		return data_blob(NULL, 0);
+	}
 
 	return ret;
 }
@@ -100,7 +112,7 @@ char *sess_decrypt_string(TALLOC_CTX *mem_ctx,
 			  DATA_BLOB *blob, const DATA_BLOB *session_key)
 {
 	DATA_BLOB out;
-	int slen;
+	int rc, slen;
 	char *ret;
 
 	if (blob->length < 8) {
@@ -112,7 +124,11 @@ char *sess_decrypt_string(TALLOC_CTX *mem_ctx,
 		return NULL;
 	}
 
-	sess_crypt_blob(&out, blob, session_key, false);
+	rc = sess_crypt_blob(&out, blob, session_key, SAMBA_GNUTLS_DECRYPT);
+	if (rc != 0) {
+		data_blob_free(&out);
+		return NULL;
+	}
 
 	if (IVAL(out.data, 4) != 1) {
 		DEBUG(0,("Unexpected revision number %d in session crypted string\n",
@@ -149,6 +165,7 @@ DATA_BLOB sess_encrypt_blob(TALLOC_CTX *mem_ctx, DATA_BLOB *blob_in, const DATA_
 {
 	DATA_BLOB ret, src;
 	int dlen = (blob_in->length+7) & ~7;
+	int rc;
 
 	src = data_blob_talloc(mem_ctx, NULL, 8+dlen);
 	if (!src.data) {
@@ -166,9 +183,13 @@ DATA_BLOB sess_encrypt_blob(TALLOC_CTX *mem_ctx, DATA_BLOB *blob_in, const DATA_
 	memset(src.data+8, 0, dlen);
 	memcpy(src.data+8, blob_in->data, blob_in->length);
 
-	sess_crypt_blob(&ret, &src, session_key, true);
+	rc = sess_crypt_blob(&ret, &src, session_key, SAMBA_GNUTLS_ENCRYPT);
 	
 	data_blob_free(&src);
+	if (rc != 0) {
+		data_blob_free(&ret);
+		return data_blob(NULL, 0);
+	}
 
 	return ret;
 }
@@ -180,7 +201,7 @@ NTSTATUS sess_decrypt_blob(TALLOC_CTX *mem_ctx, const DATA_BLOB *blob, const DAT
 			   DATA_BLOB *ret)
 {
 	DATA_BLOB out;
-	int slen;
+	int rc, slen;
 
 	if (blob->length < 8) {
 		DEBUG(0, ("Unexpected length %d in session crypted secret (BLOB)\n",
@@ -193,7 +214,11 @@ NTSTATUS sess_decrypt_blob(TALLOC_CTX *mem_ctx, const DATA_BLOB *blob, const DAT
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	sess_crypt_blob(&out, blob, session_key, false);
+	rc = sess_crypt_blob(&out, blob, session_key, SAMBA_GNUTLS_DECRYPT);
+	if (rc != 0) {
+		data_blob_free(&out);
+		return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+	}
 
 	if (IVAL(out.data, 4) != 1) {
 		DEBUG(2,("Unexpected revision number %d in session crypted secret (BLOB)\n",
diff --git a/libcli/auth/smbdes.c b/libcli/auth/smbdes.c
index 6d9a6dc2ce8..c6c44419306 100644
--- a/libcli/auth/smbdes.c
+++ b/libcli/auth/smbdes.c
@@ -23,238 +23,8 @@
 #include "includes.h"
 #include "libcli/auth/libcli_auth.h"
 
-/* NOTES: 
-
-   This code makes no attempt to be fast! In fact, it is a very
-   slow implementation 
-
-   This code is NOT a complete DES implementation. It implements only
-   the minimum necessary for SMB authentication, as used by all SMB
-   products (including every copy of Microsoft Windows95 ever sold)
-
-   In particular, it can only do a unchained forward DES pass. This
-   means it is not possible to use this code for encryption/decryption
-   of data, instead it is only useful as a "hash" algorithm.
-
-   There is no entry point into this code that allows normal DES operation.
-
-   I believe this means that this code does not come under ITAR
-   regulations but this is NOT a legal opinion. If you are concerned
-   about the applicability of ITAR regulations to this code then you
-   should confirm it for yourself (and maybe let me know if you come
-   up with a different answer to the one above)
-*/
-
-
-static const uint8_t perm1[56] = {57, 49, 41, 33, 25, 17,  9,
-			 1, 58, 50, 42, 34, 26, 18,
-			10,  2, 59, 51, 43, 35, 27,
-			19, 11,  3, 60, 52, 44, 36,
-			63, 55, 47, 39, 31, 23, 15,
-			 7, 62, 54, 46, 38, 30, 22,
-			14,  6, 61, 53, 45, 37, 29,
-			21, 13,  5, 28, 20, 12,  4};
-
-static const uint8_t perm2[48] = {14, 17, 11, 24,  1,  5,
-                         3, 28, 15,  6, 21, 10,
-                        23, 19, 12,  4, 26,  8,
-                        16,  7, 27, 20, 13,  2,
-                        41, 52, 31, 37, 47, 55,
-                        30, 40, 51, 45, 33, 48,
-                        44, 49, 39, 56, 34, 53,
-                        46, 42, 50, 36, 29, 32};
-
-static const uint8_t perm3[64] = {58, 50, 42, 34, 26, 18, 10,  2,
-			60, 52, 44, 36, 28, 20, 12,  4,
-			62, 54, 46, 38, 30, 22, 14,  6,
-			64, 56, 48, 40, 32, 24, 16,  8,
-			57, 49, 41, 33, 25, 17,  9,  1,
-			59, 51, 43, 35, 27, 19, 11,  3,
-			61, 53, 45, 37, 29, 21, 13,  5,
-			63, 55, 47, 39, 31, 23, 15,  7};
-
-static const uint8_t perm4[48] = {   32,  1,  2,  3,  4,  5,
-                            4,  5,  6,  7,  8,  9,
-                            8,  9, 10, 11, 12, 13,
-                           12, 13, 14, 15, 16, 17,
-                           16, 17, 18, 19, 20, 21,
-                           20, 21, 22, 23, 24, 25,
-                           24, 25, 26, 27, 28, 29,
-                           28, 29, 30, 31, 32,  1};
-
-static const uint8_t perm5[32] = {      16,  7, 20, 21,
-                              29, 12, 28, 17,
-                               1, 15, 23, 26,
-                               5, 18, 31, 10,
-                               2,  8, 24, 14,
-                              32, 27,  3,  9,
-                              19, 13, 30,  6,
-                              22, 11,  4, 25};
-
-
-static const uint8_t perm6[64] ={ 40,  8, 48, 16, 56, 24, 64, 32,
-                        39,  7, 47, 15, 55, 23, 63, 31,
-                        38,  6, 46, 14, 54, 22, 62, 30,
-                        37,  5, 45, 13, 53, 21, 61, 29,
-                        36,  4, 44, 12, 52, 20, 60, 28,
-                        35,  3, 43, 11, 51, 19, 59, 27,
-                        34,  2, 42, 10, 50, 18, 58, 26,
-                        33,  1, 41,  9, 49, 17, 57, 25};
-
-
-static const uint8_t sc[16] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};
-
-static const uint8_t sbox[8][4][16] = {
-	{{14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7},
-	 {0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8},
-	 {4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0},
-	 {15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13}},
-
-	{{15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10},
-	 {3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5},
-	 {0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15},
-	 {13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9}},
-
-	{{10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8},
-	 {13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1},
-	 {13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7},
-	 {1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12}},
-
-	{{7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15},
-	 {13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9},
-	 {10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4},
-	 {3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14}},
-
-	{{2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9},
-	 {14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6},
-	 {4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14},
-	 {11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3}},
-
-	{{12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11},
-	 {10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8},
-	 {9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6},
-	 {4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13}},
-
-	{{4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1},
-	 {13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6},
-	 {1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2},
-	 {6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12}},
-
-	{{13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7},
-	 {1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2},
-	 {7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8},
-	 {2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11}}};
-
-static void permute(char *out, const char *in, const uint8_t *p, int n)
-{
-	int i;
-	for (i=0;i<n;i++)
-		out[i] = in[p[i]-1];
-}
-
-static void lshift(char *d, int count, int n)
-{
-	char out[64];
-	int i;
-	for (i=0;i<n;i++)
-		out[i] = d[(i+count)%n];
-	for (i=0;i<n;i++)
-		d[i] = out[i];
-}
-
-static void concat(char *out, char *in1, char *in2, int l1, int l2)
-{
-	while (l1--)
-		*out++ = *in1++;
-	while (l2--)
-		*out++ = *in2++;
-}
-
-static void xor(char *out, char *in1, char *in2, int n)
-{
-	int i;
-	for (i=0;i<n;i++)
-		out[i] = in1[i] ^ in2[i];
-}
-
-static void dohash(char *out, char *in, char *key, int forw)
-{
-	int i, j, k;
-	char pk1[56];
-	char c[28];
-	char d[28];
-	char cd[56];
-	char ki[16][48];
-	char pd1[64];
-	char l[32], r[32];
-	char rl[64];
-
-	permute(pk1, key, perm1, 56);
-
-	for (i=0;i<28;i++)
-		c[i] = pk1[i];
-	for (i=0;i<28;i++)
-		d[i] = pk1[i+28];
-
-	for (i=0;i<16;i++) {
-		lshift(c, sc[i], 28);
-		lshift(d, sc[i], 28);
-
-		concat(cd, c, d, 28, 28); 
-		permute(ki[i], cd, perm2, 48); 
-	}
-
-	permute(pd1, in, perm3, 64);
-
-	for (j=0;j<32;j++) {
-		l[j] = pd1[j];
-		r[j] = pd1[j+32];
-	}
-
-	for (i=0;i<16;i++) {
-		char er[48];
-		char erk[48];
-		char b[8][6];
-		char cb[32];
-		char pcb[32];
-		char r2[32];
-
-		permute(er, r, perm4, 48);
-
-		xor(erk, er, ki[forw ? i : 15 - i], 48);
-
-		for (j=0;j<8;j++)
-			for (k=0;k<6;k++)
-				b[j][k] = erk[j*6 + k];
-
-		for (j=0;j<8;j++) {
-			int m, n;
-			m = (b[j][0]<<1) | b[j][5];
-
-			n = (b[j][1]<<3) | (b[j][2]<<2) | (b[j][3]<<1) | b[j][4]; 
-
-			for (k=0;k<4;k++) 
-				b[j][k] = (sbox[j][m][n] & (1<<(3-k)))?1:0; 
-		}
-
-		for (j=0;j<8;j++)
-			for (k=0;k<4;k++)
-				cb[j*4+k] = b[j][k];
-		permute(pcb, cb, perm5, 32);
-
-		xor(r2, l, pcb, 32);
-
-		for (j=0;j<32;j++)
-			l[j] = r[j];
-
-		for (j=0;j<32;j++)
-			r[j] = r2[j];
-	}
-
-	concat(rl, r, l, 32, 32);
-
-	permute(out, rl, perm6, 64);
-}
+#include <gnutls/gnutls.h>
+#include <gnutls/crypto.h>
 
 static void str_to_key(const uint8_t *str,uint8_t *key)
 {
@@ -273,98 +43,171 @@ static void str_to_key(const uint8_t *str,uint8_t *key)
 	}
 }
 
-/*
-  basic des crypt using a 56 bit (7 byte) key
-*/
-void des_crypt56(uint8_t out[8], const uint8_t in[8], const uint8_t key[7], int forw)
+int des_crypt56_gnutls(uint8_t out[8], const uint8_t in[8],
+		       const uint8_t key_in[7],
+		       enum samba_gnutls_direction encrypt)
 {
-	int i;
-	char outb[64];
-	char inb[64];
-	char keyb[64];
+	/*
+	 * A single block DES-CBC op, with an all-zero IV is the same as DES
+	 * because the IV is combined with the data using XOR.
+	 * This allows us to use GNUTLS_CIPHER_DES_CBC from GnuTLS and not
+	 * implement single-DES in Samba.
+	 *
+	 * In turn this is used to build DES-ECB, which is used
+	 * for example in the NTLM challenge/response calculation.
+	 */
+	static const uint8_t iv8[8];
+	gnutls_datum_t iv = { discard_const(iv8), 8 };
+	gnutls_datum_t key;
+	gnutls_cipher_hd_t ctx;
 	uint8_t key2[8];
+	uint8_t outb[8];
+	int ret;
+
+	memset(out, 0, 8);
 
-	str_to_key(key, key2);
+	str_to_key(key_in, key2);
 
-	for (i=0;i<64;i++) {
-		inb[i] = (in[i/8] & (1<<(7-(i%8)))) ? 1 : 0;
-		keyb[i] = (key2[i/8] & (1<<(7-(i%8)))) ? 1 : 0;
-		outb[i] = 0;
+	key.data = key2;
+	key.size = 8;
+
+	ret = gnutls_global_init();
+	if (ret != 0) {
+		return ret;
 	}
 
-	dohash(outb, inb, keyb, forw);
+	ret = gnutls_cipher_init(&ctx, GNUTLS_CIPHER_DES_CBC, &key, &iv);
+	if (ret != 0) {
+		return ret;
+	}
 
-	for (i=0;i<8;i++) {
-		out[i] = 0;
+	memcpy(outb, in, 8);
+	if (encrypt == SAMBA_GNUTLS_ENCRYPT) {
+		ret = gnutls_cipher_encrypt(ctx, outb, 8);
+	} else {
+		ret = gnutls_cipher_decrypt(ctx, outb, 8);
 	}
 
-	for (i=0;i<64;i++) {
-		if (outb[i])
-			out[i/8] |= (1<<(7-(i%8)));
+	if (ret == 0) {
+		memcpy(out, outb, 8);
 	}
+
+	gnutls_cipher_deinit(ctx);
+
+	return ret;
 }
 
-void E_P16(const uint8_t *p14,uint8_t *p16)
+int E_P16(const uint8_t *p14,uint8_t *p16)
 {
 	const uint8_t sp8[8] = {0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25};
-	des_crypt56(p16, sp8, p14, 1);
-	des_crypt56(p16+8, sp8, p14+7, 1);
-}
+	int ret;
 
-void E_P24(const uint8_t *p21, const uint8_t *c8, uint8_t *p24)
-{
-	des_crypt56(p24, c8, p21, 1);
-	des_crypt56(p24+8, c8, p21+7, 1);
-	des_crypt56(p24+16, c8, p21+14, 1);
+	ret = des_crypt56_gnutls(p16, sp8, p14, SAMBA_GNUTLS_ENCRYPT);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return des_crypt56_gnutls(p16+8, sp8, p14+7, SAMBA_GNUTLS_ENCRYPT);
 }
 
-void D_P16(const uint8_t *p14, const uint8_t *in, uint8_t *out)
+int E_P24(const uint8_t *p21, const uint8_t *c8, uint8_t *p24)
 {
-	des_crypt56(out, in, p14, 0);
-        des_crypt56(out+8, in+8, p14+7, 0);
+	int ret;
+
+	ret = des_crypt56_gnutls(p24, c8, p21, SAMBA_GNUTLS_ENCRYPT);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = des_crypt56_gnutls(p24+8, c8, p21+7, SAMBA_GNUTLS_ENCRYPT);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return des_crypt56_gnutls(p24+16, c8, p21+14, SAMBA_GNUTLS_ENCRYPT);
 }
 
-void E_old_pw_hash( uint8_t *p14, const uint8_t *in, uint8_t *out)
+int E_old_pw_hash( uint8_t *p14, const uint8_t *in, uint8_t *out)
 {
-        des_crypt56(out, in, p14, 1);
-        des_crypt56(out+8, in+8, p14+7, 1);
+	int ret;
+
+        ret = des_crypt56_gnutls(out, in, p14, SAMBA_GNUTLS_ENCRYPT);
+	if (ret != 0) {
+		return ret;
+	}
+
+        return des_crypt56_gnutls(out+8, in+8, p14+7, SAMBA_GNUTLS_ENCRYPT);
 }
 
 /* des encryption with a 128 bit key */
-void des_crypt128(uint8_t out[8], const uint8_t in[8], const uint8_t key[16])
+int des_crypt128(uint8_t out[8], const uint8_t in[8], const uint8_t key[16])
 {
 	uint8_t buf[8];
-	des_crypt56(buf, in, key, 1);
-	des_crypt56(out, buf, key+9, 1);
+	int ret;
+
+	ret = des_crypt56_gnutls(buf, in, key, SAMBA_GNUTLS_ENCRYPT);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return des_crypt56_gnutls(out, buf, key+9, SAMBA_GNUTLS_ENCRYPT);
 }
 
 /* des encryption with a 112 bit (14 byte) key */
-void des_crypt112(uint8_t out[8], const uint8_t in[8], const uint8_t key[14], int forw)
+int des_crypt112(uint8_t out[8], const uint8_t in[8], const uint8_t key[14],
+		 enum samba_gnutls_direction encrypt)
 {
 	uint8_t buf[8];
-	des_crypt56(buf, in, key, forw);
-	des_crypt56(out, buf, key+7, forw);
+	int ret;
+
+	if (encrypt == SAMBA_GNUTLS_ENCRYPT) {
+		ret = des_crypt56_gnutls(buf, in, key, SAMBA_GNUTLS_ENCRYPT);
+		if (ret != 0) {
+			return ret;
+		}
+
+		return des_crypt56_gnutls(out, buf, key+7, SAMBA_GNUTLS_ENCRYPT);
+	}
+
+	ret = des_crypt56_gnutls(buf, in, key+7, SAMBA_GNUTLS_DECRYPT);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return des_crypt56_gnutls(out, buf, key, SAMBA_GNUTLS_DECRYPT);
 }
 
 /* des encryption of a 16 byte lump of data with a 112 bit key */
-void des_crypt112_16(uint8_t out[16], const uint8_t in[16], const uint8_t key[14], int forw)
+int des_crypt112_16(uint8_t out[16], const uint8_t in[16], const uint8_t key[14],
+		    enum samba_gnutls_direction encrypt)
 {
-        des_crypt56(out, in, key, forw);
-        des_crypt56(out + 8, in + 8, key+7, forw);
+	int ret;
+
+	ret = des_crypt56_gnutls(out, in, key, encrypt);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return des_crypt56_gnutls(out + 8, in + 8, key+7, encrypt);
 }
 
 /* Decode a sam password hash into a password.  The password hash is the
    same method used to store passwords in the NT registry.  The DES key
    used is based on the RID of the user. */
-void sam_rid_crypt(unsigned int rid, const uint8_t *in, uint8_t *out, int forw)
+int sam_rid_crypt(unsigned int rid, const uint8_t *in, uint8_t *out,
+		  enum samba_gnutls_direction encrypt)
 {
 	uint8_t s[14];
+	int ret;
 
 	s[0] = s[4] = s[8] = s[12] = (uint8_t)(rid & 0xFF);
 	s[1] = s[5] = s[9] = s[13] = (uint8_t)((rid >> 8) & 0xFF);
 	s[2] = s[6] = s[10]        = (uint8_t)((rid >> 16) & 0xFF);
 	s[3] = s[7] = s[11]        = (uint8_t)((rid >> 24) & 0xFF);
 
-	des_crypt56(out, in, s, forw);
-	des_crypt56(out+8, in+8, s+7, forw);
+	ret = des_crypt56_gnutls(out, in, s, encrypt);
+	if (ret != 0) {
+		return ret;
+	}
+	return des_crypt56_gnutls(out+8, in+8, s+7, encrypt);
 }
diff --git a/libcli/auth/smbencrypt.c b/libcli/auth/smbencrypt.c
index ab2c47ad9bb..337e89ef559 100644
--- a/libcli/auth/smbencrypt.c
+++ b/libcli/auth/smbencrypt.c
@@ -32,14 +32,15 @@
 #include <gnutls/gnutls.h>
 #include <gnutls/crypto.h>
 
-void SMBencrypt_hash(const uint8_t lm_hash[16], const uint8_t *c8, uint8_t p24[24])
+int SMBencrypt_hash(const uint8_t lm_hash[16], const uint8_t *c8, uint8_t p24[24])
 {
 	uint8_t p21[21];
+	int rc;
 
 	memset(p21,'\0',21);
 	memcpy(p21, lm_hash, 16);
 
-	SMBOWFencrypt(p21, c8, p24);
+	rc = SMBOWFencrypt(p21, c8, p24);
 
 #ifdef DEBUG_PASSWORD
 	DEBUG(100,("SMBencrypt_hash: lm#, challenge, response\n"));
@@ -47,6 +48,8 @@ void SMBencrypt_hash(const uint8_t lm_hash[16], const uint8_t *c8, uint8_t p24[2
 	dump_data(100, c8, 8);
 	dump_data(100, p24, 24);
 #endif
+
+	return rc;
 }
 
 /*
@@ -61,9 +64,13 @@ bool SMBencrypt(const char *passwd, const uint8_t *c8, uint8_t p24[24])
 {
 	bool ret;
 	uint8_t lm_hash[16];
+	int rc;
 
 	ret = E_deshash(passwd, lm_hash);
-	SMBencrypt_hash(lm_hash, c8, p24);
+	rc = SMBencrypt_hash(lm_hash, c8, p24);
+	if (rc != 0) {
+		ret = false;
+	}
 	return ret;
 }
 
@@ -105,6 +112,7 @@ bool E_md4hash(const char *passwd, uint8_t p16[16])
 bool E_deshash(const char *passwd, uint8_t p16[16])
 {
 	bool ret;
+	int rc;
 	uint8_t dospwd[14];
 	TALLOC_CTX *frame = talloc_stackframe();
 
@@ -133,7 +141,10 @@ bool E_deshash(const char *passwd, uint8_t p16[16])
 	 * case to avoid returning a fixed 'password' buffer, but
 	 * callers should not use it when E_deshash returns false */
 
-	E_P16((const uint8_t *)dospwd, p16);
+	rc = E_P16((const uint8_t *)dospwd, p16);
+	if (rc != 0) {
+		ret = false;
+	}
 
 	ZERO_STRUCT(dospwd);
 
@@ -262,25 +273,26 @@ out:
 }
 
 /* Does the des encryption from the NT or LM MD4 hash. */
-void SMBOWFencrypt(const uint8_t passwd[16], const uint8_t *c8, uint8_t p24[24])
+int SMBOWFencrypt(const uint8_t passwd[16], const uint8_t *c8, uint8_t p24[24])
 {
 	uint8_t p21[21];
 
 	ZERO_STRUCT(p21);
 
 	memcpy(p21, passwd, 16);
-	E_P24(p21, c8, p24);
+	return E_P24(p21, c8, p24);
 }
 
 /* Does the des encryption. */
 
-void SMBNTencrypt_hash(const uint8_t nt_hash[16], const uint8_t *c8, uint8_t *p24)
+int SMBNTencrypt_hash(const uint8_t nt_hash[16], const uint8_t *c8, uint8_t *p24)
 {
 	uint8_t p21[21];
+	int rc;
 
 	memset(p21,'\0',21);
 	memcpy(p21, nt_hash, 16);
-	SMBOWFencrypt(p21, c8, p24);
+	rc = SMBOWFencrypt(p21, c8, p24);
 
 #ifdef DEBUG_PASSWORD
 	DEBUG(100,("SMBNTencrypt: nt#, challenge, response\n"));
@@ -288,15 +300,17 @@ void SMBNTencrypt_hash(const uint8_t nt_hash[16], const uint8_t *c8, uint8_t *p2
 	dump_data(100, c8, 8);
 	dump_data(100, p24, 24);
 #endif
+
+	return rc;
 }
 
 /* Does the NT MD4 hash then des encryption. Plaintext version of the above. */
 
-void SMBNTencrypt(const char *passwd, const uint8_t *c8, uint8_t *p24)
+int SMBNTencrypt(const char *passwd, const uint8_t *c8, uint8_t *p24)
 {
 	uint8_t nt_hash[16];
 	E_md4hash(passwd, nt_hash);
-	SMBNTencrypt_hash(nt_hash, c8, p24);
+	return SMBNTencrypt_hash(nt_hash, c8, p24);
 }
 
 
@@ -380,7 +394,7 @@ void SMBsesskeygen_ntv1(const uint8_t kr[16], uint8_t sess_key[16])
 #endif
 }
 
-void SMBsesskeygen_lm_sess_key(const uint8_t lm_hash[16],
+NTSTATUS SMBsesskeygen_lm_sess_key(const uint8_t lm_hash[16],
 			       const uint8_t lm_resp[24], /* only uses 8 */
 			       uint8_t sess_key[16])
 {
@@ -388,12 +402,19 @@ void SMBsesskeygen_lm_sess_key(const uint8_t lm_hash[16],
 	   but changes with each session) */
 	uint8_t p24[24];
 	uint8_t partial_lm_hash[14];
+	int rc;
 
 	memcpy(partial_lm_hash, lm_hash, 8);
 	memset(partial_lm_hash + 8, 0xbd, 6);
 
-	des_crypt56(p24,   lm_resp, partial_lm_hash,     1);
-	des_crypt56(p24+8, lm_resp, partial_lm_hash + 7, 1);
+	rc = des_crypt56_gnutls(p24, lm_resp, partial_lm_hash, SAMBA_GNUTLS_ENCRYPT);
+	if (rc < 0) {
+		return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+	}
+	rc = des_crypt56_gnutls(p24+8, lm_resp, partial_lm_hash + 7, SAMBA_GNUTLS_ENCRYPT);
+	if (rc < 0) {
+		return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+	}
 
 	memcpy(sess_key, p24, 16);
 
@@ -401,6 +422,8 @@ void SMBsesskeygen_lm_sess_key(const uint8_t lm_hash[16],
 	DEBUG(100, ("SMBsesskeygen_lm_sess_key: \n"));
 	dump_data(100, sess_key, 16);
 #endif
+
+	return NT_STATUS_OK;
 }
 
 DATA_BLOB NTLMv2_generate_names_blob(TALLOC_CTX *mem_ctx,
diff --git a/libcli/auth/tests/test_gnutls.c b/libcli/auth/tests/test_gnutls.c
index f4ef4ec19c8..da7a3b41dd1 100644
--- a/libcli/auth/tests/test_gnutls.c
+++ b/libcli/auth/tests/test_gnutls.c
@@ -24,12 +24,13 @@
 #include <cmocka.h>
 
 #include "includes.h"
+#include "libcli/auth/libcli_auth.h"
 
 #include "lib/crypto/gnutls_helpers.h"
 #include <gnutls/gnutls.h>
 #include <gnutls/crypto.h>
 
-#ifdef HAVE_GNUTLS_AES_CFB8
+#if defined(HAVE_GNUTLS_AES_CFB8) && GNUTLS_VERSION_NUMBER > 0x03060a
 static void torture_gnutls_aes_128_cfb_flags(void **state,
 					const DATA_BLOB session_key,
 					const DATA_BLOB seq_num_initial,
@@ -72,7 +73,9 @@ static void torture_gnutls_aes_128_cfb_flags(void **state,
 
 	DEBUG(0,("confounder before crypt:\n"));
 	dump_data(0, confounder, 8);
+	DEBUG(0,("initial seq num:\n"));
 	dump_data(0, seq_num_initial.data, 8);
+	DEBUG(0,("io data before crypt:\n"));
 	dump_data(0, io.data, io.length);
 
 	for (i = 0; i < key.size; i++) {
@@ -100,10 +103,12 @@ static void torture_gnutls_aes_128_cfb_flags(void **state,
 				   io.length);
 	assert_int_equal(rc, 0);
 
-	dump_data(0, io.data, io.length);
 	DEBUG(0,("confounder after crypt:\n"));
 	dump_data(0, confounder, 8);
+	DEBUG(0,("initial seq num:\n"));
 	dump_data(0, seq_num_initial.data, 8);
+	DEBUG(0,("io data after crypt:\n"));
+	dump_data(0, io.data, io.length);
 	assert_memory_equal(io.data, crypt_expected.data, crypt_expected.length);
 	assert_memory_equal(confounder, confounder_expected.data, confounder_expected.length);
 
@@ -118,10 +123,12 @@ static void torture_gnutls_aes_128_cfb_flags(void **state,
 	assert_int_equal(rc, 0);
 	gnutls_cipher_deinit(cipher_hnd);
 
-	dump_data(0, io.data, io.length);
 	DEBUG(0,("confounder after decrypt:\n"));
 	dump_data(0, confounder, 8);
+	DEBUG(0,("initial seq num:\n"));
 	dump_data(0, seq_num_initial.data, 8);
+	DEBUG(0,("io data after decrypt:\n"));
+	dump_data(0, io.data, io.length);
 	assert_memory_equal(io.data, clear_initial.data, clear_initial.length);
 	assert_memory_equal(confounder, confounder_initial.data, confounder_initial.length);
 }
@@ -129,7 +136,7 @@ static void torture_gnutls_aes_128_cfb_flags(void **state,
 
 static void torture_gnutls_aes_128_cfb(void **state)
 {
-#ifdef HAVE_GNUTLS_AES_CFB8
+#if defined(HAVE_GNUTLS_AES_CFB8) && GNUTLS_VERSION_NUMBER > 0x03060a
 	const uint8_t _session_key[16] = {
 		0x8E, 0xE8, 0x27, 0x85, 0x83, 0x41, 0x3C, 0x8D,
 		0xC9, 0x54, 0x70, 0x75, 0x8E, 0xC9, 0x69, 0x91
@@ -221,11 +228,293 @@ static void torture_gnutls_aes_128_cfb(void **state)
 #endif
 }
 
+static void torture_gnutls_des_crypt56(void **state)
+{
+	static const uint8_t key[7] = {
+		0x69, 0x88, 0x96, 0x8E, 0xB5, 0x3A, 0x24
+	};
+	static const uint8_t clear[8] = {
+		0x3F, 0x49, 0x5B, 0x20, 0xA7, 0x84, 0xC2, 0x34
+	};
+	static const uint8_t crypt_expected[8] = {
+		0x54, 0x86, 0xCF, 0x51, 0x49, 0x3A, 0x53, 0x5B
+	};
+
+	uint8_t crypt[8];
+	uint8_t decrypt[8];
+	int rc;
+
+	rc = des_crypt56_gnutls(crypt, clear, key, SAMBA_GNUTLS_ENCRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(crypt, crypt_expected, 8);
+
+	rc = des_crypt56_gnutls(decrypt, crypt, key, SAMBA_GNUTLS_DECRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(decrypt, clear, 8);
+}
+
+static void torture_gnutls_E_P16(void **state)
+{
+	static const uint8_t key[14] = {
+		0x98, 0xFD, 0xCB, 0x3A, 0xF7, 0xB5, 0x1C, 0xF8,
+		0x69, 0x88, 0x96, 0x8E, 0xB5, 0x3A
+	};
+	uint8_t buffer[16] = {
+		0x9C, 0x14, 0xDD, 0xE1, 0x39, 0x23, 0xE0, 0x55,
+		0x3F, 0x49, 0x5B, 0x20, 0xA7, 0x84, 0xC2, 0x34
+	};
+	static const uint8_t crypt_expected[16] = {
+		0x41, 0x4A, 0x7B, 0xEA, 0xAB, 0xBB, 0x95, 0xCE,
+		0x1D, 0xEA, 0xD9, 0xFF, 0xB0, 0xA9, 0xA4, 0x05
+	};
+
+	int rc;
+
+	rc = E_P16(key, buffer);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(buffer, crypt_expected, 16);
+}
+
+static void torture_gnutls_E_P24(void **state)
+{
+	static const uint8_t key[21] = {
+		0xFB, 0x67, 0x99, 0xA4, 0x83, 0xF3, 0xD4, 0xED,
+		0x98, 0xFD, 0xCB, 0x3A, 0xF7, 0xB5, 0x1C, 0xF8,
+		0x69, 0x88, 0x96, 0x8E, 0x3A
+	};
+	const uint8_t c8[8] = {
+		0x44, 0xFB, 0xAC, 0xFB, 0x83, 0xB6, 0x75, 0x2A
+	};
+	static const uint8_t crypt_expected[24] = {
+		0x1A, 0x5E, 0x11, 0xA1, 0x59, 0xA9, 0x6B, 0x4E,
+		0x12, 0x5D, 0x81, 0x75, 0xA6, 0x62, 0x15, 0x6D,
+		0x5D, 0x20, 0x25, 0xC1, 0xA3, 0x92, 0xB3, 0x28
+	};
+
+	uint8_t crypt[24];
+	int rc;
+
+	rc = E_P24(key, c8, crypt);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(crypt, crypt_expected, 24);
+}
+
+static void torture_gnutls_SMBOWFencrypt(void **state)
+{
+	static const uint8_t password[16] = {
+		'M', 'y', 'p', 'a', 's', 's', 'w', 'o',
+		'r', 'd', 'i', 's', '1', '1', '1', '1'
+	};
+	const uint8_t c8[8] = {
+		0x79, 0x88, 0x5A, 0x3D, 0xD3, 0x40, 0x1E, 0x69
+	};
+	static const uint8_t crypt_expected[24] = {
+		0x3F, 0xE3, 0x53, 0x75, 0x81, 0xB4, 0xF0, 0xE7,
+		0x0C, 0xDE, 0xCD, 0xAE, 0x39, 0x1F, 0x14, 0xB4,
+		0xA4, 0x2B, 0x3E, 0x39, 0x16, 0xFD, 0x1D, 0x62
+	};
+
+	uint8_t crypt[24];
+	int rc;
+
+	rc = SMBOWFencrypt(password, c8, crypt);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(crypt, crypt_expected, 24);
+}
+
+static void torture_gnutls_E_old_pw_hash(void **state)
+{
+	static uint8_t key[14] = {
+		0x98, 0xFD, 0xCB, 0x3A, 0xF7, 0xB5, 0x1C, 0xF8,
+		0x69, 0x88, 0x96, 0x8E, 0xB5, 0x3A
+	};
+	uint8_t clear[16] = {
+		0x9C, 0x14, 0xDD, 0xE1, 0x39, 0x23, 0xE0, 0x55,
+		0x3F, 0x49, 0x5B, 0x20, 0xA7, 0x84, 0xC2, 0x34
+	};
+	static const uint8_t crypt_expected[16] = {
+		0x6A, 0xC7, 0x08, 0xCA, 0x2A, 0xC1, 0xAA, 0x64,
+		0x37, 0xEF, 0xBE, 0x58, 0xC2, 0x59, 0x33, 0xEC
+	};
+	uint8_t crypt[16];
+	int rc;
+
+	rc = E_old_pw_hash(key, clear, crypt);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(crypt, crypt_expected, 16);
+}
+
+static void torture_gnutls_des_crypt128(void **state)
+{
+	static uint8_t key[16] = {
+		0x98, 0xFD, 0xCB, 0x3A, 0xF7, 0xB5, 0x1C, 0xF8,
+		0xA9, 0x69, 0x88, 0x96, 0x8E, 0xB5, 0x3A, 0x24
+	};
+	static const uint8_t clear[8] = {
+		0x3F, 0x49, 0x5B, 0x20, 0xA7, 0x84, 0xC2, 0x34
+	};
+	static const uint8_t crypt_expected[8] = {
+		0x4C, 0xB4, 0x4B, 0xD3, 0xC8, 0xC1, 0xA5, 0x50
+	};
+
+	uint8_t crypt[8];
+	int rc;
+
+	rc = des_crypt128(crypt, clear, key);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(crypt, crypt_expected, 8);
+}
+
+static void torture_gnutls_des_crypt112(void **state)
+{
+	static uint8_t key[14] = {
+		0x98, 0xFD, 0xCB, 0x3A, 0xF7, 0xB5, 0x1C, 0xF8,
+		0x88, 0x96, 0x8E, 0xB5, 0x3A, 0x24
+	};
+	static const uint8_t clear[8] = {
+		0x2F, 0x49, 0x5B, 0x20, 0xD7, 0x84, 0xC2, 0x34
+	};
+	static const uint8_t crypt_expected[8] = {
+		0x87, 0x35, 0xFA, 0xA4, 0x5D, 0x7A, 0xA5, 0x05
+	};
+
+	uint8_t crypt[8];
+	uint8_t decrypt[8];
+	int rc;
+
+	rc = des_crypt112(crypt, clear, key, SAMBA_GNUTLS_ENCRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(crypt, crypt_expected, 8);
+
+	rc = des_crypt112(decrypt, crypt, key, SAMBA_GNUTLS_DECRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(decrypt, clear, 8);
+}
+
+static void torture_gnutls_des_crypt112_16(void **state)
+{
+	static uint8_t key[14] = {
+		0x1E, 0x38, 0x27, 0x5B, 0x3B, 0xB8, 0x67, 0xEB,
+		0x88, 0x96, 0x8E, 0xB5, 0x3A, 0x24
+	};
+	static const uint8_t clear[16] = {
+		0x02, 0xFA, 0x3B, 0xEE, 0xE8, 0xBA, 0x06, 0x01,
+		0xFB, 0x67, 0x99, 0xA4, 0x83, 0xF3, 0xD4, 0xED
+	};
+	static const uint8_t crypt_expected[16] = {
+		0x3C, 0x10, 0x37, 0x67, 0x96, 0x95, 0xF7, 0x96,
+		0xAA, 0x03, 0xB9, 0xEA, 0xD6, 0xB3, 0xC3, 0x2D
+	};
+
+	uint8_t crypt[16];
+	uint8_t decrypt[16];
+	int rc;
+
+	rc = des_crypt112_16(crypt, clear, key, SAMBA_GNUTLS_ENCRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(crypt, crypt_expected, 16);
+
+	rc = des_crypt112_16(decrypt, crypt, key, SAMBA_GNUTLS_DECRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(decrypt, clear, 16);
+}
+
+static void torture_gnutls_sam_rid_crypt(void **state)
+{
+	static const uint8_t clear[16] = {
+		0x02, 0xFA, 0x3B, 0xEE, 0xE8, 0xBA, 0x06, 0x01,
+		0x3F, 0x49, 0x5B, 0x20, 0xA7, 0x84, 0xC2, 0x34
+	};
+	static const uint8_t crypt_expected[16] = {
+		0x1E, 0x38, 0x27, 0x5B, 0x3B, 0xB8, 0x67, 0xEB,
+		0xFB, 0x67, 0x99, 0xA4, 0x83, 0xF3, 0xD4, 0xED
+	};
+
+	uint8_t crypt[16];
+	uint8_t decrypt[16];
+	int rid = 500;
+	int rc;
+
+	rc = sam_rid_crypt(rid, clear, crypt, SAMBA_GNUTLS_ENCRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(crypt, crypt_expected, 16);
+
+	rc = sam_rid_crypt(rid, crypt, decrypt, SAMBA_GNUTLS_DECRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(decrypt, clear, 16);
+}
+
+static void torture_gnutls_SMBsesskeygen_lm_sess_key(void **state)
+{
+	static const uint8_t lm_hash[16] = {
+		0xFB, 0x67, 0x99, 0xA4, 0x83, 0xF3, 0xD4, 0xED,
+		0x9C, 0x14, 0xDD, 0xE1, 0x39, 0x23, 0xE0, 0x55
+	};
+	static const uint8_t lm_resp[24] = {
+		0x02, 0xFA, 0x3B, 0xEE, 0xE8, 0xBA, 0x06, 0x01,
+		0x02, 0xFA, 0x3B, 0xEE, 0xE8, 0xBA, 0x06, 0x01,
+		0x1E, 0x38, 0x27, 0x5B, 0x3B, 0xB8, 0x67, 0xEB
+	};
+	static const uint8_t crypt_expected[16] = {
+		0x52, 0x8D, 0xB2, 0xD3, 0x89, 0x83, 0xFB, 0x9C,
+		0x96, 0x45, 0x15, 0x4B, 0xC3, 0xF5, 0xD5, 0x7F
+	};
+
+	uint8_t crypt_sess_key[16];
+	NTSTATUS status;
+
+	status = SMBsesskeygen_lm_sess_key(lm_hash, lm_resp, crypt_sess_key);
+	assert_true(NT_STATUS_IS_OK(status));
+	assert_memory_equal(crypt_sess_key, crypt_expected, 16);
+}
+
+static void torture_gnutls_sess_crypt_blob(void **state)
+{
+	static uint8_t _key[16] = {
+		0x1E, 0x38, 0x27, 0x5B, 0x3B, 0xB8, 0x67, 0xEB,
+		0xFA, 0xEE, 0xE8, 0xBA, 0x06, 0x01, 0x2D, 0x95
+	};
+	DATA_BLOB key = data_blob_const(_key, 16);
+	static const uint8_t _clear[24] = {
+		0x98, 0xFD, 0xCB, 0x3A, 0xF7, 0xB5, 0x1C, 0xF8,
+		0x02, 0xFA, 0x3B, 0xEE, 0xE8, 0xBA, 0x06, 0x01,
+		0x3F, 0x49, 0x5B, 0x20, 0xA7, 0x84, 0xC2, 0x34
+	};
+	DATA_BLOB clear = data_blob_const(_clear, 24);
+	static const uint8_t crypt_expected[24] = {
+		0x2B, 0xDD, 0x3B, 0xFA, 0x48, 0xC9, 0x63, 0x56,
+		0xAE, 0x8B, 0x3E, 0xCF, 0xEF, 0xDF, 0x7A, 0x42,
+		0xB3, 0x00, 0x71, 0x7F, 0x5D, 0x1D, 0xE4, 0x70
+	};
+	DATA_BLOB crypt = data_blob(NULL, 24);
+	DATA_BLOB decrypt = data_blob(NULL, 24);
+	int rc;
+
+	rc = sess_crypt_blob(&crypt, &clear, &key, SAMBA_GNUTLS_ENCRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(crypt.data, crypt_expected, 24);
+
+	rc = sess_crypt_blob(&decrypt, &crypt, &key, SAMBA_GNUTLS_DECRYPT);
+	assert_int_equal(rc, 0);
+	assert_memory_equal(decrypt.data, clear.data, 24);
+}
+
 int main(int argc, char *argv[])
 {
 	int rc;
 	const struct CMUnitTest tests[] = {
 		cmocka_unit_test(torture_gnutls_aes_128_cfb),
+		cmocka_unit_test(torture_gnutls_des_crypt56),
+		cmocka_unit_test(torture_gnutls_E_P16),
+		cmocka_unit_test(torture_gnutls_E_P24),
+		cmocka_unit_test(torture_gnutls_SMBOWFencrypt),
+		cmocka_unit_test(torture_gnutls_E_old_pw_hash),
+		cmocka_unit_test(torture_gnutls_des_crypt128),
+		cmocka_unit_test(torture_gnutls_des_crypt112),
+		cmocka_unit_test(torture_gnutls_des_crypt112_16),
+		cmocka_unit_test(torture_gnutls_sam_rid_crypt),
+		cmocka_unit_test(torture_gnutls_SMBsesskeygen_lm_sess_key),
+		cmocka_unit_test(torture_gnutls_sess_crypt_blob),
 	};
 
 	if (argc == 2) {
diff --git a/libcli/auth/wscript_build b/libcli/auth/wscript_build
index f1d513e6449..41937623630 100644
--- a/libcli/auth/wscript_build
+++ b/libcli/auth/wscript_build
@@ -13,7 +13,7 @@ bld.SAMBA_SUBSYSTEM('MSRPC_PARSE',
 
 bld.SAMBA_SUBSYSTEM('NTLM_CHECK',
                     source='ntlm_check.c',
-                    deps = 'talloc'
+                    deps = 'talloc LIBCLI_AUTH'
                     )
 
 bld.SAMBA_SUBSYSTEM('LIBCLI_AUTH',
@@ -52,7 +52,7 @@ bld.SAMBA_BINARY(
              cmocka
              talloc
         ''',
-        install=False
+        for_selftest=True
     )
 
 bld.SAMBA_BINARY('test_rc4_passwd_buffer',
@@ -62,7 +62,7 @@ bld.SAMBA_BINARY('test_rc4_passwd_buffer',
                       LIBCLI_AUTH
                       cmocka
                       ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA_BINARY('test_schannel',
                  source='tests/test_schannel.c',
@@ -70,13 +70,14 @@ bld.SAMBA_BINARY('test_schannel',
                       gensec
                       cmocka
                       ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA_BINARY('test_gnutls',
                  source='tests/test_gnutls.c',
                  deps='''
                       gnutls
+                      LIBCLI_AUTH
                       cmocka
                       samba-util
                       ''',
-                 install=False)
+                 for_selftest=True)
diff --git a/libcli/dns/wscript_build b/libcli/dns/wscript_build
index ea745c14028..2d90aa7ec0f 100644
--- a/libcli/dns/wscript_build
+++ b/libcli/dns/wscript_build
@@ -9,7 +9,7 @@ bld.SAMBA_BINARY('resolvconftest',
                   source='resolvconftest.c',
                   deps='clidns',
                   enabled=bld.CONFIG_SET('HAVE_FMEMOPEN'),
-                  install=False)
+                  for_selftest=True)
 
 bld.SAMBA_SUBSYSTEM('dns_lookup',
                     source='dns_lookup.c',
@@ -18,4 +18,4 @@ bld.SAMBA_SUBSYSTEM('dns_lookup',
 bld.SAMBA_BINARY('dns_lookuptest',
                   source='dns_lookuptest.c',
                   deps='dns_lookup',
-                  install=False)
+                  for_selftest=True)
diff --git a/libcli/drsuapi/repl_decrypt.c b/libcli/drsuapi/repl_decrypt.c
index 83275360c7d..30b3c64379f 100644
--- a/libcli/drsuapi/repl_decrypt.c
+++ b/libcli/drsuapi/repl_decrypt.c
@@ -135,7 +135,13 @@ static WERROR drsuapi_decrypt_attribute_value(TALLOC_CTX *mem_ctx,
 		num_hashes = plain_buffer.length / 16;
 		for (i = 0; i < num_hashes; i++) {
 			uint32_t offset = i * 16;
-			sam_rid_crypt(rid, checked_buffer.data + offset, plain_buffer.data + offset, 0);
+			rc = sam_rid_crypt(rid, checked_buffer.data + offset,
+					   plain_buffer.data + offset,
+					   SAMBA_GNUTLS_DECRYPT);
+			if (rc != 0) {
+				result = gnutls_error_to_werror(rc, WERR_INTERNAL_ERROR);
+				goto out;
+			}
 		}
 	}
 
@@ -255,7 +261,13 @@ static WERROR drsuapi_encrypt_attribute_value(TALLOC_CTX *mem_ctx,
 		num_hashes = rid_crypt_out.length / 16;
 		for (i = 0; i < num_hashes; i++) {
 			uint32_t offset = i * 16;
-			sam_rid_crypt(rid, in->data + offset, rid_crypt_out.data + offset, 1);
+			rc = sam_rid_crypt(rid, in->data + offset,
+					   rid_crypt_out.data + offset,
+					   SAMBA_GNUTLS_ENCRYPT);
+			if (rc != 0) {
+				result = gnutls_error_to_werror(rc, WERR_INTERNAL_ERROR);
+				goto out;
+			}
 		}
 		in = &rid_crypt_out;
 	}
diff --git a/libcli/drsuapi/wscript_build b/libcli/drsuapi/wscript_build
index 271248215be..1aee095130c 100644
--- a/libcli/drsuapi/wscript_build
+++ b/libcli/drsuapi/wscript_build
@@ -6,15 +6,14 @@ bld.SAMBA_SUBSYSTEM('LIBCLI_DRSUAPI',
 	public_deps='LIBCLI_AUTH samdb z'
 	)
 
-if bld.CONFIG_GET('ENABLE_SELFTEST'):
-    bld.SAMBA_BINARY(
-        'test_repl_decrypt',
-        source='tests/test_repl_decrypt.c',
-        deps='''
-            LIBCLI_DRSUAPI
-            cmocka
-            talloc
-        ''',
-        install=False,
-        enabled=bld.AD_DC_BUILD_IS_ENABLED()
-    )
+bld.SAMBA_BINARY(
+    'test_repl_decrypt',
+    source='tests/test_repl_decrypt.c',
+    deps='''
+    LIBCLI_DRSUAPI
+    cmocka
+    talloc
+    ''',
+    for_selftest=True,
+    enabled=bld.AD_DC_BUILD_IS_ENABLED()
+)
diff --git a/libcli/http/wscript_build b/libcli/http/wscript_build
index 4ef1574bc67..da8768ffa06 100644
--- a/libcli/http/wscript_build
+++ b/libcli/http/wscript_build
@@ -2,7 +2,7 @@
 
 bld.SAMBA_LIBRARY('http',
 	source='http.c http_auth.c http_conn.c',
-	deps='talloc tevent samba3core dns_lookup',
+	deps='talloc tevent gensec dns_lookup',
 	private_library=True,
 )
 
diff --git a/libcli/nbt/wscript_build b/libcli/nbt/wscript_build
index 090789ce99a..15610765268 100644
--- a/libcli/nbt/wscript_build
+++ b/libcli/nbt/wscript_build
@@ -21,7 +21,7 @@ bld.SAMBA_BINARY('nmblookup' + bld.env.suffix4,
                  source='tools/nmblookup.c',
                  manpages='man/nmblookup4.1',
                  deps='samba-hostconfig samba-util cli-nbt popt POPT_SAMBA netif LIBCLI_RESOLVE',
-                 install=False
+                 install=False,
                  )
 
 bld.SAMBA_PYTHON('python_netbios',
diff --git a/libcli/samsync/decrypt.c b/libcli/samsync/decrypt.c
index 5cda966fb42..77ef93251bc 100644
--- a/libcli/samsync/decrypt.c
+++ b/libcli/samsync/decrypt.c
@@ -25,6 +25,7 @@
 #include "../libcli/auth/libcli_auth.h"
 #include "../libcli/samsync/samsync.h"
 #include "librpc/gen_ndr/ndr_netlogon.h"
+#include "lib/crypto/gnutls_helpers.h"
 
 /**
  * Decrypt and extract the user's passwords.
@@ -43,13 +44,19 @@ static NTSTATUS fix_user(TALLOC_CTX *mem_ctx,
 	struct netr_DELTA_USER *user = delta->delta_union.user;
 	struct samr_Password lm_hash;
 	struct samr_Password nt_hash;
+	int rc;
 
 	/* Note that win2000 may send us all zeros
 	 * for the hashes if it doesn't
 	 * think this channel is secure enough. */
 	if (user->lm_password_present) {
 		if (!all_zero(user->lmpassword.hash, 16)) {
-			sam_rid_crypt(rid, user->lmpassword.hash, lm_hash.hash, 0);
+			rc = sam_rid_crypt(rid, user->lmpassword.hash,
+					    lm_hash.hash, SAMBA_GNUTLS_DECRYPT);
+			if (rc != 0) {
+				return gnutls_error_to_ntstatus(rc,
+								NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			}
 		} else {
 			memset(lm_hash.hash, '\0', sizeof(lm_hash.hash));
 		}
@@ -58,7 +65,12 @@ static NTSTATUS fix_user(TALLOC_CTX *mem_ctx,
 
 	if (user->nt_password_present) {
 		if (!all_zero(user->ntpassword.hash, 16)) {
-			sam_rid_crypt(rid, user->ntpassword.hash, nt_hash.hash, 0);
+			rc = sam_rid_crypt(rid, user->ntpassword.hash,
+					    nt_hash.hash, SAMBA_GNUTLS_DECRYPT);
+			if (rc != 0) {
+				return gnutls_error_to_ntstatus(rc,
+								NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			}
 		} else {
 			memset(nt_hash.hash, '\0', sizeof(nt_hash.hash));
 		}
@@ -97,9 +109,13 @@ static NTSTATUS fix_user(TALLOC_CTX *mem_ctx,
 		if (keys.keys.keys2.lmpassword.length == 16) {
 			if (!all_zero(keys.keys.keys2.lmpassword.pwd.hash,
 				      16)) {
-				sam_rid_crypt(rid,
-					      keys.keys.keys2.lmpassword.pwd.hash,
-					      lm_hash.hash, 0);
+				rc = sam_rid_crypt(rid,
+					           keys.keys.keys2.lmpassword.pwd.hash,
+					           lm_hash.hash, SAMBA_GNUTLS_DECRYPT);
+				if (rc != 0) {
+					return gnutls_error_to_ntstatus(rc,
+									NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+				}
 			} else {
 				memset(lm_hash.hash, '\0', sizeof(lm_hash.hash));
 			}
@@ -109,9 +125,13 @@ static NTSTATUS fix_user(TALLOC_CTX *mem_ctx,
 		if (keys.keys.keys2.ntpassword.length == 16) {
 			if (!all_zero(keys.keys.keys2.ntpassword.pwd.hash,
 				      16)) {
-				sam_rid_crypt(rid,
-					      keys.keys.keys2.ntpassword.pwd.hash,
-					      nt_hash.hash, 0);
+				rc = sam_rid_crypt(rid,
+						   keys.keys.keys2.ntpassword.pwd.hash,
+						   nt_hash.hash, SAMBA_GNUTLS_DECRYPT);
+				if (rc != 0) {
+					return gnutls_error_to_ntstatus(rc,
+									NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+				}
 			} else {
 				memset(nt_hash.hash, '\0', sizeof(nt_hash.hash));
 			}
diff --git a/libcli/security/security_token.c b/libcli/security/security_token.c
index de75033deae..ef6ee0ff661 100644
--- a/libcli/security/security_token.c
+++ b/libcli/security/security_token.c
@@ -46,7 +46,6 @@ struct security_token *security_token_initialise(TALLOC_CTX *mem_ctx)
 ****************************************************************************/
 void security_token_debug(int dbg_class, int dbg_lev, const struct security_token *token)
 {
-	TALLOC_CTX *mem_ctx;
 	uint32_t i;
 
 	if (!token) {
@@ -54,11 +53,6 @@ void security_token_debug(int dbg_class, int dbg_lev, const struct security_toke
 		return;
 	}
 
-	mem_ctx = talloc_init("security_token_debug()");
-	if (!mem_ctx) {
-		return;
-	}
-
 	DEBUGC(dbg_class, dbg_lev, ("Security token SIDs (%lu):\n",
 				       (unsigned long)token->num_sids));
 	for (i = 0; i < token->num_sids; i++) {
@@ -70,8 +64,6 @@ void security_token_debug(int dbg_class, int dbg_lev, const struct security_toke
 	}
 
 	security_token_debug_privileges(dbg_class, dbg_lev, token);
-
-	talloc_free(mem_ctx);
 }
 
 /* These really should be cheaper... */
diff --git a/libcli/smb/smb2_signing.c b/libcli/smb/smb2_signing.c
index 7561a7a858d..623fc23fb18 100644
--- a/libcli/smb/smb2_signing.c
+++ b/libcli/smb/smb2_signing.c
@@ -20,6 +20,9 @@
 
 #include "includes.h"
 #include "system/filesys.h"
+#include <gnutls/gnutls.h>
+#include <gnutls/crypto.h>
+#define SMB2_SIGNING_KEY_GNUTLS_TYPES 1
 #include "../libcli/smb/smb_common.h"
 #include "../lib/crypto/crypto.h"
 #include "lib/util/iov_buf.h"
@@ -30,8 +33,6 @@
 #endif
 
 #include "lib/crypto/gnutls_helpers.h"
-#include <gnutls/gnutls.h>
-#include <gnutls/crypto.h>
 
 int smb2_signing_key_destructor(struct smb2_signing_key *key)
 {
@@ -478,9 +479,7 @@ NTSTATUS smb2_signing_encrypt_pdu(struct smb2_signing_key *encryption_key,
 	       0,
 	       16 - iv_size);
 
-/* gnutls_aead_cipher_encryptv2() has a bug in version 3.6.10 */
-#if defined(HAVE_GNUTLS_AEAD_CIPHER_ENCRYPTV2) && \
-    GNUTLS_VERSION_NUMBER > 0x03060a
+#if defined(HAVE_GNUTLS_AEAD_CIPHER_ENCRYPTV2)
 	{
 		uint8_t tag[tag_size];
 		giovec_t auth_iov[1];
@@ -682,8 +681,7 @@ NTSTATUS smb2_signing_decrypt_pdu(struct smb2_signing_key *decryption_key,
 	}
 
 /* gnutls_aead_cipher_encryptv2() has a bug in version 3.6.10 */
-#if defined(HAVE_GNUTLS_AEAD_CIPHER_ENCRYPTV2) && \
-    GNUTLS_VERSION_NUMBER > 0x03060a
+#if defined(HAVE_GNUTLS_AEAD_CIPHER_ENCRYPTV2)
 	{
 		giovec_t auth_iov[1];
 
diff --git a/libcli/smb/smb2_signing.h b/libcli/smb/smb2_signing.h
index e28b5c8de9a..ca22de9dbfa 100644
--- a/libcli/smb/smb2_signing.h
+++ b/libcli/smb/smb2_signing.h
@@ -22,16 +22,21 @@
 #define _LIBCLI_SMB_SMB2_SIGNING_H_
 
 struct iovec;
- /* Forward declaration of GnuTLS typedefs */
-struct hmac_hd_st;
-typedef struct hmac_hd_st* gnutls_hmac_hd_t;
-struct  api_aead_cipher_hd_st;
-typedef struct api_aead_cipher_hd_st *gnutls_aead_cipher_hd_t;
 
 struct smb2_signing_key {
-	gnutls_hmac_hd_t hmac_hnd;
-	gnutls_aead_cipher_hd_t cipher_hnd;
 	DATA_BLOB blob;
+	union {
+#ifdef SMB2_SIGNING_KEY_GNUTLS_TYPES
+		gnutls_hmac_hd_t hmac_hnd;
+#endif
+		void *__hmac_hnd;
+	};
+	union {
+#ifdef SMB2_SIGNING_KEY_GNUTLS_TYPES
+		gnutls_aead_cipher_hd_t cipher_hnd;
+#endif
+		void *__cipher_hnd;
+	};
 };
 
 int smb2_signing_key_destructor(struct smb2_signing_key *key);
diff --git a/libcli/smb/wscript b/libcli/smb/wscript
index 2fad5ee37c3..66c2b9b7e70 100644
--- a/libcli/smb/wscript
+++ b/libcli/smb/wscript
@@ -69,4 +69,4 @@ def build(bld):
     bld.SAMBA_BINARY('test_smb1cli_session',
                      source='test_smb1cli_session.c',
                      deps='cmocka cli_smb_common',
-                     install=False)
+                     for_selftest=True)
diff --git a/libgpo/gpo_ldap.c b/libgpo/gpo_ldap.c
index e5a5adb7235..2d95f74276c 100644
--- a/libgpo/gpo_ldap.c
+++ b/libgpo/gpo_ldap.c
@@ -98,7 +98,9 @@ bool ads_parse_gp_ext(TALLOC_CTX *mem_ctx,
 		for (k = 0; ext_strings[k] != NULL; k++) {
 			/* no op */
 		}
-
+		if (k == 0) {
+			goto parse_error;
+		}
 		q = ext_strings[0];
 
 		if (q[0] == '{') {
diff --git a/libgpo/pygpo.c b/libgpo/pygpo.c
index 581d20e0649..97bbb3ec528 100644
--- a/libgpo/pygpo.c
+++ b/libgpo/pygpo.c
@@ -118,7 +118,7 @@ out:
 static PyMethodDef GPO_methods[] = {
 	{"get_unix_path", PY_DISCARD_FUNC_SIG(PyCFunction,
 					      py_gpo_get_unix_path),
-		METH_KEYWORDS,
+		METH_VARARGS | METH_KEYWORDS,
 		NULL },
 	{NULL}
 };
diff --git a/librpc/ABI/ndr-1.0.0.sigs b/librpc/ABI/ndr-1.0.0.sigs
index ffb3d0763fc..bc7c3e88848 100644
--- a/librpc/ABI/ndr-1.0.0.sigs
+++ b/librpc/ABI/ndr-1.0.0.sigs
@@ -49,7 +49,6 @@ ndr_print_double: void (struct ndr_print *, const char *, double)
 ndr_print_enum: void (struct ndr_print *, const char *, const char *, const char *, uint32_t)
 ndr_print_function_debug: void (ndr_print_function_t, const char *, int, void *)
 ndr_print_function_string: char *(TALLOC_CTX *, ndr_print_function_t, const char *, int, void *)
-ndr_print_get_switch_value: uint32_t (struct ndr_print *, const void *)
 ndr_print_gid_t: void (struct ndr_print *, const char *, gid_t)
 ndr_print_hyper: void (struct ndr_print *, const char *, uint64_t)
 ndr_print_int16: void (struct ndr_print *, const char *, int16_t)
@@ -68,6 +67,7 @@ ndr_print_printf_helper: void (struct ndr_print *, const char *, ...)
 ndr_print_ptr: void (struct ndr_print *, const char *, const void *)
 ndr_print_set_switch_value: enum ndr_err_code (struct ndr_print *, const void *, uint32_t)
 ndr_print_sockaddr_storage: void (struct ndr_print *, const char *, const struct sockaddr_storage *)
+ndr_print_steal_switch_value: uint32_t (struct ndr_print *, const void *)
 ndr_print_string: void (struct ndr_print *, const char *, const char *)
 ndr_print_string_array: void (struct ndr_print *, const char *, const char **)
 ndr_print_string_helper: void (struct ndr_print *, const char *, ...)
@@ -116,7 +116,6 @@ ndr_pull_enum_uint32: enum ndr_err_code (struct ndr_pull *, int, uint32_t *)
 ndr_pull_enum_uint8: enum ndr_err_code (struct ndr_pull *, int, uint8_t *)
 ndr_pull_generic_ptr: enum ndr_err_code (struct ndr_pull *, uint32_t *)
 ndr_pull_get_relative_base_offset: uint32_t (struct ndr_pull *)
-ndr_pull_get_switch_value: uint32_t (struct ndr_pull *, const void *)
 ndr_pull_gid_t: enum ndr_err_code (struct ndr_pull *, int, gid_t *)
 ndr_pull_hyper: enum ndr_err_code (struct ndr_pull *, int, uint64_t *)
 ndr_pull_init_blob: struct ndr_pull *(const DATA_BLOB *, TALLOC_CTX *)
@@ -139,7 +138,7 @@ ndr_pull_restore_relative_base_offset: void (struct ndr_pull *, uint32_t)
 ndr_pull_set_switch_value: enum ndr_err_code (struct ndr_pull *, const void *, uint32_t)
 ndr_pull_setup_relative_base_offset1: enum ndr_err_code (struct ndr_pull *, const void *, uint32_t)
 ndr_pull_setup_relative_base_offset2: enum ndr_err_code (struct ndr_pull *, const void *)
-ndr_pull_steal_switch_value: uint32_t (struct ndr_pull *, const void *)
+ndr_pull_steal_switch_value: enum ndr_err_code (struct ndr_pull *, const void *, uint32_t *)
 ndr_pull_string: enum ndr_err_code (struct ndr_pull *, int, const char **)
 ndr_pull_string_array: enum ndr_err_code (struct ndr_pull *, int, const char ***)
 ndr_pull_struct_blob: enum ndr_err_code (const DATA_BLOB *, TALLOC_CTX *, void *, ndr_pull_flags_fn_t)
@@ -190,7 +189,6 @@ ndr_push_enum_uint8: enum ndr_err_code (struct ndr_push *, int, uint8_t)
 ndr_push_expand: enum ndr_err_code (struct ndr_push *, uint32_t)
 ndr_push_full_ptr: enum ndr_err_code (struct ndr_push *, const void *)
 ndr_push_get_relative_base_offset: uint32_t (struct ndr_push *)
-ndr_push_get_switch_value: uint32_t (struct ndr_push *, const void *)
 ndr_push_gid_t: enum ndr_err_code (struct ndr_push *, int, gid_t)
 ndr_push_hyper: enum ndr_err_code (struct ndr_push *, int, uint64_t)
 ndr_push_init_ctx: struct ndr_push *(TALLOC_CTX *)
@@ -215,6 +213,7 @@ ndr_push_setup_relative_base_offset1: enum ndr_err_code (struct ndr_push *, cons
 ndr_push_setup_relative_base_offset2: enum ndr_err_code (struct ndr_push *, const void *)
 ndr_push_short_relative_ptr1: enum ndr_err_code (struct ndr_push *, const void *)
 ndr_push_short_relative_ptr2: enum ndr_err_code (struct ndr_push *, const void *)
+ndr_push_steal_switch_value: enum ndr_err_code (struct ndr_push *, const void *, uint32_t *)
 ndr_push_string: enum ndr_err_code (struct ndr_push *, int, const char *)
 ndr_push_string_array: enum ndr_err_code (struct ndr_push *, int, const char **)
 ndr_push_struct_blob: enum ndr_err_code (DATA_BLOB *, TALLOC_CTX *, const void *, ndr_push_flags_fn_t)
diff --git a/librpc/idl/cab.idl b/librpc/idl/cab.idl
index 8eaae591c1f..d08b53566db 100644
--- a/librpc/idl/cab.idl
+++ b/librpc/idl/cab.idl
@@ -110,8 +110,8 @@ import "misc.idl";
 		[flag(r->attribs & _A_NAME_IS_UTF ? STR_UTF8|STR_NULLTERM : STR_ASCII|STR_NULLTERM)] string szName;
 	} CFFILE;
 
-	typedef [public,flag(NDR_PAHEX|NDR_LITTLE_ENDIAN|NDR_NOALIGN)] struct {
-		[value(ndr_cab_generate_checksum(r))] uint32 csum;		/* checksum of this CFDATA entry */
+	typedef [flag(NDR_PAHEX|NDR_LITTLE_ENDIAN|NDR_NOALIGN),nopull,nopush] struct {
+		uint32 csum;		/* checksum of this CFDATA entry */
 		uint16 cbData;		/* number of compressed bytes in this block */
 		uint16 cbUncomp;	/* number of uncompressed bytes in this block */
 #if 0
diff --git a/librpc/idl/clusapi.idl b/librpc/idl/clusapi.idl
index 6c86f10638f..7cc3f5ff825 100644
--- a/librpc/idl/clusapi.idl
+++ b/librpc/idl/clusapi.idl
@@ -10,6 +10,7 @@ import "winreg.idl", "misc.idl";
 	authservice("MSServerClusterMgmtAPI"),
 	helpstring("Failover Cluster Management API (clusapi)")
 ]
+#define MAX_CLUSTER_CONTROL_CODE_BUFFER_SIZE 0x7FFFFFFF
 	interface clusapi
 {
 #if 0
@@ -2598,4 +2599,364 @@ import "winreg.idl", "misc.idl";
 		DiskIdUnKnown = 0x00001388
 	} CLUSDSK_DISKID_ENUM;
 #endif
+
+	/*****************/
+	/* Function 0x94 */
+
+	WERROR
+	Opnum148NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0x95 */
+
+	WERROR
+	Opnum149otUsedOnWire(void);
+
+	/*****************/
+	/* Function 0x96 */
+
+	WERROR
+	Opnum150NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0x97 */
+
+	WERROR
+	Opnum151NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0x98 */
+
+	WERROR
+	Opnum152NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0x99 */
+
+	WERROR
+	Opnum153NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0x9A */
+
+	WERROR
+	Opnum154NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0x9B */
+
+	WERROR
+	clusapi_AddNotifyResourceTypeV2(
+		[ in ] HNOTIFY_RPC hNotify,
+		[ in ] hyper filter,
+		[ in ] uint32 dwNotifyKey,
+		[ in, string ] [charset(UTF16)] uint16 *resTypeName,
+		[ in ] uint32 dwVersion,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0x9C */
+
+	WERROR
+	Opnum156NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0x9D */
+
+	WERROR
+	clusapi_ExecuteReadBatchEx(
+		[in] HKEY_RPC hKey,
+		[in] uint32 cbInData,
+		[in, size_is(cbInData)] uint8* lpInData,
+		[in] uint32 flags,
+		[out] uint32* cbOutData,
+		[out, size_is(,*cbOutData)] uint8** lpOutData,
+		[out] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0x9E */
+
+	WERROR
+	Opnum158NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0x9F */
+
+	WERROR
+	Opnum159NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0xA0 */
+
+	WERROR
+	Opnum160NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0xA1 */
+
+	WERROR
+	Opnum161NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0xA2 */
+
+	WERROR
+	Opnum162NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0xA3 */
+
+#define HGROUPSET_RPC policy_handle
+#if 0
+	typedef [context_handle] void *HGROUPSET_RPC;
+#endif
+#if 0
+	HGROUPSET_RPC
+	clusapi_CreateGroupSet (
+		[ in, string ] [charset(UTF16)] uint16 *lpszGroupSetName,
+		[ out ] WERROR *Status,
+		[ out ] WERROR *rpc_status
+	);
+#else
+	void
+	clusapi_CreateGroupSet (
+		[ in, string ] [charset(UTF16)] uint16 *lpszGroupSetName,
+		[ out ] WERROR *Status,
+		[ out ] WERROR *rpc_status,
+		[ out ] HGROUPSET_RPC *hGroupSet
+	);
+#endif
+
+	/*****************/
+	/* Function 0xA4 */
+#if 0
+	HGROUPSET_RPC
+	clusapi_OpenGroupSet(
+		[ in, string ] [charset(UTF16)] uint16 *lpszGroupSetName,
+		[ out ] WERROR *Status,
+		[ out ] WERROR *rpc_status
+	);
+#else
+	void
+	clusapi_OpenGroupSet(
+		[ in, string ] [charset(UTF16)] uint16 *lpszGroupSetName,
+		[ out ] WERROR *Status,
+		[ out ] WERROR *rpc_status,
+		[ out ] HGROUPSET_RPC *hGroupSet
+	);
+#endif
+
+	/*****************/
+	/* Function 0xA5 */
+
+	WERROR
+	clusapi_CloseGroupSet(
+		[ in, out ] HGROUPSET_RPC *GroupSet
+	);
+
+	/*****************/
+	/* Function 0xA6 */
+
+	WERROR
+	clusapi_DeleteGroupSet(
+		[ in ] HGROUPSET_RPC GroupSet,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xA7 */
+
+	WERROR
+	clusapi_AddGroupToGroupSet(
+		[ in ] HGROUPSET_RPC GroupSet,
+		[ in ] HGROUP_RPC Group,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xA8 */
+
+	WERROR
+	clusapi_RemoveGroupFromGroupSet(
+		[ in ] HGROUP_RPC Group,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xA9 */
+
+	WERROR
+	clusapi_MoveGroupToGroupSet(
+		[ in ] HGROUPSET_RPC GroupSet,
+		[ in ] HGROUP_RPC Group,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xAA */
+
+	WERROR
+	Opnum170NotUsedOnWire(void);
+
+	/*****************/
+	/* Function 0xAB */
+
+	WERROR
+	clusapi_AddGroupSetDependency(
+		[ in ] HGROUPSET_RPC DependentGroupSet,
+		[ in ] HGROUPSET_RPC ProviderGroupSet,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xAC */
+
+	WERROR
+	clusapi_AddGroupToGroupSetDependency(
+		[ in ] HGROUP_RPC DependentGroup,
+		[ in ] HGROUPSET_RPC ProviderGroupSet,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xAD */
+
+	typedef [v1_enum] enum {
+		CLUSCTL_GROUPSET_GET_ID				= 0x08000039,
+		CLUSCTL_GROUPSET_GET_RO_COMMON_PROPERTIES	= 0x08000055,
+		CLUSCTL_GROUPSET_GET_COMMON_PROPERTIES		= 0x08000059,
+		CLUSCTL_GROUPSET_GET_GROUPS			= 0x08002D71,
+		CLUSCTL_GROUPSET_GET_PROVIDER_GROUPS		= 0x08002D75,
+		CLUSCTL_GROUPSET_GET_PROVIDER_GROUPSETS		= 0x08002D79,
+		CLUSCTL_GROUPSET_SET_COMMON_PROPERTIES		= 0x0840005E
+	} clusapi_GroupSetControlCode;
+
+	WERROR
+	clusapi_NodeGroupSetControl(
+		[ in ] HGROUPSET_RPC hGroupSet,
+		[ in ] HNODE_RPC hNode,
+		[ in ] clusapi_GroupSetControlCode dwControlCode,
+		[ in, unique, size_is(nInBufferSize) ] uint8 *lpInBuffer,
+		[ in ] uint32 nInBufferSize,
+		[ out, size_is(nOutBufferSize), length_is (*lpBytesReturned)] uint8 *lpOutBuffer,
+		[ in, range(0, MAX_CLUSTER_CONTROL_CODE_BUFFER_SIZE)] uint32 nOutBufferSize,
+		[ out ] uint32 *lpBytesReturned,
+		[ out ] uint32 *lpcbRequired,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xAE */
+
+	WERROR
+	clusapi_GroupSetControl(
+		[ in ] HGROUPSET_RPC hGroupSet,
+		[ in ] clusapi_GroupSetControlCode dwControlCode,
+		[ in, unique, size_is(nInBufferSize) ] uint8 *lpInBuffer,
+		[ in ] uint32 nInBufferSize,
+		[ out, size_is(nOutBufferSize), length_is (*lpBytesReturned)] uint8 *lpOutBuffer,
+		[ in, range(0, 0x7FFFFFFF)] uint32 nOutBufferSize,
+		[ out ] uint32 *lpBytesReturned,
+		[ out ] uint32 *lpcbRequired,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xAF */
+
+	WERROR
+	clusapi_SetGroupDependencyExpression(
+		[ in ] HGROUP_RPC hGroup,
+		[ in, string ] [charset(UTF16)] uint16 *lpszDependencyExpression,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xB0 */
+
+	WERROR
+	clusapi_RemoveClusterGroupDependency(
+		[ in ] HGROUP_RPC hGroup,
+		[ in ] HGROUP_RPC hDependsOn,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xB1 */
+
+	WERROR
+	clusapi_SetGroupSetDependencyExpression(
+		[ in ] HGROUPSET_RPC hGroupSet,
+		[ in, string ] [charset(UTF16)] uint16 *lpszDependencyExpression,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xB2 */
+
+	WERROR
+	clusapi_RemoveGroupSetDependency(
+		[ in ] HGROUPSET_RPC hGroupSet,
+		[ in ] HGROUPSET_RPC hDependsOn,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xB3 */
+
+	WERROR
+	clusapi_RemoveClusterGroupToGroupSetDependency(
+		[ in ] HGROUP_RPC hGroup,
+		[ in ] HGROUPSET_RPC hDependsOn,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xB4 */
+
+	WERROR
+	clusapi_CreateGroupSetEnum(
+		[ in ] HCLUSTER_RPC hCluster,
+		[ out ] ENUM_LIST **ReturnEnum,
+		[ out ] WERROR * rpc_status
+	);
+
+	/*****************/
+	/* Function 0xB5 */
+
+	WERROR
+	clusapi_CreateNetInterfaceEnum(
+		[in] HCLUSTER_RPC hCluster,
+		[in, string] [charset(UTF16)] uint16 *lpszNodeName,
+		[in, string] [charset(UTF16)] uint16 *lpszNetworkName,
+		[out] ENUM_LIST **ReturnEnum,
+		[out] WERROR * rpc_status
+	);
+
+	/*****************/
+	/* Function 0xB6 */
+
+	WERROR
+	clusapi_ChangeCsvStateEx(
+		[ in ] HRES_RPC hResource,
+		[ in ] uint32 dwState,
+		[ in, string ] [charset(UTF16)] uint16 *lpszVolumeName,
+		[ out ] WERROR *rpc_status
+	);
+
+	/*****************/
+	/* Function 0xB7 */
+
+	WERROR
+	clusapi_AddGroupToGroupSetEx(
+		[ in ] HGROUPSET_RPC GroupSet,
+		[ in ] HGROUP_RPC Group,
+		[ in ] uint32 FaultDomain,
+		[ in ] uint32 UpdateDomain,
+		[ in ] boolean8 UseDomains,
+		[ in ] uint32 *Reserved,
+		[ out ] WERROR *rpc_status
+	);
 }
diff --git a/librpc/idl/dnsp.idl b/librpc/idl/dnsp.idl
index 1bbcaca6bfa..814d573cddf 100644
--- a/librpc/idl/dnsp.idl
+++ b/librpc/idl/dnsp.idl
@@ -257,7 +257,7 @@ interface dnsp
 		[value(0)] uint32   flag;
 		[value(1)] uint32   version;
 		dns_property_id     id;
-		[switch_is(wDataLength?id:DSPROPERTY_ZONE_EMPTY)]     dnsPropertyData data;
+		[switch_is(id)]     dnsPropertyData data;
 		uint32              name;
 	} dnsp_DnsProperty;
 }
diff --git a/librpc/idl/messaging.idl b/librpc/idl/messaging.idl
index f355c7503d9..8160c76149c 100644
--- a/librpc/idl/messaging.idl
+++ b/librpc/idl/messaging.idl
@@ -111,6 +111,9 @@ interface messaging
 		MSG_SMB_NOTIFY_STARTED          = 0x031F,
 		MSG_SMB_SLEEP			= 0x0320,
 
+		/* smbd message */
+		MSG_SMB_FORCE_TDIS_DENIED	= 0x0321,
+
 		/* winbind messages */
 		MSG_WINBIND_FINISHED		= 0x0401,
 		MSG_WINBIND_FORGET_STATE	= 0x0402,
diff --git a/librpc/idl/ntlmssp.idl b/librpc/idl/ntlmssp.idl
index f984b7b0b4c..dd4c0b91640 100644
--- a/librpc/idl/ntlmssp.idl
+++ b/librpc/idl/ntlmssp.idl
@@ -271,7 +271,7 @@ interface ntlmssp
 		[value(ndr_ntlmssp_string_length(NegotiateFlags, Workstation))] uint16 WorkstationLen;
 		[value(WorkstationLen)] uint16 WorkstationMaxLen;
 		[relative] [subcontext(0),subcontext_size(WorkstationLen)] [flag(ndr_ntlmssp_negotiated_string_flags(r->NegotiateFlags))] string *Workstation;
-		[value(EncryptedRandomSessionKey->length)] uint16 EncryptedRandomSessionKeyLen;
+		[value(EncryptedRandomSessionKey == NULL ? 0 : EncryptedRandomSessionKey->length)] uint16 EncryptedRandomSessionKeyLen;
 		[value(EncryptedRandomSessionKeyLen)] uint16 EncryptedRandomSessionKeyMaxLen;
 		[relative] [subcontext(0),subcontext_size(EncryptedRandomSessionKeyLen)] DATA_BLOB *EncryptedRandomSessionKey;
 		NEGOTIATE NegotiateFlags;
diff --git a/librpc/idl/spoolss.idl b/librpc/idl/spoolss.idl
index 9d294969a0a..afe60d2faf0 100644
--- a/librpc/idl/spoolss.idl
+++ b/librpc/idl/spoolss.idl
@@ -3066,7 +3066,25 @@ cpp_quote("#define spoolss_security_descriptor security_descriptor")
 
 	/******************/
 	/* Function: 0x57 */
-	[todo] WERROR spoolss_EnumPerMachineConnections(
+	[public,noopnum,noprint] WERROR _spoolss_EnumPerMachineConnections(
+		[in,unique] [string,charset(UTF16)] uint16 *server,
+		[in,unique] DATA_BLOB *buffer,
+		[in] uint32 offered,
+		[out,unique] DATA_BLOB *info,
+		[out,ref] uint32 *needed,
+		[out,ref] uint32 *count
+	);
+	[public,noopnum,noprint] void __spoolss_EnumPerMachineConnections(
+		[in] uint32 count,
+		[out] spoolss_PrinterInfo4 info[count]
+	);
+	[nopull,nopush] WERROR spoolss_EnumPerMachineConnections(
+		[in,unique] [string,charset(UTF16)] uint16 *server,
+		[in,unique] DATA_BLOB *buffer,
+		[in] uint32 offered,
+		[out,ref] uint32 *count,
+		[out,ref,size_is(,*count)] spoolss_PrinterInfo4 **info,
+		[out,ref] uint32 *needed
 	);
 
 	/******************/
@@ -3296,7 +3314,7 @@ cpp_quote("#define spoolss_security_descriptor security_descriptor")
 		[in,unique] [string,charset(UTF16)] uint16 *servername,
 		[in,ref] [string,charset(UTF16)] uint16 *architecture,
 		[in] uint32 core_driver_size,
-		[in,size_is(core_driver_size)] [charset(UTF16)] uint16 *core_driver_dependencies,
+		[in,size_is(core_driver_size)] uint16 *core_driver_dependencies,
 		[in] uint32 core_printer_driver_count,
 		[out,size_is(core_printer_driver_count)] spoolss_CorePrinterDriver *core_printer_drivers
 	);
diff --git a/source4/librpc/idl/winstation.idl b/librpc/idl/winstation.idl
similarity index 100%
rename from source4/librpc/idl/winstation.idl
rename to librpc/idl/winstation.idl
diff --git a/librpc/idl/wscript_build b/librpc/idl/wscript_build
index c9b19c4aac4..b66f27be901 100644
--- a/librpc/idl/wscript_build
+++ b/librpc/idl/wscript_build
@@ -5,16 +5,26 @@ bld.SAMBA_PIDL_LIST('PIDL',
                        eventlog.idl
                        browser.idl dssetup.idl frsapi.idl
                        spoolss.idl
-                       dnsserver.idl echo.idl lsa.idl
+                       dnsserver.idl
                        samr.idl srvsvc.idl winreg.idl
                        mgmt.idl netlogon.idl
                        svcctl.idl wkssvc.idl eventlog6.idl backupkey.idl
-                       fsrvp.idl witness.idl clusapi.idl
-                       mdssvc.idl
-                       winspool.idl''',
+                       witness.idl clusapi.idl
+                       mdssvc.idl''',
                     options='--header --ndr-parser --samba3-ndr-server --server --client --python',
                     output_dir='../gen_ndr')
 
+# The interface names here are not the same as the IDL name, so the
+# auto-genration of the fuzzer fails to link
+bld.SAMBA_PIDL_LIST('PIDL',
+                    '''echo.idl
+                       fsrvp.idl
+                       lsa.idl
+                       winspool.idl''',
+                    options='--header --ndr-parser --samba3-ndr-server --server --client --python',
+                    output_dir='../gen_ndr',
+                    generate_fuzzers=False)
+
 # Services that we only have a client for
 bld.SAMBA_PIDL_LIST('PIDL',
                     '''atsvc.idl''',
@@ -23,33 +33,53 @@ bld.SAMBA_PIDL_LIST('PIDL',
 
 # Services that we only have a server in the source3 style
 bld.SAMBA_PIDL_LIST('PIDL',
-                    '''dfs.idl initshutdown.idl ntsvcs.idl''',
+                    '''initshutdown.idl ntsvcs.idl''',
                     options='--header --ndr-parser --client --python --samba3-ndr-server',
                     output_dir='../gen_ndr')
 
-# Services that we only have a server in the source4 style
+# The interface names here are not the same as the IDL name, so the
+# auto-genration of the fuzzer fails to link
+bld.SAMBA_PIDL_LIST('PIDL',
+                    '''dfs.idl''',
+                    options='--header --ndr-parser --client --python --samba3-ndr-server',
+                    output_dir='../gen_ndr',
+                    generate_fuzzers=False)
+
+# Services that we only have a server in the source4 style. 
+
 bld.SAMBA_PIDL_LIST('PIDL',
                     '''unixinfo.idl''',
                     options='--header --ndr-parser --client --python --server',
                     output_dir='../gen_ndr')
 
 # DCOM stuff
+
+# The interface names here are not the same as the IDL name, so the
+# auto-genration of the fuzzer fails to link
 bld.SAMBA_PIDL_LIST('PIDL',
                     '''oxidresolver.idl remact.idl''',
                     options='--header --ndr-parser --client',
-                    output_dir='../gen_ndr')
+                    output_dir='../gen_ndr',
+                    generate_fuzzers=False)
 
+# The interface names here are not the same as the IDL name, so the
+# auto-genration of the fuzzer fails to link
 bld.SAMBA_PIDL_LIST('PIDL',
                     'wmi.idl dcom.idl',
                     options='--header --ndr-parser --server --client --dcom-proxy --com-header',
-                    output_dir='../gen_ndr')
+                    output_dir='../gen_ndr',
+                    generate_fuzzers=False)
 
 # DCE/RPC protocols which Samba does not implement a client or server
-# for
+# for.  We don't generate a fuzzer for these as they are unreachable
+#
+# Do not include IDL with public structures in this list as we want to
+# fuzz those
 
 bld.SAMBA_PIDL_LIST('PIDL',
                     '''
                     audiosrv.idl
+                    dbgidl.idl
                     dsbackup.idl
                     efs.idl
                     frstrans.idl
@@ -62,9 +92,11 @@ bld.SAMBA_PIDL_LIST('PIDL',
                     scerpc.idl
                     trkwks.idl
                     w32time.idl
+                    winstation.idl
                     wzcsvc.idl
                     ''',
                     options='--header --ndr-parser',
+                    generate_fuzzers=False,
                     output_dir='../gen_ndr')
 
 # Non-DCE/RPC protocols encoded in IDL for Samba or helper IDLs for
@@ -74,18 +106,14 @@ bld.SAMBA_PIDL_LIST('PIDL',
                     '''
                     bkupblobs.idl
                     cab.idl
-                    dbgidl.idl
                     file_id.idl
                     fscc.idl
                     fsrvp_state.idl
-                    ioctl.idl
                     named_pipe_auth.idl
                     negoex.idl
-                    nfs4acl.idl
                     notify.idl
                     ntprinting.idl
                     printcap.idl
-                    quota.idl
                     rap.idl
                     schannel.idl
                     smb2_lease_struct.idl
@@ -93,6 +121,19 @@ bld.SAMBA_PIDL_LIST('PIDL',
                     options='--header --ndr-parser',
                     output_dir='../gen_ndr')
 
+# The interface names here are not the same as the IDL name, so the
+# auto-genration of the fuzzer fails to link
+
+bld.SAMBA_PIDL_LIST('PIDL',
+                    '''
+                    ioctl.idl
+                    nfs4acl.idl
+                    quota.idl
+                    ''',
+                    options='--header --ndr-parser',
+                    output_dir='../gen_ndr',
+                    generate_fuzzers=False)
+
 # Non-DCE/RPC protocls with Python bindings
 # (for structures or constants)
 
diff --git a/librpc/ndr/libndr.h b/librpc/ndr/libndr.h
index 392ab76cc94..58ef517d363 100644
--- a/librpc/ndr/libndr.h
+++ b/librpc/ndr/libndr.h
@@ -616,10 +616,16 @@ enum ndr_err_code ndr_check_pipe_chunk_trailer(struct ndr_pull *ndr, int ndr_fla
 enum ndr_err_code ndr_push_set_switch_value(struct ndr_push *ndr, const void *p, uint32_t val);
 enum ndr_err_code ndr_pull_set_switch_value(struct ndr_pull *ndr, const void *p, uint32_t val);
 enum ndr_err_code ndr_print_set_switch_value(struct ndr_print *ndr, const void *p, uint32_t val);
-uint32_t ndr_push_get_switch_value(struct ndr_push *ndr, const void *p);
-uint32_t ndr_pull_get_switch_value(struct ndr_pull *ndr, const void *p);
-uint32_t ndr_print_get_switch_value(struct ndr_print *ndr, const void *p);
-uint32_t ndr_pull_steal_switch_value(struct ndr_pull *ndr, const void *p);
+/* retrieve a switch value (for push) and remove it from the list */
+enum ndr_err_code ndr_push_steal_switch_value(struct ndr_push *ndr,
+					      const void *p,
+					      uint32_t *v);
+/* retrieve a switch value and remove it from the list */
+uint32_t ndr_print_steal_switch_value(struct ndr_print *ndr, const void *p);
+/* retrieve a switch value and remove it from the list */
+enum ndr_err_code ndr_pull_steal_switch_value(struct ndr_pull *ndr,
+					      const void *p,
+					      uint32_t *v);
 enum ndr_err_code ndr_pull_struct_blob(const DATA_BLOB *blob, TALLOC_CTX *mem_ctx, void *p, ndr_pull_flags_fn_t fn);
 enum ndr_err_code ndr_pull_struct_blob_all(const DATA_BLOB *blob, TALLOC_CTX *mem_ctx, void *p, ndr_pull_flags_fn_t fn);
 enum ndr_err_code ndr_pull_struct_blob_all_noalloc(const DATA_BLOB *blob,
diff --git a/librpc/ndr/ndr.c b/librpc/ndr/ndr.c
index 53f9a816f94..2259a35b170 100644
--- a/librpc/ndr/ndr.c
+++ b/librpc/ndr/ndr.c
@@ -36,6 +36,17 @@
 
 #define NDR_BASE_MARSHALL_SIZE 1024
 
+/*
+ * This value is arbitary, but designed to reduce the memory a client
+ * can allocate and the work the client can force in processing a
+ * malicious packet.
+ *
+ * In an ideal world this would be controlled by range() restrictions
+ * on array sizes and careful IDL construction to avoid arbitary
+ * linked lists, but this is a backstop for now.
+ */
+#define NDR_TOKEN_MAX_LIST_SIZE 65535
+
 /* this guid indicates NDR encoding in a protocol tower */
 const struct ndr_syntax_id ndr_transfer_syntax_ndr = {
   { 0x8a885d04, 0x1ceb, 0x11c9, {0x9f, 0xe8}, {0x08,0x00,0x2b,0x10,0x48,0x60} },
@@ -972,19 +983,32 @@ _PUBLIC_ enum ndr_err_code ndr_token_store(TALLOC_CTX *mem_ctx,
 			NDR_ERR_HAVE_NO_MEMORY(list->tokens);
 		}
 	} else {
+		struct ndr_token *new_tokens = NULL;
 		uint32_t alloc_count = talloc_array_length(list->tokens);
+
+		/*
+		 * Check every time we have not allocated too many
+		 * tokens.  This ensures developer sanity when
+		 * debugging the boundary condition
+		 */
+		if (list->count >= NDR_TOKEN_MAX_LIST_SIZE) {
+			return NDR_ERR_RANGE;
+		}
 		if (list->count == alloc_count) {
 			unsigned new_alloc;
+			/*
+			 * Double the list, until we start in chunks
+			 * of 1000
+			 */
 			unsigned increment = MIN(list->count, 1000);
 			new_alloc = alloc_count + increment;
 			if (new_alloc < alloc_count) {
 				return NDR_ERR_RANGE;
 			}
-			list->tokens = talloc_realloc(mem_ctx, list->tokens,
-						      struct ndr_token, new_alloc);
-			if (list->tokens == NULL) {
-				NDR_ERR_HAVE_NO_MEMORY(list->tokens);
-			}
+			new_tokens = talloc_realloc(mem_ctx, list->tokens,
+						    struct ndr_token, new_alloc);
+			NDR_ERR_HAVE_NO_MEMORY(new_tokens);
+			list->tokens = new_tokens;
 		}
 	}
 	list->tokens[list->count].key = key;
@@ -1059,9 +1083,16 @@ _PUBLIC_ uint32_t ndr_token_peek(struct ndr_token_list *list, const void *key)
 */
 _PUBLIC_ enum ndr_err_code ndr_pull_array_size(struct ndr_pull *ndr, const void *p)
 {
+	enum ndr_err_code ret;
 	uint32_t size;
 	NDR_CHECK(ndr_pull_uint3264(ndr, NDR_SCALARS, &size));
-	return ndr_token_store(ndr, &ndr->array_size_list, p, size);
+	ret = ndr_token_store(ndr, &ndr->array_size_list, p, size);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_pull_error(ndr, ret,
+				      "More than %d NDR tokens stored for array_size",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	return ret;
 }
 
 /*
@@ -1092,6 +1123,7 @@ _PUBLIC_ enum ndr_err_code ndr_check_array_size(struct ndr_pull *ndr, void *p, u
 */
 _PUBLIC_ enum ndr_err_code ndr_pull_array_length(struct ndr_pull *ndr, const void *p)
 {
+	enum ndr_err_code ret;
 	uint32_t length, offset;
 	NDR_CHECK(ndr_pull_uint3264(ndr, NDR_SCALARS, &offset));
 	if (offset != 0) {
@@ -1099,7 +1131,13 @@ _PUBLIC_ enum ndr_err_code ndr_pull_array_length(struct ndr_pull *ndr, const voi
 				      "non-zero array offset %u\n", offset);
 	}
 	NDR_CHECK(ndr_pull_uint3264(ndr, NDR_SCALARS, &length));
-	return ndr_token_store(ndr, &ndr->array_length_list, p, length);
+	ret = ndr_token_store(ndr, &ndr->array_length_list, p, length);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_pull_error(ndr, ret,
+				      "More than %d NDR tokens stored for array_length_list",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	return ret;
 }
 
 /*
@@ -1164,12 +1202,27 @@ _PUBLIC_ enum ndr_err_code ndr_check_pipe_chunk_trailer(struct ndr_pull *ndr, in
  */
 _PUBLIC_ enum ndr_err_code ndr_push_set_switch_value(struct ndr_push *ndr, const void *p, uint32_t val)
 {
-	return ndr_token_store(ndr, &ndr->switch_list, p, val);
+	enum ndr_err_code ret =
+		ndr_token_store(ndr, &ndr->switch_list, p, val);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_push_error(ndr, ret,
+				      "More than %d NDR tokens stored for switch_list",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	return ret;
 }
 
 _PUBLIC_ enum ndr_err_code ndr_pull_set_switch_value(struct ndr_pull *ndr, const void *p, uint32_t val)
 {
-	return ndr_token_store(ndr, &ndr->switch_list, p, val);
+
+	enum ndr_err_code ret =
+		ndr_token_store(ndr, &ndr->switch_list, p, val);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_pull_error(ndr, ret,
+				      "More than %d NDR tokens stored for switch_list",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	return ret;
 }
 
 _PUBLIC_ enum ndr_err_code ndr_print_set_switch_value(struct ndr_print *ndr, const void *p, uint32_t val)
@@ -1177,26 +1230,16 @@ _PUBLIC_ enum ndr_err_code ndr_print_set_switch_value(struct ndr_print *ndr, con
 	return ndr_token_store(ndr, &ndr->switch_list, p, val);
 }
 
-/*
-  retrieve a switch value
- */
-_PUBLIC_ uint32_t ndr_push_get_switch_value(struct ndr_push *ndr, const void *p)
-{
-	return ndr_token_peek(&ndr->switch_list, p);
-}
-
-_PUBLIC_ uint32_t ndr_pull_get_switch_value(struct ndr_pull *ndr, const void *p)
-{
-	return ndr_token_peek(&ndr->switch_list, p);
-}
-
-_PUBLIC_ uint32_t ndr_print_get_switch_value(struct ndr_print *ndr, const void *p)
+/* retrieve a switch value (for push) and remove it from the list */
+_PUBLIC_ enum ndr_err_code ndr_push_steal_switch_value(struct ndr_push *ndr,
+						       const void *p,
+						       uint32_t *v)
 {
-	return ndr_token_peek(&ndr->switch_list, p);
+	return ndr_token_retrieve(&ndr->switch_list, p, v);
 }
 
 /* retrieve a switch value and remove it from the list */
-_PUBLIC_ uint32_t ndr_pull_steal_switch_value(struct ndr_pull *ndr, const void *p)
+_PUBLIC_ uint32_t ndr_print_steal_switch_value(struct ndr_print *ndr, const void *p)
 {
 	enum ndr_err_code status;
 	uint32_t v;
@@ -1209,6 +1252,14 @@ _PUBLIC_ uint32_t ndr_pull_steal_switch_value(struct ndr_pull *ndr, const void *
 	return v;
 }
 
+/* retrieve a switch value and remove it from the list */
+_PUBLIC_ enum ndr_err_code ndr_pull_steal_switch_value(struct ndr_pull *ndr,
+						       const void *p,
+						       uint32_t *v)
+{
+	return ndr_token_retrieve(&ndr->switch_list, p, v);
+}
+
 /*
   pull a struct from a blob using NDR
 */
@@ -1416,6 +1467,11 @@ _PUBLIC_ size_t ndr_size_struct(const void *p, int flags, ndr_push_flags_fn_t pu
 	/* avoid recursion */
 	if (flags & LIBNDR_FLAG_NO_NDR_SIZE) return 0;
 
+	/* Avoid following a NULL pointer */
+	if (p == NULL) {
+		return 0;
+	}
+
 	ndr = ndr_push_init_ctx(NULL);
 	if (!ndr) return 0;
 	ndr->flags |= flags | LIBNDR_FLAG_NO_NDR_SIZE;
@@ -1441,6 +1497,11 @@ _PUBLIC_ size_t ndr_size_union(const void *p, int flags, uint32_t level, ndr_pus
 	/* avoid recursion */
 	if (flags & LIBNDR_FLAG_NO_NDR_SIZE) return 0;
 
+	/* Avoid following a NULL pointer */
+	if (p == NULL) {
+		return 0;
+	}
+
 	ndr = ndr_push_init_ctx(NULL);
 	if (!ndr) return 0;
 	ndr->flags |= flags | LIBNDR_FLAG_NO_NDR_SIZE;
@@ -1482,8 +1543,15 @@ _PUBLIC_ void ndr_push_restore_relative_base_offset(struct ndr_push *ndr, uint32
 */
 _PUBLIC_ enum ndr_err_code ndr_push_setup_relative_base_offset1(struct ndr_push *ndr, const void *p, uint32_t offset)
 {
+	enum ndr_err_code ret;
 	ndr->relative_base_offset = offset;
-	return ndr_token_store(ndr, &ndr->relative_base_list, p, offset);
+	ret = ndr_token_store(ndr, &ndr->relative_base_list, p, offset);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_push_error(ndr, ret,
+				      "More than %d NDR tokens stored for relative_base_list",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	return ret;
 }
 
 /*
@@ -1501,12 +1569,19 @@ _PUBLIC_ enum ndr_err_code ndr_push_setup_relative_base_offset2(struct ndr_push
 */
 _PUBLIC_ enum ndr_err_code ndr_push_relative_ptr1(struct ndr_push *ndr, const void *p)
 {
+	enum ndr_err_code ret;
 	if (p == NULL) {
 		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
 		return NDR_ERR_SUCCESS;
 	}
 	NDR_CHECK(ndr_push_align(ndr, 4));
-	NDR_CHECK(ndr_token_store(ndr, &ndr->relative_list, p, ndr->offset));
+	ret = ndr_token_store(ndr, &ndr->relative_list, p, ndr->offset);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_push_error(ndr, ret,
+				      "More than %d NDR tokens stored for relative_list",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	NDR_CHECK(ret);
 	return ndr_push_uint32(ndr, NDR_SCALARS, 0xFFFFFFFF);
 }
 
@@ -1516,12 +1591,19 @@ _PUBLIC_ enum ndr_err_code ndr_push_relative_ptr1(struct ndr_push *ndr, const vo
 */
 _PUBLIC_ enum ndr_err_code ndr_push_short_relative_ptr1(struct ndr_push *ndr, const void *p)
 {
+	enum ndr_err_code ret;
 	if (p == NULL) {
 		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
 		return NDR_ERR_SUCCESS;
 	}
 	NDR_CHECK(ndr_push_align(ndr, 2));
-	NDR_CHECK(ndr_token_store(ndr, &ndr->relative_list, p, ndr->offset));
+	ret = ndr_token_store(ndr, &ndr->relative_list, p, ndr->offset);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_push_error(ndr, ret,
+				      "More than %d NDR tokens stored for relative_list",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	NDR_CHECK(ret);
 	return ndr_push_uint16(ndr, NDR_SCALARS, 0xFFFF);
 }
 /*
@@ -1617,6 +1699,7 @@ _PUBLIC_ enum ndr_err_code ndr_push_short_relative_ptr2(struct ndr_push *ndr, co
 */
 _PUBLIC_ enum ndr_err_code ndr_push_relative_ptr2_start(struct ndr_push *ndr, const void *p)
 {
+	enum ndr_err_code ret;
 	if (p == NULL) {
 		return NDR_ERR_SUCCESS;
 	}
@@ -1655,8 +1738,16 @@ _PUBLIC_ enum ndr_err_code ndr_push_relative_ptr2_start(struct ndr_push *ndr, co
 			      "ndr_push_relative_ptr2_start RELATIVE_REVERSE flag set and relative_end_offset %d",
 			      ndr->relative_end_offset);
 	}
-	NDR_CHECK(ndr_token_store(ndr, &ndr->relative_begin_list, p, ndr->offset));
-	return NDR_ERR_SUCCESS;
+	ret = ndr_token_store(ndr,
+			      &ndr->relative_begin_list,
+			      p,
+			      ndr->offset);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_push_error(ndr, ret,
+				      "More than %d NDR tokens stored for array_size",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	return ret;
 }
 
 /*
@@ -1786,8 +1877,15 @@ _PUBLIC_ void ndr_pull_restore_relative_base_offset(struct ndr_pull *ndr, uint32
 */
 _PUBLIC_ enum ndr_err_code ndr_pull_setup_relative_base_offset1(struct ndr_pull *ndr, const void *p, uint32_t offset)
 {
+	enum ndr_err_code ret;
 	ndr->relative_base_offset = offset;
-	return ndr_token_store(ndr, &ndr->relative_base_list, p, offset);
+	ret = ndr_token_store(ndr, &ndr->relative_base_list, p, offset);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_pull_error(ndr, ret,
+				      "More than %d NDR tokens stored for relative_base_list",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	return ret;
 }
 
 /*
@@ -1805,13 +1903,20 @@ _PUBLIC_ enum ndr_err_code ndr_pull_setup_relative_base_offset2(struct ndr_pull
 */
 _PUBLIC_ enum ndr_err_code ndr_pull_relative_ptr1(struct ndr_pull *ndr, const void *p, uint32_t rel_offset)
 {
+	enum ndr_err_code ret;
 	rel_offset += ndr->relative_base_offset;
 	if (rel_offset > ndr->data_size) {
 		return ndr_pull_error(ndr, NDR_ERR_BUFSIZE,
 				      "ndr_pull_relative_ptr1 rel_offset(%u) > ndr->data_size(%u)",
 				      rel_offset, ndr->data_size);
 	}
-	return ndr_token_store(ndr, &ndr->relative_list, p, rel_offset);
+	ret = ndr_token_store(ndr, &ndr->relative_list, p, rel_offset);
+	if (ret == NDR_ERR_RANGE) {
+		return ndr_pull_error(ndr, ret,
+				      "More than %d NDR tokens stored for relative_list",
+				      NDR_TOKEN_MAX_LIST_SIZE);
+	}
+	return ret;
 }
 
 /*
diff --git a/librpc/ndr/ndr_basic.c b/librpc/ndr/ndr_basic.c
index 0bce1322265..0811a590971 100644
--- a/librpc/ndr/ndr_basic.c
+++ b/librpc/ndr/ndr_basic.c
@@ -781,9 +781,13 @@ _PUBLIC_ enum ndr_err_code ndr_push_full_ptr(struct ndr_push *ndr, const void *p
 		/* Check if the pointer already exists and has an id */
 		ptr = ndr_token_peek(&ndr->full_ptr_list, p);
 		if (ptr == 0) {
+			enum ndr_err_code ret = NDR_ERR_SUCCESS;
 			ndr->ptr_count++;
 			ptr = ndr->ptr_count;
-			ndr_token_store(ndr, &ndr->full_ptr_list, p, ptr);
+			ret = ndr_token_store(ndr, &ndr->full_ptr_list, p, ptr);
+			if (ret != NDR_ERR_SUCCESS) {
+				return ret;
+			}
 		}
 	}
 	return ndr_push_uint3264(ndr, NDR_SCALARS, ptr);
@@ -1466,8 +1470,9 @@ _PUBLIC_ enum ndr_err_code ndr_pull_timespec(struct ndr_pull *ndr,
 _PUBLIC_ void ndr_print_timespec(struct ndr_print *ndr, const char *name,
 				 const struct timespec *t)
 {
-	ndr->print(ndr, "%-25s: %s.%ld", name, timestring(ndr, t->tv_sec),
-		   (long)t->tv_nsec);
+	char *str = timestring(ndr, t->tv_sec);
+	ndr->print(ndr, "%-25s: %s.%ld", name, str, t->tv_nsec);
+	TALLOC_FREE(str);
 }
 
 _PUBLIC_ enum ndr_err_code ndr_push_timeval(struct ndr_push *ndr,
diff --git a/librpc/ndr/ndr_cab.c b/librpc/ndr/ndr_cab.c
index c415bfab34c..476e21cd417 100644
--- a/librpc/ndr/ndr_cab.c
+++ b/librpc/ndr/ndr_cab.c
@@ -111,17 +111,6 @@ static uint32_t ndr_cab_compute_checksum(uint8_t *data, uint32_t length, uint32_
 	return checksum;
 }
 
-uint32_t ndr_cab_generate_checksum(const struct CFDATA *r)
-{
-	uint32_t csumPartial;
-
-	csumPartial = ndr_cab_compute_checksum(&r->ab.data[0], r->cbData, 0);
-
-	return ndr_cab_compute_checksum((uint8_t *)discard_const(&r->cbData),
-					sizeof(r->cbData) + sizeof(r->cbUncomp),
-					csumPartial);
-}
-
 /* Push all CFDATA of a folder.
  *
  * This works on a folder level because compression type is set per
diff --git a/librpc/ndr/ndr_cab.h b/librpc/ndr/ndr_cab.h
index 59dbc991442..39b6bc9b483 100644
--- a/librpc/ndr/ndr_cab.h
+++ b/librpc/ndr/ndr_cab.h
@@ -20,4 +20,3 @@
 */
 
 uint32_t ndr_count_cfdata(const struct cab_file *r);
-uint32_t ndr_cab_generate_checksum(const struct CFDATA *r);
diff --git a/librpc/ndr/ndr_dnsp.c b/librpc/ndr/ndr_dnsp.c
index 974ff5ebff2..d75c58fca37 100644
--- a/librpc/ndr/ndr_dnsp.c
+++ b/librpc/ndr/ndr_dnsp.c
@@ -106,8 +106,18 @@ enum ndr_err_code ndr_push_dnsp_name(struct ndr_push *ndr, int ndr_flags, const
 	}
 	total_len = strlen(name) + 1;
 
-	/* cope with names ending in '.' */
-	if (name[strlen(name)-1] != '.') {
+	/*
+	 * cope with names ending in '.'
+	 */
+	if (name[0] == '\0') {
+		/*
+		 * Don't access name[-1] for the "" input, which has
+		 * the same meaning as a lone '.'.
+		 *
+		 * This allows a round-trip of a dnsRecord from
+		 * Windows of a MX record of '.'
+		 */
+	} else if (name[strlen(name)-1] != '.') {
 		total_len++;
 		count++;
 	}
diff --git a/librpc/ndr/ndr_drsuapi.c b/librpc/ndr/ndr_drsuapi.c
index 45d3ac095c3..cda2e2cf3c5 100644
--- a/librpc/ndr/ndr_drsuapi.c
+++ b/librpc/ndr/ndr_drsuapi.c
@@ -94,8 +94,14 @@ static void _print_drsuapi_DsAttributeValue_attid(struct ndr_print *ndr, const c
 
 	ndr_print_struct(ndr, name, "drsuapi_DsAttributeValue");
 	ndr->depth++;
-	v = IVAL(r->blob->data, 0);
-	ndr_print_uint32(ndr, "attid", v);
+	if (r->blob == NULL || r->blob->data == NULL) {
+		ndr_print_string(ndr, "attid", "NULL");
+	} else if (r->blob->length < 4) {
+		ndr_print_DATA_BLOB(ndr, "attid", *r->blob);
+	} else {
+		v = IVAL(r->blob->data, 0);
+		ndr_print_uint32(ndr, "attid", v);
+	}
 	ndr->depth--;
 }
 
@@ -107,12 +113,15 @@ static void _print_drsuapi_DsAttributeValue_str(struct ndr_print *ndr, const cha
 
 	ndr_print_struct(ndr, name, "drsuapi_DsAttributeValue");
 	ndr->depth++;
-	if (!convert_string_talloc(ndr,
-	                           CH_UTF16, CH_UNIX,
-	                           r->blob->data,
-	                           r->blob->length,
-	                           &p, &converted_size)) {
-		ndr_print_string(ndr, "string", "INVALID CONVERSION");
+	if (r->blob == NULL || r->blob->data == NULL) {
+		ndr_print_string(ndr, "string", "NULL");
+	} else if (!convert_string_talloc(ndr,
+					  CH_UTF16, CH_UNIX,
+					  r->blob->data,
+					  r->blob->length,
+					  &p, &converted_size)) {
+		ndr_print_DATA_BLOB(ndr, "string (INVALID CONVERSION)",
+				    *r->blob);
 	} else {
 		char *str = (char *)p;
 		ndr_print_string(ndr, "string", str);
@@ -414,7 +423,8 @@ enum ndr_err_code ndr_push_drsuapi_DsBindInfo(struct ndr_push *ndr, int ndr_flag
 	ndr->flags = ndr->flags & ~LIBNDR_FLAG_NDR64;
 	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
 	if (ndr_flags & NDR_SCALARS) {
-		uint32_t level = ndr_push_get_switch_value(ndr, r);
+		uint32_t level;
+		NDR_CHECK(ndr_push_steal_switch_value(ndr, r, &level));
 		NDR_CHECK(ndr_push_union_align(ndr, 4));
 		switch (level) {
 			case 24: {
@@ -464,38 +474,18 @@ enum ndr_err_code ndr_push_drsuapi_DsBindInfo(struct ndr_push *ndr, int ndr_flag
 
 		}
 	}
-	if (ndr_flags & NDR_BUFFERS) {
-		uint32_t level = ndr_push_get_switch_value(ndr, r);
-		switch (level) {
-			case 24:
-			break;
-
-			case 28:
-			break;
-
-			case 48:
-			break;
-
-			case 52:
-			break;
-
-			default:
-			break;
-
-		}
-	}
 	ndr->flags = _flags_save;
 	return NDR_ERR_SUCCESS;
 }
 
 enum ndr_err_code ndr_pull_drsuapi_DsBindInfo(struct ndr_pull *ndr, int ndr_flags, union drsuapi_DsBindInfo *r)
 {
-	uint32_t level;
 	uint32_t _flags_save = ndr->flags;
 	ndr->flags = ndr->flags & ~LIBNDR_FLAG_NDR64;
-	level = ndr_pull_get_switch_value(ndr, r);
 	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
 	if (ndr_flags & NDR_SCALARS) {
+		uint32_t level;
+		NDR_CHECK(ndr_pull_steal_switch_value(ndr, r, &level));
 		NDR_CHECK(ndr_pull_union_align(ndr, 4));
 		switch (level) {
 			case 24: {
@@ -545,25 +535,6 @@ enum ndr_err_code ndr_pull_drsuapi_DsBindInfo(struct ndr_pull *ndr, int ndr_flag
 
 		}
 	}
-	if (ndr_flags & NDR_BUFFERS) {
-		switch (level) {
-			case 24:
-			break;
-
-			case 28:
-			break;
-
-			case 48:
-			break;
-
-			case 52:
-			break;
-
-			default:
-			break;
-
-		}
-	}
 	ndr->flags = _flags_save;
 	return NDR_ERR_SUCCESS;
 }
@@ -571,7 +542,7 @@ enum ndr_err_code ndr_pull_drsuapi_DsBindInfo(struct ndr_pull *ndr, int ndr_flag
 _PUBLIC_ void ndr_print_drsuapi_DsBindInfo(struct ndr_print *ndr, const char *name, const union drsuapi_DsBindInfo *r)
 {
 	uint32_t level;
-	level = ndr_print_get_switch_value(ndr, r);
+	level = ndr_print_steal_switch_value(ndr, r);
 	ndr_print_union(ndr, name, level, "drsuapi_DsBindInfo");
 	switch (level) {
 		case 24:
diff --git a/librpc/ndr/ndr_negoex.c b/librpc/ndr/ndr_negoex.c
index b5cb5bc8bcf..95adce5a7e3 100644
--- a/librpc/ndr/ndr_negoex.c
+++ b/librpc/ndr/ndr_negoex.c
@@ -439,6 +439,7 @@ enum ndr_err_code ndr_pull_negoex_MESSAGE(struct ndr_pull *ndr, int ndr_flags, s
 		NDR_PULL_NEED_BYTES(ndr, r->message_length);
 		ndr->data_size = ndr->offset + r->message_length;
 		ndr->offset = saved_offset;
+		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->p, r->type));
 		NDR_CHECK(ndr_pull_negoex_PAYLOAD(ndr, NDR_BUFFERS, &r->p));
 		ndr->offset = ndr->data_size;
 		ndr->data_size = start_data_size;
diff --git a/librpc/ndr/ndr_ntlmssp.c b/librpc/ndr/ndr_ntlmssp.c
index 7027ac0b13d..021bc402a80 100644
--- a/librpc/ndr/ndr_ntlmssp.c
+++ b/librpc/ndr/ndr_ntlmssp.c
@@ -164,7 +164,7 @@ _PUBLIC_ void ndr_print_ntlmssp_lm_response(TALLOC_CTX *mem_ctx,
 _PUBLIC_ void ndr_print_ntlmssp_Version(struct ndr_print *ndr, const char *name, const union ntlmssp_Version *r)
 {
 	int level;
-	level = ndr_print_get_switch_value(ndr, r);
+	level = ndr_print_steal_switch_value(ndr, r);
 	switch (level) {
 		case NTLMSSP_NEGOTIATE_VERSION:
 			ndr_print_ntlmssp_VERSION(ndr, name, &r->version);
diff --git a/librpc/ndr/ndr_orpc.c b/librpc/ndr/ndr_orpc.c
index f24ddc5f826..01ba885d942 100644
--- a/librpc/ndr/ndr_orpc.c
+++ b/librpc/ndr/ndr_orpc.c
@@ -37,7 +37,7 @@ enum ndr_err_code ndr_pull_DUALSTRINGARRAY(struct ndr_pull *ndr, int ndr_flags,
 	NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &num_entries));
 	NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &security_offset));
 
-	ar->stringbindings = talloc_array(ndr, struct STRINGBINDING *, num_entries);
+	ar->stringbindings = talloc_array(ndr, struct STRINGBINDING *, 1);
 	ar->stringbindings[0] = NULL;
 
 	do {
@@ -56,7 +56,7 @@ enum ndr_err_code ndr_pull_DUALSTRINGARRAY(struct ndr_pull *ndr, int ndr_flags,
 	ar->stringbindings[towernum] = NULL;
 	towernum = 0;
 
-	ar->securitybindings = talloc_array(ndr, struct SECURITYBINDING *, num_entries);
+	ar->securitybindings = talloc_array(ndr, struct SECURITYBINDING *, 1);
 	ar->securitybindings[0] = NULL;
 
 	do {
diff --git a/librpc/ndr/ndr_schannel.c b/librpc/ndr/ndr_schannel.c
index 9bbc628a294..6b08a79cab2 100644
--- a/librpc/ndr/ndr_schannel.c
+++ b/librpc/ndr/ndr_schannel.c
@@ -27,7 +27,7 @@
 _PUBLIC_ void ndr_print_NL_AUTH_MESSAGE_BUFFER(struct ndr_print *ndr, const char *name, const union NL_AUTH_MESSAGE_BUFFER *r)
 {
 	int level;
-	level = ndr_print_get_switch_value(ndr, r);
+	level = ndr_print_steal_switch_value(ndr, r);
 	switch (level) {
 		case NL_FLAG_OEM_NETBIOS_DOMAIN_NAME:
 			ndr_print_string(ndr, name, r->a);
@@ -58,7 +58,7 @@ _PUBLIC_ void ndr_print_NL_AUTH_MESSAGE_BUFFER(struct ndr_print *ndr, const char
 _PUBLIC_ void ndr_print_NL_AUTH_MESSAGE_BUFFER_REPLY(struct ndr_print *ndr, const char *name, const union NL_AUTH_MESSAGE_BUFFER_REPLY *r)
 {
 	int level;
-	level = ndr_print_get_switch_value(ndr, r);
+	level = ndr_print_steal_switch_value(ndr, r);
 	switch (level) {
 		case NL_NEGOTIATE_RESPONSE:
 			ndr_print_uint32(ndr, name, r->dummy);
diff --git a/librpc/ndr/ndr_sec_helper.c b/librpc/ndr/ndr_sec_helper.c
index b9e10cca27f..3adb46f5b9c 100644
--- a/librpc/ndr/ndr_sec_helper.c
+++ b/librpc/ndr/ndr_sec_helper.c
@@ -81,6 +81,7 @@ enum ndr_err_code ndr_pull_security_ace(struct ndr_pull *ndr, int ndr_flags, str
 		ndr->offset += pad;
 	}
 	if (ndr_flags & NDR_BUFFERS) {
+		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->object, r->type));
 		NDR_CHECK(ndr_pull_security_ace_object_ctr(ndr, NDR_BUFFERS, &r->object));
 	}
 	return NDR_ERR_SUCCESS;
diff --git a/librpc/ndr/ndr_spoolss_buf.c b/librpc/ndr/ndr_spoolss_buf.c
index 244d692dca8..393d7addeb5 100644
--- a/librpc/ndr/ndr_spoolss_buf.c
+++ b/librpc/ndr/ndr_spoolss_buf.c
@@ -36,13 +36,17 @@
 			"SPOOLSS Buffer: r->in.offered[%u] doesn't match length of r->in.buffer[%u]",\
 			(unsigned)r->in.offered, (unsigned)r->in.buffer->length);\
 	}\
-	_r.in.level	= r->in.level;\
 	_r.in.buffer	= r->in.buffer;\
 	_r.in.offered	= r->in.offered;\
 	NDR_CHECK(ndr_push__##fn(ndr, flags, &_r));\
 } while(0)
 
-#define NDR_SPOOLSS_PUSH_ENUM_OUT(fn) do { \
+#define NDR_SPOOLSS_PUSH_ENUM_IN_LEVEL(fn) do { \
+	_r.in.level     = r->in.level;\
+	NDR_SPOOLSS_PUSH_ENUM_IN(fn);\
+} while(0)
+
+#define NDR_SPOOLSS_PUSH_ENUM_OUT_LEVEL(fn) do { \
 	DATA_BLOB _data_blob_info = data_blob_null;\
 	struct ndr_push *_ndr_info = NULL;\
 	_r.in.level	= r->in.level;\
@@ -84,6 +88,58 @@
 	NDR_CHECK(ndr_push__##fn(ndr, flags, &_r));\
 } while(0)
 
+#define NDR_SPOOLSS_PUSH_ENUM_OUT(fn) do { \
+	DATA_BLOB _data_blob_info = data_blob_null;\
+	struct ndr_push *_ndr_info = NULL;\
+	_r.in.buffer	= r->in.buffer;\
+	_r.in.offered	= r->in.offered;\
+	_r.out.info	= NULL;\
+	_r.out.needed	= r->out.needed;\
+	_r.out.count	= r->out.count;\
+	_r.out.result	= r->out.result;\
+	if (r->out.info && *r->out.info && !r->in.buffer) {\
+		return ndr_push_error(ndr, NDR_ERR_BUFSIZE,\
+			"SPOOLSS Buffer: *r->out.info but there's no r->in.buffer");\
+	}\
+	if (r->in.buffer) {\
+		_ndr_info = ndr_push_init_ctx(ndr);\
+		NDR_ERR_HAVE_NO_MEMORY(_ndr_info);\
+		_ndr_info->flags= ndr->flags;\
+		if (r->out.info) {\
+			struct ndr_push *_subndr_info;\
+			struct __##fn __r;\
+			__r.in.count	= *r->out.count;\
+			__r.out.info	= *r->out.info;\
+			NDR_CHECK(ndr_push_subcontext_start(_ndr_info, &_subndr_info, 0, r->in.offered));\
+			NDR_CHECK(ndr_push___##fn(_subndr_info, flags, &__r)); \
+			NDR_CHECK(ndr_push_subcontext_end(_ndr_info, _subndr_info, 0, r->in.offered));\
+		}\
+		if (r->in.offered > _ndr_info->offset) {\
+			uint32_t _padding_len = r->in.offered - _ndr_info->offset;\
+			NDR_CHECK(ndr_push_zero(_ndr_info, _padding_len));\
+		} else if (r->in.offered < _ndr_info->offset) {\
+			return ndr_push_error(ndr, NDR_ERR_BUFSIZE,\
+				"SPOOLSS Buffer: r->in.offered[%u] doesn't match length of out buffer[%u]!",\
+				(unsigned)r->in.offered, (unsigned)_ndr_info->offset);\
+		}\
+		_data_blob_info = ndr_push_blob(_ndr_info);\
+		_r.out.info	= &_data_blob_info;\
+	}\
+	NDR_CHECK(ndr_push__##fn(ndr, flags, &_r));\
+} while(0)
+
+#define NDR_SPOOLSS_PUSH_ENUM_LEVEL(fn,in,out) do { \
+	struct _##fn _r;\
+	if (flags & NDR_IN) {\
+		in;\
+		NDR_SPOOLSS_PUSH_ENUM_IN_LEVEL(fn);\
+	}\
+	if (flags & NDR_OUT) {\
+		out;\
+		NDR_SPOOLSS_PUSH_ENUM_OUT_LEVEL(fn);\
+	}\
+} while(0)
+
 #define NDR_SPOOLSS_PUSH_ENUM(fn,in,out) do { \
 	struct _##fn _r;\
 	if (flags & NDR_IN) {\
@@ -96,10 +152,8 @@
 	}\
 } while(0)
 
-#define NDR_SPOOLSS_PULL_ENUM_IN(fn) do { \
+#define NDR_SPOOLSS_PULL_ENUM_IN_COMMON(fn) do { \
 	ZERO_STRUCT(r->out);\
-	NDR_CHECK(ndr_pull__##fn(ndr, flags, &_r));\
-	r->in.level	= _r.in.level;\
 	r->in.buffer	= _r.in.buffer;\
 	r->in.offered	= _r.in.offered;\
 	r->out.needed	= _r.out.needed;\
@@ -117,7 +171,18 @@
 	ZERO_STRUCTP(r->out.info);\
 } while(0)
 
-#define NDR_SPOOLSS_PULL_ENUM_OUT(fn) do { \
+#define NDR_SPOOLSS_PULL_ENUM_IN(fn) do { \
+	NDR_CHECK(ndr_pull__##fn(ndr, flags, &_r));\
+	NDR_SPOOLSS_PULL_ENUM_IN_COMMON(fn); \
+} while(0)
+
+#define NDR_SPOOLSS_PULL_ENUM_IN_LEVEL(fn) do { \
+	NDR_CHECK(ndr_pull__##fn(ndr, flags, &_r));\
+	r->in.level	= _r.in.level;\
+	NDR_SPOOLSS_PULL_ENUM_IN_COMMON(fn); \
+} while(0)
+
+#define NDR_SPOOLSS_PULL_ENUM_OUT_LEVEL(fn) do { \
 	_r.in.level	= r->in.level;\
 	_r.in.buffer	= r->in.buffer;\
 	_r.in.offered	= r->in.offered;\
@@ -153,6 +218,53 @@
 	}\
 } while(0)
 
+#define NDR_SPOOLSS_PULL_ENUM_OUT(fn) do { \
+	_r.in.buffer	= r->in.buffer;\
+	_r.in.offered	= r->in.offered;\
+	_r.out.needed	= r->out.needed;\
+	_r.out.count	= r->out.count;\
+	NDR_CHECK(ndr_pull__##fn(ndr, flags, &_r));\
+	if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {\
+		NDR_PULL_ALLOC(ndr, r->out.info);\
+	}\
+	*r->out.info = NULL;\
+	r->out.needed	= _r.out.needed;\
+	r->out.count	= _r.out.count;\
+	r->out.result	= _r.out.result;\
+	if (_r.out.info) {\
+		struct ndr_pull *_ndr_info;\
+		NDR_PULL_ALLOC(ndr, *r->out.info);\
+		_ndr_info = ndr_pull_init_blob(_r.out.info, *r->out.info);\
+		NDR_ERR_HAVE_NO_MEMORY(_ndr_info);\
+		_ndr_info->flags= ndr->flags;\
+		if (r->in.offered != _ndr_info->data_size) {\
+			return ndr_pull_error(ndr, NDR_ERR_BUFSIZE,\
+				"SPOOLSS Buffer: offered[%u] doesn't match length of buffer[%u]",\
+				(unsigned)r->in.offered, (unsigned)_ndr_info->data_size);\
+		}\
+		if (*r->out.needed <= _ndr_info->data_size) {\
+			struct __##fn __r;\
+			__r.in.count	= *r->out.count;\
+			__r.out.info	= NULL;\
+			NDR_CHECK(ndr_pull___##fn(_ndr_info, flags, &__r));\
+			*r->out.info	= __r.out.info;\
+		}\
+	}\
+} while(0)
+
+#define NDR_SPOOLSS_PULL_ENUM_LEVEL(fn,in,out) do { \
+	struct _##fn _r;\
+	if (flags & NDR_IN) {\
+		out;\
+		NDR_SPOOLSS_PULL_ENUM_IN_LEVEL(fn);\
+		in;\
+	}\
+	if (flags & NDR_OUT) {\
+		out;\
+		NDR_SPOOLSS_PULL_ENUM_OUT_LEVEL(fn);\
+	}\
+} while(0)
+
 #define NDR_SPOOLSS_PULL_ENUM(fn,in,out) do { \
 	struct _##fn _r;\
 	if (flags & NDR_IN) {\
@@ -209,7 +321,7 @@
 */
 enum ndr_err_code ndr_push_spoolss_EnumPrinters(struct ndr_push *ndr, int flags, const struct spoolss_EnumPrinters *r)
 {
-	NDR_SPOOLSS_PUSH_ENUM(spoolss_EnumPrinters,{
+	NDR_SPOOLSS_PUSH_ENUM_LEVEL(spoolss_EnumPrinters,{
 		_r.in.flags	= r->in.flags;
 		_r.in.server	= r->in.server;
 	},{
@@ -221,7 +333,7 @@ enum ndr_err_code ndr_push_spoolss_EnumPrinters(struct ndr_push *ndr, int flags,
 
 enum ndr_err_code ndr_pull_spoolss_EnumPrinters(struct ndr_pull *ndr, int flags, struct spoolss_EnumPrinters *r)
 {
-	NDR_SPOOLSS_PULL_ENUM(spoolss_EnumPrinters,{
+	NDR_SPOOLSS_PULL_ENUM_LEVEL(spoolss_EnumPrinters,{
 		r->in.flags	= _r.in.flags;
 		r->in.server	= _r.in.server;
 	},{
@@ -241,7 +353,7 @@ uint32_t ndr_size_spoolss_EnumPrinters_info(TALLOC_CTX *mem_ctx, uint32_t level,
 */
 enum ndr_err_code ndr_push_spoolss_EnumJobs(struct ndr_push *ndr, int flags, const struct spoolss_EnumJobs *r)
 {
-	NDR_SPOOLSS_PUSH_ENUM(spoolss_EnumJobs,{
+	NDR_SPOOLSS_PUSH_ENUM_LEVEL(spoolss_EnumJobs,{
 		_r.in.handle	= r->in.handle;
 		_r.in.firstjob	= r->in.firstjob;
 		_r.in.numjobs	= r->in.numjobs;
@@ -255,7 +367,7 @@ enum ndr_err_code ndr_push_spoolss_EnumJobs(struct ndr_push *ndr, int flags, con
 
 enum ndr_err_code ndr_pull_spoolss_EnumJobs(struct ndr_pull *ndr, int flags, struct spoolss_EnumJobs *r)
 {
-	NDR_SPOOLSS_PULL_ENUM(spoolss_EnumJobs,{
+	NDR_SPOOLSS_PULL_ENUM_LEVEL(spoolss_EnumJobs,{
 		r->in.handle	= _r.in.handle;
 		r->in.firstjob	= _r.in.firstjob;
 		r->in.numjobs	= _r.in.numjobs;
@@ -277,7 +389,7 @@ uint32_t ndr_size_spoolss_EnumJobs_info(TALLOC_CTX *mem_ctx, uint32_t level, uin
 */
 enum ndr_err_code ndr_push_spoolss_EnumPrinterDrivers(struct ndr_push *ndr, int flags, const struct spoolss_EnumPrinterDrivers *r)
 {
-	NDR_SPOOLSS_PUSH_ENUM(spoolss_EnumPrinterDrivers,{
+	NDR_SPOOLSS_PUSH_ENUM_LEVEL(spoolss_EnumPrinterDrivers,{
 		_r.in.server		= r->in.server;
 		_r.in.environment	= r->in.environment;
 	},{
@@ -289,7 +401,7 @@ enum ndr_err_code ndr_push_spoolss_EnumPrinterDrivers(struct ndr_push *ndr, int
 
 enum ndr_err_code ndr_pull_spoolss_EnumPrinterDrivers(struct ndr_pull *ndr, int flags, struct spoolss_EnumPrinterDrivers *r)
 {
-	NDR_SPOOLSS_PULL_ENUM(spoolss_EnumPrinterDrivers,{
+	NDR_SPOOLSS_PULL_ENUM_LEVEL(spoolss_EnumPrinterDrivers,{
 		r->in.server		= _r.in.server;
 		r->in.environment	= _r.in.environment;
 	},{
@@ -309,7 +421,7 @@ uint32_t ndr_size_spoolss_EnumPrinterDrivers_info(TALLOC_CTX *mem_ctx, uint32_t
 */
 enum ndr_err_code ndr_push_spoolss_EnumForms(struct ndr_push *ndr, int flags, const struct spoolss_EnumForms *r)
 {
-	NDR_SPOOLSS_PUSH_ENUM(spoolss_EnumForms,{
+	NDR_SPOOLSS_PUSH_ENUM_LEVEL(spoolss_EnumForms,{
 		_r.in.handle	= r->in.handle;
 	},{
 		_r.in.handle	= r->in.handle;
@@ -319,7 +431,7 @@ enum ndr_err_code ndr_push_spoolss_EnumForms(struct ndr_push *ndr, int flags, co
 
 enum ndr_err_code ndr_pull_spoolss_EnumForms(struct ndr_pull *ndr, int flags, struct spoolss_EnumForms *r)
 {
-	NDR_SPOOLSS_PULL_ENUM(spoolss_EnumForms,{
+	NDR_SPOOLSS_PULL_ENUM_LEVEL(spoolss_EnumForms,{
 		r->in.handle	= _r.in.handle;
 	},{
 		_r.in.handle	= r->in.handle;
@@ -337,7 +449,7 @@ uint32_t ndr_size_spoolss_EnumForms_info(TALLOC_CTX *mem_ctx, uint32_t level, ui
 */
 enum ndr_err_code ndr_push_spoolss_EnumPorts(struct ndr_push *ndr, int flags, const struct spoolss_EnumPorts *r)
 {
-	NDR_SPOOLSS_PUSH_ENUM(spoolss_EnumPorts,{
+	NDR_SPOOLSS_PUSH_ENUM_LEVEL(spoolss_EnumPorts,{
 		_r.in.servername= r->in.servername;
 	},{
 		_r.in.servername= r->in.servername;
@@ -347,7 +459,7 @@ enum ndr_err_code ndr_push_spoolss_EnumPorts(struct ndr_push *ndr, int flags, co
 
 enum ndr_err_code ndr_pull_spoolss_EnumPorts(struct ndr_pull *ndr, int flags, struct spoolss_EnumPorts *r)
 {
-	NDR_SPOOLSS_PULL_ENUM(spoolss_EnumPorts,{
+	NDR_SPOOLSS_PULL_ENUM_LEVEL(spoolss_EnumPorts,{
 		r->in.servername= _r.in.servername;
 	},{
 		_r.in.servername= r->in.servername;
@@ -365,7 +477,7 @@ uint32_t ndr_size_spoolss_EnumPorts_info(TALLOC_CTX *mem_ctx, uint32_t level, ui
 */
 enum ndr_err_code ndr_push_spoolss_EnumMonitors(struct ndr_push *ndr, int flags, const struct spoolss_EnumMonitors *r)
 {
-	NDR_SPOOLSS_PUSH_ENUM(spoolss_EnumMonitors,{
+	NDR_SPOOLSS_PUSH_ENUM_LEVEL(spoolss_EnumMonitors,{
 		_r.in.servername= r->in.servername;
 	},{
 		_r.in.servername= r->in.servername;
@@ -375,7 +487,7 @@ enum ndr_err_code ndr_push_spoolss_EnumMonitors(struct ndr_push *ndr, int flags,
 
 enum ndr_err_code ndr_pull_spoolss_EnumMonitors(struct ndr_pull *ndr, int flags, struct spoolss_EnumMonitors *r)
 {
-	NDR_SPOOLSS_PULL_ENUM(spoolss_EnumMonitors,{
+	NDR_SPOOLSS_PULL_ENUM_LEVEL(spoolss_EnumMonitors,{
 		r->in.servername= _r.in.servername;
 	},{
 		_r.in.servername= r->in.servername;
@@ -393,7 +505,7 @@ uint32_t ndr_size_spoolss_EnumMonitors_info(TALLOC_CTX *mem_ctx, uint32_t level,
 */
 enum ndr_err_code ndr_push_spoolss_EnumPrintProcessors(struct ndr_push *ndr, int flags, const struct spoolss_EnumPrintProcessors *r)
 {
-	NDR_SPOOLSS_PUSH_ENUM(spoolss_EnumPrintProcessors,{
+	NDR_SPOOLSS_PUSH_ENUM_LEVEL(spoolss_EnumPrintProcessors,{
 		_r.in.servername	= r->in.servername;
 		_r.in.environment	= r->in.environment;
 	},{
@@ -405,7 +517,7 @@ enum ndr_err_code ndr_push_spoolss_EnumPrintProcessors(struct ndr_push *ndr, int
 
 enum ndr_err_code ndr_pull_spoolss_EnumPrintProcessors(struct ndr_pull *ndr, int flags, struct spoolss_EnumPrintProcessors *r)
 {
-	NDR_SPOOLSS_PULL_ENUM(spoolss_EnumPrintProcessors,{
+	NDR_SPOOLSS_PULL_ENUM_LEVEL(spoolss_EnumPrintProcessors,{
 		r->in.servername	= _r.in.servername;
 		r->in.environment	= _r.in.environment;
 	},{
@@ -426,7 +538,7 @@ uint32_t ndr_size_spoolss_EnumPrintProcessors_info(TALLOC_CTX *mem_ctx,
 */
 enum ndr_err_code ndr_push_spoolss_EnumPrintProcessorDataTypes(struct ndr_push *ndr, int flags, const struct spoolss_EnumPrintProcessorDataTypes *r)
 {
-	NDR_SPOOLSS_PUSH_ENUM(spoolss_EnumPrintProcessorDataTypes,{
+	NDR_SPOOLSS_PUSH_ENUM_LEVEL(spoolss_EnumPrintProcessorDataTypes,{
 		_r.in.servername		= r->in.servername;
 		_r.in.print_processor_name	= r->in.print_processor_name;
 	},{
@@ -438,7 +550,7 @@ enum ndr_err_code ndr_push_spoolss_EnumPrintProcessorDataTypes(struct ndr_push *
 
 enum ndr_err_code ndr_pull_spoolss_EnumPrintProcessorDataTypes(struct ndr_pull *ndr, int flags, struct spoolss_EnumPrintProcessorDataTypes *r)
 {
-	NDR_SPOOLSS_PULL_ENUM(spoolss_EnumPrintProcessorDataTypes,{
+	NDR_SPOOLSS_PULL_ENUM_LEVEL(spoolss_EnumPrintProcessorDataTypes,{
 		r->in.servername		= _r.in.servername;
 		r->in.print_processor_name	= _r.in.print_processor_name;
 	},{
@@ -454,6 +566,34 @@ uint32_t ndr_size_spoolss_EnumPrintProcessorDataTypes_info(TALLOC_CTX *mem_ctx,
 	NDR_SPOOLSS_SIZE_ENUM_LEVEL(spoolss_EnumPrintProcessorDataTypes);
 }
 
+/*
+  spoolss_EnumPerMachineConnections
+*/
+enum ndr_err_code ndr_push_spoolss_EnumPerMachineConnections(struct ndr_push *ndr, int flags, const struct spoolss_EnumPerMachineConnections *r)
+{
+	NDR_SPOOLSS_PUSH_ENUM(spoolss_EnumPerMachineConnections,{
+		_r.in.server	= r->in.server;
+	},{
+		_r.in.server	= r->in.server;
+	});
+	return NDR_ERR_SUCCESS;
+}
+
+enum ndr_err_code ndr_pull_spoolss_EnumPerMachineConnections(struct ndr_pull *ndr, int flags, struct spoolss_EnumPerMachineConnections *r)
+{
+	NDR_SPOOLSS_PULL_ENUM(spoolss_EnumPerMachineConnections,{
+		r->in.server	= _r.in.server;
+	},{
+		_r.in.server	= r->in.server;
+	});
+	return NDR_ERR_SUCCESS;
+}
+
+uint32_t ndr_size_spoolss_EnumPerMachineConnections_info(TALLOC_CTX *mem_ctx, uint32_t count, struct spoolss_PrinterInfo4 *info)
+{
+	NDR_SPOOLSS_SIZE_ENUM(spoolss_EnumPerMachineConnections);
+}
+
 /*
   spoolss_EnumPrinterDataEx
 */
@@ -1096,7 +1236,7 @@ _PUBLIC_ enum ndr_err_code ndr_pull_spoolss_DriverInfo101(struct ndr_pull *ndr,
 void ndr_print_spoolss_Field(struct ndr_print *ndr, const char *name, const union spoolss_Field *r)
 {
 	int level;
-	level = ndr_print_get_switch_value(ndr, r);
+	level = ndr_print_steal_switch_value(ndr, r);
 	ndr_print_union(ndr, name, level, "spoolss_Field");
 	switch (level) {
 		case PRINTER_NOTIFY_TYPE:
diff --git a/librpc/ndr/ndr_spoolss_buf.h b/librpc/ndr/ndr_spoolss_buf.h
index b0fde305c3e..2ede07ac79f 100644
--- a/librpc/ndr/ndr_spoolss_buf.h
+++ b/librpc/ndr/ndr_spoolss_buf.h
@@ -77,6 +77,7 @@ enum ndr_err_code ndr_push_spoolss_security_descriptor(struct ndr_push *ndr, int
 _PUBLIC_ void ndr_print_spoolss_Time(struct ndr_print *ndr, const char *name, const struct spoolss_Time *r);
 _PUBLIC_ uint32_t ndr_spoolss_PrinterEnumValues_align(enum winreg_Type type);
 
+uint32_t ndr_size_spoolss_EnumPerMachineConnections_info(TALLOC_CTX *mem_ctx, uint32_t count, struct spoolss_PrinterInfo4 *info);
 #undef _PRINTF_ATTRIBUTE
 #define _PRINTF_ATTRIBUTE(a1, a2)
 
diff --git a/librpc/ndr/ndr_string.c b/librpc/ndr/ndr_string.c
index 0fefc887c30..25f211b2ad3 100644
--- a/librpc/ndr/ndr_string.c
+++ b/librpc/ndr/ndr_string.c
@@ -118,9 +118,16 @@ _PUBLIC_ enum ndr_err_code ndr_pull_string(struct ndr_pull *ndr, int ndr_flags,
 		break;
 
 	case LIBNDR_FLAG_STR_NULLTERM:
+		/*
+		 * We ensure that conv_str_len cannot return 0 by
+		 * requring that there be enough bytes for at least
+		 * the NULL terminator
+		 */
 		if (byte_mul == 1) {
+			NDR_PULL_NEED_BYTES(ndr, 1);
 			conv_src_len = ascii_len_n((const char *)(ndr->data+ndr->offset), ndr->data_size - ndr->offset);
 		} else {
+			NDR_PULL_NEED_BYTES(ndr, 2);
 			conv_src_len = utf16_len_n(ndr->data+ndr->offset, ndr->data_size - ndr->offset);
 		}
 		byte_mul = 1; /* the length is now absolute */
@@ -553,6 +560,47 @@ _PUBLIC_ uint32_t ndr_string_length(const void *_var, uint32_t element_size)
 	return i+1;
 }
 
+/**
+ * @brief Get the string length including the null terminator if available.
+ *
+ * This checks the string length based on the elements. The returned number
+ * includes the terminating null byte(s) if found.
+ *
+ * @param[in]  _var    The string the calculate the length for.
+ *
+ * @param[in]  length  The length of the buffer passed by _var.
+ *
+ * @param[in]  element_size The element_size of a string char in bytes.
+ *
+ * @return The length of the strings or 0.
+ */
+static uint32_t ndr_string_n_length(const void *_var,
+				    size_t length,
+				    uint32_t element_size)
+{
+	size_t i = 0;
+	uint8_t zero[4] = {0,0,0,0};
+	const char *var = (const char *)_var;
+	int cmp;
+
+	if (element_size > 4) {
+		return 0;
+	}
+
+	for (i = 0; i < length; i++, var += element_size) {
+		cmp = memcmp(var, zero, element_size);
+		if (cmp == 0) {
+			break;
+		}
+	}
+
+	if (i == length) {
+		return length;
+	}
+
+	return i + 1;
+}
+
 _PUBLIC_ enum ndr_err_code ndr_check_string_terminator(struct ndr_pull *ndr, uint32_t count, uint32_t element_size)
 {
 	uint32_t i;
@@ -622,8 +670,12 @@ _PUBLIC_ enum ndr_err_code ndr_pull_charset_to_null(struct ndr_pull *ndr, int nd
 
 	NDR_PULL_NEED_BYTES(ndr, length*byte_mul);
 
-	str_len = ndr_string_length(ndr->data+ndr->offset, byte_mul);
-	str_len = MIN(str_len, length);	/* overrun protection */
+	str_len = ndr_string_n_length(ndr->data+ndr->offset, length, byte_mul);
+	if (str_len == 0) {
+		return ndr_pull_error(ndr, NDR_ERR_LENGTH,
+				      "Invalid length");
+	}
+
 	if (!convert_string_talloc(ndr->current_mem_ctx, chset, CH_UNIX,
 				   ndr->data+ndr->offset, str_len*byte_mul,
 				   discard_const_p(void *, var),
diff --git a/librpc/rpc/dcerpc_util.c b/librpc/rpc/dcerpc_util.c
index 32df534d5d9..f7596cb1ac1 100644
--- a/librpc/rpc/dcerpc_util.c
+++ b/librpc/rpc/dcerpc_util.c
@@ -29,6 +29,9 @@
 #include "rpc_common.h"
 #include "lib/util/bitmap.h"
 #include "auth/gensec/gensec.h"
+#include "lib/util/mkdir_p.h"
+#include "lib/crypto/gnutls_helpers.h"
+#include <gnutls/crypto.h>
 
 /* we need to be able to get/set the fragment length without doing a full
    decode */
@@ -1410,25 +1413,30 @@ NTSTATUS dcerpc_ncacn_push_auth(DATA_BLOB *blob,
   log a rpc packet in a format suitable for ndrdump. This is especially useful
   for sealed packets, where ethereal cannot easily see the contents
 
-  this triggers on a debug level of >= 10
+  this triggers if "dcesrv:stubs directory" is set and present
+  for all packets that fail to parse
 */
-void dcerpc_log_packet(const char *lockdir,
-		       const struct ndr_interface_table *ndr,
+void dcerpc_log_packet(const char *packet_log_dir,
+		       const char *interface_name,
 		       uint32_t opnum, uint32_t flags,
-		       const DATA_BLOB *pkt)
+		       const DATA_BLOB *pkt,
+		       const char *why)
 {
 	const int num_examples = 20;
 	int i;
 
-	if (lockdir == NULL) return;
+	if (packet_log_dir == NULL) {
+		return;
+	}
 
 	for (i=0;i<num_examples;i++) {
 		char *name=NULL;
 		int ret;
 		bool saved;
-		ret = asprintf(&name, "%s/rpclog/%s-%u.%d.%s",
-			       lockdir, ndr->name, opnum, i,
-			       (flags&NDR_IN)?"in":"out");
+		ret = asprintf(&name, "%s/%s-%u.%d.%s.%s",
+			       packet_log_dir, interface_name, opnum, i,
+			       (flags&NDR_IN)?"in":"out",
+			       why);
 		if (ret == -1) {
 			return;
 		}
@@ -1442,3 +1450,129 @@ void dcerpc_log_packet(const char *lockdir,
 		free(name);
 	}
 }
+
+
+#ifdef DEVELOPER
+
+/*
+ * Save valid, well-formed DCE/RPC stubs to use as a seed for
+ * ndr_fuzz_X
+ */
+void dcerpc_save_ndr_fuzz_seed(TALLOC_CTX *mem_ctx,
+			       DATA_BLOB raw_blob,
+			       const char *dump_dir,
+			       const char *iface_name,
+			       int flags,
+			       int opnum,
+			       bool ndr64)
+{
+	char *fname = NULL;
+	const char *sub_dir = NULL;
+	TALLOC_CTX *temp_ctx = talloc_new(mem_ctx);
+	DATA_BLOB blob;
+	int ret, rc;
+	uint8_t digest[20];
+	DATA_BLOB digest_blob;
+	char *digest_hex;
+	uint16_t fuzz_flags = 0;
+
+	/*
+	 * We want to save the 'stub' in a per-pipe subdirectory, with
+	 * the ndr_fuzz_X header 4 byte header. For the sake of
+	 * convenience (this is a developer only function), we mkdir
+	 * -p the sub-directories when they are needed.
+	 */
+
+	if (dump_dir == NULL) {
+		return;
+	}
+
+	temp_ctx = talloc_stackframe();
+
+	sub_dir = talloc_asprintf(temp_ctx, "%s/%s",
+				  dump_dir,
+				  iface_name);
+	if (sub_dir == NULL) {
+		talloc_free(temp_ctx);
+		return;
+	}
+	ret = mkdir_p(sub_dir, 0755);
+	if (ret && errno != EEXIST) {
+		DBG_ERR("could not create %s\n", sub_dir);
+		talloc_free(temp_ctx);
+		return;
+	}
+
+	blob.length = raw_blob.length + 4;
+	blob.data = talloc_array(sub_dir,
+				 uint8_t,
+				 blob.length);
+	if (blob.data == NULL) {
+		DBG_ERR("could not allocate for fuzz seeds! (%s)\n",
+			iface_name);
+		talloc_free(temp_ctx);
+		return;
+	}
+
+	if (ndr64) {
+		fuzz_flags = 4;
+	}
+	if (flags & NDR_IN) {
+		fuzz_flags |= 1;
+	} else if (flags & NDR_OUT) {
+		fuzz_flags |= 2;
+	}
+
+	SSVAL(blob.data, 0, fuzz_flags);
+	SSVAL(blob.data, 2, opnum);
+
+	memcpy(&blob.data[4],
+	       raw_blob.data,
+	       raw_blob.length);
+
+	/*
+	 * This matches how oss-fuzz names the corpus input files, due
+	 * to a preference from libFuzzer
+	 */
+	rc = gnutls_hash_fast(GNUTLS_DIG_SHA1,
+			      blob.data,
+			      blob.length,
+			      digest);
+	if (rc < 0) {
+		/*
+		 * This prints a better error message, eg if SHA1 is
+		 * disabled
+		 */
+		NTSTATUS status = gnutls_error_to_ntstatus(rc,
+						  NT_STATUS_HASH_NOT_SUPPORTED);
+		DBG_ERR("Failed to generate SHA1 to save fuzz seed: %s",
+			nt_errstr(status));
+		talloc_free(temp_ctx);
+		return;
+	}
+
+	digest_blob.data = digest;
+	digest_blob.length = sizeof(digest);
+	digest_hex = data_blob_hex_string_lower(temp_ctx, &digest_blob);
+
+	fname = talloc_asprintf(temp_ctx, "%s/%s",
+				sub_dir,
+				digest_hex);
+	if (fname == NULL) {
+		talloc_free(temp_ctx);
+		return;
+	}
+
+	/*
+	 * If this fails, it is most likely because that file already
+	 * exists.  This is fine, it means we already have this
+	 * sample
+	 */
+	file_save(fname,
+		  blob.data,
+		  blob.length);
+
+	talloc_free(temp_ctx);
+}
+
+#endif /*if DEVELOPER, enveloping _dcesrv_save_ndr_fuzz_seed() */
diff --git a/librpc/rpc/dcesrv_core.c b/librpc/rpc/dcesrv_core.c
index 902e82887f7..4148c3f0f1a 100644
--- a/librpc/rpc/dcesrv_core.c
+++ b/librpc/rpc/dcesrv_core.c
@@ -33,6 +33,7 @@
 #include "librpc/gen_ndr/ndr_dcerpc.h"
 #include "lib/util/tevent_ntstatus.h"
 
+
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_RPC_SRV
 
@@ -541,7 +542,10 @@ _PUBLIC_ NTSTATUS dcesrv_endpoint_connect(struct dcesrv_context *dce_ctx,
 
 	p->dce_ctx = dce_ctx;
 	p->endpoint = ep;
-	p->packet_log_dir = lpcfg_lock_directory(dce_ctx->lp_ctx);
+	p->packet_log_dir = lpcfg_parm_string(dce_ctx->lp_ctx,
+					      NULL,
+					      "dcesrv",
+					      "stubs directory");
 	p->event_ctx = event_ctx;
 	p->state_flags = state_flags;
 	p->allow_bind = true;
@@ -1693,24 +1697,41 @@ static void dcesrv_alter_done(struct tevent_req *subreq)
 static void dcesrv_save_call(struct dcesrv_call_state *call, const char *why)
 {
 #ifdef DEVELOPER
-	char *fname;
-	const char *dump_dir;
-	dump_dir = lpcfg_parm_string(call->conn->dce_ctx->lp_ctx, NULL, "dcesrv", "stubs directory");
-	if (!dump_dir) {
-		return;
-	}
-	fname = talloc_asprintf(call, "%s/RPC-%s-%u-%s.dat",
-				dump_dir,
-				call->context->iface->name,
-				call->pkt.u.request.opnum,
-				why);
-	if (file_save(fname, call->pkt.u.request.stub_and_verifier.data, call->pkt.u.request.stub_and_verifier.length)) {
-		DEBUG(0,("RPC SAVED %s\n", fname));
-	}
-	talloc_free(fname);
+	dcerpc_log_packet(call->conn->packet_log_dir,
+			  call->context->iface->name,
+			  call->pkt.u.request.opnum,
+			  NDR_IN,
+			  &call->pkt.u.request.stub_and_verifier,
+			  why);
 #endif
 }
 
+#ifdef DEVELOPER
+/*
+  Save the call for use as a seed for fuzzing.
+
+  This is only enabled in a developer build, and only has effect if the
+  "dcesrv fuzz directory" param is set.
+*/
+void _dcesrv_save_ndr_fuzz_seed(DATA_BLOB call_blob,
+				struct dcesrv_call_state *call,
+				int flags)
+{
+	const char *dump_dir = lpcfg_parm_string(call->conn->dce_ctx->lp_ctx,
+						 NULL,
+						 "dcesrv", "fuzz directory");
+
+	dcerpc_save_ndr_fuzz_seed(call,
+				  call_blob,
+				  dump_dir,
+				  call->context->iface->name,
+				  flags,
+				  call->pkt.u.request.opnum,
+				  call->ndr_pull->flags & LIBNDR_FLAG_NDR64);
+}
+#endif /*if DEVELOPER, enveloping _dcesrv_save_ndr_fuzz_seed() */
+
+
 static NTSTATUS dcesrv_check_verification_trailer(struct dcesrv_call_state *call)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
@@ -1854,9 +1875,14 @@ static NTSTATUS dcesrv_request(struct dcesrv_call_state *call)
 		} else {
 			dcesrv_save_call(call, "pullfail");
 		}
+
 		return dcesrv_fault_with_flags(call, call->fault_code, extra_flags);
 	}
 
+	dcesrv_save_ndr_fuzz_seed(call->pkt.u.request.stub_and_verifier,
+				  call,
+				  NDR_IN);
+
 	if (pull->offset != pull->data_size) {
 		dcesrv_save_call(call, "extrabytes");
 		DEBUG(3,("Warning: %d extra bytes in incoming RPC request\n",
@@ -2294,18 +2320,10 @@ static NTSTATUS dcesrv_process_ncacn_packet(struct dcesrv_connection *dce_conn,
 
 _PUBLIC_ NTSTATUS dcesrv_init_context(TALLOC_CTX *mem_ctx,
 				      struct loadparm_context *lp_ctx,
-				      const char **endpoint_servers,
 				      struct dcesrv_context_callbacks *cb,
 				      struct dcesrv_context **_dce_ctx)
 {
-	NTSTATUS status;
 	struct dcesrv_context *dce_ctx;
-	int i;
-
-	if (!endpoint_servers) {
-		DEBUG(0,("dcesrv_init_context: no endpoint servers configured\n"));
-		return NT_STATUS_INTERNAL_ERROR;
-	}
 
 	dce_ctx = talloc_zero(mem_ctx, struct dcesrv_context);
 	NT_STATUS_HAVE_NO_MEMORY(dce_ctx);
@@ -2327,24 +2345,59 @@ _PUBLIC_ NTSTATUS dcesrv_init_context(TALLOC_CTX *mem_ctx,
 		dce_ctx->callbacks = *cb;
 	}
 
-	for (i=0;endpoint_servers[i];i++) {
-		const struct dcesrv_endpoint_server *ep_server;
+	*_dce_ctx = dce_ctx;
+	return NT_STATUS_OK;
+}
 
-		ep_server = dcesrv_ep_server_byname(endpoint_servers[i]);
-		if (!ep_server) {
-			DEBUG(0,("dcesrv_init_context: failed to find endpoint server = '%s'\n", endpoint_servers[i]));
-			return NT_STATUS_INTERNAL_ERROR;
-		}
+_PUBLIC_ NTSTATUS dcesrv_reinit_context(struct dcesrv_context *dce_ctx)
+{
+	NTSTATUS status;
+
+	status = dcesrv_shutdown_registered_ep_servers(dce_ctx);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	/* Clear endpoints */
+	while (dce_ctx->endpoint_list != NULL) {
+		struct dcesrv_endpoint *e = dce_ctx->endpoint_list;
+		DLIST_REMOVE(dce_ctx->endpoint_list, e);
+		TALLOC_FREE(e);
+	}
+
+	/* Remove broken connections */
+	dcesrv_cleanup_broken_connections(dce_ctx);
+
+	/* Reinit assoc group idr */
+	TALLOC_FREE(dce_ctx->assoc_groups_idr);
+	dce_ctx->assoc_groups_idr = idr_init(dce_ctx);
+	if (dce_ctx->assoc_groups_idr == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
 
-		status = ep_server->init_server(dce_ctx, ep_server);
+	return NT_STATUS_OK;
+}
+
+_PUBLIC_ NTSTATUS dcesrv_init_ep_servers(struct dcesrv_context *dce_ctx,
+					 const char **endpoint_servers)
+{
+	NTSTATUS status;
+	int i;
+
+	if (endpoint_servers == NULL) {
+		DBG_ERR("No endpoint servers configured\n");
+		return NT_STATUS_INTERNAL_ERROR;
+	}
+
+	for (i=0;endpoint_servers[i];i++) {
+		status = dcesrv_init_ep_server(dce_ctx, endpoint_servers[i]);
 		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(0,("dcesrv_init_context: failed to init endpoint server = '%s': %s\n", endpoint_servers[i],
-				nt_errstr(status)));
+			DBG_ERR("failed to init endpoint server = '%s': %s\n",
+				endpoint_servers[i], nt_errstr(status));
 			return status;
 		}
 	}
 
-	*_dce_ctx = dce_ctx;
 	return NT_STATUS_OK;
 }
 
@@ -2355,6 +2408,103 @@ static struct ep_server {
 } *ep_servers = NULL;
 static int num_ep_servers = 0;
 
+_PUBLIC_ NTSTATUS dcesrv_init_registered_ep_servers(
+					struct dcesrv_context *dce_ctx)
+{
+	NTSTATUS status;
+	int i;
+
+	for (i = 0; i < num_ep_servers; i++) {
+		status = dcesrv_init_ep_server(dce_ctx,
+					       ep_servers[i].ep_server->name);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
+	}
+
+	return NT_STATUS_OK;
+}
+
+_PUBLIC_ NTSTATUS dcesrv_init_ep_server(struct dcesrv_context *dce_ctx,
+					const char *ep_server_name)
+{
+	struct dcesrv_endpoint_server *ep_server = NULL;
+	NTSTATUS status;
+
+	ep_server = discard_const_p(struct dcesrv_endpoint_server,
+				    dcesrv_ep_server_byname(ep_server_name));
+	if (ep_server == NULL) {
+		DBG_ERR("Failed to find endpoint server '%s'\n",
+			ep_server_name);
+		return NT_STATUS_INTERNAL_ERROR;
+	}
+
+	if (ep_server->initialized) {
+		return NT_STATUS_OK;
+	}
+
+	status = ep_server->init_server(dce_ctx, ep_server);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("Failed to init endpoint server '%s': %s\n",
+			ep_server_name, nt_errstr(status));
+		return status;
+	}
+
+	ep_server->initialized = true;
+
+	return NT_STATUS_OK;
+}
+
+_PUBLIC_ NTSTATUS dcesrv_shutdown_registered_ep_servers(
+					struct dcesrv_context *dce_ctx)
+{
+	NTSTATUS status;
+	int i;
+
+	for (i = 0; i < num_ep_servers; i++) {
+		status = dcesrv_shutdown_ep_server(dce_ctx,
+					ep_servers[i].ep_server->name);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
+	}
+
+	return NT_STATUS_OK;
+}
+
+_PUBLIC_ NTSTATUS dcesrv_shutdown_ep_server(struct dcesrv_context *dce_ctx,
+					    const char *ep_server_name)
+{
+	struct dcesrv_endpoint_server *ep_server = NULL;
+	NTSTATUS status;
+
+	ep_server = discard_const_p(struct dcesrv_endpoint_server,
+				    dcesrv_ep_server_byname(ep_server_name));
+	if (ep_server == NULL) {
+		DBG_ERR("Failed to find endpoint server '%s'\n",
+			ep_server_name);
+		return NT_STATUS_INTERNAL_ERROR;
+	}
+
+	if (!ep_server->initialized) {
+		return NT_STATUS_OK;
+	}
+
+	DBG_INFO("Shutting down DCE/RPC endpoint server '%s'\n",
+		 ep_server_name);
+
+	status = ep_server->shutdown_server(dce_ctx, ep_server);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("Failed to shutdown endpoint server '%s': %s\n",
+			ep_server_name, nt_errstr(status));
+		return status;
+	}
+
+	ep_server->initialized = false;
+
+	return NT_STATUS_OK;
+}
+
 /*
   register a DCERPC endpoint server.
 
diff --git a/librpc/rpc/dcesrv_core.h b/librpc/rpc/dcesrv_core.h
index fc2651bd9d3..74ce956032e 100644
--- a/librpc/rpc/dcesrv_core.h
+++ b/librpc/rpc/dcesrv_core.h
@@ -325,11 +325,18 @@ struct dcesrv_endpoint_server {
 	/* this is the name of the endpoint server */
 	const char *name;
 
+	/* true if the endpoint server has been initialized */
+	bool initialized;
+
 	/* this function should register endpoints and some other setup stuff,
 	 * it is called when the dcesrv_context gets initialized.
 	 */
 	NTSTATUS (*init_server)(struct dcesrv_context *, const struct dcesrv_endpoint_server *);
 
+	/* this function should cleanup endpoint server state and unregister
+	 * the endpoint server from dcesrv_context */
+	NTSTATUS (*shutdown_server)(struct dcesrv_context *, const struct dcesrv_endpoint_server *);
+
 	/* this function can be used by other endpoint servers to
 	 * ask for a dcesrv_interface implementation
 	 * - iface must be reference to an already existing struct !
@@ -444,13 +451,21 @@ NTSTATUS dcesrv_interface_register(struct dcesrv_context *dce_ctx,
 				   const struct dcesrv_interface *iface,
 				   const struct security_descriptor *sd);
 NTSTATUS dcerpc_register_ep_server(const struct dcesrv_endpoint_server *ep_server);
+NTSTATUS dcesrv_init_ep_servers(struct dcesrv_context *dce_ctx,
+				const char **ep_servers);
+NTSTATUS dcesrv_init_registered_ep_servers(struct dcesrv_context *dce_ctx);
+NTSTATUS dcesrv_shutdown_registered_ep_servers(struct dcesrv_context *dce_ctx);
+NTSTATUS dcesrv_init_ep_server(struct dcesrv_context *dce_ctx,
+			       const char *ep_server_name);
+NTSTATUS dcesrv_shutdown_ep_server(struct dcesrv_context *dce_ctx,
+				   const char *name);
 const struct dcesrv_endpoint_server *dcesrv_ep_server_byname(const char *name);
 
 NTSTATUS dcesrv_init_context(TALLOC_CTX *mem_ctx,
 			     struct loadparm_context *lp_ctx,
-			     const char **endpoint_servers,
 			     struct dcesrv_context_callbacks *cb,
 			     struct dcesrv_context **_dce_ctx);
+NTSTATUS dcesrv_reinit_context(struct dcesrv_context *dce_ctx);
 
 NTSTATUS dcesrv_reply(struct dcesrv_call_state *call);
 struct dcesrv_handle *dcesrv_handle_create(struct dcesrv_call_state *call,
@@ -605,4 +620,18 @@ _PUBLIC_ void dcesrv_sock_report_output_data(struct dcesrv_connection *dce_conn)
 
 _PUBLIC_ NTSTATUS dcesrv_connection_loop_start(struct dcesrv_connection *conn);
 
+
+void _dcesrv_save_ndr_fuzz_seed(DATA_BLOB call_blob,
+				struct dcesrv_call_state *call,
+				int flags);
+
+#if DEVELOPER
+#define  dcesrv_save_ndr_fuzz_seed(stub, call, flags) \
+	_dcesrv_save_ndr_fuzz_seed(stub, call, flags)
+#else
+#define  dcesrv_save_ndr_fuzz_seed(stub, call, flags) \
+        /* */
+#endif
+
+
 #endif /* _LIBRPC_RPC_DCESRV_CORE_H_ */
diff --git a/librpc/rpc/dcesrv_reply.c b/librpc/rpc/dcesrv_reply.c
index a217d5a5610..96bd98f53e1 100644
--- a/librpc/rpc/dcesrv_reply.c
+++ b/librpc/rpc/dcesrv_reply.c
@@ -174,6 +174,10 @@ _PUBLIC_ NTSTATUS dcesrv_reply(struct dcesrv_call_state *call)
 
 	stub = ndr_push_blob(push);
 
+	dcesrv_save_ndr_fuzz_seed(stub,
+				  call,
+				  NDR_OUT);
+
 	total_length = stub.length;
 
 	/* we can write a full max_recv_frag size, minus the dcerpc
diff --git a/librpc/rpc/rpc_common.h b/librpc/rpc/rpc_common.h
index 9812146d0ba..a606a29ed31 100644
--- a/librpc/rpc/rpc_common.h
+++ b/librpc/rpc/rpc_common.h
@@ -452,9 +452,31 @@ NTSTATUS dcerpc_ncacn_push_auth(DATA_BLOB *blob,
 				struct ncacn_packet *pkt,
 				struct dcerpc_auth *auth_info);
 
-void dcerpc_log_packet(const char *lockdir,
-		       const struct ndr_interface_table *ndr,
+void dcerpc_log_packet(const char *packet_log_dir,
+		       const char *interface_name,
 		       uint32_t opnum, uint32_t flags,
-		       const DATA_BLOB *pkt);
+		       const DATA_BLOB *pkt,
+		       const char *why);
+
+#ifdef DEVELOPER
+void dcerpc_save_ndr_fuzz_seed(TALLOC_CTX *mem_ctx,
+			       DATA_BLOB raw_blob,
+			       const char *dump_dir,
+			       const char *iface_name,
+			       int flags,
+			       int opnum,
+			       bool ndr64);
+#else
+static inline void dcerpc_save_ndr_fuzz_seed(TALLOC_CTX *mem_ctx,
+					     DATA_BLOB raw_blob,
+					     const char *dump_dir,
+					     const char *iface_name,
+					     int flags,
+					     int opnum,
+					     bool ndr64)
+{
+	return;
+}
+#endif
 
 #endif /* __DEFAULT_LIBRPC_RPCCOMMON_H__ */
diff --git a/librpc/tests/test_ndr_string.c b/librpc/tests/test_ndr_string.c
new file mode 100644
index 00000000000..b3b297c550c
--- /dev/null
+++ b/librpc/tests/test_ndr_string.c
@@ -0,0 +1,175 @@
+/*
+ * Tests for librpc ndr_string.c
+ *
+ * Copyright (C) Catalyst.NET Ltd 2019
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/*
+ * from cmocka.c:
+ * These headers or their equivalents should be included prior to
+ * including
+ * this header file.
+ *
+ * #include <stdarg.h>
+ * #include <stddef.h>
+ * #include <setjmp.h>
+ *
+ * This allows test applications to use custom definitions of C standard
+ * library functions and types.
+ *
+ */
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <setjmp.h>
+#include <cmocka.h>
+
+#include "librpc/ndr/ndr_string.c"
+
+/*
+ * Try and pull a null terminated string from a zero length buffer
+ * Should fail for both 1 byte, and 2 byte character strings.
+ */
+static void test_pull_string_zero_len_nul_term(void **state)
+{
+	struct ndr_pull ndr = {0};
+	enum ndr_err_code err;
+	int flags = NDR_SCALARS;
+	uint8_t data[] = {0x0, 0x0};
+	const char *s = NULL;
+
+	ndr.flags = LIBNDR_FLAG_STR_UTF8 | LIBNDR_FLAG_STR_NULLTERM;
+	ndr.data = data;
+	ndr.data_size = 0;
+	err = ndr_pull_string(&ndr, flags, &s);
+	assert_int_equal(err, NDR_ERR_BUFSIZE);
+	assert_null(s);
+	assert_int_equal(0, ndr.offset);
+
+	ndr.flags = LIBNDR_FLAG_STR_NULLTERM;
+	ndr.offset = 0;
+	err = ndr_pull_string(&ndr, flags, &s);
+	assert_int_equal(err, NDR_ERR_BUFSIZE);
+	assert_null(s);
+	assert_int_equal(0, ndr.offset);
+
+}
+
+/*
+ * Try and pull a null terminated string from a 1 byte buffer
+ * Should succeed for 1 byte character and
+ *        fail    for 2 byte character strings.
+ */
+static void test_pull_string_len_1_nul_term(void **state)
+{
+	struct ndr_pull ndr = {0};
+	enum ndr_err_code err;
+	int flags = NDR_SCALARS;
+	const char *s = NULL;
+	uint8_t data[] = {0x0, 0x0};
+
+	ndr.flags = LIBNDR_FLAG_STR_UTF8 | LIBNDR_FLAG_STR_NULLTERM;
+	ndr.data = data;
+	ndr.data_size = 1;
+	err = ndr_pull_string(&ndr, flags, &s);
+	assert_int_equal(err, NDR_ERR_SUCCESS);
+	assert_non_null(s);
+	assert_int_equal(1, ndr.offset);
+
+	ndr.offset = 0;
+	ndr.flags = LIBNDR_FLAG_STR_NULLTERM;
+	err = ndr_pull_string(&ndr, flags, &s);
+	assert_int_equal(err, NDR_ERR_BUFSIZE);
+	assert_int_equal(0, ndr.offset);
+}
+
+/*
+ * Try and pull a null terminated string from a 2 byte buffer
+ * Should succeed for both 1 byte, and 2 byte character strings.
+ */
+static void test_pull_string_len_2_nul_term(void **state)
+{
+	struct ndr_pull ndr = {0};
+	enum ndr_err_code err;
+	int flags = NDR_SCALARS;
+	const char *s;
+	uint8_t data[] = {0x0, 0x0};
+
+	ndr.flags = LIBNDR_FLAG_STR_UTF8 | LIBNDR_FLAG_STR_NULLTERM;
+	ndr.data = data;
+	ndr.data_size = 2;
+	err = ndr_pull_string(&ndr, flags, &s);
+	assert_int_equal(err, NDR_ERR_SUCCESS);
+	assert_non_null(s);
+	assert_int_equal(1, ndr.offset);
+
+	ndr.offset = 0;
+	ndr.flags = LIBNDR_FLAG_STR_NULLTERM;
+	err = ndr_pull_string(&ndr, flags, &s);
+	assert_int_equal(err, NDR_ERR_SUCCESS);
+	assert_non_null(s);
+	assert_int_equal(2, ndr.offset);
+
+
+}
+
+static void test_ndr_string_n_length(void **state)
+{
+	char test_str1[5] = "Test";
+	char test_str2[5] = {0};
+	char test_str3[32] = "This is a test too";
+	uint8_t test_str_u16[64] = {
+		0x5C, 0x00, 0x5C, 0x00, 0x4C, 0x00, 0x6F, 0x00,
+		0x67, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x2D, 0x00,
+		0x6D, 0x00, 0x75, 0x00, 0x63, 0x00, 0x5C, 0x00,
+		0x6B, 0x00, 0x79, 0x00, 0x6F, 0x00, 0x63, 0x00,
+		0x65, 0x00, 0x72, 0x00, 0x61, 0x00, 0x2D, 0x00,
+		0x6D, 0x00, 0x75, 0x00, 0x63, 0x00, 0x2D, 0x00,
+		0x6E, 0x00, 0x00, 0x00 };
+	size_t len;
+
+	len = ndr_string_n_length(test_str1, sizeof(test_str1), 1);
+	assert_int_equal(len, 5);
+
+	len = ndr_string_n_length(test_str1, sizeof(test_str1) - 1, 1);
+	assert_int_equal(len, 4);
+
+	len = ndr_string_n_length(test_str2, sizeof(test_str2), 1);
+	assert_int_equal(len, 1);
+
+	len = ndr_string_n_length(test_str3, sizeof(test_str3), 1);
+	assert_int_equal(len, 19);
+
+	len = ndr_string_n_length(test_str3, 0, 1);
+	assert_int_equal(len, 0);
+
+	len = ndr_string_n_length(test_str_u16, 32, 2);
+	assert_int_equal(len, 26);
+}
+
+int main(int argc, const char **argv)
+{
+	const struct CMUnitTest tests[] = {
+		cmocka_unit_test(test_pull_string_zero_len_nul_term),
+		cmocka_unit_test(test_pull_string_len_1_nul_term),
+		cmocka_unit_test(test_pull_string_len_2_nul_term),
+		cmocka_unit_test(test_ndr_string_n_length)
+	};
+
+	cmocka_set_message_output(CM_OUTPUT_SUBUNIT);
+	return cmocka_run_group_tests(tests, NULL, NULL);
+}
diff --git a/librpc/tools/ndrdump.c b/librpc/tools/ndrdump.c
index e911cf4c1e4..914c67e98e2 100644
--- a/librpc/tools/ndrdump.c
+++ b/librpc/tools/ndrdump.c
@@ -26,6 +26,7 @@
 #include "librpc/gen_ndr/ndr_dcerpc.h"
 #include "lib/cmdline/popt_common.h"
 #include "param/param.h"
+#include "lib/util/base64.h"
 
 static const struct ndr_interface_call *find_function(
 	const struct ndr_interface_table *p,
@@ -265,7 +266,8 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 	 * name of a public structure
 	 */
 	const char *format = NULL;
-	uint8_t *data;
+	const char *cmdline_input = NULL;
+	const uint8_t *data;
 	size_t size;
 	DATA_BLOB blob;
 	struct ndr_pull *ndr_pull;
@@ -284,7 +286,8 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 	bool assume_ndr64 = false;
 	bool quiet = false;
 	bool hex_input = false;
-	bool stop_on_parse_failure = false;
+	bool base64_input = false;
+	bool print_after_parse_failure = false;
 	int opt;
 	enum {
 		OPT_CONTEXT_FILE=1000,
@@ -293,8 +296,10 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 		OPT_LOAD_DSO,
 		OPT_NDR64,
 		OPT_QUIET,
+		OPT_BASE64_INPUT,
 		OPT_HEX_INPUT,
-		OPT_STOP_ON_PARSE_FAILURE,
+		OPT_CMDLINE_INPUT,
+		OPT_PRINT_AFTER_PARSE_FAILURE,
 	};
 	struct poptOption long_options[] = {
 		POPT_AUTOHELP
@@ -304,9 +309,11 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 		{"load-dso", 'l', POPT_ARG_STRING, NULL, OPT_LOAD_DSO, "load from shared object file", NULL },
 		{"ndr64", 0, POPT_ARG_NONE, NULL, OPT_NDR64, "Assume NDR64 data", NULL },
 		{"quiet", 0, POPT_ARG_NONE, NULL, OPT_QUIET, "Don't actually dump anything", NULL },
+		{"base64-input", 0, POPT_ARG_NONE, NULL, OPT_BASE64_INPUT, "Read the input file in as a base64 string", NULL },
 		{"hex-input", 0, POPT_ARG_NONE, NULL, OPT_HEX_INPUT, "Read the input file in as a hex dump", NULL },
-		{"stop-on-parse-failure", 0, POPT_ARG_NONE, NULL, OPT_STOP_ON_PARSE_FAILURE,
-		 "Do not try to print structures that fail to parse.", NULL },
+		{"input", 0, POPT_ARG_STRING, NULL, OPT_CMDLINE_INPUT, "Provide the input on the command line (use with --base64-input)", "INPUT" },
+		{"print-after-parse-failure", 0, POPT_ARG_NONE, NULL, OPT_PRINT_AFTER_PARSE_FAILURE,
+		 "Try to print structures that fail to parse (used to develop parsers, segfaults are likely).", NULL },
 		POPT_COMMON_SAMBA
 		POPT_COMMON_VERSION
 		{ NULL }
@@ -348,11 +355,17 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 		case OPT_QUIET:
 			quiet = true;
 			break;
+		case OPT_BASE64_INPUT:
+			base64_input = true;
+			break;
 		case OPT_HEX_INPUT:
 			hex_input = true;
 			break;
-		case OPT_STOP_ON_PARSE_FAILURE:
-			stop_on_parse_failure = true;
+		case OPT_CMDLINE_INPUT:
+			cmdline_input = poptGetOptArg(pc);
+			break;
+		case OPT_PRINT_AFTER_PARSE_FAILURE:
+			print_after_parse_failure = true;
 			break;
 		}
 	}
@@ -419,34 +432,43 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 
 	st = talloc_zero_size(mem_ctx, f->struct_size);
 	if (!st) {
-		printf("Unable to allocate %d bytes\n", (int)f->struct_size);
+		printf("Unable to allocate %d bytes for %s structure\n",
+		       (int)f->struct_size,
+		       f->name);
+		TALLOC_FREE(mem_ctx);
 		exit(1);
 	}
 
 	v_st = talloc_zero_size(mem_ctx, f->struct_size);
 	if (!v_st) {
-		printf("Unable to allocate %d bytes\n", (int)f->struct_size);
+		printf("Unable to allocate %d bytes for %s validation "
+		       "structure\n",
+		       (int)f->struct_size,
+		       f->name);
+		TALLOC_FREE(mem_ctx);
 		exit(1);
 	}
 
 	if (ctx_filename) {
 		if (flags & NDR_IN) {
 			printf("Context file can only be used for \"out\" packages\n");
+			TALLOC_FREE(mem_ctx);
 			exit(1);
 		}
 			
 		data = (uint8_t *)file_load(ctx_filename, &size, 0, mem_ctx);
 		if (!data) {
 			perror(ctx_filename);
+			TALLOC_FREE(mem_ctx);
 			exit(1);
 		}
 
-		blob.data = data;
-		blob.length = size;
+		blob = data_blob_const(data, size);
 
 		ndr_pull = ndr_pull_init_blob(&blob, mem_ctx);
 		if (ndr_pull == NULL) {
 			perror("ndr_pull_init_blob");
+			TALLOC_FREE(mem_ctx);
 			exit(1);
 		}
 		ndr_pull->flags |= LIBNDR_FLAG_REF_ALLOC;
@@ -469,15 +491,24 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 		if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
 			printf("pull for context file returned %s\n",
 			       ndr_map_error2string(ndr_err));
-			exit(1);
+			TALLOC_FREE(mem_ctx);
+			exit(2);
 		}
 		memcpy(v_st, st, f->struct_size);
 	}
 
-	if (filename)
+	if (filename && cmdline_input) {
+		printf("cannot combine --input with a filename\n");
+		TALLOC_FREE(mem_ctx);
+		exit(1);
+	} else if (cmdline_input) {
+		data = (const uint8_t *)cmdline_input;
+		size = strlen(cmdline_input);
+	} else if (filename) {
 		data = (uint8_t *)file_load(filename, &size, 0, mem_ctx);
-	else
+	} else {
 		data = (uint8_t *)stdin_load(mem_ctx, &size);
+	}
 
 	if (!data) {
 		if (filename)
@@ -487,16 +518,33 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 		exit(1);
 	}
 	
-	if (hex_input) {
-		blob = hexdump_to_data_blob(mem_ctx, (char *)data, size);
+	if (hex_input && base64_input) {
+		printf("cannot combine --hex-input with --base64-input\n");
+		TALLOC_FREE(mem_ctx);
+		exit(1);
+
+	} else if (hex_input) {
+		blob = hexdump_to_data_blob(mem_ctx, (const char *)data, size);
+	} else if (base64_input) {
+		/* Use talloc_strndup() to ensure null termination */
+		blob = base64_decode_data_blob(talloc_strndup(mem_ctx,
+							      (const char *)data, size));
+		/* base64_decode_data_blob() allocates on NULL */
+		talloc_steal(mem_ctx, blob.data);
 	} else {
-		blob.data = data;
-		blob.length = size;
+		blob = data_blob_const(data, size);
+	}
+
+	if (data != NULL && blob.data == NULL) {
+		printf("failed to decode input data\n");
+		TALLOC_FREE(mem_ctx);
+		exit(1);
 	}
 
 	ndr_pull = ndr_pull_init_blob(&blob, mem_ctx);
 	if (ndr_pull == NULL) {
 		perror("ndr_pull_init_blob");
+		TALLOC_FREE(mem_ctx);
 		exit(1);
 	}
 	ndr_pull->flags |= LIBNDR_FLAG_REF_ALLOC;
@@ -536,8 +584,10 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 						      ndr_print,
 						      &f->out_pipes);
 		if (!NT_STATUS_IS_OK(status)) {
-			printf("dump FAILED\n");
-			exit(1);
+			printf("pull and dump of OUT pipes FAILED: %s\n",
+			       nt_errstr(status));
+			TALLOC_FREE(mem_ctx);
+			exit(2);
 		}
 	}
 
@@ -545,17 +595,22 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 	printf("pull returned %s\n",
 	       ndr_map_error2string(ndr_err));
 
-	if (stop_on_parse_failure && !NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
-		printf("not printing because --stop-on-parse-failure\n");
-		exit(1);
-	}
-
 	if (ndr_pull->offset > ndr_pull->relative_highest_offset) {
 		highest_ofs = ndr_pull->offset;
 	} else {
 		highest_ofs = ndr_pull->relative_highest_offset;
 	}
 
+	if (dumpdata) {
+		printf("%d bytes consumed\n", highest_ofs);
+		ndrdump_data(blob.data, blob.length, dumpdata);
+	}
+
+	if (!print_after_parse_failure && !NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+		TALLOC_FREE(mem_ctx);
+		exit(2);
+	}
+
 	if (highest_ofs != ndr_pull->data_size) {
 		printf("WARNING! %d unread bytes\n", ndr_pull->data_size - highest_ofs);
 		ndrdump_data(ndr_pull->data+highest_ofs,
@@ -563,12 +618,13 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 			     dumpdata);
 	}
 
-	if (dumpdata) {
-		printf("%d bytes consumed\n", highest_ofs);
-		ndrdump_data(blob.data, blob.length, dumpdata);
+	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+		printf("WARNING: pull of %s was incomplete, "
+		       "therefore the parse below may SEGFAULT\n",
+			f->name);
 	}
 
-	f->ndr_print(ndr_print, format, flags, st);
+	f->ndr_print(ndr_print, f->name, flags, st);
 
 	if (flags & NDR_IN) {
 		status = ndrdump_pull_and_print_pipes(format,
@@ -576,11 +632,20 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 						      ndr_print,
 						      &f->in_pipes);
 		if (!NT_STATUS_IS_OK(status)) {
-			printf("dump FAILED\n");
+			printf("pull and dump of IN pipes FAILED: %s\n",
+			       nt_errstr(status));
 			exit(1);
 		}
 	}
 
+	/* Do not proceed to validate if we got an error */
+	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+		printf("dump of failed-to-parse %s complete\n",
+		       f->name);
+		TALLOC_FREE(mem_ctx);
+		exit(2);
+	}
+
 	if (validate) {
 		DATA_BLOB v_blob;
 		struct ndr_push *ndr_v_push;
@@ -602,10 +667,11 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 		}
 
 		ndr_err = f->ndr_push(ndr_v_push, flags, st);
-		status = ndr_map_error2ntstatus(ndr_err);
-		printf("push returned %s\n", nt_errstr(status));
+		printf("push returned %s\n",
+		       ndr_map_error2string(ndr_err));
 		if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
 			printf("validate push FAILED\n");
+			TALLOC_FREE(mem_ctx);
 			exit(1);
 		}
 
@@ -619,6 +685,7 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 		ndr_v_pull = ndr_pull_init_blob(&v_blob, mem_ctx);
 		if (ndr_v_pull == NULL) {
 			perror("ndr_pull_init_blob");
+			TALLOC_FREE(mem_ctx);
 			exit(1);
 		}
 		ndr_v_pull->flags |= LIBNDR_FLAG_REF_ALLOC;
@@ -628,6 +695,7 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 		       ndr_map_error2string(ndr_err));
 		if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
 			printf("validate pull FAILED\n");
+			TALLOC_FREE(mem_ctx);
 			exit(1);
 		}
 
@@ -689,7 +757,7 @@ static void ndr_print_dummy(struct ndr_print *ndr, const char *format, ...)
 	}
 
 	printf("dump OK\n");
-	talloc_free(mem_ctx);
+	TALLOC_FREE(mem_ctx);
 
 	poptFreeContext(pc);
 	
diff --git a/librpc/wscript_build b/librpc/wscript_build
index 2582a281139..5eb78e6010a 100644
--- a/librpc/wscript_build
+++ b/librpc/wscript_build
@@ -62,7 +62,7 @@ bld.SAMBA_SUBSYSTEM('NDR_ROT',
 
 bld.SAMBA_SUBSYSTEM('NDR_FRSRPC',
     source='ndr/ndr_frsrpc.c gen_ndr/ndr_frsrpc.c',
-    public_deps='ndr'
+    public_deps='ndr NDR_FSCC'
     )
 
 bld.SAMBA_SUBSYSTEM('NDR_FRSAPI',
@@ -82,7 +82,7 @@ bld.SAMBA_SUBSYSTEM('NDR_DFSBLOBS',
 
 bld.SAMBA_SUBSYSTEM('NDR_BKUPBLOBS',
 	source='ndr/ndr_bkupblobs.c gen_ndr/ndr_bkupblobs.c',
-	public_deps='ndr'
+	public_deps='ndr NDR_SECURITY NDR_FSCC'
 	)
 
 bld.SAMBA_SUBSYSTEM('NDR_FSCC',
@@ -177,7 +177,7 @@ bld.SAMBA_SUBSYSTEM('NDR_WZCSVC',
 
 bld.SAMBA_SUBSYSTEM('NDR_BROWSER',
     source='gen_ndr/ndr_browser.c',
-    public_deps='ndr'
+    public_deps='ndr NDR_SRVSVC'
     )
 
 bld.SAMBA_SUBSYSTEM('NDR_W32TIME',
@@ -289,6 +289,11 @@ bld.SAMBA_SUBSYSTEM('NDR_EVENTLOG',
     public_deps='ndr NDR_SECURITY NDR_LSA'
     )
 
+bld.SAMBA_SUBSYSTEM('NDR_EVENTLOG6',
+    source='gen_ndr/ndr_eventlog6.c',
+    public_deps='ndr'
+    )
+
 bld.SAMBA_SUBSYSTEM('NDR_NTSVCS',
     source='gen_ndr/ndr_ntsvcs.c',
     public_deps='ndr'
@@ -296,7 +301,7 @@ bld.SAMBA_SUBSYSTEM('NDR_NTSVCS',
 
 bld.SAMBA_SUBSYSTEM('NDR_WKSSVC',
     source='gen_ndr/ndr_wkssvc.c',
-    public_deps='ndr NDR_SECURITY'
+    public_deps='ndr NDR_SECURITY NDR_SRVSVC NDR_LSA'
     )
 
 bld.SAMBA_SUBSYSTEM('NDR_ECHO',
@@ -327,7 +332,7 @@ bld.SAMBA_SUBSYSTEM('NDR_WITNESS',
 
 bld.SAMBA_SUBSYSTEM('NDR_CLUSAPI',
     source='gen_ndr/ndr_clusapi.c',
-    public_deps='ndr'
+    public_deps='ndr NDR_WINREG'
     )
 
 bld.SAMBA_SUBSYSTEM('NDR_MDSSVC',
@@ -356,6 +361,10 @@ bld.SAMBA_SUBSYSTEM('NDR_DRSBLOBS',
     header_path=[ ('gen_ndr*', 'gen_ndr'), ('ndr*', 'ndr')]
     )
 
+bld.SAMBA_SUBSYSTEM('NDR_KRB5PAC',
+                    source='',
+                    deps='ndr-krb5pac')
+
 bld.SAMBA_LIBRARY('ndr-krb5pac',
     source='ndr/ndr_krb5pac.c gen_ndr/ndr_krb5pac.c',
     public_deps='ndr ndr-standard NDR_SECURITY',
@@ -366,10 +375,11 @@ bld.SAMBA_LIBRARY('ndr-krb5pac',
     )
 
 bld.SAMBA_LIBRARY('ndr-standard',
-    source='gen_ndr/ndr_eventlog6.c',
+    source='',
     vnum='0.0.1',
     pc_files='ndr_standard.pc',
-    deps='''NDR_SECURITY NDR_LSA NDR_SAMR NDR_NETLOGON NDR_EVENTLOG NDR_DFS
+    deps='''NDR_SECURITY NDR_LSA NDR_SAMR NDR_NETLOGON
+    NDR_EVENTLOG NDR_EVENTLOG6 NDR_DFS
     NDR_NTSVCS NDR_SVCCTL NDR_INITSHUTDOWN NDR_WKSSVC NDR_SRVSVC NDR_WINREG
     NDR_ECHO security NDR_DNS NDR_DNSP NDR_ATSVC NDR_SPOOLSS NDR_DSSETUP
     NDR_SERVER_ID NDR_NOTIFY''',
@@ -399,6 +409,10 @@ bld.SAMBA_SUBSYSTEM('NDR_SCHANNEL',
     public_deps='ndr ndr_nbt'
     )
 
+bld.SAMBA_SUBSYSTEM('NDR_NBT',
+                    source='',
+                    deps='ndr_nbt')
+
 bld.SAMBA_LIBRARY('ndr_nbt',
     source='gen_ndr/ndr_nbt.c ndr/ndr_nbt.c',
     public_deps='ndr NDR_NBT_BUF NDR_SECURITY',
@@ -410,7 +424,7 @@ bld.SAMBA_LIBRARY('ndr_nbt',
 
 bld.SAMBA_SUBSYSTEM('NDR_BACKUPKEY',
     source='ndr/ndr_backupkey.c gen_ndr/ndr_backupkey.c',
-    public_deps='ndr'
+    public_deps='ndr NDR_SECURITY'
     )
 
 bld.SAMBA_SUBSYSTEM('NDR_PREG',
@@ -423,7 +437,7 @@ bld.SAMBA_SUBSYSTEM('NDR_CAB',
            gen_ndr/ndr_cab.c
            ndr/ndr_cab.c
            ''',
-    public_deps='ndr')
+    public_deps='ndr NDR_COMPRESSION')
 
 bld.SAMBA_SUBSYSTEM('NDR_FILE_ID',
     source='gen_ndr/ndr_file_id.c',
@@ -435,6 +449,11 @@ bld.SAMBA_SUBSYSTEM('NDR_MESSAGING',
     public_deps='ndr NDR_SERVER_ID'
     )
 
+bld.SAMBA_SUBSYSTEM('NDR_WINSTATION',
+	source='gen_ndr/ndr_winstation.c',
+	public_deps='ndr'
+	)
+
 bld.SAMBA_SUBSYSTEM('RPC_NDR_ATSVC',
     source='gen_ndr/ndr_atsvc_c.c',
     public_deps='dcerpc-binding NDR_ATSVC'
@@ -614,6 +633,10 @@ bld.SAMBA_LIBRARY('dcerpc-samba',
     grouping_library=True
     )
 
+bld.SAMBA_SUBSYSTEM('NDR_MISC',
+                    source='',
+                    deps='ndr')
+
 bld.SAMBA_LIBRARY('ndr',
     source='ndr/ndr_string.c ndr/ndr_basic.c ndr/uuid.c ndr/ndr.c ndr/ndr_misc.c gen_ndr/ndr_misc.c ndr/util.c',
     pc_files='ndr.pc',
@@ -639,7 +662,7 @@ bld.SAMBA_LIBRARY('dcerpc-server-core',
            rpc/dcesrv_mgmt.c
            rpc/dcesrv_reply.c
            ''',
-    deps='ndr dcerpc-binding',
+    deps='ndr dcerpc-binding samba-util-core gnutls GNUTLS_HELPERS',
     pc_files=[],
     public_headers='rpc/dcesrv_core.h',
     autoproto='rpc/dcesrv_core_proto.h',
@@ -664,3 +687,14 @@ bld.SAMBA_SUBSYSTEM('NDR_FSRVP_STATE',
     source='gen_ndr/ndr_fsrvp_state.c',
     public_deps='ndr'
     )
+#
+# Cmocka tests
+#
+bld.SAMBA_BINARY('test_ndr_string',
+                 source='tests/test_ndr_string.c',
+                 deps='''
+                      cmocka
+                      talloc
+                      ndr
+                      ''',
+                 for_selftest=True)
diff --git a/nsswitch/wscript_build b/nsswitch/wscript_build
index 861ed2f23bf..b754c168425 100644
--- a/nsswitch/wscript_build
+++ b/nsswitch/wscript_build
@@ -14,14 +14,14 @@ bld.SAMBA_LIBRARY('winbind-client',
 bld.SAMBA_BINARY('nsstest',
 		 source='nsstest.c',
 		 deps='replace dl',
-                 install=False
+                 for_selftest=True
 		 )
 
 if bld.CONFIG_SET('HAVE_PTHREAD'):
     bld.SAMBA_BINARY('stress-nss-libwbclient',
 		     source='stress-nss-libwbclient.c',
 		     deps='wbclient pthread',
-		     install=False
+		     for_selftest=True
 		     )
 
 # The nss_wrapper code relies strictly on the linux implementation and
diff --git a/pidl/lib/Parse/Pidl.pm b/pidl/lib/Parse/Pidl.pm
index 40e3673908e..e4c39b3d063 100644
--- a/pidl/lib/Parse/Pidl.pm
+++ b/pidl/lib/Parse/Pidl.pm
@@ -12,7 +12,7 @@ require Exporter;
 @EXPORT_OK = qw(warning error fatal $VERSION);
 
 use strict;
-
+use warnings;
 use vars qw ( $VERSION );
 
 $VERSION = '0.02';
diff --git a/pidl/lib/Parse/Pidl/Base.pm b/pidl/lib/Parse/Pidl/Base.pm
new file mode 100644
index 00000000000..056b7b37d48
--- /dev/null
+++ b/pidl/lib/Parse/Pidl/Base.pm
@@ -0,0 +1,99 @@
+# Superclass for IDL structure generators
+# GPL3
+
+package Parse::Pidl::Base;
+
+use strict;
+use warnings;
+
+use Parse::Pidl qw(fatal warning error);
+
+use vars qw($VERSION);
+$VERSION = '0.01';
+
+sub indent {
+	my $self = shift;
+	$self->{tabs} .= "\t";
+}
+
+sub deindent {
+	my $self = shift;
+	$self->{tabs} = substr($self->{tabs}, 1);
+}
+
+sub pidl {
+	my ($self, $txt) = @_;
+	if ($txt) {
+		if ($txt !~ /^#/) {
+			$self->{res} .= $self->{tabs};
+		}
+		$self->{res} .= $txt;
+	}
+	$self->{res} .= "\n";
+}
+
+
+sub pidl_hdr {
+	my ($self, $txt) = @_;
+	$self->{res_hdr} .= "$txt\n";
+}
+
+
+sub pidl_both {
+	my ($self, $txt) = @_;
+	$self->{res} .= "$txt\n";
+	$self->{res_hdr} .= "$txt\n";
+}
+
+
+# When the PIDL_DEVELOPER env flag is set, we overwrite $self->pidl()
+# and $self->pidl_hdr() to annotate the output with location
+# information.
+
+sub pidl_dev_msg {
+	my $self = shift;
+	my ($pkg, $file, $line, $sub) = caller(2);
+	# minimise the path
+	if ($file =~ m{/pidl/(lib/.+|pidl)$}) {
+		$file = $1;
+	}
+	my $state = $self->{dev_state} // ['uninitialised', 0, ''];
+	my ($ploc, $pline, $ptabs) = @$state;
+	my $loc = "$sub	 $file";
+
+	if ($loc ne $ploc or
+	    abs($line - $pline) > 20 or
+	    $self->{tabs} ne $ptabs) {
+		$self->{dev_state} = [$loc, $line, $self->{tabs}];
+		return "  //<PIDL> $loc:$line";
+	}
+	return '';
+}
+
+
+if ($ENV{PIDL_DEVELOPER}) {
+	undef &pidl;
+	undef &pidl_hdr;
+
+	*Parse::Pidl::Base::pidl = sub {
+		my ($self, $txt) = @_;
+
+		if ($txt) {
+			if ($txt !~ /^#/) {
+				$self->{res} .= $self->{tabs};
+			}
+			$self->{res} .= $txt;
+		}
+		$self->{res} .= $self->pidl_dev_msg;
+		$self->{res} .= "\n";
+	};
+
+	*Parse::Pidl::Base::pidl_hdr = sub {
+		my ($self, $txt) = @_;
+		$txt .= $self->pidl_dev_msg;
+		$self->{res_hdr} .= "$txt\n";
+	}
+}
+
+
+1;
diff --git a/pidl/lib/Parse/Pidl/CUtil.pm b/pidl/lib/Parse/Pidl/CUtil.pm
index 9deb6ee1779..ccd8fcc3d82 100644
--- a/pidl/lib/Parse/Pidl/CUtil.pm
+++ b/pidl/lib/Parse/Pidl/CUtil.pm
@@ -11,6 +11,7 @@ use vars qw($VERSION);
 $VERSION = '0.01';
 
 use strict;
+use warnings;
 
 sub get_pointer_to($)
 {
diff --git a/pidl/lib/Parse/Pidl/Compat.pm b/pidl/lib/Parse/Pidl/Compat.pm
index b8abcb88195..062a53b8bea 100644
--- a/pidl/lib/Parse/Pidl/Compat.pm
+++ b/pidl/lib/Parse/Pidl/Compat.pm
@@ -8,6 +8,7 @@ package Parse::Pidl::Compat;
 use Parse::Pidl qw(warning);
 use Parse::Pidl::Util qw(has_property);
 use strict;
+use warnings;
 
 use vars qw($VERSION);
 $VERSION = '0.01';
diff --git a/pidl/lib/Parse/Pidl/Dump.pm b/pidl/lib/Parse/Pidl/Dump.pm
index 4e623db673a..5d241b812c5 100644
--- a/pidl/lib/Parse/Pidl/Dump.pm
+++ b/pidl/lib/Parse/Pidl/Dump.pm
@@ -27,6 +27,7 @@ $VERSION = '0.01';
 @EXPORT_OK = qw(DumpType DumpTypedef DumpStruct DumpEnum DumpBitmap DumpUnion DumpFunction);
 
 use strict;
+use warnings;
 use Parse::Pidl::Util qw(has_property);
 
 my($res);
diff --git a/pidl/lib/Parse/Pidl/Expr.pm b/pidl/lib/Parse/Pidl/Expr.pm
index 24581d29f49..967d687670e 100644
--- a/pidl/lib/Parse/Pidl/Expr.pm
+++ b/pidl/lib/Parse/Pidl/Expr.pm
@@ -10,6 +10,7 @@
 package Parse::Pidl::Expr;
 use vars qw ( @ISA );
 use strict;
+use warnings;
 
 @ISA= qw ( Parse::Yapp::Driver );
 use Parse::Yapp::Driver;
diff --git a/pidl/lib/Parse/Pidl/IDL.pm b/pidl/lib/Parse/Pidl/IDL.pm
index 6927c892556..28bdf2f9d84 100644
--- a/pidl/lib/Parse/Pidl/IDL.pm
+++ b/pidl/lib/Parse/Pidl/IDL.pm
@@ -10,6 +10,7 @@
 package Parse::Pidl::IDL;
 use vars qw ( @ISA );
 use strict;
+use warnings;
 
 @ISA= qw ( Parse::Yapp::Driver );
 use Parse::Yapp::Driver;
diff --git a/pidl/lib/Parse/Pidl/NDR.pm b/pidl/lib/Parse/Pidl/NDR.pm
index 003156e3a11..44338a1298d 100644
--- a/pidl/lib/Parse/Pidl/NDR.pm
+++ b/pidl/lib/Parse/Pidl/NDR.pm
@@ -38,6 +38,7 @@ $VERSION = '0.01';
 @EXPORT_OK = qw(GetElementLevelTable ParseElement ReturnTypeElement ValidElement align_type mapToScalar ParseType can_contain_deferred is_charset_array);
 
 use strict;
+use warnings;
 use Parse::Pidl qw(warning fatal);
 use Parse::Pidl::Typelist qw(hasType getType typeIs expandAlias mapScalarType is_fixed_size_scalar);
 use Parse::Pidl::Util qw(has_property property_matches);
@@ -80,7 +81,8 @@ my $scalar_alignment = {
 	'ipv4address' => 4,
 	'ipv6address' => 4, #16?
 	'dnsp_name' => 1,
-	'dnsp_string' => 1
+	'dnsp_string' => 1,
+	'HRESULT' => 4,
 };
 
 sub GetElementLevelTable($$$)
@@ -115,7 +117,7 @@ sub GetElementLevelTable($$$)
 		warning($e, "[out] argument `$e->{NAME}' not a pointer") if ($needptrs > $e->{POINTERS});
 	}
 
-	my $allow_pipe = ($e->{PARENT}->{TYPE} eq "FUNCTION");
+	my $allow_pipe = (($e->{PARENT}->{TYPE} // '') eq "FUNCTION");
 	my $is_pipe = typeIs($e->{TYPE}, "PIPE");
 
 	if ($is_pipe) {
@@ -468,7 +470,12 @@ sub align_type($)
 	my ($e) = @_;
 
 	if (ref($e) eq "HASH" and $e->{TYPE} eq "SCALAR") {
-		return $scalar_alignment->{$e->{NAME}};
+		my $ret = $scalar_alignment->{$e->{NAME}};
+		if (not defined $ret) {
+			warning($e, "no scalar alignment for $e->{NAME}!");
+			return 0;
+		}
+		return $ret;
 	}
 
 	return 0 if ($e eq "EMPTY");
@@ -903,7 +910,7 @@ sub ParseInterface($)
 
 	return { 
 		NAME => $idl->{NAME},
-		UUID => lc(has_property($idl, "uuid")),
+		UUID => lc(has_property($idl, "uuid") // ''),
 		VERSION => $version,
 		TYPE => "INTERFACE",
 		PROPERTIES => $idl->{PROPERTIES},
diff --git a/pidl/lib/Parse/Pidl/ODL.pm b/pidl/lib/Parse/Pidl/ODL.pm
index 14e77fa93f2..12f869c662e 100644
--- a/pidl/lib/Parse/Pidl/ODL.pm
+++ b/pidl/lib/Parse/Pidl/ODL.pm
@@ -10,6 +10,7 @@ use Parse::Pidl::Util qw(has_property unmake_str);
 use Parse::Pidl::Typelist qw(hasType getType);
 use File::Basename;
 use strict;
+use warnings;
 
 use vars qw($VERSION);
 $VERSION = '0.01';
diff --git a/pidl/lib/Parse/Pidl/Samba3/ClientNDR.pm b/pidl/lib/Parse/Pidl/Samba3/ClientNDR.pm
index 6acf1c5af2c..816440ef033 100644
--- a/pidl/lib/Parse/Pidl/Samba3/ClientNDR.pm
+++ b/pidl/lib/Parse/Pidl/Samba3/ClientNDR.pm
@@ -6,12 +6,10 @@
 # released under the GNU GPL
 
 package Parse::Pidl::Samba3::ClientNDR;
-
-use Exporter;
-@ISA = qw(Exporter);
-@EXPORT_OK = qw(ParseFunction $res $res_hdr);
+use base Parse::Pidl::Base;
 
 use strict;
+use warnings;
 use Parse::Pidl qw(fatal warning error);
 use Parse::Pidl::Util qw(has_property ParseExpr genpad);
 use Parse::Pidl::NDR qw(ContainsPipe);
@@ -19,13 +17,10 @@ use Parse::Pidl::Typelist qw(mapTypeName);
 use Parse::Pidl::Samba4 qw(DeclLong);
 use Parse::Pidl::Samba4::Header qw(GenerateFunctionInEnv GenerateFunctionOutEnv);
 
+
 use vars qw($VERSION);
 $VERSION = '0.01';
 
-sub indent($) { my ($self) = @_; $self->{tabs}.="\t"; }
-sub deindent($) { my ($self) = @_; $self->{tabs} = substr($self->{tabs}, 1); }
-sub pidl($$) { my ($self,$txt) = @_; $self->{res} .= $txt ? "$self->{tabs}$txt\n" : "\n"; }
-sub pidl_hdr($$) { my ($self, $txt) = @_; $self->{res_hdr} .= "$txt\n"; }
 sub fn_declare($$) { my ($self,$n) = @_; $self->pidl($n); $self->pidl_hdr("$n;"); }
 
 sub new($)
diff --git a/pidl/lib/Parse/Pidl/Samba3/ServerNDR.pm b/pidl/lib/Parse/Pidl/Samba3/ServerNDR.pm
index fa7303b8543..d93d5197260 100644
--- a/pidl/lib/Parse/Pidl/Samba3/ServerNDR.pm
+++ b/pidl/lib/Parse/Pidl/Samba3/ServerNDR.pm
@@ -11,6 +11,7 @@ use Exporter;
 @EXPORT_OK = qw(DeclLevel);
 
 use strict;
+use warnings;
 use Parse::Pidl qw(warning error fatal);
 use Parse::Pidl::Typelist qw(mapTypeName scalar_is_reference);
 use Parse::Pidl::Util qw(ParseExpr has_property is_constant);
diff --git a/pidl/lib/Parse/Pidl/Samba3/Template.pm b/pidl/lib/Parse/Pidl/Samba3/Template.pm
index d50f7062395..ee64aebf365 100644
--- a/pidl/lib/Parse/Pidl/Samba3/Template.pm
+++ b/pidl/lib/Parse/Pidl/Samba3/Template.pm
@@ -11,6 +11,7 @@ $VERSION = '0.01';
 use Parse::Pidl::Util qw(genpad);
 
 use strict;
+use warnings;
 
 my($res);
 
diff --git a/pidl/lib/Parse/Pidl/Samba4.pm b/pidl/lib/Parse/Pidl/Samba4.pm
index b720ab90159..6b3f221887f 100644
--- a/pidl/lib/Parse/Pidl/Samba4.pm
+++ b/pidl/lib/Parse/Pidl/Samba4.pm
@@ -14,6 +14,7 @@ use Parse::Pidl::NDR qw(GetNextLevel);
 use Parse::Pidl::Typelist qw(mapTypeName scalar_is_reference);
 use Parse::Pidl qw(fatal error);
 use strict;
+use warnings;
 
 use vars qw($VERSION);
 $VERSION = '0.01';
diff --git a/pidl/lib/Parse/Pidl/Samba4/COM/Header.pm b/pidl/lib/Parse/Pidl/Samba4/COM/Header.pm
index de7d4547a5b..159f417236f 100644
--- a/pidl/lib/Parse/Pidl/Samba4/COM/Header.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/COM/Header.pm
@@ -10,6 +10,7 @@ use vars qw($VERSION);
 $VERSION = '0.01';
 
 use strict;
+use warnings;
 
 sub GetArgumentProtoList($)
 {
diff --git a/pidl/lib/Parse/Pidl/Samba4/COM/Proxy.pm b/pidl/lib/Parse/Pidl/Samba4/COM/Proxy.pm
index de050e8f8c6..1630cf235dc 100644
--- a/pidl/lib/Parse/Pidl/Samba4/COM/Proxy.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/COM/Proxy.pm
@@ -14,6 +14,7 @@ use vars qw($VERSION);
 $VERSION = '0.01';
 
 use strict;
+use warnings;
 
 my($res);
 
diff --git a/pidl/lib/Parse/Pidl/Samba4/COM/Stub.pm b/pidl/lib/Parse/Pidl/Samba4/COM/Stub.pm
index 239f5baaeed..71980383572 100644
--- a/pidl/lib/Parse/Pidl/Samba4/COM/Stub.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/COM/Stub.pm
@@ -9,6 +9,7 @@ package Parse::Pidl::Samba4::COM::Stub;
 
 use Parse::Pidl::Util qw(has_property);
 use strict;
+use warnings;
 
 use vars qw($VERSION);
 $VERSION = '0.01';
@@ -125,8 +126,6 @@ static NTSTATUS $name\__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_C
         /* unravel the NDR for the packet */
 	status = dcerpc_table_$name.calls[opnum].ndr_pull(pull, NDR_IN, *r);
 	if (!NT_STATUS_IS_OK(status)) {
-		dcerpc_log_packet(&dcerpc_table_$name, opnum, NDR_IN,
-				  &dce_call->pkt.u.request.stub_and_verifier);
 		dce_call->fault_code = DCERPC_FAULT_NDR;
 		return NT_STATUS_NET_WRITE_FAULT;
 	}
@@ -152,8 +151,6 @@ pidl "
 	}
 
 	if (dce_call->fault_code != 0) {
-		dcerpc_log_packet(&dcerpc_table_$name, opnum, NDR_IN,
-				  &dce_call->pkt.u.request.stub_and_verifier);
 		return NT_STATUS_NET_WRITE_FAULT;
 	}
 
@@ -175,8 +172,6 @@ pidl "
 	}
 
 	if (dce_call->fault_code != 0) {
-		dcerpc_log_packet(&dcerpc_table_$name, opnum, NDR_IN,
-				  &dce_call->pkt.u.request.stub_and_verifier);
 		return NT_STATUS_NET_WRITE_FAULT;
 	}
 
diff --git a/pidl/lib/Parse/Pidl/Samba4/Header.pm b/pidl/lib/Parse/Pidl/Samba4/Header.pm
index e9b7bee040c..b818dce30ca 100644
--- a/pidl/lib/Parse/Pidl/Samba4/Header.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/Header.pm
@@ -11,6 +11,7 @@ require Exporter;
 @EXPORT_OK = qw(GenerateFunctionInEnv GenerateFunctionOutEnv EnvSubstituteValue GenerateStructEnv);
 
 use strict;
+use warnings;
 use Parse::Pidl qw(fatal);
 use Parse::Pidl::Typelist qw(mapTypeName scalar_is_reference);
 use Parse::Pidl::Util qw(has_property is_constant unmake_str ParseExpr);
diff --git a/pidl/lib/Parse/Pidl/Samba4/NDR/Client.pm b/pidl/lib/Parse/Pidl/Samba4/NDR/Client.pm
index 734e86dd183..58ec389a9f3 100644
--- a/pidl/lib/Parse/Pidl/Samba4/NDR/Client.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/NDR/Client.pm
@@ -5,10 +5,7 @@
 # released under the GNU GPL
 
 package Parse::Pidl::Samba4::NDR::Client;
-
-use Exporter;
-@ISA = qw(Exporter);
-@EXPORT_OK = qw(Parse);
+use parent Parse::Pidl::Base;
 
 use Parse::Pidl qw(fatal warning error);
 use Parse::Pidl::Util qw(has_property ParseExpr genpad);
@@ -17,18 +14,14 @@ use Parse::Pidl::Typelist qw(mapTypeName);
 use Parse::Pidl::Samba4 qw(choose_header is_intree DeclLong);
 use Parse::Pidl::Samba4::Header qw(GenerateFunctionInEnv GenerateFunctionOutEnv);
 
+
 use vars qw($VERSION);
 $VERSION = '0.01';
 
 use strict;
+use warnings;
 
-sub indent($) { my ($self) = @_; $self->{tabs}.="\t"; }
-sub deindent($) { my ($self) = @_; $self->{tabs} = substr($self->{tabs}, 1); }
-sub pidl($$) { my ($self,$txt) = @_; $self->{res} .= $txt ? "$self->{tabs}$txt\n" : "\n"; }
-sub pidl_hdr($$) { my ($self, $txt) = @_; $self->{res_hdr} .= "$txt\n"; }
-sub pidl_both($$) { my ($self, $txt) = @_; $self->{hdr} .= "$txt\n"; $self->{res_hdr} .= "$txt\n"; }
 sub fn_declare($$) { my ($self,$n) = @_; $self->pidl($n); $self->pidl_hdr("$n;"); }
-
 sub new($)
 {
 	my ($class) = shift;
diff --git a/pidl/lib/Parse/Pidl/Samba4/NDR/Parser.pm b/pidl/lib/Parse/Pidl/Samba4/NDR/Parser.pm
index 8759e46aedb..0d58cb5f03d 100644
--- a/pidl/lib/Parse/Pidl/Samba4/NDR/Parser.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/NDR/Parser.pm
@@ -6,14 +6,22 @@
 # released under the GNU GPL
 
 package Parse::Pidl::Samba4::NDR::Parser;
+use parent Parse::Pidl::Base;
 
 require Exporter;
-@ISA = qw(Exporter);
+push @ISA, qw(Exporter);
 @EXPORT_OK = qw(check_null_pointer NeededFunction NeededElement NeededType $res NeededInterface TypeFunctionName ParseElementPrint);
 
 use strict;
+use warnings;
 use Parse::Pidl::Typelist qw(hasType getType mapTypeName typeHasBody);
-use Parse::Pidl::Util qw(has_property ParseExpr ParseExprExt print_uuid unmake_str);
+use Parse::Pidl::Util qw(has_property
+			 ParseExpr
+			 ParseExprExt
+			 print_uuid
+			 unmake_str
+			 parse_int
+			 parse_range);
 use Parse::Pidl::CUtil qw(get_pointer_to get_value_of get_array_element);
 use Parse::Pidl::NDR qw(GetPrevLevel GetNextLevel ContainsDeferred ContainsPipe is_charset_array);
 use Parse::Pidl::Samba4 qw(is_intree choose_header ArrayDynamicallyAllocated);
@@ -76,25 +84,23 @@ sub has_fast_array($$)
 
 	my $t = getType($nl->{DATA_TYPE});
 
-	# Only uint8 and string have fast array functions at the moment
-	return ($t->{NAME} eq "uint8") or ($t->{NAME} eq "string");
+	# Only uint8 has a fast array function at the moment
+	return ($t->{NAME} eq "uint8");
 }
 
-
-####################################
-# pidl() is our basic output routine
-sub pidl($$)
+sub is_public_struct
 {
-	my ($self, $d) = @_;
-	if ($d) {
-		$self->{res} .= $self->{tabs};
-		$self->{res} .= $d;
+	my ($d) = @_;
+	if (!has_property($d, "public")) {
+		return 0;
+	}
+	my $t = $d;
+	if ($d->{TYPE} eq "TYPEDEF") {
+		$t = $d->{DATA};
 	}
-	$self->{res} .="\n";
+	return $t->{TYPE} eq "STRUCT";
 }
 
-sub pidl_hdr($$) { my ($self, $d) = @_; $self->{res_hdr} .= "$d\n"; }
-
 ####################################
 # defer() is like pidl(), but adds to 
 # a deferred buffer which is then added to the 
@@ -123,18 +129,6 @@ sub add_deferred($)
 	$self->{defer_tabs} = "";
 }
 
-sub indent($)
-{
-	my ($self) = @_;
-	$self->{tabs} .= "\t";
-}
-
-sub deindent($)
-{
-	my ($self) = @_;
-	$self->{tabs} = substr($self->{tabs}, 0, -1);
-}
-
 #####################################################################
 # declare a function public or static, depending on its attributes
 sub fn_declare($$$$)
@@ -361,7 +355,7 @@ sub ParseArrayPullGetSize($$$$$$)
 	my $array_size = "size_$e->{NAME}_$l->{LEVEL_INDEX}";
 
 	if (my $range = has_property($e, "range")) {
-		my ($low, $high) = split(/,/, $range, 2);
+		my ($low, $high) = parse_range($range);
 		if ($low < 0) {
 			warning(0, "$low is invalid for the range of an array size");
 		}
@@ -396,7 +390,7 @@ sub ParseArrayPullGetLength($$$$$$;$)
 	my $array_length = "length_$e->{NAME}_$l->{LEVEL_INDEX}";
 
 	if (my $range = has_property($e, "range")) {
-		my ($low, $high) = split(/,/, $range, 2);
+		my ($low, $high) = parse_range($range);
 		if ($low < 0) {
 			warning(0, "$low is invalid for the range of an array size");
 		}
@@ -647,8 +641,6 @@ sub ParseElementPushLevel
 				$self->pidl("NDR_CHECK(ndr_push_array_$nl->{DATA_TYPE}($ndr, $ndr_flags, $var_name, $length));");
 				return;
 			} 
-		} elsif ($l->{TYPE} eq "SWITCH") {
-			$self->ParseSwitchPush($e, $l, $ndr, $var_name, $env);
 		} elsif ($l->{TYPE} eq "DATA") {
 			$self->ParseDataPush($e, $l, $ndr, $var_name, $primitives, $deferred);
 		} elsif ($l->{TYPE} eq "TYPEDEF") {
@@ -709,6 +701,14 @@ sub ParseElementPushLevel
 			$self->pidl("}");
 		}
 	} elsif ($l->{TYPE} eq "SWITCH") {
+		my $nl = GetNextLevel($e,$l);
+		my $needs_deferred_switch = is_deferred_switch_non_empty($nl);
+
+		# Avoid setting a switch value if it will not be
+		# consumed again in the NDR_BUFFERS pull
+		if ($needs_deferred_switch or !$deferred) {
+			$self->ParseSwitchPush($e, $l, $ndr, $var_name, $env);
+		}
 		$self->ParseElementPushLevel($e, GetNextLevel($e, $l), $ndr, $var_name, $env, $primitives, $deferred);
 	}
 }
@@ -998,10 +998,10 @@ sub ParseDataPull($$$$$$$)
 		my $pl = GetPrevLevel($e, $l);
 
 		my $range = has_property($e, "range");
-		if ($range and $pl->{TYPE} ne "ARRAY") {
+		if ($range and (not $pl or $pl->{TYPE} ne "ARRAY")) {
 			$var_name = get_value_of($var_name);
 			my $signed = Parse::Pidl::Typelist::is_signed($l->{DATA_TYPE});
-			my ($low, $high) = split(/,/, $range, 2);
+			my ($low, $high) = parse_range($range);
 			if ($low < 0 and not $signed) {
 				warning(0, "$low is invalid for the range of an unsigned type");
 			}
@@ -1174,8 +1174,6 @@ sub ParseElementPullLevel
 			}
 		} elsif ($l->{TYPE} eq "POINTER") {
 			$self->ParsePtrPull($e, $l, $ndr, $var_name);
-		} elsif ($l->{TYPE} eq "SWITCH") {
-			$self->ParseSwitchPull($e, $l, $ndr, $var_name, $env);
 		} elsif ($l->{TYPE} eq "DATA") {
 			$self->ParseDataPull($e, $l, $ndr, $var_name, $primitives, $deferred);
 		} elsif ($l->{TYPE} eq "TYPEDEF") {
@@ -1247,16 +1245,28 @@ sub ParseElementPullLevel
 
 		if ($deferred and ContainsDeferred($e, $l)) {
 			$self->pidl("for ($counter = 0; $counter < ($length); $counter++) {");
+			$self->defer("for ($counter = 0; $counter < ($length); $counter++) {");
+			$self->defer_indent;
 			$self->indent;
 			$self->ParseElementPullLevel($e,GetNextLevel($e,$l), $ndr, $var_name, $env, 0, 1);
 			$self->deindent;
+			$self->defer_deindent;
 			$self->pidl("}");
+			$self->defer("}");
 		}
 
 		$self->ParseMemCtxPullEnd($e, $l, $ndr);
 
 	} elsif ($l->{TYPE} eq "SWITCH") {
-		$self->ParseElementPullLevel($e, GetNextLevel($e,$l), $ndr, $var_name, $env, $primitives, $deferred);
+		my $nl = GetNextLevel($e,$l);
+		my $needs_deferred_switch = is_deferred_switch_non_empty($nl);
+
+		# Avoid setting a switch value if it will not be
+		# consumed again in the NDR_BUFFERS pull
+		if ($needs_deferred_switch or !$deferred) {
+			$self->ParseSwitchPull($e, $l, $ndr, $var_name, $env);
+		}
+		$self->ParseElementPullLevel($e, $nl, $ndr, $var_name, $env, $primitives, $deferred);
 	}
 }
 
@@ -1874,8 +1884,6 @@ sub ParseUnionPushPrimitives($$$$)
 
 	my $have_default = 0;
 
-	$self->pidl("uint32_t level = ndr_push_get_switch_value($ndr, $varname);");
-
 	if (defined($e->{SWITCH_TYPE})) {
 		if (defined($e->{ALIGN})) {
 			$self->pidl("NDR_CHECK(ndr_push_union_align($ndr, $e->{ALIGN}));");
@@ -1932,7 +1940,6 @@ sub ParseUnionPushDeferred($$$$)
 
 	my $have_default = 0;
 
-	$self->pidl("uint32_t level = ndr_push_get_switch_value($ndr, $varname);");
 	if (defined($e->{PROPERTIES}{relative_base})) {
 		# retrieve the current offset as base for relative pointers
 		# based on the toplevel struct/union
@@ -1969,17 +1976,28 @@ sub ParseUnionPush($$$$)
 	my ($self,$e,$ndr,$varname) = @_;
 	my $have_default = 0;
 
+	$self->pidl("uint32_t level;");
 	$self->start_flags($e, $ndr);
 
 	$self->pidl("NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);");
 	$self->pidl("if (ndr_flags & NDR_SCALARS) {");
 	$self->indent;
+	$self->pidl("/* This token is not used again (except perhaps below in the NDR_BUFFERS case) */");
+	$self->pidl("NDR_CHECK(ndr_push_steal_switch_value($ndr, $varname, &level));");
+
 	$self->ParseUnionPushPrimitives($e, $ndr, $varname);
 	$self->deindent;
 	$self->pidl("}");
         if (is_deferred_switch_non_empty($e)) {
                 $self->pidl("if (ndr_flags & NDR_BUFFERS) {");
                 $self->indent;
+                # In case we had ndr_flags of NDR_SCALERS|NDR_BUFFERS
+                $self->pidl("if (!(ndr_flags & NDR_SCALARS)) {");
+                $self->indent;
+                $self->pidl("/* We didn't get it above, and the token is not needed after this. */");
+                $self->pidl("NDR_CHECK(ndr_push_steal_switch_value($ndr, $varname, &level));");
+                $self->deindent;
+                $self->pidl("}");
                 $self->ParseUnionPushDeferred($e, $ndr, $varname);
                 $self->deindent;
                 $self->pidl("}");
@@ -2001,7 +2019,7 @@ sub ParseUnionPrint($$$$$)
 
 	$self->start_flags($e, $ndr);
 
-	$self->pidl("level = ndr_print_get_switch_value($ndr, $varname);");
+	$self->pidl("level = ndr_print_steal_switch_value($ndr, $varname);");
 
 	$self->pidl("ndr_print_union($ndr, name, level, \"$name\");");
 
@@ -2091,11 +2109,6 @@ sub ParseUnionPullDeferred($$$$)
 	my ($self,$e,$ndr,$varname) = @_;
 	my $have_default = 0;
 
-	if (defined($e->{PROPERTIES}{relative_base})) {
-		# retrieve the current offset as base for relative pointers
-		# based on the toplevel struct/union
-		$self->pidl("NDR_CHECK(ndr_pull_setup_relative_base_offset2($ndr, $varname));");
-	}
 	$self->pidl("switch (level) {");
 	$self->indent;
 	foreach my $el (@{$e->{ELEMENTS}}) {
@@ -2106,6 +2119,11 @@ sub ParseUnionPullDeferred($$$$)
 		$self->pidl("$el->{CASE}:");
 		if ($el->{TYPE} ne "EMPTY") {
 			$self->indent;
+			if (defined($e->{PROPERTIES}{relative_base})) {
+				# retrieve the current offset as base for relative pointers
+				# based on the toplevel struct/union
+				$self->pidl("NDR_CHECK(ndr_pull_setup_relative_base_offset2($ndr, $varname));");
+			}
 			$self->ParseElementPull($el, $ndr, {$el->{NAME} => "$varname->$el->{NAME}"}, 0, 1);
 			$self->deindent;
 		}
@@ -2152,20 +2170,21 @@ sub ParseUnionPull($$$$)
 	$self->pidl("NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);");
 	$self->pidl("if (ndr_flags & NDR_SCALARS) {");
 	$self->indent;
-	if (! $needs_deferred_switch) {
-		$self->pidl("/* This token is not used again */");
-		$self->pidl("level = ndr_pull_steal_switch_value($ndr, $varname);");
-	} else {
-		$self->pidl("level = ndr_pull_get_switch_value($ndr, $varname);");
-	}
+	$self->pidl("/* This token is not used again (except perhaps below in the NDR_BUFFERS case) */");
+	$self->pidl("NDR_CHECK(ndr_pull_steal_switch_value($ndr, $varname, &level));");
 	$self->ParseUnionPullPrimitives($e,$ndr,$varname,$switch_type);
 	$self->deindent;
 	$self->pidl("}");
 	if ($needs_deferred_switch) {
 		$self->pidl("if (ndr_flags & NDR_BUFFERS) {");
 		$self->indent;
-		$self->pidl("/* The token is not needed after this. */");
-		$self->pidl("level = ndr_pull_steal_switch_value($ndr, $varname);");
+		# In case we had ndr_flags of NDR_SCALERS|NDR_BUFFERS
+		$self->pidl("if (!(ndr_flags & NDR_SCALARS)) {");
+		$self->indent;
+		$self->pidl("/* We didn't get it above, and the token is not needed after this. */");
+		$self->pidl("NDR_CHECK(ndr_pull_steal_switch_value($ndr, $varname, &level));");
+		$self->deindent;
+		$self->pidl("}");
 		$self->ParseUnionPullDeferred($e,$ndr,$varname);
 		$self->deindent;
 		$self->pidl("}");
@@ -2618,6 +2637,31 @@ sub ParseFunctionPull($$)
 	$self->pidl("if (flags & NDR_OUT) {");
 	$self->indent;
 
+	$self->pidl("#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION");
+
+	# This for fuzzers of ndr_pull where the out elements refer to
+	# in elements in size_is or length_is.
+	#
+	# Not actually very harmful but also not useful outsie a fuzzer
+	foreach my $e (@{$fn->{ELEMENTS}}) {
+		next unless (grep(/in/, @{$e->{DIRECTION}}));
+		next unless ($e->{LEVELS}[0]->{TYPE} eq "POINTER" and
+		             $e->{LEVELS}[0]->{POINTER_TYPE} eq "ref");
+		next if (($e->{LEVELS}[1]->{TYPE} eq "DATA") and
+				 ($e->{LEVELS}[1]->{DATA_TYPE} eq "string"));
+		next if ($e->{LEVELS}[1]->{TYPE} eq "PIPE");
+		next if ($e->{LEVELS}[1]->{TYPE} eq "ARRAY");
+
+		$self->pidl("if (r->in.$e->{NAME} == NULL) {");
+		$self->indent;
+		$self->pidl("NDR_PULL_ALLOC($ndr, r->in.$e->{NAME});");
+		$self->pidl("NDR_ZERO_STRUCTP(r->in.$e->{NAME});");
+		$self->deindent;
+		$self->pidl("}");
+	}
+
+	$self->pidl("#endif /* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */");
+
 	$env = GenerateFunctionOutEnv($fn);
 	foreach my $e (@{$fn->{ELEMENTS}}) {
 		next unless grep(/out/, @{$e->{DIRECTION}});
@@ -2783,7 +2827,7 @@ sub FunctionTable($$)
 	my $uname = uc $interface->{NAME};
 
 	foreach my $d (@{$interface->{TYPES}}) {
-	        next unless (has_property($d, "public"));
+	        next unless (is_public_struct($d));
 		$count_public_structs += 1;
 	}
 	return if ($#{$interface->{FUNCTIONS}}+1 == 0 and
@@ -2796,8 +2840,8 @@ sub FunctionTable($$)
 	$self->pidl("static const struct ndr_interface_public_struct $interface->{NAME}\_public_structs[] = {");
 
 	foreach my $d (@{$interface->{TYPES}}) {
-	        next unless (has_property($d, "public"));
-		$self->StructEntry($d)
+	        next unless (is_public_struct($d));
+		$self->StructEntry($d);
 	}
 	$self->pidl("\t{ .name = NULL }");
 	$self->pidl("};");
@@ -3023,7 +3067,7 @@ sub ParseTypePrintFunction($$$)
 
 	$self->pidl_hdr("void ".TypeFunctionName("ndr_print", $e)."(struct ndr_print *ndr, const char *name, $args);");
 
-	if (has_property($e, "public")) {
+	if (is_public_struct($e)) {
                 $self->pidl("static void ".TypeFunctionName("ndr_print_flags", $e).
                              "(struct ndr_print *$ndr, const char *name, int unused, $args)"
                              );
diff --git a/pidl/lib/Parse/Pidl/Samba4/NDR/Server.pm b/pidl/lib/Parse/Pidl/Samba4/NDR/Server.pm
index 945c0ffcee0..eed7d799c0e 100644
--- a/pidl/lib/Parse/Pidl/Samba4/NDR/Server.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/NDR/Server.pm
@@ -7,6 +7,7 @@
 package Parse::Pidl::Samba4::NDR::Server;
 
 use strict;
+use warnings;
 use Parse::Pidl::Util;
 
 use vars qw($VERSION);
@@ -120,9 +121,6 @@ static NTSTATUS $name\__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_C
         /* unravel the NDR for the packet */
 	ndr_err = ndr_table_$name.calls[opnum].ndr_pull(pull, NDR_IN, *r);
 	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
-		dcerpc_log_packet(dce_call->conn->packet_log_dir, 
-				  &ndr_table_$name, opnum, NDR_IN,
-				  &dce_call->pkt.u.request.stub_and_verifier);
 		dce_call->fault_code = DCERPC_FAULT_NDR;
 		return NT_STATUS_NET_WRITE_FAULT;
 	}
@@ -145,9 +143,6 @@ pidl "
 	}
 
 	if (dce_call->fault_code != 0) {
-		dcerpc_log_packet(dce_call->conn->packet_log_dir, 
-		          &ndr_table_$name, opnum, NDR_IN,
-				  &dce_call->pkt.u.request.stub_and_verifier);
 		return NT_STATUS_NET_WRITE_FAULT;
 	}
 
@@ -169,9 +164,6 @@ pidl "
 	}
 
 	if (dce_call->fault_code != 0) {
-		dcerpc_log_packet(dce_call->conn->packet_log_dir,
-		          &ndr_table_$name, opnum, NDR_IN,
-				  &dce_call->pkt.u.request.stub_and_verifier);
 		return NT_STATUS_NET_WRITE_FAULT;
 	}
 
@@ -248,6 +240,11 @@ static NTSTATUS $name\__op_init_server(struct dcesrv_context *dce_ctx, const str
 	return NT_STATUS_OK;
 }
 
+static NTSTATUS $name\__op_shutdown_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
+{
+	return NT_STATUS_OK;
+}
+
 static bool $name\__op_interface_by_uuid(struct dcesrv_interface *iface, const struct GUID *uuid, uint32_t if_version)
 {
 	if (dcesrv_$name\_interface.syntax_id.if_version == if_version &&
@@ -276,11 +273,19 @@ NTSTATUS dcerpc_server_$name\_init(TALLOC_CTX *ctx)
 	    /* fill in our name */
 	    .name = \"$name\",
 
+	    /* Initialization flag */
+	    .initialized = false,
+
 	    /* fill in all the operations */
 #ifdef DCESRV_INTERFACE_$uname\_INIT_SERVER
 	    .init_server = DCESRV_INTERFACE_$uname\_INIT_SERVER,
 #else
 	    .init_server = $name\__op_init_server,
+#endif
+#ifdef DCESRV_INTERFACE_$uname\_SHUTDOWN_SERVER
+	    .shutdown_server = DCESRV_INTERFACE_$uname\_SHUTDOWN_SERVER,
+#else
+	    .shutdown_server = $name\__op_shutdown_server,
 #endif
 	    .interface_by_uuid = $name\__op_interface_by_uuid,
 	    .interface_by_name = $name\__op_interface_by_name
diff --git a/pidl/lib/Parse/Pidl/Samba4/Python.pm b/pidl/lib/Parse/Pidl/Samba4/Python.pm
index 161521c6e3a..84d4dade512 100644
--- a/pidl/lib/Parse/Pidl/Samba4/Python.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/Python.pm
@@ -4,11 +4,10 @@
 # released under the GNU GPL
 
 package Parse::Pidl::Samba4::Python;
-
-use Exporter;
-@ISA = qw(Exporter);
+use parent Parse::Pidl::Base;
 
 use strict;
+use warnings;
 use Parse::Pidl qw(warning fatal error);
 use Parse::Pidl::Typelist qw(hasType resolveType getType mapTypeName expandAlias bitmap_type_fn enum_type_fn);
 use Parse::Pidl::Util qw(has_property ParseExpr unmake_str);
@@ -17,6 +16,7 @@ use Parse::Pidl::CUtil qw(get_value_of get_pointer_to);
 use Parse::Pidl::Samba4 qw(ArrayDynamicallyAllocated);
 use Parse::Pidl::Samba4::Header qw(GenerateFunctionInEnv GenerateFunctionOutEnv EnvSubstituteValue GenerateStructEnv);
 
+
 use vars qw($VERSION);
 $VERSION = '0.01';
 
@@ -34,41 +34,11 @@ sub new($) {
 	bless($self, $class);
 }
 
-sub pidl_hdr ($$)
-{
-	my $self = shift;
-	$self->{res_hdr} .= shift;
-}
-
-sub pidl($$)
-{
-	my ($self, $d) = @_;
-	if ($d) {
-		if ((!($d =~ /^#/))) {
-			$self->{res} .= $self->{tabs};
-		}
-		$self->{res} .= $d;
-	}
-	$self->{res} .= "\n";
-}
-
-sub indent($)
-{
-	my ($self) = @_;
-	$self->{tabs} .= "\t";
-}
-
-sub deindent($)
-{
-	my ($self) = @_;
-	$self->{tabs} = substr($self->{tabs}, 0, -1);
-}
-
 sub PrettifyTypeName($$)
 {
 	my ($name, $basename) = @_;
 
-	$basename =~ s/^.*\.([^.]+)$/\1/;
+	$basename =~ s/^.*\.([^.]+)$/$1/;
 
 	$name =~ s/^$basename\_//;
 
@@ -83,7 +53,7 @@ sub Import
 	foreach (@imports) {
 		$_ = unmake_str($_);
 		s/\.idl$//;
-		$self->pidl_hdr("#include \"librpc/gen_ndr/$_\.h\"\n");
+		$self->pidl_hdr("#include \"librpc/gen_ndr/$_\.h\"");
 		$self->register_module_import("samba.dcerpc.$_");
 	}
 }
@@ -220,7 +190,6 @@ sub PythonElementGetSet($$$$$$) {
 	$self->indent;
 	$self->pidl("$cname *object = ($cname *)pytalloc_get_ptr(py_obj);");
 	my $mem_ctx = "pytalloc_get_mem_ctx(py_obj)";
-	my $l = $e->{LEVELS}[0];
 	my $nl = GetNextLevel($e, $l);
 	if ($l->{TYPE} eq "POINTER" and
 		not ($nl->{TYPE} eq "ARRAY" and ($nl->{IS_FIXED} or is_charset_array($e, $nl))) and
@@ -395,7 +364,7 @@ sub PythonStruct($$$$$$)
 		$self->pidl("");
 	}
 
-	$self->pidl_hdr("static PyTypeObject $name\_Type;\n");
+	$self->pidl_hdr("static PyTypeObject $name\_Type;");
 	$self->pidl("");
 	my $docstring = $self->DocString($d, $name);
 	my $typeobject = "$name\_Type";
@@ -926,7 +895,7 @@ sub PythonFunctionStruct($$$$)
 	$self->pidl("};");
 	$self->pidl("");
 
-	$self->pidl_hdr("static PyTypeObject $name\_Type;\n");
+	$self->pidl_hdr("static PyTypeObject $name\_Type;");
 	$self->pidl("");
 	my $docstring = $self->DocString($fn, $name);
 	my $typeobject = "$name\_Type";
@@ -1357,7 +1326,7 @@ sub PythonType($$$$)
 		$self->pidl("");
 
 		$self->pidl("");
-		$self->pidl_hdr("static PyTypeObject $typeobject;\n");
+		$self->pidl_hdr("static PyTypeObject $typeobject;");
 		$self->pidl("static PyTypeObject $typeobject = {");
 		$self->indent;
 		$self->pidl("PyVarObject_HEAD_INIT(NULL, 0)");
@@ -1412,7 +1381,7 @@ sub Interface($$$)
 	}
 
 	if (defined $interface->{PROPERTIES}->{uuid}) {
-		$self->pidl_hdr("static PyTypeObject $interface->{NAME}_InterfaceType;\n");
+		$self->pidl_hdr("static PyTypeObject $interface->{NAME}_InterfaceType;");
 		$self->pidl("");
 
 		my @fns = ();
@@ -1509,9 +1478,9 @@ sub Interface($$$)
 
 		$self->pidl("");
 
-		my $signature = "\"$interface->{NAME}_abstract_syntax()\\n\"";
+		$signature = "\"$interface->{NAME}_abstract_syntax()\\n\"";
 
-		my $docstring = $self->DocString($interface, $interface->{NAME}."_syntax");
+		$docstring = $self->DocString($interface, $interface->{NAME}."_syntax");
 
 		if ($docstring) {
 			$docstring = "$signature$docstring";
@@ -1545,7 +1514,7 @@ sub Interface($$$)
 						     ""]);
 	}
 
-	$self->pidl_hdr("\n");
+	$self->pidl_hdr("");
 }
 
 sub register_module_method($$$$$)
@@ -2387,7 +2356,6 @@ static inline long long ndr_sizeof2intmax(size_t var_size)
 
 	return 0;
 }
-
 ");
 
 	foreach my $x (@$ndr) {
@@ -2439,7 +2407,7 @@ static inline long long ndr_sizeof2intmax(size_t var_size)
 	foreach my $h (@{$self->{type_imports}}) {
 		my $type_var = "$h->{'key'}\_Type";
 		my $module_path = $h->{'val'};
-		$self->pidl_hdr("static PyTypeObject *$type_var;\n");
+		$self->pidl_hdr("static PyTypeObject *$type_var;");
 		my $pretty_name = PrettifyTypeName($h->{'key'}, $module_path);
 		my $module_var = "dep_$module_path";
 		$module_var =~ s/\./_/g;
diff --git a/pidl/lib/Parse/Pidl/Samba4/TDR.pm b/pidl/lib/Parse/Pidl/Samba4/TDR.pm
index c0749304ef3..c3282879988 100644
--- a/pidl/lib/Parse/Pidl/Samba4/TDR.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/TDR.pm
@@ -9,25 +9,20 @@ use Parse::Pidl::Util qw(has_property ParseExpr is_constant);
 use Parse::Pidl::Samba4 qw(is_intree choose_header);
 use Parse::Pidl::Typelist qw(mapTypeName);
 
-use Exporter;
-@ISA = qw(Exporter);
-@EXPORT_OK = qw(ParserType $ret $ret_hdr);
+use base Parse::Pidl::Base;
 
 use vars qw($VERSION);
 $VERSION = '0.01';
 
 use strict;
+use warnings;
 
 sub new($) {
 	my ($class) = shift;
-	my $self = { ret => "", ret_hdr => "", tabs => "" };
+	my $self = { res => "", res_hdr => "", tabs => "" };
 	bless($self, $class);
 }
 
-sub indent($) { my $self = shift; $self->{tabs}.="\t"; }
-sub deindent($) { my $self = shift; $self->{tabs} = substr($self->{tabs}, 1); }
-sub pidl($$) { my $self = shift; $self->{ret} .= $self->{tabs}.(shift)."\n"; }
-sub pidl_hdr($$) { my $self = shift; $self->{ret_hdr} .= (shift)."\n"; }
 sub typearg($) { 
 	my $t = shift; 
 	return(", const char *name") if ($t eq "print");
@@ -277,7 +272,7 @@ sub Parser($$$$)
 	$self->pidl_hdr("");
 
 	foreach (@$idl) { $self->ParserInterface($_) if ($_->{TYPE} eq "INTERFACE"); }	
-	return ($self->{ret_hdr}, $self->{ret});
+	return ($self->{res_hdr}, $self->{res});
 }
 
 1;
diff --git a/pidl/lib/Parse/Pidl/Samba4/Template.pm b/pidl/lib/Parse/Pidl/Samba4/Template.pm
index d9fb3041163..6a6755b8f57 100644
--- a/pidl/lib/Parse/Pidl/Samba4/Template.pm
+++ b/pidl/lib/Parse/Pidl/Samba4/Template.pm
@@ -11,6 +11,7 @@ $VERSION = '0.01';
 use Parse::Pidl::Util qw(genpad);
 
 use strict;
+use warnings;
 
 my($res);
 
diff --git a/pidl/lib/Parse/Pidl/Typelist.pm b/pidl/lib/Parse/Pidl/Typelist.pm
index 774554f093b..2b850ffee4b 100644
--- a/pidl/lib/Parse/Pidl/Typelist.pm
+++ b/pidl/lib/Parse/Pidl/Typelist.pm
@@ -16,6 +16,7 @@ $VERSION = '0.01';
 
 use Parse::Pidl::Util qw(has_property);
 use strict;
+use warnings;
 
 my %types = ();
 
diff --git a/pidl/lib/Parse/Pidl/Util.pm b/pidl/lib/Parse/Pidl/Util.pm
index 83e23937a87..7a6039ba12b 100644
--- a/pidl/lib/Parse/Pidl/Util.pm
+++ b/pidl/lib/Parse/Pidl/Util.pm
@@ -6,11 +6,12 @@ package Parse::Pidl::Util;
 
 require Exporter;
 @ISA = qw(Exporter);
-@EXPORT = qw(has_property property_matches ParseExpr ParseExprExt is_constant make_str unmake_str print_uuid MyDumper genpad);
+@EXPORT = qw(has_property property_matches ParseExpr ParseExprExt is_constant make_str unmake_str print_uuid MyDumper genpad parse_int parse_range);
 use vars qw($VERSION);
 $VERSION = '0.01';
 
 use strict;
+use warnings;
 
 use Parse::Pidl::Expr;
 use Parse::Pidl qw(error);
@@ -190,6 +191,41 @@ sub genpad($)
 	return "\t"x($nt)." "x($ns);
 }
 
+=item B<parse_int>
+
+Try to convert hex and octal strings to numbers. If a string doesn't
+look hexish or octish it will be left as is. If the unconverted string
+is actually a decimal number, Perl is likely to handle it correctly.
+
+=cut
+
+sub parse_int {
+	my $s = shift;
+	if ($s =~ /^0[xX][0-9A-Fa-f]+$/) {
+		return hex $s;
+	}
+	if ($s =~ /^0[0-7]+$/) {
+		return oct $s;
+	}
+	return $s;
+}
+
+=item B<parse_range>
+
+Read a range specification that might contain hex or octal numbers,
+and work out what those numbers are.
+
+=cut
+
+sub parse_range {
+	my $range = shift;
+	my ($low, $high) = split(/,/, $range, 2);
+	$low = parse_int($low);
+	$high = parse_int($high);
+	return ($low, $high);
+}
+
+
 =back
 
 =cut
diff --git a/pidl/lib/Parse/Pidl/Wireshark/Conformance.pm b/pidl/lib/Parse/Pidl/Wireshark/Conformance.pm
index 01a8c473c56..7f7ef184c18 100644
--- a/pidl/lib/Parse/Pidl/Wireshark/Conformance.pm
+++ b/pidl/lib/Parse/Pidl/Wireshark/Conformance.pm
@@ -115,6 +115,7 @@ $VERSION = '0.01';
 @EXPORT_OK = qw(ReadConformance ReadConformanceFH valid_ft_type valid_base_type);
 
 use strict;
+use warnings;
 
 use Parse::Pidl qw(fatal warning error);
 use Parse::Pidl::Util qw(has_property);
diff --git a/pidl/lib/Parse/Pidl/Wireshark/NDR.pm b/pidl/lib/Parse/Pidl/Wireshark/NDR.pm
index 49b0c2c33ba..59cbba8251a 100644
--- a/pidl/lib/Parse/Pidl/Wireshark/NDR.pm
+++ b/pidl/lib/Parse/Pidl/Wireshark/NDR.pm
@@ -21,6 +21,7 @@ use Exporter;
 @EXPORT_OK = qw(field2name %res PrintIdl StripPrefixes RegisterInterfaceHandoff register_hf_field CheckUsed ProcessImport ProcessInclude find_type DumpEttList DumpEttDeclaration DumpHfList DumpHfDeclaration DumpFunctionTable register_type register_ett);
 
 use strict;
+use warnings;
 use Parse::Pidl qw(error warning);
 use Parse::Pidl::Typelist qw(getType);
 use Parse::Pidl::Util qw(has_property property_matches make_str);
diff --git a/pidl/lib/Parse/Yapp/Driver.pm b/pidl/lib/Parse/Yapp/Driver.pm
deleted file mode 100644
index 3652be06d5b..00000000000
--- a/pidl/lib/Parse/Yapp/Driver.pm
+++ /dev/null
@@ -1,471 +0,0 @@
-#
-# Module Parse::Yapp::Driver
-#
-# This module is part of the Parse::Yapp package available on your
-# nearest CPAN
-#
-# Any use of this module in a standalone parser make the included
-# text under the same copyright as the Parse::Yapp module itself.
-#
-# This notice should remain unchanged.
-#
-# (c) Copyright 1998-2001 Francois Desarmenien, all rights reserved.
-# (see the pod text in Parse::Yapp module for use and distribution rights)
-#
-
-package Parse::Yapp::Driver;
-
-require 5.004;
-
-use strict;
-
-use vars qw ( $VERSION $COMPATIBLE $FILENAME );
-
-$VERSION = '1.05';
-$COMPATIBLE = '0.07';
-$FILENAME=__FILE__;
-
-use Carp;
-
-#Known parameters, all starting with YY (leading YY will be discarded)
-my(%params)=(YYLEX => 'CODE', 'YYERROR' => 'CODE', YYVERSION => '',
-			 YYRULES => 'ARRAY', YYSTATES => 'ARRAY', YYDEBUG => '');
-#Mandatory parameters
-my(@params)=('LEX','RULES','STATES');
-
-sub new {
-    my($class)=shift;
-	my($errst,$nberr,$token,$value,$check,$dotpos);
-    my($self)={ ERROR => \&_Error,
-				ERRST => \$errst,
-                NBERR => \$nberr,
-				TOKEN => \$token,
-				VALUE => \$value,
-				DOTPOS => \$dotpos,
-				STACK => [],
-				DEBUG => 0,
-				CHECK => \$check };
-
-	_CheckParams( [], \%params, \@_, $self );
-
-		exists($$self{VERSION})
-	and	$$self{VERSION} < $COMPATIBLE
-	and	croak "Yapp driver version $VERSION ".
-			  "incompatible with version $$self{VERSION}:\n".
-			  "Please recompile parser module.";
-
-        ref($class)
-    and $class=ref($class);
-
-    bless($self,$class);
-}
-
-sub YYParse {
-    my($self)=shift;
-    my($retval);
-
-	_CheckParams( \@params, \%params, \@_, $self );
-
-	if($$self{DEBUG}) {
-		_DBLoad();
-		$retval = eval '$self->_DBParse()';#Do not create stab entry on compile
-        $@ and die $@;
-	}
-	else {
-		$retval = $self->_Parse();
-	}
-    $retval
-}
-
-sub YYData {
-	my($self)=shift;
-
-		exists($$self{USER})
-	or	$$self{USER}={};
-
-	$$self{USER};
-	
-}
-
-sub YYErrok {
-	my($self)=shift;
-
-	${$$self{ERRST}}=0;
-    undef;
-}
-
-sub YYNberr {
-	my($self)=shift;
-
-	${$$self{NBERR}};
-}
-
-sub YYRecovering {
-	my($self)=shift;
-
-	${$$self{ERRST}} != 0;
-}
-
-sub YYAbort {
-	my($self)=shift;
-
-	${$$self{CHECK}}='ABORT';
-    undef;
-}
-
-sub YYAccept {
-	my($self)=shift;
-
-	${$$self{CHECK}}='ACCEPT';
-    undef;
-}
-
-sub YYError {
-	my($self)=shift;
-
-	${$$self{CHECK}}='ERROR';
-    undef;
-}
-
-sub YYSemval {
-	my($self)=shift;
-	my($index)= $_[0] - ${$$self{DOTPOS}} - 1;
-
-		$index < 0
-	and	-$index <= @{$$self{STACK}}
-	and	return $$self{STACK}[$index][1];
-
-	undef;	#Invalid index
-}
-
-sub YYCurtok {
-	my($self)=shift;
-
-        @_
-    and ${$$self{TOKEN}}=$_[0];
-    ${$$self{TOKEN}};
-}
-
-sub YYCurval {
-	my($self)=shift;
-
-        @_
-    and ${$$self{VALUE}}=$_[0];
-    ${$$self{VALUE}};
-}
-
-sub YYExpect {
-    my($self)=shift;
-
-    keys %{$self->{STATES}[$self->{STACK}[-1][0]]{ACTIONS}}
-}
-
-sub YYLexer {
-    my($self)=shift;
-
-	$$self{LEX};
-}
-
-
-#################
-# Private stuff #
-#################
-
-
-sub _CheckParams {
-	my($mandatory,$checklist,$inarray,$outhash)=@_;
-	my($prm,$value);
-	my($prmlst)={};
-
-	while(($prm,$value)=splice(@$inarray,0,2)) {
-        $prm=uc($prm);
-			exists($$checklist{$prm})
-		or	croak("Unknown parameter '$prm'");
-			ref($value) eq $$checklist{$prm}
-		or	croak("Invalid value for parameter '$prm'");
-        $prm=unpack('@2A*',$prm);
-		$$outhash{$prm}=$value;
-	}
-	for (@$mandatory) {
-			exists($$outhash{$_})
-		or	croak("Missing mandatory parameter '".lc($_)."'");
-	}
-}
-
-sub _Error {
-	print "Parse error.\n";
-}
-
-sub _DBLoad {
-	{
-		no strict 'refs';
-
-			exists(${__PACKAGE__.'::'}{_DBParse})#Already loaded ?
-		and	return;
-	}
-	my($fname)=__FILE__;
-	my(@drv);
-	open(DRV,"<$fname") or die "Report this as a BUG: Cannot open $fname";
-	while(<DRV>) {
-                	/^\s*sub\s+_Parse\s*{\s*$/ .. /^\s*}\s*#\s*_Parse\s*$/
-        	and     do {
-                	s/^#DBG>//;
-                	push(@drv,$_);
-        	}
-	}
-	close(DRV);
-
-	$drv[0]=~s/_P/_DBP/;
-	eval join('',@drv);
-}
-
-#Note that for loading debugging version of the driver,
-#this file will be parsed from 'sub _Parse' up to '}#_Parse' inclusive.
-#So, DO NOT remove comment at end of sub !!!
-sub _Parse {
-    my($self)=shift;
-
-	my($rules,$states,$lex,$error)
-     = @$self{ 'RULES', 'STATES', 'LEX', 'ERROR' };
-	my($errstatus,$nberror,$token,$value,$stack,$check,$dotpos)
-     = @$self{ 'ERRST', 'NBERR', 'TOKEN', 'VALUE', 'STACK', 'CHECK', 'DOTPOS' };
-
-#DBG>	my($debug)=$$self{DEBUG};
-#DBG>	my($dbgerror)=0;
-
-#DBG>	my($ShowCurToken) = sub {
-#DBG>		my($tok)='>';
-#DBG>		for (split('',$$token)) {
-#DBG>			$tok.=		(ord($_) < 32 or ord($_) > 126)
-#DBG>					?	sprintf('<%02X>',ord($_))
-#DBG>					:	$_;
-#DBG>		}
-#DBG>		$tok.='<';
-#DBG>	};
-
-	$$errstatus=0;
-	$$nberror=0;
-	($$token,$$value)=(undef,undef);
-	@$stack=( [ 0, undef ] );
-	$$check='';
-
-    while(1) {
-        my($actions,$act,$stateno);
-
-        $stateno=$$stack[-1][0];
-        $actions=$$states[$stateno];
-
-#DBG>	print STDERR ('-' x 40),"\n";
-#DBG>		$debug & 0x2
-#DBG>	and	print STDERR "In state $stateno:\n";
-#DBG>		$debug & 0x08
-#DBG>	and	print STDERR "Stack:[".
-#DBG>					 join(',',map { $$_[0] } @$stack).
-#DBG>					 "]\n";
-
-
-        if  (exists($$actions{ACTIONS})) {
-
-				defined($$token)
-            or	do {
-				($$token,$$value)=&$lex($self);
-#DBG>				$debug & 0x01
-#DBG>			and	print STDERR "Need token. Got ".&$ShowCurToken."\n";
-			};
-
-            $act=   exists($$actions{ACTIONS}{$$token})
-                    ?   $$actions{ACTIONS}{$$token}
-                    :   exists($$actions{DEFAULT})
-                        ?   $$actions{DEFAULT}
-                        :   undef;
-        }
-        else {
-            $act=$$actions{DEFAULT};
-#DBG>			$debug & 0x01
-#DBG>		and	print STDERR "Don't need token.\n";
-        }
-
-            defined($act)
-        and do {
-
-                $act > 0
-            and do {        #shift
-
-#DBG>				$debug & 0x04
-#DBG>			and	print STDERR "Shift and go to state $act.\n";
-
-					$$errstatus
-				and	do {
-					--$$errstatus;
-
-#DBG>					$debug & 0x10
-#DBG>				and	$dbgerror
-#DBG>				and	$$errstatus == 0
-#DBG>				and	do {
-#DBG>					print STDERR "**End of Error recovery.\n";
-#DBG>					$dbgerror=0;
-#DBG>				};
-				};
-
-
-                push(@$stack,[ $act, $$value ]);
-
-					$$token ne ''	#Don't eat the eof
-				and	$$token=$$value=undef;
-                next;
-            };
-
-            #reduce
-            my($lhs,$len,$code,@sempar,$semval);
-            ($lhs,$len,$code)=@{$$rules[-$act]};
-
-#DBG>			$debug & 0x04
-#DBG>		and	$act
-#DBG>		and	print STDERR "Reduce using rule ".-$act." ($lhs,$len): ";
-
-                $act
-            or  $self->YYAccept();
-
-            $$dotpos=$len;
-
-                unpack('A1',$lhs) eq '@'    #In line rule
-            and do {
-                    $lhs =~ /^\@[0-9]+\-([0-9]+)$/
-                or  die "In line rule name '$lhs' ill formed: ".
-                        "report it as a BUG.\n";
-                $$dotpos = $1;
-            };
-
-            @sempar =       $$dotpos
-                        ?   map { $$_[1] } @$stack[ -$$dotpos .. -1 ]
-                        :   ();
-
-            $semval = $code ? &$code( $self, @sempar )
-                            : @sempar ? $sempar[0] : undef;
-
-            splice(@$stack,-$len,$len);
-
-                $$check eq 'ACCEPT'
-            and do {
-
-#DBG>			$debug & 0x04
-#DBG>		and	print STDERR "Accept.\n";
-
-				return($semval);
-			};
-
-                $$check eq 'ABORT'
-            and	do {
-
-#DBG>			$debug & 0x04
-#DBG>		and	print STDERR "Abort.\n";
-
-				return(undef);
-
-			};
-
-#DBG>			$debug & 0x04
-#DBG>		and	print STDERR "Back to state $$stack[-1][0], then ";
-
-                $$check eq 'ERROR'
-            or  do {
-#DBG>				$debug & 0x04
-#DBG>			and	print STDERR 
-#DBG>				    "go to state $$states[$$stack[-1][0]]{GOTOS}{$lhs}.\n";
-
-#DBG>				$debug & 0x10
-#DBG>			and	$dbgerror
-#DBG>			and	$$errstatus == 0
-#DBG>			and	do {
-#DBG>				print STDERR "**End of Error recovery.\n";
-#DBG>				$dbgerror=0;
-#DBG>			};
-
-			    push(@$stack,
-                     [ $$states[$$stack[-1][0]]{GOTOS}{$lhs}, $semval ]);
-                $$check='';
-                next;
-            };
-
-#DBG>			$debug & 0x04
-#DBG>		and	print STDERR "Forced Error recovery.\n";
-
-            $$check='';
-
-        };
-
-        #Error
-            $$errstatus
-        or   do {
-
-            $$errstatus = 1;
-            &$error($self);
-                $$errstatus # if 0, then YYErrok has been called
-            or  next;       # so continue parsing
-
-#DBG>			$debug & 0x10
-#DBG>		and	do {
-#DBG>			print STDERR "**Entering Error recovery.\n";
-#DBG>			++$dbgerror;
-#DBG>		};
-
-            ++$$nberror;
-
-        };
-
-			$$errstatus == 3	#The next token is not valid: discard it
-		and	do {
-				$$token eq ''	# End of input: no hope
-			and	do {
-#DBG>				$debug & 0x10
-#DBG>			and	print STDERR "**At eof: aborting.\n";
-				return(undef);
-			};
-
-#DBG>			$debug & 0x10
-#DBG>		and	print STDERR "**Dicard invalid token ".&$ShowCurToken.".\n";
-
-			$$token=$$value=undef;
-		};
-
-        $$errstatus=3;
-
-		while(	  @$stack
-			  and (		not exists($$states[$$stack[-1][0]]{ACTIONS})
-			        or  not exists($$states[$$stack[-1][0]]{ACTIONS}{error})
-					or	$$states[$$stack[-1][0]]{ACTIONS}{error} <= 0)) {
-
-#DBG>			$debug & 0x10
-#DBG>		and	print STDERR "**Pop state $$stack[-1][0].\n";
-
-			pop(@$stack);
-		}
-
-			@$stack
-		or	do {
-
-#DBG>			$debug & 0x10
-#DBG>		and	print STDERR "**No state left on stack: aborting.\n";
-
-			return(undef);
-		};
-
-		#shift the error token
-
-#DBG>			$debug & 0x10
-#DBG>		and	print STDERR "**Shift \$error token and go to state ".
-#DBG>						 $$states[$$stack[-1][0]]{ACTIONS}{error}.
-#DBG>						 ".\n";
-
-		push(@$stack, [ $$states[$$stack[-1][0]]{ACTIONS}{error}, undef ]);
-
-    }
-
-    #never reached
-	croak("Error in driver logic. Please, report it as a BUG");
-
-}#_Parse
-#DO NOT remove comment
-
-1;
-
diff --git a/pidl/pidl b/pidl/pidl
index 06b0f78a485..3f48ef8e0f4 100755
--- a/pidl/pidl
+++ b/pidl/pidl
@@ -402,6 +402,7 @@ pidl README by Andrew Tridgell.
 
 
 use strict;
+use warnings;
 use FindBin qw($RealBin $Script);
 use lib "$RealBin/lib";
 use Getopt::Long;
diff --git a/pidl/tests/Util.pm b/pidl/tests/Util.pm
index 86b521bf94a..a7b5a63f1fb 100644
--- a/pidl/tests/Util.pm
+++ b/pidl/tests/Util.pm
@@ -9,6 +9,7 @@ require Exporter;
 @EXPORT = qw(test_samba4_ndr test_warnings test_errors);
 
 use strict;
+use warnings;
 
 use FindBin qw($RealBin);
 use lib "$RealBin/../lib";
diff --git a/pidl/tests/ndr_align.pl b/pidl/tests/ndr_align.pl
index 1f4a0da9bbb..80d61158e37 100755
--- a/pidl/tests/ndr_align.pl
+++ b/pidl/tests/ndr_align.pl
@@ -2,6 +2,7 @@
 # NDR alignment tests
 # (C) 2005 Jelmer Vernooij. Published under the GNU GPL
 use strict;
+use warnings;
 
 use Test::More tests => 5 * 8;
 use FindBin qw($RealBin);
diff --git a/pidl/tests/ndr_alloc.pl b/pidl/tests/ndr_alloc.pl
index 399fbd21d62..c708c3b5393 100755
--- a/pidl/tests/ndr_alloc.pl
+++ b/pidl/tests/ndr_alloc.pl
@@ -2,6 +2,7 @@
 # NDR allocation tests
 # (C) 2005 Jelmer Vernooij. Published under the GNU GPL
 use strict;
+use warnings;
 
 use Test::More tests => 5 * 8;
 use FindBin qw($RealBin);
diff --git a/pidl/tests/ndr_array.pl b/pidl/tests/ndr_array.pl
index 2a6b5bbd57d..46ab83ec14c 100755
--- a/pidl/tests/ndr_array.pl
+++ b/pidl/tests/ndr_array.pl
@@ -3,6 +3,7 @@
 # (C) 2005 Jelmer Vernooij <jelmer@samba.org>
 # Published under the GNU General Public License
 use strict;
+use warnings;
 
 use Test::More tests => 8;
 use FindBin qw($RealBin);
diff --git a/pidl/tests/ndr_compat.pl b/pidl/tests/ndr_compat.pl
index 355e7f67323..06f7efb4000 100755
--- a/pidl/tests/ndr_compat.pl
+++ b/pidl/tests/ndr_compat.pl
@@ -2,6 +2,7 @@
 # (C) 2007 Jelmer Vernooij <jelmer@samba.org>
 # Published under the GNU General Public License
 use strict;
+use warnings;
 
 use Test::More tests => 2;
 use FindBin qw($RealBin);
diff --git a/pidl/tests/ndr_fullptr.pl b/pidl/tests/ndr_fullptr.pl
index 4ba11b740c6..109b368ea22 100755
--- a/pidl/tests/ndr_fullptr.pl
+++ b/pidl/tests/ndr_fullptr.pl
@@ -3,6 +3,7 @@
 # (C) 2006 Jelmer Vernooij <jelmer@samba.org>.
 # Published under the GNU General Public License.
 use strict;
+use warnings;
 
 use Test::More tests => 1 * 8;
 use FindBin qw($RealBin);
diff --git a/pidl/tests/ndr_refptr.pl b/pidl/tests/ndr_refptr.pl
index f972611ed81..94676a80524 100755
--- a/pidl/tests/ndr_refptr.pl
+++ b/pidl/tests/ndr_refptr.pl
@@ -4,6 +4,7 @@
 # (C) 2005 Jelmer Vernooij <jelmer@samba.org>.
 # Published under the GNU General Public License.
 use strict;
+use warnings;
 
 use Test::More tests => 22 * 8;
 use FindBin qw($RealBin);
diff --git a/pidl/tests/ndr_represent.pl b/pidl/tests/ndr_represent.pl
index 2d65fb92b09..af9a92b6a23 100755
--- a/pidl/tests/ndr_represent.pl
+++ b/pidl/tests/ndr_represent.pl
@@ -2,6 +2,7 @@
 # NDR represent_as() / transmit_as() tests
 # (C) 2006 Jelmer Vernooij. Published under the GNU GPL
 use strict;
+use warnings;
 
 use Test::More tests => 2 * 8;
 use FindBin qw($RealBin);
diff --git a/pidl/tests/ndr_simple.pl b/pidl/tests/ndr_simple.pl
index 15e07d56934..c5c32445cfd 100755
--- a/pidl/tests/ndr_simple.pl
+++ b/pidl/tests/ndr_simple.pl
@@ -3,6 +3,7 @@
 # (C) 2005 Jelmer Vernooij <jelmer@samba.org>
 # Published under the GNU General Public License
 use strict;
+use warnings;
 
 use Test::More tests => 8;
 use FindBin qw($RealBin);
diff --git a/pidl/tests/ndr_string.pl b/pidl/tests/ndr_string.pl
index 8e8b8ecbad6..aa5fd8b5d1d 100755
--- a/pidl/tests/ndr_string.pl
+++ b/pidl/tests/ndr_string.pl
@@ -3,6 +3,7 @@
 # (C) 2005 Jelmer Vernooij <jelmer@samba.org>
 # Published under the GNU General Public License
 use strict;
+use warnings;
 
 use Test::More tests => 6 * 8;
 use FindBin qw($RealBin);
diff --git a/pidl/tests/ndr_tagtype.pl b/pidl/tests/ndr_tagtype.pl
index 4d6bcb53afc..fa09cf773c1 100755
--- a/pidl/tests/ndr_tagtype.pl
+++ b/pidl/tests/ndr_tagtype.pl
@@ -2,7 +2,7 @@
 # Support for tagged types
 # (C) 2005 Jelmer Vernooij. Published under the GNU GPL
 use strict;
-
+use warnings;
 use Test::More tests => 3 * 8;
 use FindBin qw($RealBin);
 use lib "$RealBin";
diff --git a/pidl/tests/parse_idl.pl b/pidl/tests/parse_idl.pl
index 14138a37b89..caf701b3b77 100755
--- a/pidl/tests/parse_idl.pl
+++ b/pidl/tests/parse_idl.pl
@@ -3,7 +3,7 @@
 # (C) 2005 Jelmer Vernooij <jelmer@samba.org>
 # Published under the GNU General Public License
 use strict;
-
+use warnings;
 use Test::More tests => 65 * 2 + 7;
 use FindBin qw($RealBin);
 use lib "$RealBin";
diff --git a/pidl/tests/samba-ndr.pl b/pidl/tests/samba-ndr.pl
index 7c53cbc76f0..54a4e46d65f 100755
--- a/pidl/tests/samba-ndr.pl
+++ b/pidl/tests/samba-ndr.pl
@@ -8,7 +8,6 @@ use Test::More tests => 31;
 use FindBin qw($RealBin);
 use lib "$RealBin";
 use Util;
-use strict;
 use Parse::Pidl::Util qw(MyDumper);
 use Parse::Pidl::Samba4::NDR::Parser qw(check_null_pointer 
 	NeededFunction NeededElement NeededType
diff --git a/pidl/tests/samba3-cli.pl b/pidl/tests/samba3-cli.pl
index c758ef45425..4349abb39d6 100755
--- a/pidl/tests/samba3-cli.pl
+++ b/pidl/tests/samba3-cli.pl
@@ -9,7 +9,7 @@ use FindBin qw($RealBin);
 use lib "$RealBin";
 use Util;
 use Parse::Pidl::Util qw(MyDumper);
-use Parse::Pidl::Samba3::ClientNDR qw(ParseFunction);
+use Parse::Pidl::Samba3::ClientNDR;
 use Parse::Pidl::Samba4::Header qw(GenerateFunctionInEnv GenerateFunctionOutEnv);
 
 # Make sure GenerateFunctionInEnv and GenerateFunctionOutEnv work
diff --git a/pidl/tests/tdr.pl b/pidl/tests/tdr.pl
index d6cd7a03d4c..41a560c842b 100755
--- a/pidl/tests/tdr.pl
+++ b/pidl/tests/tdr.pl
@@ -13,18 +13,18 @@ use Parse::Pidl::Samba4::TDR qw(ParserType);
 my $tdr = new Parse::Pidl::Samba4::TDR();
 
 $tdr->ParserType({TYPE => "STRUCT", NAME => "foo", PROPERTIES => {public => 1}}, "pull");
-is($tdr->{ret}, "NTSTATUS tdr_pull_foo (struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, struct foo *v)
+is($tdr->{res}, "NTSTATUS tdr_pull_foo (struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, struct foo *v)
 {
 	return NT_STATUS_OK;
 }
 
 ");
-is($tdr->{ret_hdr}, "NTSTATUS tdr_pull_foo (struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, struct foo *v);\n");
+is($tdr->{res_hdr}, "NTSTATUS tdr_pull_foo (struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, struct foo *v);\n");
 
 
 $tdr = new Parse::Pidl::Samba4::TDR();
 $tdr->ParserType({TYPE => "UNION", NAME => "bar", PROPERTIES => {public => 1}}, "pull");
-is($tdr->{ret}, "NTSTATUS tdr_pull_bar(struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, int level, union bar *v)
+is($tdr->{res}, "NTSTATUS tdr_pull_bar(struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, int level, union bar *v)
 {
 	switch (level) {
 	}
@@ -33,11 +33,11 @@ is($tdr->{ret}, "NTSTATUS tdr_pull_bar(struct tdr_pull *tdr, TALLOC_CTX *mem_ctx
 }
 
 ");
-is($tdr->{ret_hdr}, "NTSTATUS tdr_pull_bar(struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, int level, union bar *v);\n");
+is($tdr->{res_hdr}, "NTSTATUS tdr_pull_bar(struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, int level, union bar *v);\n");
 
 $tdr = new Parse::Pidl::Samba4::TDR();
 $tdr->ParserType({TYPE => "UNION", NAME => "bar", PROPERTIES => {}}, "pull");
-is($tdr->{ret}, "static NTSTATUS tdr_pull_bar(struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, int level, union bar *v)
+is($tdr->{res}, "static NTSTATUS tdr_pull_bar(struct tdr_pull *tdr, TALLOC_CTX *mem_ctx, int level, union bar *v)
 {
 	switch (level) {
 	}
@@ -46,4 +46,4 @@ is($tdr->{ret}, "static NTSTATUS tdr_pull_bar(struct tdr_pull *tdr, TALLOC_CTX *
 }
 
 "); 
-is($tdr->{ret_hdr}, "");
+is($tdr->{res_hdr}, "");
diff --git a/pidl/tests/test_util.pl b/pidl/tests/test_util.pl
index 2d59f6283bb..93addceaed4 100755
--- a/pidl/tests/test_util.pl
+++ b/pidl/tests/test_util.pl
@@ -2,6 +2,7 @@
 # (C) 2007 Jelmer Vernooij <jelmer@samba.org>
 # Published under the GNU General Public License
 use strict;
+use warnings;
 
 use Test::More tests => 6;
 use FindBin qw($RealBin);
diff --git a/pidl/wscript b/pidl/wscript
index d1b8278990a..50fe12c013d 100644
--- a/pidl/wscript
+++ b/pidl/wscript
@@ -2,27 +2,20 @@
 
 import os, string
 from samba_utils import MODE_755
-from waflib import Logs
+from waflib import Logs, Errors
 
 # This function checks if a perl module is installed on the system.
 def check_system_perl_module(conf, module, version=None):
-    bundle_name = module.replace('::', '_')
     module_check = module
 
     # Create module string with version
     if version:
         module_check = module + ' ' + str(version)
 
-    # Check if we have to bundle it.
-    if conf.LIB_MUST_BE_BUNDLED(bundle_name.lower()):
-        return False
-
     # Check for system perl module
     if conf.check_perl_module(module_check) is None:
         return False
 
-    conf.define('USING_SYSTEM_%s' % bundle_name.upper(), 1)
-
     return True
 
 def options(opt):
@@ -30,10 +23,14 @@ def options(opt):
 
 def configure(conf):
     # Check if perl(Parse::Yapp::Driver) is available.
-    check_system_perl_module(conf, "Parse::Yapp::Driver", 1.05)
+    if not check_system_perl_module(conf,
+                                    "Parse::Yapp::Driver",
+                                    1.05):
+        raise Errors.WafError('perl module "Parse::Yapp::Driver" not found')
 
     # yapp is used for building the parser
-    conf.find_program('yapp', var='YAPP')
+    if not conf.find_program('yapp', var='YAPP'):
+        raise Errors.WafError('yapp not found')
 
 def build(bld):
 
diff --git a/python/samba/auth_util.py b/python/samba/auth_util.py
new file mode 100644
index 00000000000..570c638fbeb
--- /dev/null
+++ b/python/samba/auth_util.py
@@ -0,0 +1,34 @@
+# Unix SMB/CIFS implementation.
+# auth util helpers
+#
+# Copyright (C) Ralph Boehme <slow@sambba.org> 2019
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+from samba.auth import (
+    system_session,
+    session_info_fill_unix,
+    copy_session_info,
+)
+
+def system_session_unix():
+    """
+    Return a copy of the system session_info with a valid UNIX token
+    """
+
+    session_info = system_session()
+    session_info_unix = copy_session_info(session_info)
+    session_info_fill_unix(session_info_unix, None)
+
+    return session_info_unix
diff --git a/python/samba/kcc/__init__.py b/python/samba/kcc/__init__.py
index 6c6c202fa2c..734c7641883 100644
--- a/python/samba/kcc/__init__.py
+++ b/python/samba/kcc/__init__.py
@@ -499,6 +499,11 @@ class KCC(object):
                 local_connections.append((cn_conn, s_dnstr,
                                           packed_guid, removable))
 
+        # Avoid "ValueError: r cannot be bigger than the iterable" in
+        # for a, b in itertools.permutations(local_connections, 2):
+        if (len(local_connections) < 2):
+            return
+
         for a, b in itertools.permutations(local_connections, 2):
             cn_conn, s_dnstr, packed_guid, removable = a
             cn_conn2, s_dnstr2, packed_guid2, removable2 = b
diff --git a/python/samba/netcmd/computer.py b/python/samba/netcmd/computer.py
index b66dcc4a7a5..d48a3e732fd 100644
--- a/python/samba/netcmd/computer.py
+++ b/python/samba/netcmd/computer.py
@@ -36,6 +36,7 @@ from samba.auth import system_session
 from samba.samdb import SamDB
 from samba.compat import get_bytes
 from subprocess import check_call, CalledProcessError
+from . import common
 
 from samba import (
     credentials,
@@ -457,8 +458,6 @@ class cmd_computer_edit(Command):
 
     def run(self, computername, credopts=None, sambaopts=None, versionopts=None,
             H=None, editor=None):
-        from . import common
-
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
         samdb = SamDB(url=H, session_info=system_session(),
@@ -528,6 +527,13 @@ class cmd_computer_list(Command):
     takes_options = [
         Option("-H", "--URL", help="LDB URL for database or target server",
                type=str, metavar="URL", dest="H"),
+        Option("-b", "--base-dn",
+               help="Specify base DN to use",
+               type=str),
+        Option("--full-dn", dest="full_dn",
+               default=False,
+               action="store_true",
+               help="Display DN instead of the sAMAccountName.")
     ]
 
     takes_optiongroups = {
@@ -536,7 +542,13 @@ class cmd_computer_list(Command):
         "versionopts": options.VersionOptions,
     }
 
-    def run(self, sambaopts=None, credopts=None, versionopts=None, H=None):
+    def run(self,
+            sambaopts=None,
+            credopts=None,
+            versionopts=None,
+            H=None,
+            base_dn=None,
+            full_dn=False):
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
 
@@ -545,14 +557,22 @@ class cmd_computer_list(Command):
 
         filter = "(sAMAccountType=%u)" % (dsdb.ATYPE_WORKSTATION_TRUST)
 
-        domain_dn = samdb.domain_dn()
-        res = samdb.search(domain_dn, scope=ldb.SCOPE_SUBTREE,
+        search_dn = samdb.domain_dn()
+        if base_dn:
+            search_dn = samdb.normalize_dn_in_domain(base_dn)
+
+        res = samdb.search(search_dn,
+                           scope=ldb.SCOPE_SUBTREE,
                            expression=filter,
                            attrs=["samaccountname"])
         if (len(res) == 0):
             return
 
         for msg in res:
+            if full_dn:
+                self.outf.write("%s\n" % msg.get("dn"))
+                continue
+
             self.outf.write("%s\n" % msg.get("samaccountname", idx=0))
 
 
@@ -639,7 +659,7 @@ attribute.
                                samaccountname)
 
         for msg in res:
-            computer_ldif = samdb.write_ldif(msg, ldb.CHANGETYPE_NONE)
+            computer_ldif = common.get_ldif_for_editor(samdb, msg)
             self.outf.write(computer_ldif)
 
 
diff --git a/python/samba/netcmd/contact.py b/python/samba/netcmd/contact.py
index 506e644c3f8..73b7d141af6 100644
--- a/python/samba/netcmd/contact.py
+++ b/python/samba/netcmd/contact.py
@@ -37,6 +37,7 @@ from samba.netcmd import (
     Option,
 )
 from samba.compat import get_bytes
+from . import common
 
 
 class cmd_create(Command):
@@ -253,6 +254,9 @@ class cmd_list(Command):
                type=str,
                metavar="URL",
                dest="H"),
+        Option("-b", "--base-dn",
+               help="Specify base DN to use.",
+               type=str),
         Option("--full-dn",
                dest="full_dn",
                default=False,
@@ -271,6 +275,7 @@ class cmd_list(Command):
             credopts=None,
             versionopts=None,
             H=None,
+            base_dn=None,
             full_dn=False):
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
@@ -280,8 +285,11 @@ class cmd_list(Command):
                       credentials=creds,
                       lp=lp)
 
-        domain_dn = samdb.domain_dn()
-        res = samdb.search(domain_dn,
+        search_dn = samdb.domain_dn()
+        if base_dn:
+            search_dn = samdb.normalize_dn_in_domain(base_dn)
+
+        res = samdb.search(search_dn,
                            scope=ldb.SCOPE_SUBTREE,
                            expression="(objectClass=contact)",
                            attrs=["name"])
@@ -365,8 +373,6 @@ class cmd_edit(Command):
             versionopts=None,
             H=None,
             editor=None):
-        from . import common
-
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
         samdb = SamDB(url=H, session_info=system_session(),
@@ -548,7 +554,7 @@ class cmd_show(Command):
                                contactname)
 
         for msg in res:
-            contact_ldif = samdb.write_ldif(msg, ldb.CHANGETYPE_NONE)
+            contact_ldif = common.get_ldif_for_editor(samdb, msg)
             self.outf.write(contact_ldif)
 
 
diff --git a/python/samba/netcmd/dns.py b/python/samba/netcmd/dns.py
index d9fda0b93cd..6cf8d40b2aa 100644
--- a/python/samba/netcmd/dns.py
+++ b/python/samba/netcmd/dns.py
@@ -417,14 +417,14 @@ def data_to_dns_record(record_type, data):
     elif record_type == dnsp.DNS_TYPE_NS:
         rec = NSRecord(data)
     elif record_type == dnsp.DNS_TYPE_MX:
-        tmp = data.split(' ')
+        tmp = data.split()
         if len(tmp) != 2:
             raise CommandError('Data requires 2 elements - mail_server, preference')
         mail_server = tmp[0]
         preference = int(tmp[1])
         rec = MXRecord(mail_server, preference)
     elif record_type == dnsp.DNS_TYPE_SRV:
-        tmp = data.split(' ')
+        tmp = data.split()
         if len(tmp) != 4:
             raise CommandError('Data requires 4 elements - server, port, priority, weight')
         server = tmp[0]
@@ -433,7 +433,7 @@ def data_to_dns_record(record_type, data):
         weight = int(tmp[3])
         rec = SRVRecord(server, port, priority=priority, weight=weight)
     elif record_type == dnsp.DNS_TYPE_SOA:
-        tmp = data.split(' ')
+        tmp = data.split()
         if len(tmp) != 7:
             raise CommandError('Data requires 7 elements - nameserver, email, serial, '
                                'refresh, retry, expire, minimumttl')
diff --git a/python/samba/netcmd/domain.py b/python/samba/netcmd/domain.py
index 80811154d4d..bea6482f99e 100644
--- a/python/samba/netcmd/domain.py
+++ b/python/samba/netcmd/domain.py
@@ -66,6 +66,7 @@ from samba.samba3 import param as s3param
 from samba.upgrade import upgrade_from_samba3
 from samba.drs_utils import drsuapi_connect
 from samba import remove_dc, arcfour_encrypt, string_to_byte_array
+from samba.auth_util import system_session_unix
 
 from samba.dsdb import (
     DS_DOMAIN_FUNCTION_2000,
@@ -463,7 +464,10 @@ class cmd_domain_provision(Command):
             try:
                 try:
                     samba.ntacls.setntacl(lp, file.name,
-                                          "O:S-1-5-32G:S-1-5-32", "S-1-5-32", "native")
+                                          "O:S-1-5-32G:S-1-5-32",
+                                          "S-1-5-32",
+                                          system_session_unix(),
+                                          "native")
                     eadb = False
                 except Exception:
                     self.logger.info("You are not root or your system does not support xattr, using tdb backend for attributes. ")
@@ -1607,7 +1611,10 @@ class cmd_domain_classicupgrade(Command):
             try:
                 try:
                     samba.ntacls.setntacl(lp, tmpfile.name,
-                                          "O:S-1-5-32G:S-1-5-32", "S-1-5-32", "native")
+                                          "O:S-1-5-32G:S-1-5-32",
+                                          "S-1-5-32",
+                                          system_session_unix(),
+                                          "native")
                     eadb = False
                 except Exception:
                     # FIXME: Don't catch all exceptions here
diff --git a/python/samba/netcmd/gpo.py b/python/samba/netcmd/gpo.py
index e9878c13570..76ba9fa18a9 100644
--- a/python/samba/netcmd/gpo.py
+++ b/python/samba/netcmd/gpo.py
@@ -235,15 +235,16 @@ def del_gpo_link(samdb, container_dn, gpo):
 
 def parse_unc(unc):
     '''Parse UNC string into a hostname, a service, and a filepath'''
-    if unc.startswith('\\\\') and unc.startswith('//'):
-        raise ValueError("UNC doesn't start with \\\\ or //")
-    tmp = unc[2:].split('/', 2)
-    if len(tmp) == 3:
-        return tmp
-    tmp = unc[2:].split('\\', 2)
-    if len(tmp) == 3:
-        return tmp
-    raise ValueError("Invalid UNC string: %s" % unc)
+    tmp = []
+    if unc.startswith('\\\\'):
+        tmp = unc[2:].split('\\', 2)
+    elif unc.startswith('//'):
+        tmp = unc[2:].split('/', 2)
+
+    if len(tmp) != 3:
+        raise ValueError("Invalid UNC string: %s" % unc)
+
+    return tmp
 
 
 def find_parser(name, flags=re.IGNORECASE):
diff --git a/python/samba/netcmd/group.py b/python/samba/netcmd/group.py
index 4798b773ddf..6e5ed1def28 100644
--- a/python/samba/netcmd/group.py
+++ b/python/samba/netcmd/group.py
@@ -39,6 +39,7 @@ from subprocess import check_call, CalledProcessError
 from samba.compat import get_bytes
 import os
 import tempfile
+from . import common
 
 security_group = dict({"Builtin": GTYPE_SECURITY_BUILTIN_LOCAL_GROUP,
                        "Domain": GTYPE_SECURITY_DOMAIN_LOCAL_GROUP,
@@ -217,7 +218,7 @@ sudo samba-tool group addmembers supergroup User2
 Example2 shows how to add a single user account, User2, to the supergroup AD group.  It uses the sudo command to run as root when issuing the command.
 """
 
-    synopsis = "%prog <groupname> <listofmembers> [options]"
+    synopsis = "%prog <groupname> (<listofmembers>]|--member-dn=<member-dn>) [options]"
 
     takes_optiongroups = {
         "sambaopts": options.SambaOptions,
@@ -228,26 +229,68 @@ Example2 shows how to add a single user account, User2, to the supergroup AD gro
     takes_options = [
         Option("-H", "--URL", help="LDB URL for database or target server", type=str,
                metavar="URL", dest="H"),
+        Option("--member-dn",
+               help=("DN of the new group member to be added.\n"
+                     "The --object-types option will be ignored."),
+               type=str,
+               action="append"),
+        Option("--object-types",
+               help=("Comma separated list of object types.\n"
+                     "The types are used to filter the search for the "
+                     "specified members.\n"
+                     "Valid values are: user, group, computer, serviceaccount, "
+                     "contact and all.\n"
+                     "Default: user,group,computer"),
+               default="user,group,computer",
+               type=str),
+        Option("--member-base-dn",
+               help=("Base DN for group member search.\n"
+                     "Default is the domain DN."),
+               type=str),
     ]
 
-    takes_args = ["groupname", "listofmembers"]
+    takes_args = ["groupname", "listofmembers?"]
 
-    def run(self, groupname, listofmembers, credopts=None, sambaopts=None,
-            versionopts=None, H=None):
+    def run(self,
+            groupname,
+            listofmembers=None,
+            credopts=None,
+            sambaopts=None,
+            versionopts=None,
+            H=None,
+            member_base_dn=None,
+            member_dn=None,
+            object_types="user,group,computer"):
 
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
 
+        if member_dn is None and listofmembers is None:
+            self.usage()
+            raise CommandError(
+                'Either listofmembers or --member-dn must be specified.')
+
         try:
             samdb = SamDB(url=H, session_info=system_session(),
                           credentials=creds, lp=lp)
-            groupmembers = listofmembers.split(',')
+            groupmembers = []
+            if member_dn is not None:
+                groupmembers += member_dn
+            if listofmembers is not None:
+                groupmembers += listofmembers.split(',')
+            group_member_types = object_types.split(',')
+
+            if member_base_dn is not None:
+                member_base_dn = samdb.normalize_dn_in_domain(member_base_dn)
+
             samdb.add_remove_group_members(groupname, groupmembers,
-                                           add_members_operation=True)
+                                           add_members_operation=True,
+                                           member_types=group_member_types,
+                                           member_base_dn=member_base_dn)
         except Exception as e:
             # FIXME: catch more specific exception
-            raise CommandError('Failed to add members "%s" to group "%s"' % (
-                listofmembers, groupname), e)
+            raise CommandError('Failed to add members %r to group "%s" - %s' % (
+                groupmembers, groupname, e))
         self.outf.write("Added members to group %s\n" % groupname)
 
 
@@ -269,7 +312,7 @@ sudo samba-tool group removemembers supergroup User1
 Example2 shows how to remove a single user account, User2, from the supergroup AD group.  It uses the sudo command to run as root when issuing the command.
 """
 
-    synopsis = "%prog <groupname> <listofmembers> [options]"
+    synopsis = "%prog <groupname> (<listofmembers>]|--member-dn=<member-dn>) [options]"
 
     takes_optiongroups = {
         "sambaopts": options.SambaOptions,
@@ -280,24 +323,68 @@ Example2 shows how to remove a single user account, User2, from the supergroup A
     takes_options = [
         Option("-H", "--URL", help="LDB URL for database or target server", type=str,
                metavar="URL", dest="H"),
+        Option("--member-dn",
+               help=("DN of the group member to be removed.\n"
+                     "The --object-types option will be ignored."),
+               type=str,
+               action="append"),
+        Option("--object-types",
+               help=("Comma separated list of object types.\n"
+                     "The types are used to filter the search for the "
+                     "specified members.\n"
+                     "Valid values are: user, group, computer, serviceaccount, "
+                     "contact and all.\n"
+                     "Default: user,group,computer"),
+               default="user,group,computer",
+               type=str),
+        Option("--member-base-dn",
+               help=("Base DN for group member search.\n"
+                     "Default is the domain DN."),
+               type=str),
     ]
 
-    takes_args = ["groupname", "listofmembers"]
+    takes_args = ["groupname", "listofmembers?"]
 
-    def run(self, groupname, listofmembers, credopts=None, sambaopts=None,
-            versionopts=None, H=None):
+    def run(self,
+            groupname,
+            listofmembers=None,
+            credopts=None,
+            sambaopts=None,
+            versionopts=None,
+            H=None,
+            member_base_dn=None,
+            member_dn=None,
+            object_types="user,group,computer"):
 
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
 
+        if member_dn is None and listofmembers is None:
+            self.usage()
+            raise CommandError(
+                'Either listofmembers or --member-dn must be specified.')
+
         try:
             samdb = SamDB(url=H, session_info=system_session(),
                           credentials=creds, lp=lp)
-            samdb.add_remove_group_members(groupname, listofmembers.split(","),
-                                           add_members_operation=False)
+            groupmembers = []
+            if member_dn is not None:
+                groupmembers += member_dn
+            if listofmembers is not None:
+                groupmembers += listofmembers.split(',')
+            group_member_types = object_types.split(',')
+
+            if member_base_dn is not None:
+                member_base_dn = samdb.normalize_dn_in_domain(member_base_dn)
+
+            samdb.add_remove_group_members(groupname,
+                                           groupmembers,
+                                           add_members_operation=False,
+                                           member_types=group_member_types,
+                                           member_base_dn=member_base_dn)
         except Exception as e:
             # FIXME: Catch more specific exception
-            raise CommandError('Failed to remove members "%s" from group "%s"' % (listofmembers, groupname), e)
+            raise CommandError('Failed to remove members %r from group "%s"' % (listofmembers, groupname), e)
         self.outf.write("Removed members from group %s\n" % groupname)
 
 
@@ -312,7 +399,13 @@ class cmd_group_list(Command):
         Option("-v", "--verbose",
                help="Verbose output, showing group type and group scope.",
                action="store_true"),
-
+        Option("-b", "--base-dn",
+               help="Specify base DN to use.",
+               type=str),
+        Option("--full-dn", dest="full_dn",
+               default=False,
+               action='store_true',
+               help="Display DN instead of the sAMAccountName."),
     ]
 
     takes_optiongroups = {
@@ -321,8 +414,14 @@ class cmd_group_list(Command):
         "versionopts": options.VersionOptions,
     }
 
-    def run(self, sambaopts=None, credopts=None, versionopts=None, H=None,
-            verbose=False):
+    def run(self,
+            sambaopts=None,
+            credopts=None,
+            versionopts=None,
+            H=None,
+            verbose=False,
+            base_dn=None,
+            full_dn=False):
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
 
@@ -333,6 +432,8 @@ class cmd_group_list(Command):
         if verbose:
             attrs += ["grouptype", "member"]
         domain_dn = samdb.domain_dn()
+        if base_dn:
+            domain_dn = samdb.normalize_dn_in_domain(base_dn)
         res = samdb.search(domain_dn, scope=ldb.SCOPE_SUBTREE,
                            expression=("(objectClass=group)"),
                            attrs=attrs)
@@ -366,6 +467,10 @@ class cmd_group_list(Command):
                 self.outf.write("    %6u\n" % num_members)
         else:
             for msg in res:
+                if full_dn:
+                    self.outf.write("%s\n" % msg.get("dn"))
+                    continue
+
                 self.outf.write("%s\n" % msg.get("samaccountname", idx=0))
 
 
@@ -383,6 +488,10 @@ samba-tool group listmembers \"Domain Users\" -H ldap://samba.samdom.example.com
     takes_options = [
         Option("-H", "--URL", help="LDB URL for database or target server", type=str,
                metavar="URL", dest="H"),
+        Option("--full-dn", dest="full_dn",
+               default=False,
+               action='store_true',
+               help="Display DN instead of the sAMAccountName.")
     ]
 
     takes_optiongroups = {
@@ -393,7 +502,13 @@ samba-tool group listmembers \"Domain Users\" -H ldap://samba.samdom.example.com
 
     takes_args = ["groupname"]
 
-    def run(self, groupname, credopts=None, sambaopts=None, versionopts=None, H=None):
+    def run(self,
+            groupname,
+            credopts=None,
+            sambaopts=None,
+            versionopts=None,
+            H=None,
+            full_dn=False):
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
 
@@ -424,6 +539,10 @@ samba-tool group listmembers \"Domain Users\" -H ldap://samba.samdom.example.com
                 return
 
             for msg in res:
+                if full_dn:
+                    self.outf.write("%s\n" % msg.get("dn"))
+                    continue
+
                 member_name = msg.get("samAccountName", idx=0)
                 if member_name is None:
                     member_name = msg.get("cn", idx=0)
@@ -543,7 +662,7 @@ LDAP server.
 Example3:
 samba-tool group show Group3 --attributes=member,objectGUID
 
-Example3 shows how to display a users objectGUID and member attributes.
+Example3 shows how to display a groups objectGUID and member attributes.
 """
     synopsis = "%prog <group name> [options]"
 
@@ -589,8 +708,8 @@ Example3 shows how to display a users objectGUID and member attributes.
             raise CommandError('Unable to find group "%s"' % (groupname))
 
         for msg in res:
-            user_ldif = samdb.write_ldif(msg, ldb.CHANGETYPE_NONE)
-            self.outf.write(user_ldif)
+            group_ldif = common.get_ldif_for_editor(samdb, msg)
+            self.outf.write(group_ldif)
 
 
 class cmd_group_stats(Command):
@@ -747,8 +866,6 @@ class cmd_group_edit(Command):
 
     def run(self, groupname, credopts=None, sambaopts=None, versionopts=None,
             H=None, editor=None):
-        from . import common
-
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
         samdb = SamDB(url=H, session_info=system_session(),
diff --git a/python/samba/netcmd/ntacl.py b/python/samba/netcmd/ntacl.py
index 4cc7737ae77..a8a9fa1e49f 100644
--- a/python/samba/netcmd/ntacl.py
+++ b/python/samba/netcmd/ntacl.py
@@ -25,13 +25,10 @@ from samba.ndr import ndr_unpack, ndr_print
 from samba.samdb import SamDB
 from samba.samba3 import param as s3param, passdb, smbd
 from samba import provision
+from samba.auth_util import system_session_unix
 import os
 
-from samba.auth import (
-    system_session,
-    session_info_fill_unix,
-    copy_session_info,
-)
+from samba.auth import system_session
 
 from samba.netcmd import (
     Command,
@@ -40,13 +37,6 @@ from samba.netcmd import (
     Option,
 )
 
-def system_session_unix():
-    session_info = system_session()
-    session_info_unix = copy_session_info(session_info)
-    session_info_fill_unix(session_info_unix, None)
-
-    return session_info_unix
-
 def get_local_domain_sid(lp):
     is_ad_dc = False
     server_role = lp.server_role()
@@ -117,11 +107,11 @@ class cmd_ntacl_set(Command):
                  file,
                  acl,
                  str(domain_sid),
+                 system_session_unix(),
                  xattr_backend,
                  eadb_file,
                  use_ntvfs=use_ntvfs,
-                 service=service,
-                 session_info=system_session_unix())
+                 service=service)
 
         if use_ntvfs:
             logger.warning("Please note that POSIX permissions have NOT been changed, only the stored NT ACL")
@@ -185,11 +175,11 @@ class cmd_ntacl_get(Command):
 
         acl = getntacl(lp,
                        file,
+                       system_session_unix(),
                        xattr_backend,
                        eadb_file,
                        direct_db_access=use_ntvfs,
-                       service=service,
-                       session_info=system_session_unix())
+                       service=service)
         if as_sddl:
             self.outf.write(acl.as_sddl(domain_sid) + "\n")
         else:
@@ -291,11 +281,11 @@ class cmd_ntacl_changedomsid(Command):
             try:
                 acl = getntacl(lp,
                                file,
+                               system_session_unix(),
                                xattr_backend,
                                eadb_file,
                                direct_db_access=use_ntvfs,
-                               service=service,
-                               session_info=system_session_unix())
+                               service=service)
             except Exception as e:
                 raise CommandError("Could not get acl for %s: %s" % (file, e))
 
@@ -333,11 +323,11 @@ class cmd_ntacl_changedomsid(Command):
                          file,
                          acl,
                          new_domain_sid,
+                         system_session_unix(),
                          xattr_backend,
                          eadb_file,
                          use_ntvfs=use_ntvfs,
-                         service=service,
-                         session_info=system_session_unix())
+                         service=service)
             except Exception as e:
                 raise CommandError("Could not set acl for %s: %s" % (file, e))
 
diff --git a/python/samba/netcmd/ou.py b/python/samba/netcmd/ou.py
index a715a5bee13..f68cd2f7af2 100644
--- a/python/samba/netcmd/ou.py
+++ b/python/samba/netcmd/ou.py
@@ -298,6 +298,9 @@ class cmd_list(Command):
     takes_options = [
         Option("-H", "--URL", help="LDB URL for database or target server",
                type=str, metavar="URL", dest="H"),
+        Option("-b", "--base-dn",
+               help="Specify base DN to use.",
+               type=str),
         Option("--full-dn", dest="full_dn", default=False, action='store_true',
                help="Display DNs including the base DN."),
     ]
@@ -308,15 +311,24 @@ class cmd_list(Command):
         "versionopts": options.VersionOptions,
     }
 
-    def run(self, sambaopts=None, credopts=None, versionopts=None, H=None,
+    def run(self,
+            sambaopts=None,
+            credopts=None,
+            versionopts=None,
+            H=None,
+            base_dn=None,
             full_dn=False):
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
         samdb = SamDB(url=H, session_info=system_session(),
                       credentials=creds, lp=lp)
 
-        domain_dn = ldb.Dn(samdb, samdb.domain_dn())
-        res = samdb.search(domain_dn, scope=ldb.SCOPE_SUBTREE,
+        search_dn = ldb.Dn(samdb, samdb.domain_dn())
+        if base_dn:
+            search_dn = samdb.normalize_dn_in_domain(base_dn)
+
+        res = samdb.search(search_dn,
+                           scope=ldb.SCOPE_SUBTREE,
                            expression="(objectClass=organizationalUnit)",
                            attrs=[])
         if (len(res) == 0):
@@ -324,6 +336,7 @@ class cmd_list(Command):
 
         for msg in sorted(res, key=attrgetter('dn')):
             if not full_dn:
+                domain_dn = ldb.Dn(samdb, samdb.domain_dn())
                 msg.dn.remove_base_components(len(domain_dn))
             self.outf.write("%s\n" % str(msg.dn))
 
diff --git a/python/samba/netcmd/testparm.py b/python/samba/netcmd/testparm.py
index bf566f38d78..aef24bf5c8d 100644
--- a/python/samba/netcmd/testparm.py
+++ b/python/samba/netcmd/testparm.py
@@ -157,12 +157,20 @@ class cmd_testparm(Command):
             valid = False
 
         role = lp.get("server role")
-        charset = lp.get("unix charset").upper()
 
-        if role in ["active directory domain controller", "domain controller", "dc"] and charset not in ["UTF-8", "UTF8"]:
-            logger.warning(
-                "When acting as Active Directory domain controller, "
-                "unix charset is expected to be UTF-8.")
+        if role in ["active directory domain controller", "domain controller", "dc"]:
+            charset = lp.get("unix charset").upper()
+            if charset not in ["UTF-8", "UTF8"]:
+                logger.warning(
+                    "When acting as Active Directory domain controller, "
+                    "unix charset is expected to be UTF-8.")
+            vfsobjects = lp.get("vfs objects")
+            if vfsobjects:
+                for entry in ['dfs_samba4', 'acl_xattr']:
+                    if entry not in vfsobjects:
+                        logger.warning(
+                            "When acting as Active Directory domain controller, " +
+                            entry + " should be in vfs objects.")
 
         return valid
 
diff --git a/python/samba/netcmd/user.py b/python/samba/netcmd/user.py
index cadd80fd991..26db3105da0 100644
--- a/python/samba/netcmd/user.py
+++ b/python/samba/netcmd/user.py
@@ -56,7 +56,7 @@ from samba.netcmd import (
 from samba.compat import text_type
 from samba.compat import get_bytes
 from samba.compat import get_string
-
+from . import common
 
 # python[3]-gpgme is abandoned since ubuntu 1804 and debian 9
 # have to use python[3]-gpg instead
@@ -481,6 +481,13 @@ class cmd_user_list(Command):
     takes_options = [
         Option("-H", "--URL", help="LDB URL for database or target server", type=str,
                metavar="URL", dest="H"),
+        Option("-b", "--base-dn",
+               help="Specify base DN to use",
+               type=str),
+        Option("--full-dn", dest="full_dn",
+               default=False,
+               action='store_true',
+               help="Display DN instead of the sAMAccountName.")
     ]
 
     takes_optiongroups = {
@@ -489,15 +496,25 @@ class cmd_user_list(Command):
         "versionopts": options.VersionOptions,
     }
 
-    def run(self, sambaopts=None, credopts=None, versionopts=None, H=None):
+    def run(self,
+            sambaopts=None,
+            credopts=None,
+            versionopts=None,
+            H=None,
+            base_dn=None,
+            full_dn=False):
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
 
         samdb = SamDB(url=H, session_info=system_session(),
                       credentials=creds, lp=lp)
 
-        domain_dn = samdb.domain_dn()
-        res = samdb.search(domain_dn, scope=ldb.SCOPE_SUBTREE,
+        search_dn = samdb.domain_dn()
+        if base_dn:
+            search_dn = samdb.normalize_dn_in_domain(base_dn)
+
+        res = samdb.search(search_dn,
+                           scope=ldb.SCOPE_SUBTREE,
                            expression=("(&(objectClass=user)(userAccountControl:%s:=%u))"
                                        % (ldb.OID_COMPARATOR_AND, dsdb.UF_NORMAL_ACCOUNT)),
                            attrs=["samaccountname"])
@@ -505,6 +522,10 @@ class cmd_user_list(Command):
             return
 
         for msg in res:
+            if full_dn:
+                self.outf.write("%s\n" % msg.get("dn"))
+                continue
+
             self.outf.write("%s\n" % msg.get("samaccountname", idx=0))
 
 
@@ -736,6 +757,208 @@ class cmd_user_password(Command):
         self.outf.write("Changed password OK\n")
 
 
+class cmd_user_getgroups(Command):
+    """Get the direct group memberships of a user account.
+
+The username specified on the command is the sAMAccountName."""
+    synopsis = "%prog <username> [options]"
+
+    takes_optiongroups = {
+        "sambaopts": options.SambaOptions,
+        "versionopts": options.VersionOptions,
+        "credopts": options.CredentialsOptions,
+    }
+
+    takes_options = [
+        Option("-H", "--URL", help="LDB URL for database or target server",
+               type=str, metavar="URL", dest="H"),
+        Option("--full-dn", dest="full_dn",
+               default=False,
+               action='store_true',
+               help="Display DN instead of the sAMAccountName."),
+        ]
+
+    takes_args = ["username"]
+
+    def run(self,
+            username,
+            credopts=None,
+            sambaopts=None,
+            versionopts=None,
+            H=None,
+            full_dn=False):
+
+        lp = sambaopts.get_loadparm()
+        creds = credopts.get_credentials(lp)
+
+        samdb = SamDB(url=H, session_info=system_session(),
+                      credentials=creds, lp=lp)
+
+        filter = ("(&(sAMAccountName=%s)(objectClass=user))" %
+                  ldb.binary_encode(username))
+        try:
+            res = samdb.search(base=samdb.domain_dn(),
+                               expression=filter,
+                               scope=ldb.SCOPE_SUBTREE,
+                               attrs=["objectSid",
+                                      "memberOf",
+                                      "primaryGroupID"])
+            user_sid_binary = res[0].get('objectSid', idx=0)
+            user_sid = ndr_unpack(security.dom_sid, user_sid_binary)
+            (user_dom_sid, user_rid) = user_sid.split()
+            user_sid_dn = "<SID=%s>" % user_sid
+            user_pgid = int(res[0].get('primaryGroupID', idx=0))
+            user_groups = res[0].get('memberOf')
+            if user_groups is None:
+                user_groups = []
+        except IndexError:
+            raise CommandError("Unable to find user '%s'" % (username))
+
+        primarygroup_sid_dn = "<SID=%s-%u>" % (user_dom_sid, user_pgid)
+
+        filter = "(objectClass=group)"
+        try:
+            res = samdb.search(base=primarygroup_sid_dn,
+                               expression=filter,
+                               scope=ldb.SCOPE_BASE,
+                               attrs=['sAMAccountName'])
+            primary_group_dn = str(res[0].dn)
+            primary_group_name = res[0].get('sAMAccountName')
+        except IndexError:
+            raise CommandError("Unable to find primary group '%s'" % (primarygroup_sid_dn))
+
+        if full_dn:
+            self.outf.write("%s\n" % primary_group_dn)
+            for group_dn in user_groups:
+                self.outf.write("%s\n" % group_dn)
+            return
+
+        group_names = []
+        for gdn in user_groups:
+            try:
+                res = samdb.search(base=gdn,
+                                   expression=filter,
+                                   scope=ldb.SCOPE_BASE,
+                                   attrs=['sAMAccountName'])
+                group_names.extend(res[0].get('sAMAccountName'))
+            except IndexError:
+                raise CommandError("Unable to find group '%s'" % (gdn))
+
+        self.outf.write("%s\n" % primary_group_name)
+        for group_name in group_names:
+            self.outf.write("%s\n" % group_name)
+
+
+class cmd_user_setprimarygroup(Command):
+    """Set the primary group a user account.
+
+This command sets the primary group a user account. The username specified on
+the command is the sAMAccountName. The primarygroupname is the sAMAccountName
+of the new primary group. The user must be a member of the group.
+
+The command may be run from the root userid or another authorized userid. The
+-H or --URL= option can be used to execute the command against a remote server.
+
+Example1:
+samba-tool user setprimarygroup TestUser1 newPrimaryGroup --URL=ldap://samba.samdom.example.com -Uadministrator%passw1rd
+
+Example1 shows how to set the primary group for TestUser1 on a remote LDAP
+server. The --URL parameter is used to specify the remote target server.  The
+-U option is used to pass the username and password of a user that exists on
+the remote server and is authorized to update the server.
+"""
+    synopsis = "%prog <username> <primarygroupname> [options]"
+
+    takes_optiongroups = {
+        "sambaopts": options.SambaOptions,
+        "versionopts": options.VersionOptions,
+        "credopts": options.CredentialsOptions,
+    }
+
+    takes_options = [
+        Option("-H", "--URL", help="LDB URL for database or target server", type=str,
+               metavar="URL", dest="H"),
+        ]
+
+    takes_args = ["username", "primarygroupname"]
+
+    def run(self, username, primarygroupname, credopts=None, sambaopts=None,
+            versionopts=None, H=None):
+
+        lp = sambaopts.get_loadparm()
+        creds = credopts.get_credentials(lp)
+
+        samdb = SamDB(url=H, session_info=system_session(),
+                      credentials=creds, lp=lp)
+
+        filter = ("(&(sAMAccountName=%s)(objectClass=user))" %
+                  ldb.binary_encode(username))
+        try:
+            res = samdb.search(base=samdb.domain_dn(),
+                               expression=filter,
+                               scope=ldb.SCOPE_SUBTREE,
+                               controls=["extended_dn:1:1"],
+                               attrs=["objectSid",
+                                      "memberOf",
+                                      "primaryGroupID"])
+            user_sid_binary = res[0].get('objectSid', idx=0)
+            user_sid = ndr_unpack(security.dom_sid, user_sid_binary)
+            (user_dom_sid, user_rid) = user_sid.split()
+            user_sid_dn = "<SID=%s>" % user_sid
+            user_pgid = int(res[0].get('primaryGroupID', idx=0))
+            user_groups = res[0].get('memberOf')
+            if user_groups is None:
+                user_groups = []
+        except IndexError:
+            raise CommandError("Unable to find user '%s'" % (username))
+
+        user_group_sids = []
+        for user_group in user_groups:
+            user_group_dn = ldb.Dn(samdb, str(user_group))
+            user_group_binary_sid = user_group_dn.get_extended_component("SID")
+            user_group_sid = ndr_unpack(security.dom_sid, user_group_binary_sid)
+            user_group_sids.append(user_group_sid)
+
+        filter = ("(&(sAMAccountName=%s)(objectClass=group))" %
+                  ldb.binary_encode(primarygroupname))
+        try:
+            res = samdb.search(base=samdb.domain_dn(),
+                               expression=filter,
+                               scope=ldb.SCOPE_SUBTREE,
+                               attrs=["objectSid"])
+            group_sid_binary = res[0].get('objectSid', idx=0)
+        except IndexError:
+            raise CommandError("Unable to find group '%s'" % (primarygroupname))
+
+        primarygroup_sid = ndr_unpack(security.dom_sid, group_sid_binary)
+        (primarygroup_dom_sid, primarygroup_rid) = primarygroup_sid.split()
+
+        if user_dom_sid != primarygroup_dom_sid:
+            raise CommandError("Group '%s' does not belong to the user's "
+                               "domain" % primarygroupname)
+
+        if primarygroup_rid != user_pgid and primarygroup_sid not in user_group_sids:
+            raise CommandError("User '%s' is not member of group '%s'" %
+                               (username, primarygroupname))
+
+        setprimarygroup_ldif = """
+dn: %s
+changetype: modify
+delete: primaryGroupID
+primaryGroupID: %u
+add: primaryGroupID
+primaryGroupID: %u
+""" % (user_sid_dn, user_pgid, primarygroup_rid)
+
+        try:
+            samdb.modify_ldif(setprimarygroup_ldif)
+        except Exception as msg:
+            raise CommandError("Failed to set primary group '%s' "
+                               "for user '%s': %s" %
+                               (primarygroupname, username, msg))
+        self.outf.write("Changed primary group to '%s'\n" % primarygroupname)
+
+
 class cmd_user_setpassword(Command):
     """Set or reset the password of a user account.
 
@@ -2389,8 +2612,6 @@ LDAP server using the 'nano' editor.
 
     def run(self, username, credopts=None, sambaopts=None, versionopts=None,
             H=None, editor=None):
-        from . import common
-
         lp = sambaopts.get_loadparm()
         creds = credopts.get_credentials(lp, fallback_machine=True)
         samdb = SamDB(url=H, session_info=system_session(),
@@ -2520,7 +2741,7 @@ Example3 shows how to display a users objectSid and memberOf attributes.
             raise CommandError('Unable to find user "%s"' % (username))
 
         for msg in res:
-            user_ldif = samdb.write_ldif(msg, ldb.CHANGETYPE_NONE)
+            user_ldif = common.get_ldif_for_editor(samdb, msg)
             self.outf.write(user_ldif)
 
 
@@ -2827,6 +3048,63 @@ unixHomeDirectory: {6}
                             .format(username))
 
 
+class cmd_user_sensitive(Command):
+    """Set/unset or show UF_NOT_DELEGATED for an account."""
+
+    synopsis = "%prog <accountname> [(show|on|off)] [options]"
+
+    takes_optiongroups = {
+        "sambaopts": options.SambaOptions,
+        "credopts": options.CredentialsOptions,
+        "versionopts": options.VersionOptions,
+    }
+
+    takes_options = [
+        Option("-H", "--URL", help="LDB URL for database or target server", type=str,
+               metavar="URL", dest="H"),
+    ]
+
+    takes_args = ["accountname", "cmd"]
+
+    def run(self, accountname, cmd, H=None, credopts=None, sambaopts=None,
+            versionopts=None):
+
+        if cmd not in ("show", "on", "off"):
+            raise CommandError("invalid argument: '%s' (choose from 'show', 'on', 'off')" % cmd)
+
+        lp = sambaopts.get_loadparm()
+        creds = credopts.get_credentials(lp, fallback_machine=True)
+        sam = SamDB(url=H, session_info=system_session(),
+                    credentials=creds, lp=lp)
+
+        search_filter = "sAMAccountName=%s" % ldb.binary_encode(accountname)
+        flag = dsdb.UF_NOT_DELEGATED;
+
+        if cmd == "show":
+            res = sam.search(scope=ldb.SCOPE_SUBTREE, expression=search_filter,
+                             attrs=["userAccountControl"])
+            if len(res) == 0:
+                raise Exception("Unable to find account where '%s'" % search_filter)
+
+            uac = int(res[0].get("userAccountControl")[0])
+
+            self.outf.write("Account-DN: %s\n" % str(res[0].dn))
+            self.outf.write("UF_NOT_DELEGATED: %s\n" % bool(uac & flag))
+
+            return
+
+        if cmd == "on":
+            on = True
+        elif cmd == "off":
+            on = False
+
+        try:
+            sam.toggle_userAccountFlags(search_filter, flag, flags_str="Not-Delegated",
+                                        on=on, strict=True)
+        except Exception as err:
+            raise CommandError(err)
+
+
 class cmd_user(SuperCommand):
     """User management."""
 
@@ -2839,6 +3117,8 @@ class cmd_user(SuperCommand):
     subcommands["list"] = cmd_user_list()
     subcommands["setexpiry"] = cmd_user_setexpiry()
     subcommands["password"] = cmd_user_password()
+    subcommands["getgroups"] = cmd_user_getgroups()
+    subcommands["setprimarygroup"] = cmd_user_setprimarygroup()
     subcommands["setpassword"] = cmd_user_setpassword()
     subcommands["getpassword"] = cmd_user_getpassword()
     subcommands["syncpasswords"] = cmd_user_syncpasswords()
@@ -2846,3 +3126,4 @@ class cmd_user(SuperCommand):
     subcommands["show"] = cmd_user_show()
     subcommands["move"] = cmd_user_move()
     subcommands["addunixattrs"] = cmd_user_add_unix_attrs()
+    subcommands["sensitive"] = cmd_user_sensitive()
diff --git a/python/samba/ntacls.py b/python/samba/ntacls.py
index 7057938b56e..0dcf958f727 100644
--- a/python/samba/ntacls.py
+++ b/python/samba/ntacls.py
@@ -35,6 +35,7 @@ from samba.samba3 import smbd
 from samba.samba3 import libsmb_samba_internal as libsmb
 from samba.logger import get_samba_logger
 from samba import NTSTATUSError
+from samba.auth_util import system_session_unix
 
 # don't include volumes
 SMB_FILE_ATTRIBUTE_FLAGS = libsmb.FILE_ATTRIBUTE_SYSTEM | \
@@ -98,11 +99,11 @@ def getdosinfo(lp, file):
 
 def getntacl(lp,
              file,
+             session_info,
              backend=None,
              eadbfile=None,
              direct_db_access=True,
-             service=None,
-             session_info=None):
+             service=None):
     if direct_db_access:
         (backend_obj, dbname) = checkset_backend(lp, backend, eadbfile)
         if dbname is not None:
@@ -130,14 +131,14 @@ def getntacl(lp,
     else:
         return smbd.get_nt_acl(file,
                                SECURITY_SECINFO_FLAGS,
-                               service=service,
-                               session_info=session_info)
+                               session_info,
+                               service=service)
 
 
-def setntacl(lp, file, sddl, domsid,
+def setntacl(lp, file, sddl, domsid, session_info,
              backend=None, eadbfile=None,
              use_ntvfs=True, skip_invalid_chown=False,
-             passdb=None, service=None, session_info=None):
+             passdb=None, service=None):
     """
     A wrapper for smbd set_nt_acl api.
 
@@ -190,7 +191,8 @@ def setntacl(lp, file, sddl, domsid,
 
                     smbd.set_nt_acl(
                         file, SECURITY_SECINFO_FLAGS, sd2,
-                        service=service, session_info=session_info)
+                        session_info,
+                        service=service)
 
                     # and then set an NTVFS ACL (which does not set the posix ACL) to pretend the owner really was set
                     use_ntvfs = True
@@ -208,7 +210,9 @@ def setntacl(lp, file, sddl, domsid,
                     security.SECINFO_GROUP |
                     security.SECINFO_DACL |
                     security.SECINFO_SACL,
-                    sd, service=service, session_info=session_info)
+                    sd,
+                    session_info,
+                    service=service)
 
     if use_ntvfs:
         (backend_obj, dbname) = checkset_backend(lp, backend, eadbfile)
@@ -445,20 +449,20 @@ class NtaclsHelper:
 
         self.use_ntvfs = "smb" in self.lp.get("server services")
 
-    def getntacl(self, path, as_sddl=False, direct_db_access=None):
+    def getntacl(self, path, session_info, as_sddl=False, direct_db_access=None):
         if direct_db_access is None:
             direct_db_access = self.use_ntvfs
 
         ntacl_sd = getntacl(
-            self.lp, path,
+            self.lp, path, session_info,
             direct_db_access=direct_db_access,
             service=self.service)
 
         return ntacl_sd.as_sddl(self.dom_sid) if as_sddl else ntacl_sd
 
-    def setntacl(self, path, ntacl_sd):
+    def setntacl(self, path, ntacl_sd, session_info):
         # ntacl_sd can be obj or str
-        return setntacl(self.lp, path, ntacl_sd, self.dom_sid,
+        return setntacl(self.lp, path, ntacl_sd, self.dom_sid, session_info,
                         use_ntvfs=self.use_ntvfs)
 
 
@@ -543,6 +547,7 @@ def backup_offline(src_service_path, dest_tarfile_path, samdb_conn, smb_conf_pat
     """
     service = src_service_path.rstrip('/').rsplit('/', 1)[-1]
     tempdir = tempfile.mkdtemp()
+    session_info = system_session_unix()
 
     dom_sid_str = samdb_conn.get_domain_sid()
     dom_sid = security.dom_sid(dom_sid_str)
@@ -559,8 +564,8 @@ def backup_offline(src_service_path, dest_tarfile_path, samdb_conn, smb_conf_pat
             src = os.path.join(dirpath, dirname)
             dst = os.path.join(dst_dirpath, dirname)
             # mkdir with metadata
-            smbd.mkdir(dst, service)
-            ntacl_sddl_str = ntacls_helper.getntacl(src, as_sddl=True)
+            smbd.mkdir(dst, session_info, service)
+            ntacl_sddl_str = ntacls_helper.getntacl(src, session_info, as_sddl=True)
             _create_ntacl_file(dst, ntacl_sddl_str)
 
         # create files and NTACL file, then copy data
@@ -568,8 +573,8 @@ def backup_offline(src_service_path, dest_tarfile_path, samdb_conn, smb_conf_pat
             src = os.path.join(dirpath, filename)
             dst = os.path.join(dst_dirpath, filename)
             # create an empty file with metadata
-            smbd.create_file(dst, service)
-            ntacl_sddl_str = ntacls_helper.getntacl(src, as_sddl=True)
+            smbd.create_file(dst, session_info, service)
+            ntacl_sddl_str = ntacls_helper.getntacl(src, session_info, as_sddl=True)
             _create_ntacl_file(dst, ntacl_sddl_str)
 
             # now put data in
@@ -599,6 +604,7 @@ def backup_restore(src_tarfile_path, dst_service_path, samdb_conn, smb_conf_path
     dom_sid = security.dom_sid(dom_sid_str)
 
     ntacls_helper = NtaclsHelper(service, smb_conf_path, dom_sid)
+    session_info = system_session_unix()
 
     with tarfile.open(src_tarfile_path) as f:
         f.extractall(path=tempdir)
@@ -615,11 +621,11 @@ def backup_restore(src_tarfile_path, dst_service_path, samdb_conn, smb_conf_path
                 dst = os.path.join(dst_dirpath, dirname)
                 if not os.path.isdir(dst):
                     # dst must be absolute path for smbd API
-                    smbd.mkdir(dst, service)
+                    smbd.mkdir(dst, session_info, service)
 
                 ntacl_sddl_str = _read_ntacl_file(src)
                 if ntacl_sddl_str:
-                    ntacls_helper.setntacl(dst, ntacl_sddl_str)
+                    ntacls_helper.setntacl(dst, ntacl_sddl_str, session_info)
                 else:
                     logger.warning(
                         'Failed to restore ntacl for directory %s.' % dst
@@ -631,11 +637,11 @@ def backup_restore(src_tarfile_path, dst_service_path, samdb_conn, smb_conf_path
                 dst = os.path.join(dst_dirpath, filename)
                 if not os.path.isfile(dst):
                     # dst must be absolute path for smbd API
-                    smbd.create_file(dst, service)
+                    smbd.create_file(dst, session_info, service)
 
                 ntacl_sddl_str = _read_ntacl_file(src)
                 if ntacl_sddl_str:
-                    ntacls_helper.setntacl(dst, ntacl_sddl_str)
+                    ntacls_helper.setntacl(dst, ntacl_sddl_str, session_info)
                 else:
                     logger.warning('Failed to restore ntacl for file %s.' % dst
                                  + ' Please check the permissions are correct')
diff --git a/python/samba/provision/__init__.py b/python/samba/provision/__init__.py
index 217840989aa..a27c3ee78b3 100644
--- a/python/samba/provision/__init__.py
+++ b/python/samba/provision/__init__.py
@@ -46,6 +46,7 @@ import samba.dsdb
 import ldb
 
 from samba.auth import system_session, admin_session
+from samba.auth_util import system_session_unix
 import samba
 from samba import auth
 from samba.samba3 import smbd, passdb
@@ -1632,13 +1633,14 @@ SYSVOL_SERVICE = "sysvol"
 
 
 def set_dir_acl(path, acl, lp, domsid, use_ntvfs, passdb, service=SYSVOL_SERVICE):
-    setntacl(lp, path, acl, domsid, use_ntvfs=use_ntvfs, skip_invalid_chown=True, passdb=passdb, service=service)
+    session_info = system_session_unix()
+    setntacl(lp, path, acl, domsid, session_info, use_ntvfs=use_ntvfs, skip_invalid_chown=True, passdb=passdb, service=service)
     for root, dirs, files in os.walk(path, topdown=False):
         for name in files:
-            setntacl(lp, os.path.join(root, name), acl, domsid,
+            setntacl(lp, os.path.join(root, name), acl, domsid, session_info,
                      use_ntvfs=use_ntvfs, skip_invalid_chown=True, passdb=passdb, service=service)
         for name in dirs:
-            setntacl(lp, os.path.join(root, name), acl, domsid,
+            setntacl(lp, os.path.join(root, name), acl, domsid, session_info,
                      use_ntvfs=use_ntvfs, skip_invalid_chown=True, passdb=passdb, service=service)
 
 
@@ -1656,7 +1658,9 @@ def set_gpos_acl(sysvol, dnsdomain, domainsid, domaindn, samdb, lp, use_ntvfs, p
 
     # Set ACL for GPO root folder
     root_policy_path = os.path.join(sysvol, dnsdomain, "Policies")
-    setntacl(lp, root_policy_path, POLICIES_ACL, str(domainsid),
+    session_info = system_session_unix()
+
+    setntacl(lp, root_policy_path, POLICIES_ACL, str(domainsid), session_info,
              use_ntvfs=use_ntvfs, skip_invalid_chown=True, passdb=passdb, service=SYSVOL_SERVICE)
 
     res = samdb.search(base="CN=Policies,CN=System,%s" %(domaindn),
@@ -1694,7 +1698,7 @@ def setsysvolacl(samdb, netlogon, sysvol, uid, gid, domainsid, dnsdomain,
         file = tempfile.NamedTemporaryFile(dir=os.path.abspath(sysvol))
         try:
             try:
-                smbd.set_simple_acl(file.name, 0o755, gid)
+                smbd.set_simple_acl(file.name, 0o755, system_session_unix(), gid)
             except OSError:
                 if not smbd.have_posix_acls():
                     # This clue is only strictly correct for RPM and
@@ -1706,7 +1710,7 @@ def setsysvolacl(samdb, netlogon, sysvol, uid, gid, domainsid, dnsdomain,
                 raise ProvisioningError("Your filesystem or build does not support posix ACLs, which s3fs requires.  "
                                         "Try the mounting the filesystem with the 'acl' option.")
             try:
-                smbd.chown(file.name, uid, gid)
+                smbd.chown(file.name, uid, gid, system_session_unix())
             except OSError:
                 raise ProvisioningError("Unable to chown a file on your filesystem.  "
                                         "You may not be running provision as root.")
@@ -1758,9 +1762,9 @@ def setsysvolacl(samdb, netlogon, sysvol, uid, gid, domainsid, dnsdomain,
     def _setntacl(path):
         """A helper to reuse args"""
         return setntacl(
-            lp, path, SYSVOL_ACL, str(domainsid),
+            lp, path, SYSVOL_ACL, str(domainsid), session_info,
             use_ntvfs=use_ntvfs, skip_invalid_chown=True, passdb=s4_passdb,
-            service=SYSVOL_SERVICE, session_info=session_info)
+            service=SYSVOL_SERVICE)
 
     # Set the SYSVOL_ACL on the sysvol folder and subfolder (first level)
     _setntacl(sysvol)
@@ -1786,14 +1790,15 @@ def acl_type(direct_db_access):
 
 
 def check_dir_acl(path, acl, lp, domainsid, direct_db_access):
-    fsacl = getntacl(lp, path, direct_db_access=direct_db_access, service=SYSVOL_SERVICE)
+    session_info = system_session_unix()
+    fsacl = getntacl(lp, path, session_info, direct_db_access=direct_db_access, service=SYSVOL_SERVICE)
     fsacl_sddl = fsacl.as_sddl(domainsid)
     if fsacl_sddl != acl:
         raise ProvisioningError('%s ACL on GPO directory %s %s does not match expected value %s from GPO object' % (acl_type(direct_db_access), path, fsacl_sddl, acl))
 
     for root, dirs, files in os.walk(path, topdown=False):
         for name in files:
-            fsacl = getntacl(lp, os.path.join(root, name),
+            fsacl = getntacl(lp, os.path.join(root, name), session_info,
                              direct_db_access=direct_db_access, service=SYSVOL_SERVICE)
             if fsacl is None:
                 raise ProvisioningError('%s ACL on GPO file %s not found!' %
@@ -1804,7 +1809,7 @@ def check_dir_acl(path, acl, lp, domainsid, direct_db_access):
                 raise ProvisioningError('%s ACL on GPO file %s %s does not match expected value %s from GPO object' % (acl_type(direct_db_access), os.path.join(root, name), fsacl_sddl, acl))
 
         for name in dirs:
-            fsacl = getntacl(lp, os.path.join(root, name),
+            fsacl = getntacl(lp, os.path.join(root, name), session_info,
                              direct_db_access=direct_db_access, service=SYSVOL_SERVICE)
             if fsacl is None:
                 raise ProvisioningError('%s ACL on GPO directory %s not found!'
@@ -1830,7 +1835,8 @@ def check_gpos_acl(sysvol, dnsdomain, domainsid, domaindn, samdb, lp,
 
     # Set ACL for GPO root folder
     root_policy_path = os.path.join(sysvol, dnsdomain, "Policies")
-    fsacl = getntacl(lp, root_policy_path,
+    session_info = system_session_unix()
+    fsacl = getntacl(lp, root_policy_path, session_info,
                      direct_db_access=direct_db_access, service=SYSVOL_SERVICE)
     if fsacl is None:
         raise ProvisioningError('DB ACL on policy root %s %s not found!' % (acl_type(direct_db_access), root_policy_path))
@@ -1883,10 +1889,11 @@ def checksysvolacl(samdb, netlogon, sysvol, domainsid, dnsdomain, domaindn,
         raise ProvisioningError('Realm as seen by pdb_samba_dsdb [%s] does not match Realm as seen by the provision script [%s]!' % (domain_info["dns_domain"].upper(), dnsdomain.upper()))
 
     # Ensure we can read this directly, and via the smbd VFS
+    session_info = system_session_unix()
     for direct_db_access in [True, False]:
         # Check the SYSVOL_ACL on the sysvol folder and subfolder (first level)
         for dir_path in [os.path.join(sysvol, dnsdomain), netlogon]:
-            fsacl = getntacl(lp, dir_path, direct_db_access=direct_db_access, service=SYSVOL_SERVICE)
+            fsacl = getntacl(lp, dir_path, session_info, direct_db_access=direct_db_access, service=SYSVOL_SERVICE)
             if fsacl is None:
                 raise ProvisioningError('%s ACL on sysvol directory %s not found!' % (acl_type(direct_db_access), dir_path))
             fsacl_sddl = fsacl.as_sddl(domainsid)
diff --git a/python/samba/provision/sambadns.py b/python/samba/provision/sambadns.py
index e7273fc759e..ffdb2559979 100644
--- a/python/samba/provision/sambadns.py
+++ b/python/samba/provision/sambadns.py
@@ -850,9 +850,19 @@ def create_samdb_copy(samdb, logger, paths, names, domainsid, domainguid):
                 os.path.join(dns_samldb_dir, metadata_file))
         os.link(os.path.join(private_dir, domainzone_file),
                 os.path.join(dns_dir, domainzone_file))
+        if backend_store == "mdb":
+            # If the file is an lmdb data file need to link the
+            # lock file as well
+            os.link(os.path.join(private_dir, domainzone_file + "-lock"),
+                    os.path.join(dns_dir, domainzone_file + "-lock"))
         if forestzone_file:
             os.link(os.path.join(private_dir, forestzone_file),
                     os.path.join(dns_dir, forestzone_file))
+            if backend_store == "mdb":
+                # If the database file is an lmdb data file need to link the
+                # lock file as well
+                os.link(os.path.join(private_dir, forestzone_file + "-lock"),
+                        os.path.join(dns_dir, forestzone_file + "-lock"))
     except OSError:
         logger.error(
             "Failed to setup database for BIND, AD based DNS cannot be used")
diff --git a/python/samba/samdb.py b/python/samba/samdb.py
index 22819641802..d903babb406 100644
--- a/python/samba/samdb.py
+++ b/python/samba/samdb.py
@@ -251,8 +251,63 @@ pwdLastSet: 0
         else:
             self.transaction_commit()
 
+    def group_member_filter(self, member, member_types):
+        filter = ""
+
+        all_member_types = [ 'user',
+                             'group',
+                             'computer',
+                             'serviceaccount',
+                             'contact',
+                           ]
+
+        if 'all' in member_types:
+            member_types = all_member_types
+
+        for member_type in member_types:
+            if member_type not in all_member_types:
+                raise Exception('Invalid group member type "%s". '
+                                'Valid types are %s and all.' %
+                                (member_type, ", ".join(all_member_types)))
+
+        if 'user' in member_types:
+            filter += ('(&(sAMAccountName=%s)(samAccountType=%d))' %
+                       (ldb.binary_encode(member), dsdb.ATYPE_NORMAL_ACCOUNT))
+        if 'group' in member_types:
+            filter += ('(&(sAMAccountName=%s)'
+                       '(objectClass=group)'
+                       '(!(groupType:1.2.840.113556.1.4.803:=1)))' %
+                       ldb.binary_encode(member))
+        if 'computer' in member_types:
+            samaccountname = member
+            if member[-1] != '$':
+                samaccountname = "%s$" % member
+            filter += ('(&(samAccountType=%d)'
+                       '(!(objectCategory=msDS-ManagedServiceAccount))'
+                       '(sAMAccountName=%s))' %
+                       (dsdb.ATYPE_WORKSTATION_TRUST,
+                        ldb.binary_encode(samaccountname)))
+        if 'serviceaccount' in member_types:
+            samaccountname = member
+            if member[-1] != '$':
+                samaccountname = "%s$" % member
+            filter += ('(&(samAccountType=%d)'
+                       '(objectCategory=msDS-ManagedServiceAccount)'
+                       '(sAMAccountName=%s))' %
+                       (dsdb.ATYPE_WORKSTATION_TRUST,
+                        ldb.binary_encode(samaccountname)))
+        if 'contact' in member_types:
+            filter += ('(&(objectCategory=Person)(!(objectSid=*))(name=%s))' %
+                       ldb.binary_encode(member))
+
+        filter = "(|%s)" % filter
+
+        return filter
+
     def add_remove_group_members(self, groupname, members,
-                                 add_members_operation=True):
+                                 add_members_operation=True,
+                                 member_types=[ 'user', 'group', 'computer' ],
+                                 member_base_dn=None):
         """Adds or removes group members
 
         :param groupname: Name of the target group
@@ -280,30 +335,44 @@ changetype: modify
 """ % (str(targetgroup[0].dn))
 
             for member in members:
-                filter = ('(&(sAMAccountName=%s)(|(objectclass=user)'
-                          '(objectclass=group)))' % ldb.binary_encode(member))
-                foreign_msg = None
+                targetmember_dn = None
+                if member_base_dn is None:
+                    member_base_dn = self.domain_dn()
+
                 try:
                     membersid = security.dom_sid(member)
+                    targetmember_dn = "<SID=%s>" % str(membersid)
                 except TypeError as e:
-                    membersid = None
-
-                if membersid is not None:
-                    filter = '(objectSid=%s)' % str(membersid)
-                    dn_str = "<SID=%s>" % str(membersid)
-                    foreign_msg = ldb.Message()
-                    foreign_msg.dn = ldb.Dn(self, dn_str)
-
-                targetmember = self.search(base=self.domain_dn(),
-                                           scope=ldb.SCOPE_SUBTREE,
-                                           expression="%s" % filter,
-                                           attrs=[])
-
-                if len(targetmember) == 0 and foreign_msg is not None:
-                    targetmember = [foreign_msg]
-                if len(targetmember) != 1:
-                    raise Exception('Unable to find "%s". Operation cancelled.' % member)
-                targetmember_dn = targetmember[0].dn.extended_str(1)
+                    pass
+
+                if targetmember_dn is None:
+                    try:
+                        member_dn = ldb.Dn(self, member)
+                        if member_dn.get_linearized() == member_dn.extended_str(1):
+                            full_member_dn = self.normalize_dn_in_domain(member_dn)
+                        else:
+                            full_member_dn = member_dn
+                        targetmember_dn = full_member_dn.extended_str(1)
+                    except ValueError as e:
+                        pass
+
+                if targetmember_dn is None:
+                    filter = self.group_member_filter(member, member_types)
+                    targetmember = self.search(base=member_base_dn,
+                                               scope=ldb.SCOPE_SUBTREE,
+                                               expression=filter,
+                                               attrs=[])
+
+                    if len(targetmember) > 1:
+                        targetmemberlist_str = ""
+                        for msg in targetmember:
+                            targetmemberlist_str += "%s\n" % msg.get("dn")
+                        raise Exception('Found multiple results for "%s":\n%s' %
+                                        (member, targetmemberlist_str))
+                    if len(targetmember) != 1:
+                        raise Exception('Unable to find "%s". Operation cancelled.' % member)
+                    targetmember_dn = targetmember[0].dn.extended_str(1)
+
                 if add_members_operation is True and (targetgroup[0].get('member') is None or get_bytes(targetmember_dn) not in [str(x) for x in targetgroup[0]['member']]):
                     modified = True
                     addtargettogroup += """add: member
diff --git a/python/samba/tests/__init__.py b/python/samba/tests/__init__.py
index fef21d261ca..3f22eaa1c94 100644
--- a/python/samba/tests/__init__.py
+++ b/python/samba/tests/__init__.py
@@ -438,6 +438,7 @@ class BlackboxTestCase(TestCaseInTempDir):
                                        stdoutdata,
                                        stderrdata,
                                        msg)
+        return stdoutdata
 
     def check_output(self, line):
         use_shell = not isinstance(line, list)
diff --git a/python/samba/tests/auth_log_winbind.py b/python/samba/tests/auth_log_winbind.py
index 4f4beff1e32..4c68187aef8 100644
--- a/python/samba/tests/auth_log_winbind.py
+++ b/python/samba/tests/auth_log_winbind.py
@@ -321,7 +321,7 @@ class AuthLogTestsWinbind(AuthLogTestBase, BlackboxTestCase):
         self.assertEquals("unix:", msg["Authentication"]["localAddress"])
         self.assertEquals('', msg["Authentication"]["clientDomain"])
         # This is what the existing winbind implementation returns.
-        self.assertEquals("NT_STATUS_INVALID_HANDLE",
+        self.assertEquals("NT_STATUS_NO_SUCH_USER",
                           msg["Authentication"]["status"])
         self.assertEquals(self.credentials.get_username(),
                           msg["Authentication"]["clientAccount"])
@@ -424,7 +424,7 @@ class AuthLogTestsWinbind(AuthLogTestBase, BlackboxTestCase):
         self.assertEquals("unix:", msg["Authentication"]["localAddress"])
         self.assertEquals('', msg["Authentication"]["clientDomain"])
         # This is what the existing winbind implementation returns.
-        self.assertEquals("NT_STATUS_INVALID_HANDLE",
+        self.assertEquals("NT_STATUS_NO_SUCH_USER",
                           msg["Authentication"]["status"])
         self.assertEquals(self.credentials.get_username(),
                           msg["Authentication"]["clientAccount"])
diff --git a/python/samba/tests/blackbox/ndrdump.py b/python/samba/tests/blackbox/ndrdump.py
index 4e638c920d8..b3c837819b1 100644
--- a/python/samba/tests/blackbox/ndrdump.py
+++ b/python/samba/tests/blackbox/ndrdump.py
@@ -97,7 +97,7 @@ class NdrDumpTests(BlackboxTestCase):
 
     def test_ndrdump_with_binary_struct_number(self):
         expected = '''pull returned Success
-    0                        : 33323130-3534-3736-3839-616263646566
+    GUID                     : 33323130-3534-3736-3839-616263646566
 dump OK
 '''
         try:
@@ -110,3 +110,330 @@ dump OK
         # check_output will return bytes
         # convert expected to bytes for python 3
         self.assertEqual(actual, expected.encode('utf-8'))
+
+    def test_ndrdump_with_enum_not_struct(self):
+        expected = '''Public structure 'netr_SchannelType' not found
+'''
+        try:
+            actual = self.check_exit_code(
+                "ndrdump misc netr_SchannelType --input=x struct",
+                1)
+        except BlackboxProcessError as e:
+            self.fail(e)
+
+        # check_output will return bytes
+        # convert expected to bytes for python 3
+        self.assertEqual(actual, expected.encode('utf-8'))
+
+    def test_ndrdump_input_cmdline_short_struct_name(self):
+        expected = '''pull returned Buffer Size Error
+'''
+        try:
+            actual = self.check_exit_code(
+                "ndrdump -d0 misc GUID struct --input=abcdefg", 2)
+        except BlackboxProcessError as e:
+            self.fail(e)
+
+        # check_output will return bytes
+        # convert expected to bytes for python 3
+        self.assertEqual(actual, expected.encode('utf-8'))
+
+    def test_ndrdump_input_cmdline_short_struct_name_dump(self):
+        expected = '''pull returned Buffer Size Error
+6 bytes consumed
+[0000] 61 62 63 64 65 66 67                               abcdefg ''' \
+        '''
+'''
+        try:
+            actual = self.check_exit_code(
+                "ndrdump -d0 misc GUID struct --input=abcdefg --dump-data", 2)
+        except BlackboxProcessError as e:
+            self.fail(e)
+
+        # check_output will return bytes
+        # convert expected to bytes for python 3
+        self.assertEqual(actual, expected.encode('utf-8'))
+
+    def test_ndrdump_input_cmdline_short_struct_name_print_fail(self):
+        expected = '''pull returned Buffer Size Error
+6 bytes consumed
+[0000] 61 62 63 64 65 66 67                               abcdefg ''' \
+        '''
+WARNING! 1 unread bytes
+[0000] 67                                                 g ''' \
+    '''
+WARNING: pull of GUID was incomplete, therefore the parse below may SEGFAULT
+    GUID                     : 64636261-6665-0000-0000-000000000000
+dump of failed-to-parse GUID complete
+'''
+        try:
+            actual = self.check_exit_code(
+                "ndrdump -d0 misc GUID struct --input=abcdefg --dump-data --print-after-parse-failure", 2)
+        except BlackboxProcessError as e:
+            self.fail(e)
+
+        # check_output will return bytes
+        # convert expected to bytes for python 3
+        self.assertEqual(actual, expected.encode('utf-8'))
+
+    def test_ndrdump_fuzzed_clusapi_QueryAllValues(self):
+        expected = b'''pull returned Success
+WARNING! 53 unread bytes
+[0000] 00 FF 00 00 FF 00 00 00   00 09 00 00 00 08 00 33   ........ .......3
+[0010] 33 32 37 36 32 36 39 33   32 37 36 38 34 01 00 00   32762693 27684...
+[0020] 80 32 0D FF 00 00 FF 00   00 00 00 08 00 00 00 1C   .2...... ........
+[0030] F1 29 08 00 00                                     .)... ''' \
+        b'''
+    clusapi_QueryAllValues: struct clusapi_QueryAllValues
+        out: struct clusapi_QueryAllValues
+            pcbData                  : *
+                pcbData                  : 0x01000000 (16777216)
+            ppData                   : *
+                ppData: ARRAY(1)
+                    ppData                   : NULL
+            rpc_status               : *
+                rpc_status               : WERR_OK
+            result                   : WERR_NOT_ENOUGH_MEMORY
+dump OK
+'''
+        try:
+            actual = self.check_output(
+                'ndrdump clusapi clusapi_QueryAllValues out ' +\
+                '--base64-input --input=' +\
+                'AAAAAQEAAAAAAAAAAAAAAAgAAAAA/wAA/wAAAAAJAAAACAAzMzI3NjI2OTMyNzY4NAEAAIAyDf8AAP8AAAAACAAAABzxKQgAAA==')
+        except BlackboxProcessError as e:
+            self.fail(e)
+        self.assertEqual(actual, expected)
+
+    def test_ndrdump_fuzzed_IOXIDResolver_ResolveOxid(self):
+        expected = '''pull returned Character Conversion Error
+'''
+        try:
+            actual = self.check_exit_code(
+                'ndrdump IOXIDResolver ResolveOxid out ' +\
+                '--base64-input --input=' +\
+                'c87PMf7CBAUAAAAADgQMBASjfPqKw0KPld6DY87PMfQ=',
+                2)
+        except BlackboxProcessError as e:
+            self.fail(e)
+        self.assertRegex(actual.decode('utf8'), expected + "$")
+
+    def test_ndrdump_fuzzed_IOXIDResolver_ResolveOxid2(self):
+        expected = '''pull returned Buffer Size Error
+'''
+        try:
+            actual = self.check_exit_code(
+                'ndrdump IOXIDResolver ResolveOxid2 out ' +\
+                '--base64-input --input=' +\
+                'AAAAAQ0K9Q0AAAAAAAAAA6ampqampqampqampqampqampqampqamNAAAAAAtNDQ=',
+                2)
+        except BlackboxProcessError as e:
+            self.fail(e)
+        self.assertRegex(actual.decode('utf8'), expected + "$")
+
+    def test_ndrdump_fuzzed_IOXIDResolver_ServerAlive2(self):
+        expected = b'''pull returned Success
+WARNING! 46 unread bytes
+[0000] 0D 36 0A 0A 0A 0A 0A 00   00 00 00 00 00 00 03 00   .6...... ........
+[0010] 00 00 01 00 00 33 39 36   31 36 31 37 37 36 38 34   .....396 16177684
+[0020] 32 34 FC 85 AC 49 0B 61   87 0A 0A 0A F5 00         24...I.a ......
+    ServerAlive: struct ServerAlive
+        out: struct ServerAlive
+            result                   : DOS code 0x01000000
+dump OK
+'''
+        try:
+            actual = self.check_output(
+                'ndrdump IOXIDResolver ServerAlive out ' +\
+                '--base64-input --input=' +\
+                'AAAAAQ02CgoKCgoAAAAAAAAAAwAAAAEAADM5NjE2MTc3Njg0MjT8haxJC2GHCgoK9QA=')
+        except BlackboxProcessError as e:
+            self.fail(e)
+        self.assertEqual(actual, expected)
+
+    def test_ndrdump_fuzzed_IRemoteActivation_RemoteActivation(self):
+        expected = '''pull returned Buffer Size Error
+'''
+        try:
+            actual = self.check_exit_code(
+                'ndrdump IRemoteActivation RemoteActivation out ' +\
+                '--base64-input --input=' +\
+                'AAAAAQAAAAAAAABKAAD/AAAAAP4AAAAAAAAASgAAAAAAAAABIiIjIiIiIiIiIiIiIiMiAAAAAAD/AAAAAAAA',
+                2)
+        except BlackboxProcessError as e:
+            self.fail(e)
+        self.assertRegex(actual.decode('utf8'), expected + "$")
+
+    def test_ndrdump_fuzzed_ntlmsssp_AUTHENTICATE_MESSAGE(self):
+        expected = open(self.data_path("fuzzed_ntlmssp-AUTHENTICATE_MESSAGE.txt")).read()
+        try:
+            actual = self.check_output(
+                "ndrdump ntlmssp AUTHENTICATE_MESSAGE struct --base64-input %s --validate" %
+                self.data_path("fuzzed_ntlmssp-AUTHENTICATE_MESSAGE.b64.txt"))
+        except BlackboxProcessError as e:
+            self.fail(e)
+        # check_output will return bytes
+        # convert expected to bytes for python 3
+        self.assertEqual(actual, expected.encode('utf-8'))
+
+    def test_ndrdump_fuzzed_PackagesBlob(self):
+        expected = 'ndr_pull_string: ndr_pull_error\\(Buffer Size Error\\):'
+        command = (
+            "ndrdump drsblobs package_PackagesBlob struct --input='aw=='"
+            " --base64-input")
+        try:
+            actual = self.check_exit_code(command, 2)
+        except BlackboxProcessError as e:
+            self.fail(e)
+        # check_output will return bytes
+        # convert expected to bytes for python 3
+        self.assertRegex(actual.decode('utf8'), expected)
+
+    def test_ndrdump_fuzzed_drsuapi_DsAddEntry_1(self):
+        expected = open(self.data_path("fuzzed_drsuapi_DsAddEntry_1.txt")).read()
+        try:
+            actual = self.check_output(
+                "ndrdump drsuapi drsuapi_DsAddEntry in --base64-input --validate %s" %
+                self.data_path("fuzzed_drsuapi_DsAddEntry_1.b64.txt"))
+        except BlackboxProcessError as e:
+            self.fail(e)
+        # check_output will return bytes
+        # convert expected to bytes for python 3
+        self.assertEqual(actual, expected.encode('utf-8'))
+
+    def test_ndrdump_fuzzed_drsuapi_DsReplicaAttribute(self):
+        expected = open(self.data_path("fuzzed_drsuapi_DsReplicaAttribute.txt")).read()
+        try:
+            actual = self.check_output(
+                "ndrdump drsuapi drsuapi_DsReplicaAttribute struct --base64-input --validate %s" %
+                self.data_path("fuzzed_drsuapi_DsReplicaAttribute.b64.txt"))
+        except BlackboxProcessError as e:
+            self.fail(e)
+        # check_output will return bytes
+        # convert expected to bytes for python 3
+        self.assertEqual(actual, expected.encode('utf-8'))
+
+    # This is a good example of a union with an empty default
+    # and no buffers to parse.
+    def test_ndrdump_fuzzed_spoolss_EnumForms(self):
+        expected_head = b'''pull returned Success
+WARNING! 2 unread bytes
+[0000] 00 00                                              .. ''' b'''
+    spoolss_EnumForms: struct spoolss_EnumForms
+        out: struct spoolss_EnumForms
+            count                    : *
+                count                    : 0x00000100 (256)
+            info                     : *
+                info                     : *
+                    info: ARRAY(256)
+                        info                     : union spoolss_FormInfo(case 0)
+                        info                     : union spoolss_FormInfo(case 0)
+'''
+        expected_tail = b'''info                     : union spoolss_FormInfo(case 0)
+                        info                     : union spoolss_FormInfo(case 0)
+                        info                     : union spoolss_FormInfo(case 0)
+                        info                     : union spoolss_FormInfo(case 0)
+                        info                     : union spoolss_FormInfo(case 0)
+                        info                     : union spoolss_FormInfo(case 0)
+            needed                   : *
+                needed                   : 0x00000000 (0)
+            result                   : DOS code 0xa9a9a900
+dump OK
+'''
+        try:
+            actual = self.check_output(
+                "ndrdump spoolss spoolss_EnumForms out --base64-input " +\
+                "--input AAAAAQAAAAAAAAAAAAEAAACpqakAAA="
+                )
+        except BlackboxProcessError as e:
+            self.fail(e)
+        self.assertEqual(actual[:len(expected_head)],
+                         expected_head)
+        self.assertTrue(actual.endswith(expected_tail))
+
+    # This is a good example of a union with scalars and buffers
+    def test_ndrdump_xattr_NTACL(self):
+
+        expected_head =  open(self.data_path("xattr_NTACL.txt")).read().encode('utf8')
+        expected_tail = b'''dump OK
+'''
+        try:
+            actual = self.check_output(
+                "ndrdump xattr xattr_NTACL struct --hex-input %s --validate" %
+                self.data_path("xattr_NTACL.dat"))
+        except BlackboxProcessError as e:
+            self.fail(e)
+
+        self.assertEqual(actual[:len(expected_head)],
+                         expected_head)
+        self.assertTrue(actual.endswith(expected_tail))
+
+    # Confirm parsing of dnsProperty records
+    def test_ndrdump_dnsp_DnssrvRpcRecord(self):
+
+        expected = open(self.data_path("dnsp-DnssrvRpcRecord.txt")).read().encode('utf8')
+        try:
+            actual = self.check_output(
+                "ndrdump dnsp dnsp_DnssrvRpcRecord struct " +\
+                "--input BQAPAAXwAAC3AAAAAAADhAAAAAAAAAAAAAoBAAA= "+\
+                "--base64-input --validate")
+        except BlackboxProcessError as e:
+            self.fail(e)
+
+        self.assertEqual(actual, expected)
+
+    # Test a --validate push of a NULL union pointer
+    def test_ndrdump_fuzzed_NULL_union_PAC_BUFFER(self):
+        expected = b'''pull returned Success
+WARNING! 13 unread bytes
+[0000] F5 FF 00 3C 3C 25 FF 70   16 1F A0 12 84            ...<<%.p .....
+    PAC_BUFFER: struct PAC_BUFFER
+        type                     : UNKNOWN_ENUM_VALUE (1094251328)
+        _ndr_size                : 0x048792c6 (75993798)
+        info                     : NULL
+        _pad                     : 0x06000000 (100663296)
+push returned Success
+pull returned Success
+    PAC_BUFFER: struct PAC_BUFFER
+        type                     : UNKNOWN_ENUM_VALUE (1094251328)
+        _ndr_size                : 0x00000000 (0)
+        info                     : NULL
+        _pad                     : 0x00000000 (0)
+WARNING! orig bytes:29 validated pushed bytes:16
+WARNING! orig and validated differ at byte 0x04 (4)
+WARNING! orig byte[0x04] = 0xC6 validated byte[0x04] = 0x00
+dump OK
+'''
+        try:
+            actual = self.check_output(
+                "ndrdump krb5pac PAC_BUFFER struct --validate --input " +\
+                "QPM4QcaShwQAAAAAAAAABvX/ADw8Jf9wFh+gEoQ= --base64-input")
+        except BlackboxProcessError as e:
+            self.fail(e)
+
+        self.assertEqual(actual, expected)
+
+    # Test a --validate push of a NULL struct pointer
+    def test_ndrdump_fuzzed_NULL_struct_ntlmssp_CHALLENGE_MESSAGE(self):
+        expected =  open(self.data_path("fuzzed_ntlmssp-CHALLENGE_MESSAGE.txt")).read().encode('utf8')
+        try:
+            actual = self.check_exit_code(
+                "ndrdump ntlmssp CHALLENGE_MESSAGE struct --validate --input " +\
+                "'AAAACwIAAAAAJwIAAAAAAAcAAAAAAAAAAIAbhG8uyk9dAL0mQE73MAAAAAAAAAAA' --base64-input",
+                1)
+        except BlackboxProcessError as e:
+            self.fail(e)
+
+        self.assertEqual(actual, expected)
+
+    # Test a print of NULL pointer in manually-written ndr_drsuapi.c
+    def test_fuzzed_drsuapi_DsGetNCChanges(self):
+        expected =  open(self.data_path("fuzzed_drsuapi_DsGetNCChanges.txt"), 'rb').read()
+        try:
+            actual = self.check_output(
+                "ndrdump drsuapi 3 out --base64-input --input " +\
+                "AQAAAAEAAAAGAKoAAAAGAKoGAAMAAQAAAAYAEwAAAAAAAAAA/wAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAABbAAAAAAAAAAAAAAkRAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPkAAAAAAAABAAD4BgATAAAAAAAAAAD/AAAAAAAAAD8AAAAAAAAAAAAAAAAAAAAAAFsAAAAAAAAAAAAABgAQAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAMAAAABAAAACREAAAEAAAABAAAAAAAAAAYAEAABAAgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAA=")
+        except BlackboxProcessError as e:
+            self.fail(e)
+
+        self.assertEqual(actual, expected)
diff --git a/python/samba/tests/dcerpc/dnsserver.py b/python/samba/tests/dcerpc/dnsserver.py
index 0da9614d066..c6a150c876f 100644
--- a/python/samba/tests/dcerpc/dnsserver.py
+++ b/python/samba/tests/dcerpc/dnsserver.py
@@ -156,6 +156,154 @@ class DnsserverTests(RpcInterfaceTestCase):
                                    None)
         super(DnsserverTests, self).tearDown()
 
+    def test_enum_is_sorted(self):
+        """
+        Confirm the zone is sorted
+        """
+
+        record_str = "192.168.50.50"
+        record_type_str = "A"
+        self.add_record(self.custom_zone, "atestrecord-1", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-2", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-3", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-4", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-0", record_type_str, record_str)
+
+        # This becomes an extra A on the zone itself by server-side magic
+        self.add_record(self.custom_zone, self.custom_zone, record_type_str, record_str)
+
+        _, result = self.conn.DnssrvEnumRecords2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
+                                                 0,
+                                                 self.server,
+                                                 self.custom_zone,
+                                                 "@",
+                                                 None,
+                                                 self.record_type_int(record_type_str),
+                                                 dnsserver.DNS_RPC_VIEW_AUTHORITY_DATA,
+                                                 None,
+                                                 None)
+
+        self.assertEqual(len(result.rec), 6)
+        self.assertEqual(result.rec[0].dnsNodeName.str, "")
+        self.assertEqual(result.rec[1].dnsNodeName.str, "atestrecord-0")
+        self.assertEqual(result.rec[2].dnsNodeName.str, "atestrecord-1")
+        self.assertEqual(result.rec[3].dnsNodeName.str, "atestrecord-2")
+        self.assertEqual(result.rec[4].dnsNodeName.str, "atestrecord-3")
+        self.assertEqual(result.rec[5].dnsNodeName.str, "atestrecord-4")
+
+    def test_enum_is_sorted_with_zone_dup(self):
+        """
+        Confirm the zone is sorted
+        """
+
+        record_str = "192.168.50.50"
+        record_type_str = "A"
+        self.add_record(self.custom_zone, "atestrecord-1", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-2", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-3", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-4", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-0", record_type_str, record_str)
+
+        # This triggers a bug in old Samba
+        self.add_record(self.custom_zone, self.custom_zone + "1", record_type_str, record_str)
+
+        dn, record = self.get_record_from_db(self.custom_zone, self.custom_zone + "1")
+
+        new_dn = ldb.Dn(self.samdb, str(dn))
+        new_dn.set_component(0, "dc", self.custom_zone)
+        self.samdb.rename(dn, new_dn)
+
+        _, result = self.conn.DnssrvEnumRecords2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
+                                                 0,
+                                                 self.server,
+                                                 self.custom_zone,
+                                                 "@",
+                                                 None,
+                                                 self.record_type_int(record_type_str),
+                                                 dnsserver.DNS_RPC_VIEW_AUTHORITY_DATA,
+                                                 None,
+                                                 None)
+
+        self.assertEqual(len(result.rec), 7)
+        self.assertEqual(result.rec[0].dnsNodeName.str, "")
+        self.assertEqual(result.rec[1].dnsNodeName.str, "atestrecord-0")
+        self.assertEqual(result.rec[2].dnsNodeName.str, "atestrecord-1")
+        self.assertEqual(result.rec[3].dnsNodeName.str, "atestrecord-2")
+        self.assertEqual(result.rec[4].dnsNodeName.str, "atestrecord-3")
+        self.assertEqual(result.rec[5].dnsNodeName.str, "atestrecord-4")
+
+        # Windows doesn't reload the zone fast enough, but doesn't
+        # have the bug anyway, it will sort last on both names (where
+        # it should)
+        if result.rec[6].dnsNodeName.str != (self.custom_zone + "1"):
+            self.assertEqual(result.rec[6].dnsNodeName.str, self.custom_zone)
+
+    def test_enum_is_sorted_children_prefix_first(self):
+        """
+        Confirm the zone returns the selected prefix first but no more
+        as Samba is flappy for the full sort
+        """
+
+        record_str = "192.168.50.50"
+        record_type_str = "A"
+        self.add_record(self.custom_zone, "atestrecord-1.a.b", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-2.a.b", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-3.a.b", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-4.a.b", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-0.a.b", record_type_str, record_str)
+
+        # Not expected to be returned
+        self.add_record(self.custom_zone, "atestrecord-0.b.b", record_type_str, record_str)
+
+        _, result = self.conn.DnssrvEnumRecords2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
+                                                 0,
+                                                 self.server,
+                                                 self.custom_zone,
+                                                 "a.b",
+                                                 None,
+                                                 self.record_type_int(record_type_str),
+                                                 dnsserver.DNS_RPC_VIEW_AUTHORITY_DATA,
+                                                 None,
+                                                 None)
+
+        self.assertEqual(len(result.rec), 6)
+        self.assertEqual(result.rec[0].dnsNodeName.str, "")
+
+    def test_enum_is_sorted_children(self):
+        """
+        Confirm the zone is sorted
+        """
+
+        record_str = "192.168.50.50"
+        record_type_str = "A"
+        self.add_record(self.custom_zone, "atestrecord-1.a.b", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-2.a.b", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-3.a.b", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-4.a.b", record_type_str, record_str)
+        self.add_record(self.custom_zone, "atestrecord-0.a.b", record_type_str, record_str)
+
+        # Not expected to be returned
+        self.add_record(self.custom_zone, "atestrecord-0.b.b", record_type_str, record_str)
+
+        _, result = self.conn.DnssrvEnumRecords2(dnsserver.DNS_CLIENT_VERSION_LONGHORN,
+                                                 0,
+                                                 self.server,
+                                                 self.custom_zone,
+                                                 "a.b",
+                                                 None,
+                                                 self.record_type_int(record_type_str),
+                                                 dnsserver.DNS_RPC_VIEW_AUTHORITY_DATA,
+                                                 None,
+                                                 None)
+
+        self.assertEqual(len(result.rec), 6)
+        self.assertEqual(result.rec[0].dnsNodeName.str, "")
+        self.assertEqual(result.rec[1].dnsNodeName.str, "atestrecord-0")
+        self.assertEqual(result.rec[2].dnsNodeName.str, "atestrecord-1")
+        self.assertEqual(result.rec[3].dnsNodeName.str, "atestrecord-2")
+        self.assertEqual(result.rec[4].dnsNodeName.str, "atestrecord-3")
+        self.assertEqual(result.rec[5].dnsNodeName.str, "atestrecord-4")
+
     # This test fails against Samba (but passes against Windows),
     # because Samba does not return the record when we enum records.
     # Records can be given DNS_RANK_NONE when the zone they are in
diff --git a/python/samba/tests/dns.py b/python/samba/tests/dns.py
index 1dd1f549a33..bc05076c615 100644
--- a/python/samba/tests/dns.py
+++ b/python/samba/tests/dns.py
@@ -1523,26 +1523,51 @@ class TestZones(DNSTest):
         name, txt = 'agingtest', ['test txt']
         name2, txt2 = 'agingtest2', ['test txt2']
         name3, txt3 = 'agingtest3', ['test txt3']
+        name4, txt4 = 'agingtest4', ['test txt4']
+        name5, txt5 = 'agingtest5', ['test txt5']
         self.dns_update_record(name, txt)
         self.dns_update_record(name2, txt)
         self.dns_update_record(name2, txt2)
         self.dns_update_record(name3, txt)
         self.dns_update_record(name3, txt2)
+
+        # Create a tomb stoned record.
+        self.dns_update_record(name4, txt4)
+        self.dns_tombstone(name4, txt4, self.zone)
+        records = self.ldap_get_records(name4)
+        self.assertTrue("dNSTombstoned" in records[0])
+        self.assertEqual(records[0]["dNSTombstoned"][0], b"TRUE")
+
+        # Create an un-tombstoned record, with dnsTombstoned: FALSE
+        self.dns_update_record(name5, txt5)
+        self.dns_tombstone(name5, txt5, self.zone)
+        self.dns_update_record(name5, txt5)
+        records = self.ldap_get_records(name5)
+        self.assertTrue("dNSTombstoned" in records[0])
+        self.assertEqual(records[0]["dNSTombstoned"][0], b"FALSE")
+
         last_add = self.dns_update_record(name3, txt3)
 
         def mod_ts(rec):
             self.assertTrue(rec.dwTimeStamp > 0)
             if rec.data.str == txt:
                 rec.dwTimeStamp -= interval * 5
+
+        def mod_ts_all(rec):
+            rec.dwTimeStamp -= interval * 5
         self.ldap_modify_dnsrecs(name, mod_ts)
         self.ldap_modify_dnsrecs(name2, mod_ts)
         self.ldap_modify_dnsrecs(name3, mod_ts)
+        self.ldap_modify_dnsrecs(name5, mod_ts_all)
         self.assertTrue(callable(getattr(dsdb, '_scavenge_dns_records', None)))
         dsdb._scavenge_dns_records(self.samdb)
 
         recs = self.ldap_get_dns_records(name)
         self.assertEqual(len(recs), 1)
         self.assertEqual(recs[0].wType, dnsp.DNS_TYPE_TOMBSTONE)
+        records = self.ldap_get_records(name)
+        self.assertTrue("dNSTombstoned" in records[0])
+        self.assertEqual(records[0]["dNSTombstoned"][0], b"TRUE")
 
         recs = self.ldap_get_dns_records(name2)
         self.assertEqual(len(recs), 1)
@@ -1556,6 +1581,20 @@ class TestZones(DNSTest):
         self.assertEqual(recs[0].wType, dnsp.DNS_TYPE_TXT)
         self.assertEqual(recs[1].wType, dnsp.DNS_TYPE_TXT)
 
+        recs = self.ldap_get_dns_records(name4)
+        self.assertEqual(len(recs), 1)
+        self.assertEqual(recs[0].wType, dnsp.DNS_TYPE_TOMBSTONE)
+        records = self.ldap_get_records(name4)
+        self.assertTrue("dNSTombstoned" in records[0])
+        self.assertEqual(records[0]["dNSTombstoned"][0], b"TRUE")
+
+        recs = self.ldap_get_dns_records(name5)
+        self.assertEqual(len(recs), 1)
+        self.assertEqual(recs[0].wType, dnsp.DNS_TYPE_TOMBSTONE)
+        records = self.ldap_get_records(name5)
+        self.assertTrue("dNSTombstoned" in records[0])
+        self.assertEqual(records[0]["dNSTombstoned"][0], b"TRUE")
+
         for make_it_work in [False, True]:
             inc = -1 if make_it_work else 1
 
diff --git a/python/samba/tests/ntacls.py b/python/samba/tests/ntacls.py
index b345b283a76..44c8e535218 100644
--- a/python/samba/tests/ntacls.py
+++ b/python/samba/tests/ntacls.py
@@ -24,6 +24,7 @@ from samba.ntacls import setntacl, getntacl, XattrBackendError
 from samba.param import LoadParm
 from samba.dcerpc import security
 from samba.tests import TestCaseInTempDir, SkipTest
+from samba.auth_util import system_session_unix
 
 NTACL_SDDL = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
 DOMAIN_SID = "S-1-5-21-2212615479-2695158682-2101375467"
@@ -35,6 +36,7 @@ class NtaclsTests(TestCaseInTempDir):
         super(NtaclsTests, self).setUp()
         self.tempf = os.path.join(self.tempdir, "test")
         open(self.tempf, 'w').write("empty")
+        self.session_info = system_session_unix()
 
     def tearDown(self):
         os.unlink(self.tempf)
@@ -44,15 +46,15 @@ class NtaclsTests(TestCaseInTempDir):
         lp = LoadParm()
         open(self.tempf, 'w').write("empty")
         lp.set("posix:eadb", os.path.join(self.tempdir, "eadbtest.tdb"))
-        setntacl(lp, self.tempf, NTACL_SDDL, DOMAIN_SID)
+        setntacl(lp, self.tempf, NTACL_SDDL, DOMAIN_SID, self.session_info)
         os.unlink(os.path.join(self.tempdir, "eadbtest.tdb"))
 
     def test_setntacl_getntacl(self):
         lp = LoadParm()
         open(self.tempf, 'w').write("empty")
         lp.set("posix:eadb", os.path.join(self.tempdir, "eadbtest.tdb"))
-        setntacl(lp, self.tempf, NTACL_SDDL, DOMAIN_SID)
-        facl = getntacl(lp, self.tempf)
+        setntacl(lp, self.tempf, NTACL_SDDL, DOMAIN_SID, self.session_info)
+        facl = getntacl(lp, self.tempf, self.session_info)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(facl.as_sddl(anysid), NTACL_SDDL)
         os.unlink(os.path.join(self.tempdir, "eadbtest.tdb"))
@@ -60,9 +62,9 @@ class NtaclsTests(TestCaseInTempDir):
     def test_setntacl_getntacl_param(self):
         lp = LoadParm()
         open(self.tempf, 'w').write("empty")
-        setntacl(lp, self.tempf, NTACL_SDDL, DOMAIN_SID, "tdb",
+        setntacl(lp, self.tempf, NTACL_SDDL, DOMAIN_SID, self.session_info, "tdb",
                  os.path.join(self.tempdir, "eadbtest.tdb"))
-        facl = getntacl(lp, self.tempf, "tdb", os.path.join(
+        facl = getntacl(lp, self.tempf, self.session_info, "tdb", os.path.join(
             self.tempdir, "eadbtest.tdb"))
         domsid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(facl.as_sddl(domsid), NTACL_SDDL)
@@ -72,7 +74,7 @@ class NtaclsTests(TestCaseInTempDir):
         lp = LoadParm()
         open(self.tempf, 'w').write("empty")
         self.assertRaises(XattrBackendError, setntacl, lp, self.tempf,
-                          NTACL_SDDL, DOMAIN_SID, "ttdb",
+                          NTACL_SDDL, DOMAIN_SID, self.session_info, "ttdb",
                           os.path.join(self.tempdir, "eadbtest.tdb"))
 
     def test_setntacl_forcenative(self):
@@ -82,4 +84,4 @@ class NtaclsTests(TestCaseInTempDir):
         open(self.tempf, 'w').write("empty")
         lp.set("posix:eadb", os.path.join(self.tempdir, "eadbtest.tdb"))
         self.assertRaises(Exception, setntacl, lp, self.tempf, NTACL_SDDL,
-                          DOMAIN_SID, "native")
+                          DOMAIN_SID, self.session_info, "native")
diff --git a/python/samba/tests/ntacls_backup.py b/python/samba/tests/ntacls_backup.py
index d92299187f3..6ac73d4a1b8 100644
--- a/python/samba/tests/ntacls_backup.py
+++ b/python/samba/tests/ntacls_backup.py
@@ -25,6 +25,7 @@ from samba import samdb
 from samba import ntacls
 
 from samba.auth import system_session
+from samba.auth_util import system_session_unix
 from samba.dcerpc import security
 from samba.tests import env_loadparm
 from samba.tests.smbd_base import SmbdBaseTests
@@ -110,7 +111,7 @@ class NtaclsBackupRestoreTests(SmbdBaseTests):
         """
 
         dirpath = os.path.join(self.service_root, 'a-dir')
-        smbd.mkdir(dirpath, self.service)
+        smbd.mkdir(dirpath, system_session_unix(), self.service)
         mode = os.stat(dirpath).st_mode
 
         # This works in conjunction with the TEST_UMASK in smbd_base
@@ -125,7 +126,7 @@ class NtaclsBackupRestoreTests(SmbdBaseTests):
         """
 
         filepath = os.path.join(self.service_root, 'a-file')
-        smbd.create_file(filepath, self.service)
+        smbd.create_file(filepath, system_session_unix(), self.service)
         self.assertTrue(os.path.isfile(filepath))
 
         mode = os.stat(filepath).st_mode
@@ -137,7 +138,7 @@ class NtaclsBackupRestoreTests(SmbdBaseTests):
 
         # As well as checking that unlink works, this removes the
         # fake xattrs from the dev/inode based DB
-        smbd.unlink(filepath, self.service)
+        smbd.unlink(filepath, system_session_unix(), self.service)
         self.assertFalse(os.path.isfile(filepath))
 
     def test_compare_getntacl(self):
@@ -151,10 +152,10 @@ class NtaclsBackupRestoreTests(SmbdBaseTests):
         sd0 = self.smb_helper.get_acl(file_name, as_sddl=True)
 
         sd1 = self.ntacls_helper.getntacl(
-            file_path, as_sddl=True, direct_db_access=False)
+            file_path, system_session_unix(), as_sddl=True, direct_db_access=False)
 
         sd2 = self.ntacls_helper.getntacl(
-            file_path, as_sddl=True, direct_db_access=True)
+            file_path, system_session_unix(), as_sddl=True, direct_db_access=True)
 
         self.assertEquals(sd0, sd1)
         self.assertEquals(sd1, sd2)
diff --git a/python/samba/tests/ntlm_auth.py b/python/samba/tests/ntlm_auth.py
index c93d38a0f0f..4b6fbee8b58 100644
--- a/python/samba/tests/ntlm_auth.py
+++ b/python/samba/tests/ntlm_auth.py
@@ -62,7 +62,7 @@ class NTLMAuthHelpersTests(NTLMAuthTestCase):
                               server_use_winbind=False)
         self.assertTrue(ret)
 
-    def test_agaist_winbind(self):
+    def test_against_winbind(self):
         """ ntlm_auth against winbindd """
 
         ret = self.run_helper(client_username=self.username,
diff --git a/python/samba/tests/posixacl.py b/python/samba/tests/posixacl.py
index 0ba3dc50089..f2734f54120 100644
--- a/python/samba/tests/posixacl.py
+++ b/python/samba/tests/posixacl.py
@@ -27,6 +27,7 @@ from samba.samba3 import smbd, passdb
 from samba.samba3 import param as s3param
 from samba import auth
 from samba.samdb import SamDB
+from samba.auth_util import system_session_unix
 
 DOM_SID = "S-1-5-21-2212615479-2695158682-2101375467"
 ACL = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;OICI;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)"
@@ -45,18 +46,15 @@ class PosixAclMappingTests(SmbdBaseTests):
         self.samdb = SamDB(lp=self.lp, session_info=auth.system_session())
 
     def tearDown(self):
-        smbd.unlink(self.tempf)
+        smbd.unlink(self.tempf, self.get_session_info())
         os.unlink(os.path.join(self.tempdir, "xattr.tdb"))
         super(PosixAclMappingTests, self).tearDown()
 
     def get_session_info(self, domsid=DOM_SID):
         """
         Get session_info for setntacl.
-
-        This test case always return None, to run tests without session_info
-        like before. To be overridden in derived class.
         """
-        return None
+        return system_session_unix()
 
     def print_posix_acl(self, posix_acl):
         aclstr = ""
@@ -71,33 +69,33 @@ class PosixAclMappingTests(SmbdBaseTests):
 
     def test_setntacl(self):
         acl = ACL
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=False,
-                 session_info=self.get_session_info())
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=False)
 
     def test_setntacl_smbd_getntacl(self):
         acl = ACL
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=True,
-                 session_info=self.get_session_info())
-        facl = getntacl(self.lp, self.tempf, direct_db_access=True)
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=True)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=True)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(facl.as_sddl(anysid), acl)
 
     def test_setntacl_smbd_setposixacl_getntacl(self):
         acl = ACL
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=True,
-                 session_info=self.get_session_info())
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=True)
 
         # This will invalidate the ACL, as we have a hook!
-        smbd.set_simple_acl(self.tempf, 0o640)
+        smbd.set_simple_acl(self.tempf, 0o640, self.get_session_info())
 
         # However, this only asks the xattr
         self.assertRaises(
-            TypeError, getntacl, self.lp, self.tempf, direct_db_access=True)
+            TypeError, getntacl, self.lp, self.tempf, self.get_session_info(), direct_db_access=True)
 
     def test_setntacl_invalidate_getntacl(self):
         acl = ACL
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=True,
-                 session_info=self.get_session_info())
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=True)
 
         # This should invalidate the ACL, as we include the posix ACL in the hash
         (backend_obj, dbname) = checkset_backend(self.lp, None, None)
@@ -105,14 +103,14 @@ class PosixAclMappingTests(SmbdBaseTests):
                                   self.tempf, "system.fake_access_acl", b"")
 
         # however, as this is direct DB access, we do not notice it
-        facl = getntacl(self.lp, self.tempf, direct_db_access=True)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=True)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(acl, facl.as_sddl(anysid))
 
     def test_setntacl_invalidate_getntacl_smbd(self):
         acl = ACL
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=False,
-                 session_info=self.get_session_info())
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=False)
 
         # This should invalidate the ACL, as we include the posix ACL in the hash
         (backend_obj, dbname) = checkset_backend(self.lp, None, None)
@@ -120,7 +118,7 @@ class PosixAclMappingTests(SmbdBaseTests):
                                   self.tempf, "system.fake_access_acl", b"")
 
         # the hash would break, and we return an ACL based only on the mode, except we set the ACL using the 'ntvfs' mode that doesn't include a hash
-        facl = getntacl(self.lp, self.tempf)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info())
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(acl, facl.as_sddl(anysid))
 
@@ -128,8 +126,8 @@ class PosixAclMappingTests(SmbdBaseTests):
         acl = ACL
         simple_acl_from_posix = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;;0x001f01ff;;;S-1-5-21-2212615479-2695158682-2101375467-512)(A;;0x001200a9;;;S-1-5-21-2212615479-2695158682-2101375467-513)(A;;;;;WD)"
         os.chmod(self.tempf, 0o750)
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=False,
-                 session_info=self.get_session_info())
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=False)
 
         # This should invalidate the ACL, as we include the posix ACL in the hash
         (backend_obj, dbname) = checkset_backend(self.lp, None, None)
@@ -137,34 +135,34 @@ class PosixAclMappingTests(SmbdBaseTests):
                                   self.tempf, "system.fake_access_acl", b"")
 
         # the hash will break, and we return an ACL based only on the mode
-        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=False)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(simple_acl_from_posix, facl.as_sddl(anysid))
 
     def test_setntacl_getntacl_smbd(self):
         acl = ACL
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=True,
-                 session_info=self.get_session_info())
-        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=True)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=False)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(facl.as_sddl(anysid), acl)
 
     def test_setntacl_smbd_getntacl_smbd(self):
         acl = ACL
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=False,
-                 session_info=self.get_session_info())
-        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=False)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=False)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(facl.as_sddl(anysid), acl)
 
     def test_setntacl_smbd_setposixacl_getntacl_smbd(self):
         acl = ACL
         simple_acl_from_posix = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;;0x001f019f;;;S-1-5-21-2212615479-2695158682-2101375467-512)(A;;0x00120089;;;S-1-5-21-2212615479-2695158682-2101375467-513)(A;;;;;WD)"
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=False,
-                 session_info=self.get_session_info())
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=False)
         # This invalidates the hash of the NT acl just set because there is a hook in the posix ACL set code
-        smbd.set_simple_acl(self.tempf, 0o640)
-        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
+        smbd.set_simple_acl(self.tempf, 0o640, self.get_session_info())
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=False)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(simple_acl_from_posix, facl.as_sddl(anysid))
 
@@ -172,46 +170,46 @@ class PosixAclMappingTests(SmbdBaseTests):
         acl = ACL
         BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
         simple_acl_from_posix = "O:S-1-5-21-2212615479-2695158682-2101375467-512G:S-1-5-21-2212615479-2695158682-2101375467-513D:(A;;0x001f019f;;;S-1-5-21-2212615479-2695158682-2101375467-512)(A;;0x00120089;;;BA)(A;;0x00120089;;;S-1-5-21-2212615479-2695158682-2101375467-513)(A;;;;;WD)"
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=False,
-                 session_info=self.get_session_info())
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=False)
         # This invalidates the hash of the NT acl just set because there is a hook in the posix ACL set code
         s4_passdb = passdb.PDB(self.lp.get("passdb backend"))
         (BA_gid, BA_type) = s4_passdb.sid_to_id(BA_sid)
-        smbd.set_simple_acl(self.tempf, 0o640, BA_gid)
+        smbd.set_simple_acl(self.tempf, 0o640, self.get_session_info(), BA_gid)
 
         # This should re-calculate an ACL based on the posix details
-        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=False)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(simple_acl_from_posix, facl.as_sddl(anysid))
 
     def test_setntacl_smbd_getntacl_smbd_gpo(self):
         acl = "O:DAG:DUD:P(A;OICI;0x001f01ff;;;DA)(A;OICI;0x001f01ff;;;EA)(A;OICIIO;0x001f01ff;;;CO)(A;OICI;0x001f01ff;;;DA)(A;OICI;0x001f01ff;;;SY)(A;OICI;0x001200a9;;;AU)(A;OICI;0x001200a9;;;ED)S:AI(OU;CIIDSA;WP;f30e3bbe-9ff0-11d1-b603-0000f80367c1;bf967aa5-0de6-11d0-a285-00aa003049e2;WD)(OU;CIIDSA;WP;f30e3bbf-9ff0-11d1-b603-0000f80367c1;bf967aa5-0de6-11d0-a285-00aa003049e2;WD)"
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=False,
-                 session_info=self.get_session_info())
-        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=False)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=False)
         domsid = security.dom_sid(DOM_SID)
         self.assertEquals(facl.as_sddl(domsid), acl)
 
     def test_setntacl_getposixacl(self):
         acl = ACL
-        setntacl(self.lp, self.tempf, acl, DOM_SID, use_ntvfs=False,
-                 session_info=self.get_session_info())
-        facl = getntacl(self.lp, self.tempf)
+        setntacl(self.lp, self.tempf, acl, DOM_SID,
+                 self.get_session_info(), use_ntvfs=False)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info())
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(facl.as_sddl(anysid), acl)
-        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)
+        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS, self.get_session_info())
 
     def test_setposixacl_getntacl(self):
-        smbd.set_simple_acl(self.tempf, 0o750)
+        smbd.set_simple_acl(self.tempf, 0o750, self.get_session_info())
         # We don't expect the xattr to be filled in in this case
-        self.assertRaises(TypeError, getntacl, self.lp, self.tempf)
+        self.assertRaises(TypeError, getntacl, self.lp, self.tempf, self.get_session_info())
 
     def test_setposixacl_getntacl_smbd(self):
         s4_passdb = passdb.PDB(self.lp.get("passdb backend"))
         group_SID = s4_passdb.gid_to_sid(os.stat(self.tempf).st_gid)
         user_SID = s4_passdb.uid_to_sid(os.stat(self.tempf).st_uid)
-        smbd.set_simple_acl(self.tempf, 0o640)
-        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
+        smbd.set_simple_acl(self.tempf, 0o640, self.get_session_info())
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=False)
         acl = "O:%sG:%sD:(A;;0x001f019f;;;%s)(A;;0x00120089;;;%s)(A;;;;;WD)" % (user_SID, group_SID, user_SID, group_SID)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(acl, facl.as_sddl(anysid))
@@ -226,9 +224,9 @@ class PosixAclMappingTests(SmbdBaseTests):
         SO_sid = security.dom_sid(security.SID_BUILTIN_SERVER_OPERATORS)
         (SO_id, SO_type) = s4_passdb.sid_to_id(SO_sid)
         self.assertEquals(SO_type, idmap.ID_TYPE_BOTH)
-        smbd.chown(self.tempdir, BA_id, SO_id)
-        smbd.set_simple_acl(self.tempdir, 0o750)
-        facl = getntacl(self.lp, self.tempdir, direct_db_access=False)
+        smbd.chown(self.tempdir, BA_id, SO_id, self.get_session_info())
+        smbd.set_simple_acl(self.tempdir, 0o750, self.get_session_info())
+        facl = getntacl(self.lp, self.tempdir, self.get_session_info(), direct_db_access=False)
         acl = "O:BAG:SOD:(A;;0x001f01ff;;;BA)(A;;0x001200a9;;;SO)(A;;;;;WD)(A;OICIIO;0x001f01ff;;;CO)(A;OICIIO;0x001200a9;;;CG)(A;OICIIO;0x001200a9;;;WD)"
 
         anysid = security.dom_sid(security.SID_NT_SELF)
@@ -241,16 +239,16 @@ class PosixAclMappingTests(SmbdBaseTests):
         group_SID = s4_passdb.gid_to_sid(os.stat(self.tempf).st_gid)
         user_SID = s4_passdb.uid_to_sid(os.stat(self.tempf).st_uid)
         self.assertEquals(BA_type, idmap.ID_TYPE_BOTH)
-        smbd.set_simple_acl(self.tempf, 0o640, BA_gid)
-        facl = getntacl(self.lp, self.tempf, direct_db_access=False)
+        smbd.set_simple_acl(self.tempf, 0o640, self.get_session_info(), BA_gid)
+        facl = getntacl(self.lp, self.tempf, self.get_session_info(), direct_db_access=False)
         domsid = passdb.get_global_sam_sid()
         acl = "O:%sG:%sD:(A;;0x001f019f;;;%s)(A;;0x00120089;;;BA)(A;;0x00120089;;;%s)(A;;;;;WD)" % (user_SID, group_SID, user_SID, group_SID)
         anysid = security.dom_sid(security.SID_NT_SELF)
         self.assertEquals(acl, facl.as_sddl(anysid))
 
     def test_setposixacl_getposixacl(self):
-        smbd.set_simple_acl(self.tempf, 0o640)
-        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)
+        smbd.set_simple_acl(self.tempf, 0o640, self.get_session_info())
+        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS, self.get_session_info())
         self.assertEquals(posix_acl.count, 4, self.print_posix_acl(posix_acl))
 
         self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_USER_OBJ)
@@ -266,8 +264,8 @@ class PosixAclMappingTests(SmbdBaseTests):
         self.assertEquals(posix_acl.acl[3].a_perm, 7)
 
     def test_setposixacl_dir_getposixacl(self):
-        smbd.set_simple_acl(self.tempdir, 0o750)
-        posix_acl = smbd.get_sys_acl(self.tempdir, smb_acl.SMB_ACL_TYPE_ACCESS)
+        smbd.set_simple_acl(self.tempdir, 0o750, self.get_session_info())
+        posix_acl = smbd.get_sys_acl(self.tempdir, smb_acl.SMB_ACL_TYPE_ACCESS, self.get_session_info())
         self.assertEquals(posix_acl.count, 4, self.print_posix_acl(posix_acl))
 
         self.assertEquals(posix_acl.acl[0].a_type, smb_acl.SMB_ACL_USER_OBJ)
@@ -287,8 +285,8 @@ class PosixAclMappingTests(SmbdBaseTests):
         s4_passdb = passdb.PDB(self.lp.get("passdb backend"))
         (BA_gid, BA_type) = s4_passdb.sid_to_id(BA_sid)
         self.assertEquals(BA_type, idmap.ID_TYPE_BOTH)
-        smbd.set_simple_acl(self.tempf, 0o670, BA_gid)
-        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)
+        smbd.set_simple_acl(self.tempf, 0o670, self.get_session_info(), BA_gid)
+        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS, self.get_session_info())
 
         self.assertEquals(posix_acl.count, 5, self.print_posix_acl(posix_acl))
 
@@ -312,17 +310,18 @@ class PosixAclMappingTests(SmbdBaseTests):
         acl = provision.SYSVOL_ACL
         domsid = passdb.get_global_sam_sid()
         session_info = self.get_session_info(domsid)
-        setntacl(self.lp, self.tempf, acl, str(domsid), use_ntvfs=False,
-                 session_info=session_info)
-        facl = getntacl(self.lp, self.tempf)
+        setntacl(self.lp, self.tempf, acl, str(domsid),
+                 session_info, use_ntvfs=False)
+        facl = getntacl(self.lp, self.tempf, session_info)
         self.assertEquals(facl.as_sddl(domsid), acl)
-        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)
+        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS, session_info)
 
         nwrap_module_so_path = os.getenv('NSS_WRAPPER_MODULE_SO_PATH')
         nwrap_module_fn_prefix = os.getenv('NSS_WRAPPER_MODULE_FN_PREFIX')
 
         nwrap_winbind_active = (nwrap_module_so_path != "" and
                                 nwrap_module_fn_prefix == "winbind")
+        is_user_session = not session_info.security_token.is_system()
 
         LA_sid = security.dom_sid(str(domsid) + "-" + str(security.DOMAIN_RID_ADMINISTRATOR))
         BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
@@ -353,7 +352,7 @@ class PosixAclMappingTests(SmbdBaseTests):
         self.assertEquals(posix_acl.acl[0].info.gid, BA_gid)
 
         self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_USER)
-        if nwrap_winbind_active or session_info:
+        if nwrap_winbind_active or is_user_session:
             self.assertEquals(posix_acl.acl[1].a_perm, 7)
         else:
             self.assertEquals(posix_acl.acl[1].a_perm, 6)
@@ -363,7 +362,7 @@ class PosixAclMappingTests(SmbdBaseTests):
         self.assertEquals(posix_acl.acl[2].a_perm, 0)
 
         self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_USER_OBJ)
-        if nwrap_winbind_active or session_info:
+        if nwrap_winbind_active or is_user_session:
             self.assertEquals(posix_acl.acl[3].a_perm, 7)
         else:
             self.assertEquals(posix_acl.acl[3].a_perm, 6)
@@ -455,11 +454,11 @@ class PosixAclMappingTests(SmbdBaseTests):
         acl = provision.SYSVOL_ACL
         domsid = passdb.get_global_sam_sid()
         session_info = self.get_session_info(domsid)
-        setntacl(self.lp, self.tempdir, acl, str(domsid), use_ntvfs=False,
-                 session_info=session_info)
-        facl = getntacl(self.lp, self.tempdir)
+        setntacl(self.lp, self.tempdir, acl, str(domsid),
+                 session_info, use_ntvfs=False)
+        facl = getntacl(self.lp, self.tempdir, session_info)
         self.assertEquals(facl.as_sddl(domsid), acl)
-        posix_acl = smbd.get_sys_acl(self.tempdir, smb_acl.SMB_ACL_TYPE_ACCESS)
+        posix_acl = smbd.get_sys_acl(self.tempdir, smb_acl.SMB_ACL_TYPE_ACCESS, session_info)
 
         LA_sid = security.dom_sid(str(domsid) + "-" + str(security.DOMAIN_RID_ADMINISTRATOR))
         BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
@@ -548,11 +547,11 @@ class PosixAclMappingTests(SmbdBaseTests):
         acl = provision.POLICIES_ACL
         domsid = passdb.get_global_sam_sid()
         session_info = self.get_session_info(domsid)
-        setntacl(self.lp, self.tempdir, acl, str(domsid), use_ntvfs=False,
-                 session_info=session_info)
-        facl = getntacl(self.lp, self.tempdir)
+        setntacl(self.lp, self.tempdir, acl, str(domsid),
+                 session_info, use_ntvfs=False)
+        facl = getntacl(self.lp, self.tempdir, session_info)
         self.assertEquals(facl.as_sddl(domsid), acl)
-        posix_acl = smbd.get_sys_acl(self.tempdir, smb_acl.SMB_ACL_TYPE_ACCESS)
+        posix_acl = smbd.get_sys_acl(self.tempdir, smb_acl.SMB_ACL_TYPE_ACCESS, session_info)
 
         LA_sid = security.dom_sid(str(domsid) + "-" + str(security.DOMAIN_RID_ADMINISTRATOR))
         BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
@@ -654,17 +653,18 @@ class PosixAclMappingTests(SmbdBaseTests):
 
         domsid = passdb.get_global_sam_sid()
         session_info = self.get_session_info(domsid)
-        setntacl(self.lp, self.tempf, acl, str(domsid), use_ntvfs=False,
-                 session_info=session_info)
-        facl = getntacl(self.lp, self.tempf)
+        setntacl(self.lp, self.tempf, acl, str(domsid),
+                 session_info, use_ntvfs=False)
+        facl = getntacl(self.lp, self.tempf, session_info)
         self.assertEquals(facl.as_sddl(domsid), acl)
-        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS)
+        posix_acl = smbd.get_sys_acl(self.tempf, smb_acl.SMB_ACL_TYPE_ACCESS, session_info)
 
         nwrap_module_so_path = os.getenv('NSS_WRAPPER_MODULE_SO_PATH')
         nwrap_module_fn_prefix = os.getenv('NSS_WRAPPER_MODULE_FN_PREFIX')
 
         nwrap_winbind_active = (nwrap_module_so_path != "" and
                                 nwrap_module_fn_prefix == "winbind")
+        is_user_session = not session_info.security_token.is_system()
 
         LA_sid = security.dom_sid(str(domsid) + "-" + str(security.DOMAIN_RID_ADMINISTRATOR))
         BA_sid = security.dom_sid(security.SID_BUILTIN_ADMINISTRATORS)
@@ -698,7 +698,7 @@ class PosixAclMappingTests(SmbdBaseTests):
         self.assertEquals(posix_acl.acl[0].info.gid, BA_gid)
 
         self.assertEquals(posix_acl.acl[1].a_type, smb_acl.SMB_ACL_USER)
-        if nwrap_winbind_active or session_info:
+        if nwrap_winbind_active or is_user_session:
             self.assertEquals(posix_acl.acl[1].a_perm, 7)
         else:
             self.assertEquals(posix_acl.acl[1].a_perm, 6)
@@ -708,7 +708,7 @@ class PosixAclMappingTests(SmbdBaseTests):
         self.assertEquals(posix_acl.acl[2].a_perm, 0)
 
         self.assertEquals(posix_acl.acl[3].a_type, smb_acl.SMB_ACL_USER_OBJ)
-        if nwrap_winbind_active or session_info:
+        if nwrap_winbind_active or is_user_session:
             self.assertEquals(posix_acl.acl[3].a_perm, 7)
         else:
             self.assertEquals(posix_acl.acl[3].a_perm, 6)
diff --git a/python/samba/tests/samba_tool/computer.py b/python/samba/tests/samba_tool/computer.py
index 6b06d4f32f6..9912fd408a4 100644
--- a/python/samba/tests/samba_tool/computer.py
+++ b/python/samba/tests/samba_tool/computer.py
@@ -190,6 +190,45 @@ class ComputerCmdTestCase(SambaToolCmdTest):
             found = self.assertMatch(out, str(name),
                                      "computer '%s' not found" % name)
 
+    def test_list_full_dn(self):
+        (result, out, err) = self.runsubcmd("computer", "list", "--full-dn")
+        self.assertCmdSuccess(result, out, err, "Error running list")
+
+        search_filter = ("(sAMAccountType=%u)" %
+                         dsdb.ATYPE_WORKSTATION_TRUST)
+
+        computerlist = self.samdb.search(base=self.samdb.domain_dn(),
+                                         scope=ldb.SCOPE_SUBTREE,
+                                         expression=search_filter,
+                                         attrs=[])
+
+        self.assertTrue(len(computerlist) > 0, "no computers found in samdb")
+
+        for computerobj in computerlist:
+            name = computerobj.get("dn", idx=0)
+            found = self.assertMatch(out, str(name),
+                                     "computer '%s' not found" % name)
+
+    def test_list_base_dn(self):
+        base_dn = str(self.samdb.domain_dn())
+        (result, out, err) = self.runsubcmd("computer", "list", "-b", base_dn)
+        self.assertCmdSuccess(result, out, err, "Error running list")
+
+        search_filter = ("(sAMAccountType=%u)" %
+                         dsdb.ATYPE_WORKSTATION_TRUST)
+
+        computerlist = self.samdb.search(base=base_dn,
+                                         scope=ldb.SCOPE_SUBTREE,
+                                         expression=search_filter,
+                                         attrs=["name"])
+
+        self.assertTrue(len(computerlist) > 0, "no computers found in samdb")
+
+        for computerobj in computerlist:
+            name = computerobj.get("name", idx=0)
+            found = self.assertMatch(out, str(name),
+                                     "computer '%s' not found" % name)
+
     def test_move(self):
         parentou = self._randomOU({"name": "parentOU"})
         (result, out, err) = self._create_ou(parentou)
diff --git a/python/samba/tests/samba_tool/computer_edit.sh b/python/samba/tests/samba_tool/computer_edit.sh
index fb6c668f2a3..7459c396603 100755
--- a/python/samba/tests/samba_tool/computer_edit.sh
+++ b/python/samba/tests/samba_tool/computer_edit.sh
@@ -66,8 +66,7 @@ EOF
 }
 
 get_attribute_base64() {
-	$PYTHON ${STpath}/source4/scripting/bin/samba-tool computer show \
-		testmachine1 --attributes=displayName \
+	${STpath}/bin/ldbsearch '(sAMAccountName=testmachine1$)' displayName \
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
@@ -108,6 +107,12 @@ get_attribute_base64_control() {
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
+get_attribute_force_no_base64() {
+	# LDB_FLAG_FORCE_NO_BASE64_LDIF should be used here.
+	$PYTHON ${STpath}/source4/scripting/bin/samba-tool computer show \
+		testmachine1 --attributes=displayName \
+		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
+}
 
 # Test edit computer - change base64 attribute value including control character
 change_attribute_base64_control() {
@@ -124,12 +129,6 @@ EOF
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
-get_attribute_base64_control() {
-	$PYTHON ${STpath}/source4/scripting/bin/samba-tool computer show \
-		testmachine1 --attributes=displayName \
-		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
-}
-
 # Test edit computer - change attributes with LDB_FLAG_FORCE_NO_BASE64_LDIF
 change_attribute_force_no_base64() {
 	# create editor.sh
@@ -170,7 +169,8 @@ testit "delete_attribute" delete_attribute || failed=`expr $failed + 1`
 testit "add_attribute_base64_control" add_attribute_base64_control || failed=`expr $failed + 1`
 testit_grep "get_attribute_base64_control" "^displayName:: $display_name_con_b64" get_attribute_base64_control || failed=`expr $failed + 1`
 testit "change_attribute_base64_control" change_attribute_base64_control || failed=`expr $failed + 1`
-testit_grep "get_attribute_base64_control" "^displayName:: $display_name_b64" get_attribute_base64_control || failed=`expr $failed + 1`
+testit_grep "get_attribute_base64" "^displayName:: $display_name_b64" get_attribute_base64 || failed=`expr $failed + 1`
+testit_grep "get_attribute_force_no_base64" "^displayName: $display_name" get_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit "change_attribute_force_no_base64" change_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit_grep "get_changed_attribute_force_no_base64" "^displayName: $display_name_new" get_changed_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit "delete_computer" delete_computer || failed=`expr $failed + 1`
diff --git a/python/samba/tests/samba_tool/contact.py b/python/samba/tests/samba_tool/contact.py
index 626277ce8f1..f02e3603e5d 100644
--- a/python/samba/tests/samba_tool/contact.py
+++ b/python/samba/tests/samba_tool/contact.py
@@ -204,6 +204,25 @@ class ContactCmdTestCase(SambaToolCmdTest):
             self.assertMatch(out, str(contactobj.dn),
                              "contact '%s' not found" % str(contactobj.dn))
 
+    def test_list_base_dn(self):
+        base_dn = str(self.samdb.domain_dn())
+        (result, out, err) = self.runsubcmd("contact", "list",
+                                            "-b", base_dn)
+        self.assertCmdSuccess(result, out, err, "Error running list")
+
+        search_filter = "(objectClass=contact)"
+        contactlist = self.samdb.search(base=base_dn,
+                                         scope=ldb.SCOPE_SUBTREE,
+                                         expression=search_filter,
+                                         attrs=["name"])
+
+        self.assertTrue(len(contactlist) > 0, "no contacts found in samdb")
+
+        for contactobj in contactlist:
+            name = contactobj.get("name", idx=0)
+            self.assertMatch(out, str(name),
+                             "contact '%s' not found" % name)
+
     def test_move(self):
         parentou = self._randomOU({"name": "parentOU"})
         (result, out, err) = self._create_ou(parentou)
diff --git a/python/samba/tests/samba_tool/contact_edit.sh b/python/samba/tests/samba_tool/contact_edit.sh
index ca38900062a..ee9c40b59ce 100755
--- a/python/samba/tests/samba_tool/contact_edit.sh
+++ b/python/samba/tests/samba_tool/contact_edit.sh
@@ -51,8 +51,8 @@ EOF
 }
 
 get_attribute_base64() {
-	$PYTHON ${STpath}/source4/scripting/bin/samba-tool contact show \
-		testcontact1 --attributes=displayName \
+	${STpath}/bin/ldbsearch '(&(objectClass=contact)(name=testcontact1))' \
+		displayName \
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
@@ -93,6 +93,12 @@ get_attribute_base64_control() {
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
+get_attribute_force_no_base64() {
+       # LDB_FLAG_FORCE_NO_BASE64_LDIF should be used here.
+       $PYTHON ${STpath}/source4/scripting/bin/samba-tool contact show \
+               testcontact1 --attributes=displayName \
+               -H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
+}
 
 # Test edit contact - change base64 attribute value including control character
 change_attribute_base64_control() {
@@ -109,12 +115,6 @@ EOF
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
-get_attribute_base64_control() {
-	$PYTHON ${STpath}/source4/scripting/bin/samba-tool contact show \
-		testcontact1 --attributes=displayName \
-		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
-}
-
 # Test edit contact - change attributes with LDB_FLAG_FORCE_NO_BASE64_LDIF
 change_attribute_force_no_base64() {
 	# create editor.sh
@@ -154,7 +154,8 @@ testit "delete_attribute" delete_attribute || failed=`expr $failed + 1`
 testit "add_attribute_base64_control" add_attribute_base64_control || failed=`expr $failed + 1`
 testit_grep "get_attribute_base64_control" "^displayName:: $display_name_con_b64" get_attribute_base64_control || failed=`expr $failed + 1`
 testit "change_attribute_base64_control" change_attribute_base64_control || failed=`expr $failed + 1`
-testit_grep "get_attribute_base64_control" "^displayName:: $display_name_b64" get_attribute_base64_control || failed=`expr $failed + 1`
+testit_grep "get_attribute_base64" "^displayName:: $display_name_b64" get_attribute_base64 || failed=`expr $failed + 1`
+testit_grep "get_attribute_force_no_base64" "^displayName: $display_name" get_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit "change_attribute_force_no_base64" change_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit_grep "get_changed_attribute_force_no_base64" "^displayName: $display_name_new" get_changed_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit "delete_contact" delete_contact || failed=`expr $failed + 1`
diff --git a/python/samba/tests/samba_tool/dnscmd.py b/python/samba/tests/samba_tool/dnscmd.py
index e1459fee9ac..356b2c46d05 100644
--- a/python/samba/tests/samba_tool/dnscmd.py
+++ b/python/samba/tests/samba_tool/dnscmd.py
@@ -47,7 +47,6 @@ class DnsCmdTestCase(SambaToolCmdTest):
                     "1.EXAMPLE.COM",
                     "%sEXAMPLE.COM" % ("1." * 100),
                     "EXAMPLE",
-                    "\n.COM",
                     "!@#$%^&*()_",
                     "HIGH\xFFBYTE",
                     "@.EXAMPLE.COM",
@@ -58,14 +57,16 @@ class DnsCmdTestCase(SambaToolCmdTest):
                    "",
                    "SAMDOM..EXAMPLE.COM"]
 
-        good_mx = ["SAMDOM.EXAMPLE.COM 65530"]
+        good_mx = ["SAMDOM.EXAMPLE.COM 65530",
+                   "SAMDOM.EXAMPLE.COM     0"]
         bad_mx = ["SAMDOM.EXAMPLE.COM -1",
                   "SAMDOM.EXAMPLE.COM",
                   " ",
                   "SAMDOM.EXAMPLE.COM 1 1",
                   "SAMDOM.EXAMPLE.COM SAMDOM.EXAMPLE.COM"]
 
-        good_srv = ["SAMDOM.EXAMPLE.COM 65530 65530 65530"]
+        good_srv = ["SAMDOM.EXAMPLE.COM 65530 65530 65530",
+                    "SAMDOM.EXAMPLE.COM     1     1     1"]
         bad_srv = ["SAMDOM.EXAMPLE.COM 0 65536 0",
                    "SAMDOM.EXAMPLE.COM 0 0 65536",
                    "SAMDOM.EXAMPLE.COM 65536 0 0"]
@@ -450,7 +451,7 @@ class DnsCmdTestCase(SambaToolCmdTest):
             self.assertCmdSuccess(result, out, err, "Failed to add "
                                   "record %s with type 'SRV'." % record)
 
-            split = record.split(' ')
+            split = record.split()
             new_bit = str(int(split[3]) + 1)
             new_record = '%s %s %s %s' % (split[0], split[1], split[2], new_bit)
 
diff --git a/python/samba/tests/samba_tool/group.py b/python/samba/tests/samba_tool/group.py
index 215219c3918..c5c9cdb1d34 100644
--- a/python/samba/tests/samba_tool/group.py
+++ b/python/samba/tests/samba_tool/group.py
@@ -173,6 +173,49 @@ class GroupCmdTestCase(SambaToolCmdTest):
                         "Command='%s'\nLDAP='%s'" %(output_memberships,
                                                     ldap_memberships))
 
+    def test_list_full_dn(self):
+        (result, out, err) = self.runsubcmd("group", "list", "--full-dn",
+                                            "-H", "ldap://%s" % os.environ["DC_SERVER"],
+                                            "-U%s%%%s" % (os.environ["DC_USERNAME"],
+                                                          os.environ["DC_PASSWORD"]))
+        self.assertCmdSuccess(result, out, err, "Error running list")
+
+        search_filter = "(objectClass=group)"
+
+        grouplist = self.samdb.search(base=self.samdb.domain_dn(),
+                                      scope=ldb.SCOPE_SUBTREE,
+                                      expression=search_filter,
+                                      attrs=[])
+
+        self.assertTrue(len(grouplist) > 0, "no groups found in samdb")
+
+        for groupobj in grouplist:
+            name = str(groupobj.get("dn", idx=0))
+            found = self.assertMatch(out, name,
+                                     "group '%s' not found" % name)
+
+    def test_list_base_dn(self):
+        base_dn = "CN=Users"
+        (result, out, err) = self.runsubcmd("group", "list", "--base-dn", base_dn,
+                                            "-H", "ldap://%s" % os.environ["DC_SERVER"],
+                                            "-U%s%%%s" % (os.environ["DC_USERNAME"],
+                                                          os.environ["DC_PASSWORD"]))
+        self.assertCmdSuccess(result, out, err, "Error running list")
+
+        search_filter = "(objectClass=group)"
+
+        grouplist = self.samdb.search(base=self.samdb.normalize_dn_in_domain(base_dn),
+                                      scope=ldb.SCOPE_SUBTREE,
+                                      expression=search_filter,
+                                      attrs=["name"])
+
+        self.assertTrue(len(grouplist) > 0, "no groups found in samdb")
+
+        for groupobj in grouplist:
+            name = str(groupobj.get("name", idx=0))
+            found = self.assertMatch(out, name,
+                                     "group '%s' not found" % name)
+
     def test_listmembers(self):
         (result, out, err) = self.runsubcmd("group", "listmembers", "Domain Users",
                                             "-H", "ldap://%s" % os.environ["DC_SERVER"],
@@ -193,6 +236,29 @@ class GroupCmdTestCase(SambaToolCmdTest):
             name = str(groupobj.get("samAccountName", idx=0))
             found = self.assertMatch(out, name, "group '%s' not found" % name)
 
+
+    def test_listmembers_full_dn(self):
+        (result, out, err) = self.runsubcmd("group", "listmembers", "Domain Users",
+                                            "--full-dn",
+                                            "-H", "ldap://%s" % os.environ["DC_SERVER"],
+                                            "-U%s%%%s" % (os.environ["DC_USERNAME"],
+                                                          os.environ["DC_PASSWORD"]))
+        self.assertCmdSuccess(result, out, err, "Error running listmembers")
+
+        search_filter = "(|(primaryGroupID=513)(memberOf=CN=Domain Users,CN=Users,%s))" % self.samdb.domain_dn()
+
+        grouplist = self.samdb.search(base=self.samdb.domain_dn(),
+                                      scope=ldb.SCOPE_SUBTREE,
+                                      expression=search_filter,
+                                      attrs=["dn"])
+
+        self.assertTrue(len(grouplist) > 0, "no groups found in samdb")
+
+        for groupobj in grouplist:
+            name = str(groupobj.get("dn", idx=0))
+            found = self.assertMatch(out, name, "group '%s' not found" % name)
+
+
     def test_move(self):
         full_ou_dn = str(self.samdb.normalize_dn_in_domain("OU=movetest"))
         (result, out, err) = self.runsubcmd("ou", "create", full_ou_dn)
@@ -233,7 +299,7 @@ class GroupCmdTestCase(SambaToolCmdTest):
                                                           os.environ["DC_PASSWORD"]))
         self.assertCmdSuccess(result, out, err)
         self.assertEquals(err, "", "Shouldn't be any error messages")
-        self.assertIn("dn: CN=Domain Users,CN=Users,DC=samba,DC=example,DC=com", out)
+        self.assertIn("dn: CN=Domain Users,CN=Users,DC=addom,DC=samba,DC=example,DC=com", out)
 
     def _randomGroup(self, base={}):
         """create a group with random attribute values, you can specify base
diff --git a/python/samba/tests/samba_tool/group_edit.sh b/python/samba/tests/samba_tool/group_edit.sh
index 90f5252d926..d0428af9169 100755
--- a/python/samba/tests/samba_tool/group_edit.sh
+++ b/python/samba/tests/samba_tool/group_edit.sh
@@ -97,8 +97,7 @@ EOF
 }
 
 get_attribute_base64() {
-	$PYTHON ${STpath}/source4/scripting/bin/samba-tool group show \
-		testgroup1 --attributes=displayName \
+	${STpath}/bin/ldbsearch '(sAMAccountName=testgroup1)' displayName \
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
@@ -139,6 +138,12 @@ get_attribute_base64_control() {
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
+get_attribute_force_no_base64() {
+       # LDB_FLAG_FORCE_NO_BASE64_LDIF should be used here.
+       $PYTHON ${STpath}/source4/scripting/bin/samba-tool group show \
+               testgroup1 --attributes=displayName \
+               -H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
+}
 
 # Test edit group - change base64 attribute value including control character
 change_attribute_base64_control() {
@@ -155,12 +160,6 @@ EOF
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
-get_attribute_base64_control() {
-	$PYTHON ${STpath}/source4/scripting/bin/samba-tool group show \
-		testgroup1 --attributes=displayName \
-		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
-}
-
 # Test edit group - change attributes with LDB_FLAG_FORCE_NO_BASE64_LDIF
 change_attribute_force_no_base64() {
 	# create editor.sh
@@ -197,7 +196,8 @@ testit "delete_attribute" delete_attribute || failed=`expr $failed + 1`
 testit "add_attribute_base64_control" add_attribute_base64_control || failed=`expr $failed + 1`
 testit_grep "get_attribute_base64_control" "^displayName:: $display_name_con_b64" get_attribute_base64_control || failed=`expr $failed + 1`
 testit "change_attribute_base64_control" change_attribute_base64_control || failed=`expr $failed + 1`
-testit_grep "get_attribute_base64_control" "^displayName:: $display_name_b64" get_attribute_base64_control || failed=`expr $failed + 1`
+testit_grep "get_attribute_base64" "^displayName:: $display_name_b64" get_attribute_base64 || failed=`expr $failed + 1`
+testit_grep "get_attribute_force_no_base64" "^displayName: $display_name" get_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit "change_attribute_force_no_base64" change_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit_grep "get_changed_attribute_force_no_base64" "^displayName: $display_name_new" get_changed_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit "delete_test_group" delete_test_group || failed=`expr $failed + 1`
diff --git a/python/samba/tests/samba_tool/ou.py b/python/samba/tests/samba_tool/ou.py
index 39b0cad4250..9a6ccfe226a 100644
--- a/python/samba/tests/samba_tool/ou.py
+++ b/python/samba/tests/samba_tool/ou.py
@@ -145,6 +145,25 @@ class OUCmdTestCase(SambaToolCmdTest):
             found = self.assertMatch(out, str(name),
                                      "ou '%s' not found" % name)
 
+    def test_list_base_dn(self):
+        base_dn = str(self.samdb.domain_dn())
+        (result, out, err) = self.runsubcmd("ou", "list", "-b", base_dn)
+        self.assertCmdSuccess(result, out, err, "Error running list")
+
+        search_filter = "(objectClass=organizationalUnit)"
+
+        oulist = self.samdb.search(base=base_dn,
+                                   scope=ldb.SCOPE_SUBTREE,
+                                   expression=search_filter,
+                                   attrs=["name"])
+
+        self.assertTrue(len(oulist) > 0, "no ous found in samdb")
+
+        for ouobj in oulist:
+            name = ouobj.get("name", idx=0)
+            found = self.assertMatch(out, str(name),
+                                     "ou '%s' not found" % name)
+
     def test_rename(self):
         for ou in self.ous:
             ousuffix = "RenameTest"
diff --git a/python/samba/tests/samba_tool/user.py b/python/samba/tests/samba_tool/user.py
index 4ebc9eb3bab..65930ed89de 100644
--- a/python/samba/tests/samba_tool/user.py
+++ b/python/samba/tests/samba_tool/user.py
@@ -380,6 +380,52 @@ class UserCmdTestCase(SambaToolCmdTest):
             found = self.assertMatch(out, name,
                                      "user '%s' not found" % name)
 
+
+    def test_list_base_dn(self):
+        base_dn = "CN=Users"
+        (result, out, err) = self.runsubcmd("user", "list", "-b", base_dn,
+                                            "-H", "ldap://%s" % os.environ["DC_SERVER"],
+                                            "-U%s%%%s" % (os.environ["DC_USERNAME"],
+                                                          os.environ["DC_PASSWORD"]))
+        self.assertCmdSuccess(result, out, err, "Error running list")
+
+        search_filter = ("(&(objectClass=user)(userAccountControl:%s:=%u))" %
+                         (ldb.OID_COMPARATOR_AND, dsdb.UF_NORMAL_ACCOUNT))
+
+        userlist = self.samdb.search(base=self.samdb.normalize_dn_in_domain(base_dn),
+                                     scope=ldb.SCOPE_SUBTREE,
+                                     expression=search_filter,
+                                     attrs=["samaccountname"])
+
+        self.assertTrue(len(userlist) > 0, "no users found in samdb")
+
+        for userobj in userlist:
+            name = str(userobj.get("samaccountname", idx=0))
+            found = self.assertMatch(out, name,
+                                     "user '%s' not found" % name)
+
+    def test_list_full_dn(self):
+        (result, out, err) = self.runsubcmd("user", "list", "--full-dn",
+                                            "-H", "ldap://%s" % os.environ["DC_SERVER"],
+                                            "-U%s%%%s" % (os.environ["DC_USERNAME"],
+                                                          os.environ["DC_PASSWORD"]))
+        self.assertCmdSuccess(result, out, err, "Error running list")
+
+        search_filter = ("(&(objectClass=user)(userAccountControl:%s:=%u))" %
+                         (ldb.OID_COMPARATOR_AND, dsdb.UF_NORMAL_ACCOUNT))
+
+        userlist = self.samdb.search(base=self.samdb.domain_dn(),
+                                     scope=ldb.SCOPE_SUBTREE,
+                                     expression=search_filter,
+                                     attrs=["dn"])
+
+        self.assertTrue(len(userlist) > 0, "no users found in samdb")
+
+        for userobj in userlist:
+            name = str(userobj.get("dn", idx=0))
+            found = self.assertMatch(out, name,
+                                     "user '%s' not found" % name)
+
     def test_show(self):
         for user in self.users:
             (result, out, err) = self.runsubcmd(
diff --git a/python/samba/tests/samba_tool/user_edit.sh b/python/samba/tests/samba_tool/user_edit.sh
index 03fbd61ff5d..ae0854e89f6 100755
--- a/python/samba/tests/samba_tool/user_edit.sh
+++ b/python/samba/tests/samba_tool/user_edit.sh
@@ -65,8 +65,7 @@ EOF
 }
 
 get_attribute_base64() {
-	$PYTHON ${STpath}/source4/scripting/bin/samba-tool user show \
-		sambatool1 --attributes=displayName \
+	${STpath}/bin/ldbsearch '(sAMAccountName=sambatool1)' displayName \
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
@@ -107,6 +106,12 @@ get_attribute_base64_control() {
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
+get_attribute_force_no_base64() {
+	# LDB_FLAG_FORCE_NO_BASE64_LDIF should be used here.
+	$PYTHON ${STpath}/source4/scripting/bin/samba-tool user show \
+		sambatool1 --attributes=displayName \
+		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
+}
 
 # Test edit user - change base64 attribute value including control character
 change_attribute_base64_control() {
@@ -123,12 +128,6 @@ EOF
 		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
 }
 
-get_attribute_base64_control() {
-	$PYTHON ${STpath}/source4/scripting/bin/samba-tool user show \
-		sambatool1 --attributes=displayName \
-		-H "ldap://$SERVER" "-U$USERNAME" "--password=$PASSWORD"
-}
-
 # Test edit user - change attributes with LDB_FLAG_FORCE_NO_BASE64_LDIF
 change_attribute_force_no_base64() {
 	# create editor.sh
@@ -169,7 +168,8 @@ testit "delete_attribute" delete_attribute || failed=`expr $failed + 1`
 testit "add_attribute_base64_control" add_attribute_base64_control || failed=`expr $failed + 1`
 testit_grep "get_attribute_base64_control" "^displayName:: $display_name_con_b64" get_attribute_base64_control || failed=`expr $failed + 1`
 testit "change_attribute_base64_control" change_attribute_base64_control || failed=`expr $failed + 1`
-testit_grep "get_attribute_base64_control" "^displayName:: $display_name_b64" get_attribute_base64_control || failed=`expr $failed + 1`
+testit_grep "get_attribute_base64" "^displayName:: $display_name_b64" get_attribute_base64 || failed=`expr $failed + 1`
+testit_grep "get_attribute_force_no_base64" "^displayName: $display_name" get_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit "change_attribute_force_no_base64" change_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit_grep "get_changed_attribute_force_no_base64" "^displayName: $display_name_new" get_changed_attribute_force_no_base64 || failed=`expr $failed + 1`
 testit "delete_user" delete_user || failed=`expr $failed + 1`
diff --git a/python/samba/tests/samba_upgradedns_lmdb.py b/python/samba/tests/samba_upgradedns_lmdb.py
new file mode 100644
index 00000000000..048993152e2
--- /dev/null
+++ b/python/samba/tests/samba_upgradedns_lmdb.py
@@ -0,0 +1,75 @@
+# Unix SMB/CIFS implementation.
+# Copyright (C) Catalyst IT Ltd. 2019
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+from samba.tests.samba_tool.base import SambaToolCmdTest
+import os
+import shutil
+
+
+class UpgradeDnsLmdbTestCase(SambaToolCmdTest):
+    """
+        Tests for dns upgrade on a lmdb backend
+    """
+
+    def setUp(self):
+        super(UpgradeDnsLmdbTestCase, self).setUp()
+        self.tempsambadir = os.path.join(self.tempdir, "samba")
+        os.mkdir(self.tempsambadir)
+
+    # provision a domain
+    #
+    # returns the tuple (ret, stdout, stderr)
+    def provision(self):
+        command = (
+            "samba-tool "
+            "domain provision "
+            "--realm=foo.example.com "
+            "--domain=FOO "
+            "--targetdir=%s "
+            "--backend-store=mdb "
+            "--use-ntvfs " % self.tempsambadir)
+        return self.run_command(command)
+
+    # upgrade a domains dns to BIND9
+    #
+    # returns the tuple (ret, stdout, stderr)
+    def upgrade_dns(self):
+        command = (
+            "samba_upgradedns "
+            "--dns-backend=BIND9_DLZ "
+            "--configfile %s/etc/smb.conf" % self.tempsambadir)
+        return self.run_command(command)
+
+    def tearDown(self):
+        super(UpgradeDnsLmdbTestCase, self).tearDown()
+        shutil.rmtree(self.tempsambadir)
+
+    def test_lmdb_lock_files_linked_on_upgrade_to_bind9_dlz(self):
+        """
+            Ensure that links are created for the lock files as well as the
+            data files
+        """
+        self.provision()
+        self.upgrade_dns()
+        directory = ("%s/bind-dns/dns/sam.ldb.d" % self.tempsambadir)
+        for filename in os.listdir(directory):
+            if filename.endswith(".ldb") and "DNSZONES" in filename:
+                lock_file = ("%s/%s-lock" % (directory, filename))
+                self.assertTrue(
+                    os.path.isfile(lock_file),
+                    msg=("Lock file %s/%s-lock for %s, does not exist" %
+                         (directory, filename, filename)))
diff --git a/python/samba/tests/smbd_fuzztest.py b/python/samba/tests/smbd_fuzztest.py
new file mode 100644
index 00000000000..900cddf3880
--- /dev/null
+++ b/python/samba/tests/smbd_fuzztest.py
@@ -0,0 +1,77 @@
+# Unix SMB/CIFS implementation. Tests for smbd fuzzing.
+# Copyright (C) Jeremy Allison 2019.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+import sys
+import samba
+import os
+import binascii
+import socket
+
+class fuzzsmbd(samba.tests.TestCase):
+    def test_bug_14205(self):
+        #
+        # badblob consists of an incorrectly
+        # terminated SMB1 Negprot, with a valid SessionSetup after.
+        # BUG: #14205 causes the smbd server to crash.
+        #
+        state = True;
+        badblob = binascii.a2b_base64("AAAA1P9TTUJyAAAAABhDyAAAAAAAAAAAAAAAACcA/v8AAAAAALEAAlBDIE5F"
+                                      "VFdPUksgUFJPR1JBTSD//jAAAk1JQ1JPU09GVCBOR1RXT1JLUyAxLjANDAJN"
+                                      "SR3hkXOl0mb+QXW4Da/jp0f+AAAA1P9TTUJyAAAAABgDyAAABDQAAAAAAAAA"
+                                      "ACcA/v8AAAAAALEAAlBDIE5FVFdPUksgUFJPR1JBFBX//jAAAk1JQ1JPU09G"
+                                      "VCBOR1RXT1JLUyAxLjANDAJNSR3hkUal0mb+QXW4Da/jp0f+AAAA1P9TTUJz"
+                                      "LTE0OEF1uA2v46dH/gqAIIwiAoRiVHWgODu8OdksJQAAAAAnAP7/AAAAAACx"
+                                      "AAJQQyBORVRXT1JLIFBST0dSQU0g//4wAAJNSUNST1NPRlQgTkdUV09SS1Mg"
+                                      "MS4wDQwCTUkd4ZFGpdJm/kF1uA2v46dH/gAAANT/U01Ccy0xNDgyMTIyOTE3"
+                                      "Nzk2MzIAAAAAGAPIAAAAAAAAAAAAAAAAJwD+/wAAAAAAsQACUEMgTkVUV09S"
+                                      "SyBQUk9HUkFNIP/+MAACTUlDUk9TT0ZUIE5HVFdPUktTIDEuMA0GAAAAAAAA"
+                                      "AKXSZv5BdbgNr+OnR/4AAADU/1NNQnMtMTQ4MjEyMjkxNzc5NjMyNDQ4NDNA"
+                                      "ujcyNjgAsQACUEMgTkVUF09SSyAgAAAAAAAAAP/+MAACTUlDUk9TT0bAIE5H"
+                                      "BwAtMjMxODIxMjE4MTM5OTU0ODA2OP5BdbgNr+OnR/4KgCCMIgKEYlR1oDg7"
+                                      "vDnZLCWy")
+        s = None
+        try:
+            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+            s.connect(("fileserver", 445))
+            s.send(badblob)
+            # Read the 39-byte SMB1 reply to the SMB1 Negprot.
+            # This is an error message saying the Negprot was
+            # invalid.
+            rb = s.recv(1024)
+            try:
+                # Read again to wait for the server to exit.
+                rb = s.recv(1024)
+            except socket.error as e:
+                # We expect a socket error here as
+                # in both success and fail cases the
+                # server just resets the connection.
+                pass
+            finally:
+                pass
+        finally:
+            if s is not None:
+                s.close()
+        #
+        # If the server crashed there is the
+        # following message in the debug log.
+        #
+        for line in open(os.environ['SMBD_TEST_LOG']):
+            if "INTERNAL ERROR: Signal 11 in pid" in line:
+                print("Found crash in smbd log")
+                state = False;
+                break
+        self.assertTrue(state)
diff --git a/script/autobuild.py b/script/autobuild.py
index 85167cfa993..f5cf2a85ca0 100755
--- a/script/autobuild.py
+++ b/script/autobuild.py
@@ -121,32 +121,6 @@ cleanup_list = []
 
 builddirs = {
     "ctdb": "ctdb",
-    "samba": ".",
-    "samba-mitkrb5": ".",
-    "samba-nt4": ".",
-    "samba-fileserver": ".",
-    "samba-ktest-heimdal": ".",
-    "samba-admem": ".",
-    "samba-admem-mit": ".",
-    "samba-xc": ".",
-    "samba-o3": ".",
-    "samba-ctdb": ".",
-    "samba-libs": ".",
-    "samba-static": ".",
-    "samba-none-env": ".",
-    "samba-ad-dc-1": ".",
-    "samba-ad-dc-1-mitkrb5": ".",
-    "samba-ad-dc-2": ".",
-    "samba-ad-dc-3": ".",
-    "samba-ad-dc-4": ".",
-    "samba-ad-dc-4-mitkrb5": ".",
-    "samba-ad-dc-5": ".",
-    "samba-ad-dc-6": ".",
-    "samba-ad-dc-ntvfs": ".",
-    "samba-ad-dc-backup": ".",
-    "samba-nopython": ".",
-    "samba-nopython-py2": ".",
-    "samba-schemaupgrade": ".",
     "ldb": "lib/ldb",
     "tdb": "lib/tdb",
     "talloc": "lib/talloc",
@@ -155,11 +129,6 @@ builddirs = {
     "pidl": "pidl"
 }
 
-defaulttasks = list(builddirs.keys())
-
-if os.environ.get("AUTOBUILD_SKIP_SAMBA_O3", "0") == "1":
-    defaulttasks.remove("samba-o3")
-
 ctdb_configure_params = " --enable-developer ${PREFIX}"
 samba_configure_params = " ${ENABLE_COVERAGE} ${PREFIX} --with-profiling-data"
 
@@ -207,6 +176,9 @@ def make_test(
     return ' '.join([cmd] + _options)
 
 
+# When updating this list, also update .gitlab-ci.yml to add the job
+# and to make it a dependency of 'page' for the coverage report.
+
 tasks = {
     "ctdb": [
         ("random-sleep", random_sleep(300, 900)),
@@ -651,8 +623,15 @@ tasks = {
 
         # retry with nonshared smbd and smbtorture
         ("nonshared-distclean", "make distclean"),
-        ("nonshared-configure", "./configure.developer " + samba_configure_params + " --bundled-libraries=talloc,tdb,pytdb,ldb,pyldb,tevent,pytevent --with-static-modules=ALL --nonshared-binary=smbtorture,smbd/smbd"),
-        ("nonshared-make", "make -j"),
+        ("nonshared-configure", "./configure.developer " + samba_configure_params + " --bundled-libraries=ALL --with-static-modules=ALL --nonshared-binary=smbtorture,smbd/smbd"),
+        ("nonshared-make", "make -j")
+        ],
+
+    "samba-fuzz": [
+        # build the fuzzers (static) via the oss-fuzz script
+        ("fuzzers-mkdir-prefix", "mkdir -p ${PREFIX_DIR}"),
+        ("fuzzers-build", "OUT=${PREFIX_DIR} LIB_FUZZING_ENGINE= SANITIZER=address CXX= CFLAGS= ./lib/fuzzing/oss-fuzz/build_samba.sh --enable-afl"),
+        ("fuzzers-check", "./lib/fuzzing/oss-fuzz/check_build.sh ${PREFIX_DIR}")
         ],
 
     # Test Samba without python still builds.  When this test fails
@@ -815,6 +794,15 @@ tasks = {
     'fail': [("fail", 'echo failing && /bin/false')],
 }
 
+defaulttasks = list(tasks.keys())
+
+defaulttasks.remove("pass")
+defaulttasks.remove("fail")
+defaulttasks.remove("samba-test-only")
+defaulttasks.remove("samba-fuzz")
+if os.environ.get("AUTOBUILD_SKIP_SAMBA_O3", "0") == "1":
+    defaulttasks.remove("samba-o3")
+
 
 def do_print(msg):
     print("%s" % msg)
diff --git a/script/generate_param.py b/script/generate_param.py
index 5f8a50562d4..c29a29df57e 100644
--- a/script/generate_param.py
+++ b/script/generate_param.py
@@ -75,6 +75,7 @@ def iterate_all(path):
             continue
 
         constant = parameter.attrib.get("constant")
+        substitution = parameter.attrib.get("substitution")
         parm = parameter.attrib.get("parm")
         if name is None or param_type is None or context is None:
             raise Exception("Error parsing parameter: " + name)
@@ -89,6 +90,7 @@ def iterate_all(path):
                'context': context,
                'function': func,
                'constant': (constant == '1'),
+               'substitution': (substitution == '1'),
                'parm': (parm == '1'),
                'synonym' : synonym,
                'generated' : generated,
@@ -133,8 +135,11 @@ def generate_functions(path_in, path_out):
             if temp is None:
                 raise Exception(parameter['name'] + " has an invalid context " + parameter['context'])
             output_string += temp
-            if parameter['constant']:
-                output_string += "_CONST"
+            if parameter['type'] == "string" or parameter['type'] == "ustring":
+                if parameter['substitution']:
+                    output_string += "_SUBSTITUTED"
+                else:
+                    output_string += "_CONST"
             if parameter['parm']:
                 output_string += "_PARM"
             temp = param_type_dict.get(parameter['type'])
@@ -178,8 +183,6 @@ def make_s3_param_proto(path_in, path_out):
                 continue
 
             output_string = ""
-            if parameter['constant']:
-                output_string += 'const '
             param_type = mapping.get(parameter['type'])
             if param_type is None:
                 raise Exception(parameter['name'] + " has an invalid context " + parameter['context'])
@@ -192,13 +195,21 @@ def make_s3_param_proto(path_in, path_out):
             else:
                 param = "int"
 
-            if parameter['type'] == 'string' and not parameter['constant']:
-                if parameter['context'] == 'G':
-                    output_string += '(TALLOC_CTX *ctx);\n'
-                elif parameter['context'] == 'S':
-                    output_string += '(TALLOC_CTX *ctx, %s);\n' % param
+            if parameter['type'] == 'string' or parameter['type'] == 'ustring':
+                if parameter['substitution']:
+                    if parameter['context'] == 'G':
+                        output_string += '(TALLOC_CTX *ctx, const struct loadparm_substitution *lp_sub);\n'
+                    elif parameter['context'] == 'S':
+                        output_string += '(TALLOC_CTX *ctx, const struct loadparm_substitution *lp_sub, %s);\n' % param
+                    else:
+                        raise Exception(parameter['name'] + " has an invalid param type " + parameter['type'])
                 else:
-                    raise Exception(parameter['name'] + " has an invalid param type " + parameter['type'])
+                    if parameter['context'] == 'G':
+                        output_string = 'const ' + output_string + '(void);\n'
+                    elif parameter['context'] == 'S':
+                        output_string = 'const ' + output_string + '(%s);\n' % param
+                    else:
+                        raise Exception(parameter['name'] + " has an invalid param type " + parameter['type'])
             else:
                 if parameter['context'] == 'G':
                     output_string += '(void);\n'
@@ -228,8 +239,6 @@ def make_lib_proto(path_in, path_out):
                 continue
 
             output_string = ""
-            if parameter['constant']:
-                output_string += 'const '
             param_type = mapping.get(parameter['type'])
             if param_type is None:
                 raise Exception(parameter['name'] + " has an invalid context " + parameter['context'])
@@ -237,13 +246,21 @@ def make_lib_proto(path_in, path_out):
 
             output_string += "lpcfg_%s" % parameter['function']
 
-            if parameter['type'] == 'string' and not parameter['constant']:
-                if parameter['context'] == 'G':
-                    output_string += '(struct loadparm_context *, TALLOC_CTX *ctx);\n'
-                elif parameter['context'] == 'S':
-                    output_string += '(struct loadparm_service *, struct loadparm_service *, TALLOC_CTX *ctx);\n'
+            if parameter['type'] == 'string' or parameter['type'] == 'ustring':
+                if parameter['substitution']:
+                    if parameter['context'] == 'G':
+                        output_string += '(struct loadparm_context *, const struct loadparm_substitution *lp_sub, TALLOC_CTX *ctx);\n'
+                    elif parameter['context'] == 'S':
+                        output_string += '(struct loadparm_service *, struct loadparm_service *, TALLOC_CTX *ctx);\n'
+                    else:
+                        raise Exception(parameter['name'] + " has an invalid context " + parameter['context'])
                 else:
-                    raise Exception(parameter['name'] + " has an invalid param type " + parameter['type'])
+                    if parameter['context'] == 'G':
+                        output_string = 'const ' + output_string + '(struct loadparm_context *);\n'
+                    elif parameter['context'] == 'S':
+                        output_string = 'const ' + output_string + '(struct loadparm_service *, struct loadparm_service *);\n'
+                    else:
+                        raise Exception(parameter['name'] + " has an invalid param type " + parameter['type'])
             else:
                 if parameter['context'] == 'G':
                     output_string += '(struct loadparm_context *);\n'
diff --git a/script/release.sh b/script/release.sh
index b533e259440..507d5931a6a 100755
--- a/script/release.sh
+++ b/script/release.sh
@@ -17,14 +17,14 @@ CONF_UPLOAD_URL="samba-bugs@download-master.samba.org:/home/data/ftp/pub"
 CONF_DOWNLOAD_URL="https://download.samba.org/pub"
 CONF_HISTORY_URL="https://www.samba.org"
 
-test -d ".git" || {
+test -d ".git" -o -r ".git" || {
 	echo "Run this script from the top-level directory in the"
 	echo "repository"
 	exit 1
 }
 
 usage() {
-	echo "Usage: release.sh <PRODUCT> <COMMAND>"
+	echo "Usage: script/release.sh <PRODUCT> <COMMAND>"
 	echo ""
 	echo "PRODUCT: ldb, talloc, tevent, tdb, samba-rc, samba-stable"
 	echo "COMMAND: fullrelease, create, push, upload, announce"
@@ -32,6 +32,13 @@ usage() {
 	return 0
 }
 
+test -x "script/release.sh" || {
+	usage
+	echo "Run this script from the top-level directory in the"
+	echo "repository: as 'script/release.sh'"
+	exit 1
+}
+
 check_args() {
 	local cmd="$1"
 	local got_args="$2"
@@ -186,26 +193,6 @@ verify_samba_stable() {
 
 	load_samba_stable_versions
 
-	test x"${product}" = x"samba-stable" && {
-		test -f "announce.${tagname}.quotation.txt" || {
-			echo ""
-			echo "announce.${tagname}.quotation.txt missing!"
-			echo ""
-			echo "Please create it and retry"
-			echo ""
-			echo "The content should look like this:"
-			echo "cat announce.${tagname}.quotation.txt"
-			echo '======================================================'
-			echo '                "Some text'
-			echo '                 from someone."'
-			echo ''
-			echo '                 The author'
-			echo '======================================================'
-			echo ""
-			return 1
-		}
-	}
-
 	test -n "${oldtagname}" || {
 		return 0
 	}
@@ -786,11 +773,6 @@ announcement_samba_stable() {
 		return 1
 	}
 
-	test -f "announce.${tagname}.quotation.txt" || {
-		echo "announce.${tagname}.quotation.txt missing!"
-		return 1
-	}
-
 	local release_url="${download_url}samba/stable/"
 	local patch_url="${download_url}samba/patches/"
 
@@ -833,7 +815,6 @@ announcement_samba_stable() {
 		local headlimit=$(expr ${top} - 1 )
 		local taillimit=$(expr ${headlimit} - \( ${skip} - 1 \))
 
-		cat "announce.${tagname}.quotation.txt"
 		echo ""
 		echo ""
 		echo "Release Announcements"
diff --git a/selftest/flapping.d/dnsserver b/selftest/flapping.d/dnsserver
new file mode 100644
index 00000000000..9b33e8522a3
--- /dev/null
+++ b/selftest/flapping.d/dnsserver
@@ -0,0 +1,2 @@
+# This is not stable in samba due to a bug
+^samba.tests.dcerpc.dnsserver.samba.tests.dcerpc.dnsserver.DnsserverTests.test_enum_is_sorted_children
\ No newline at end of file
diff --git a/selftest/in_screen b/selftest/in_screen
index 5aba08d4750..d60f9dc34ff 100755
--- a/selftest/in_screen
+++ b/selftest/in_screen
@@ -5,23 +5,9 @@ export TMPDIR="$SELFTEST_TMPDIR"
 SERVERNAME="$ENVNAME"
 [ -z "$SERVERNAME" ] && SERVERNAME="base"
 basedir=$TMPDIR
-osname=$(uname)
-if [ "$osname" = "Linux" ]; then
-	vars=$(mktemp)
-else
-	vars=$(mktemp -t tmpsmb)
-	function seq() {
-		dpt=$1
-		end=$2
-		while [ $dpt -le $end ]; do
-			echo "$dpt"
-			dpt=$(( $dpt + 1))
-		done
-	}
-fi
 
 [ -r $basedir/$SERVERNAME.pid ] && {
-    for i in $(seq 2 100); do
+    for i in {2..100}; do
 	if [ ! -r "$basedir/${SERVERNAME}-$i.pid" ]; then
 	    SERVERNAME="${SERVERNAME}-$i"
 	    break
@@ -29,7 +15,7 @@ fi
     done
 }
 
-rm -f $basedir/$SERVERNAME.*
+rm -f $basedir/$SERVERNAME.{launch,log,parent.pid,pid,status}
 
 # set most of the environment vars we have in the screen session too
 _ENV=""
@@ -57,6 +43,13 @@ cleanup() {
 	echo "$(date) samba exited with status $status" >> $basedir/$SERVERNAME.log
 	exit $status
     }
+
+    case $ENVNAME in
+	*.nmbd|*.smbd|*.winbindd|*.samba)
+	    kill $(cat $basedir/../"${ENVNAME%\.*}"/pid/"${ENVNAME##*\.}".pid)
+	    ;;
+    esac
+
     read pid < $basedir/$SERVERNAME.pid
     echo "$(date) Killing samba pid $pid from $$" >> $basedir/$SERVERNAME.log
     if [ "$pid" = "$$" ]; then
@@ -66,7 +59,6 @@ cleanup() {
     exit 1
 }
 
-rm -f $basedir/$SERVERNAME.status $basedir/$SERVERNAME.log
 echo $$ > $basedir/$SERVERNAME.parent.pid
 trap cleanup SIGINT SIGTERM SIGPIPE
 
@@ -87,6 +79,13 @@ fi
 echo "$(date) waiting in $$" >> $basedir/$SERVERNAME.log
 read stdin_var
 echo "$(date) EOF on stdin" >> $basedir/$SERVERNAME.log
+
+case $ENVNAME in
+    *.nmbd|*.smbd|*.winbindd|*.samba)
+	kill $(cat $basedir/../"${ENVNAME%\.*}"/pid/"${ENVNAME##*\.}".pid)
+	;;
+esac
+
 read pid < $basedir/$SERVERNAME.pid
 echo "$(date) killing $pid" >> $basedir/$SERVERNAME.log
 kill $pid 2> /dev/null
diff --git a/selftest/knownfail b/selftest/knownfail
index 82259dcfe90..c9ef0851172 100644
--- a/selftest/knownfail
+++ b/selftest/knownfail
@@ -23,7 +23,7 @@
 # see bug 8412
 ^samba3.smb2.rename.*.simple_nodelete
 ^samba3.smb2.rename.*.no_share_delete_no_delete_access
-^samba3.blackbox.smbclient_machine_auth.plain \(nt4_dc:local\)# the NT4 DC does not currently set up a self-join
+^samba3.blackbox.smbclient_machine_auth.plain.*nt4_dc:local # the NT4 DC does not currently set up a self-join
 ^samba3.raw.samba3hide.samba3hide\(ad_dc\) # This test fails against the ad_dc environment.
 ^samba3.raw.samba3closeerr.samba3closeerr\(nt4_dc\) # This test fails against an smbd environment with NT ACLs enabled
 ^samba3.raw.acls nfs4acl_xattr-simple-40.INHERITFLAGS\(nt4_dc\) # This (and the follow nfs4acl_xattr tests fail because our NFSv4 backend isn't a complete mapping yet.
@@ -99,8 +99,8 @@
 ^samba4.rpc.netlogon.*.GetPassword
 ^samba4.rpc.netlogon.*.DatabaseRedo
 ^samba4.rpc.netlogon.*.netlogon.lsa_over_netlogon\(ad_dc\) #Broken by split of \\pipe\lsass from \\pipe\netlogon in the IDL
-^samba4.rpc.netlogon.*.netlogon.SetupCredentialsDowngrade\(ad_dc_default\) # Broken by allowing NT4 crypto on this environment
-^samba4.rpc.netlogon.*.netlogon.SetupCredentialsDowngrade\(ad_dc_default:local\) # Broken by allowing NT4 crypto on this environment
+^samba4.rpc.netlogon.*.netlogon.SetupCredentialsDowngrade\(ad_dc_ntvfs\) # Broken by allowing NT4 crypto on this environment
+^samba4.rpc.netlogon.*.netlogon.SetupCredentialsDowngrade\(ad_dc_ntvfs:local\) # Broken by allowing NT4 crypto on this environment
 ^samba4.rpc.drsuapi.*ncacn_ip_tcp.*validate # should only work with seal
 ^samba4.rpc.drsuapi.*ncacn_ip_tcp.*bigendian # should only work with seal
 ^samba4.rpc.samr.passwords.validate.*ncacn_ip_tcp.*with.validate # should only work with seal
@@ -137,8 +137,8 @@
 ^samba4.smb2.acls.*.inheritflags
 ^samba4.smb2.acls.*.owner
 ^samba4.smb2.acls.*.ACCESSBASED
-^samba4.ldap.dirsync.python.ad_dc_default..__main__.ExtendedDirsyncTests.test_dirsync_deleted_items
-#^samba4.ldap.dirsync.python.ad_dc_default..__main__.ExtendedDirsyncTests.*
+^samba4.ldap.dirsync.python.ad_dc_ntvfs..__main__.ExtendedDirsyncTests.test_dirsync_deleted_items
+#^samba4.ldap.dirsync.python.ad_dc_ntvfs..__main__.ExtendedDirsyncTests.*
 ^samba4.libsmbclient.opendir.(NT1|SMB3).opendir # This requires netbios browsing
 ^samba4.rpc.drsuapi.*.drsuapi.DsGetDomainControllerInfo\(.*\)$
 ^samba4.smb2.oplock.exclusive2\(.*\)$ # samba 4 oplocks are a mess
@@ -216,6 +216,7 @@
 ^samba3.rpc.spoolss.printer.addprinterex.driver_info_winreg # knownfail or flapping?
 ^samba3.rpc.spoolss.printer.*.publish_toggle\(.*\)$ # needs spoolss AD member env
 ^samba3.rpc.spoolss.printer.*.log_jobinfo\(.*\)$ # not implemented yet
+^samba3.rpc.spoolss.printserver.*.addpermachineconnection\(.*\)$ # not implemented yet
 ^samba3.rpc.spoolss.printserver.*.add_processor\(.*\)$
 ^samba3.rpc.spoolss.printserver.*.get_core_printer_drivers\(.*\)$
 ^samba3.rpc.spoolss.printserver.*.get_printer_driver_package_path\(.*\)$
@@ -320,8 +321,8 @@
 # fl2000dc doesn't support AES
 ^samba4.krb5.kdc.*as-req-aes.*fl2000dc
 # nt4_member and ad_member don't support ntlmv1 (not even over SMB1)
-^samba3.blackbox.smbclient_auth.plain.*_member.*option=clientntlmv2auth=no.member.creds.*as.user
-^samba3.blackbox.smbclient_auth.plain.*_member.*option=clientntlmv2auth=no.*mNT1.member.creds.*as.user
+^samba3.blackbox.smbclient_auth.plain.*option=clientntlmv2auth=no.member.creds.*as.user.*_member
+^samba3.blackbox.smbclient_auth.plain.*option=clientntlmv2auth=no.*mNT1.member.creds.*as.user.*_member
 #nt-vfs server blocks read with execute access
 ^samba4.smb2.read.access
 #ntvfs server blocks copychunk with execute access on read handle
diff --git a/selftest/knownfail.d/durable-v2-delay b/selftest/knownfail.d/durable-v2-delay
new file mode 100644
index 00000000000..2a84749b0eb
--- /dev/null
+++ b/selftest/knownfail.d/durable-v2-delay
@@ -0,0 +1,2 @@
+# In the ad_dc env leases are disabled
+^samba3.smb2.durable-v2-delay.durable_v2_reconnect_delay_msec\(ad_dc\)
diff --git a/selftest/knownfail.d/empty-domain-name b/selftest/knownfail.d/empty-domain-name
new file mode 100644
index 00000000000..a1ffcaf7e3c
--- /dev/null
+++ b/selftest/knownfail.d/empty-domain-name
@@ -0,0 +1,7 @@
+^samba3.blackbox.smbclient_auth.empty_domain.domain_creds.smbclient.*as.user.*nt4_member
+^samba3.blackbox.smbclient_auth.empty_domain.domain_creds.smbclient.*as.user.*ad_member
+^samba3.blackbox.smbclient_auth.dot_domain.domain_creds.smbclient.*as.user.*nt4_member
+^samba3.blackbox.smbclient_auth.dot_domain.domain_creds.smbclient.*as.user.*ad_member
+^samba3.blackbox.smbclient_auth.upn.domain_creds.smbclient.*as.*user.*nt4_member
+^samba3.blackbox.smbclient_auth.upn.member_creds.smbclient.*as.*user.*nt4_member
+^samba3.blackbox.smbclient_auth.upn.member_creds.smbclient.*as.*user.*ad_member
diff --git a/selftest/target/Samba.pm b/selftest/target/Samba.pm
index 76f3ebb1fea..9319f301327 100644
--- a/selftest/target/Samba.pm
+++ b/selftest/target/Samba.pm
@@ -252,7 +252,6 @@ sub mk_krb5_conf($$)
 						 $ctx->{dnsname},
 						 $ctx->{domain},
 						 $ctx->{kdc_ipv4});
-	my $lc_domain = lc($ctx->{domain});
 	print KRB5CONF "
 #Generated krb5.conf for $ctx->{realm}
 
@@ -263,11 +262,6 @@ sub mk_krb5_conf($$)
  ticket_lifetime = 24h
  forwardable = yes
 
- name_canon_rules=as-is:realm=$ctx->{realm}
- name_canon_rules=as-is:realm=$ctx->{dnsname}
- name_canon_rules=as-is:realm=$ctx->{domain}
- name_canon_rules=as-is:realm=$lc_domain
-
  # We are running on the same machine, do not correct
  # system clock differences
  kdc_timesync = 0
diff --git a/selftest/target/Samba3.pm b/selftest/target/Samba3.pm
index fab8bdda86e..cdbbbdcef3d 100755
--- a/selftest/target/Samba3.pm
+++ b/selftest/target/Samba3.pm
@@ -965,7 +965,7 @@ sub setup_fileserver
 	spotlight backend = elasticsearch
 	elasticsearch:address = 127.0.0.35
 	elasticsearch:port = 8080
-	elasticsearch:mappings = \"$srcdir_abs/source3/rpc_server/mdssvc/elasticsearch_mappings.json\"
+	elasticsearch:mappings = $srcdir_abs/source3/rpc_server/mdssvc/elasticsearch_mappings.json
 
 	usershare path = $usershare_dir
 	usershare max shares = 10
@@ -1436,6 +1436,9 @@ sub provision($$$$$$$$$)
 	my $privatedir="$prefix_abs/private";
 	push(@dirs,$privatedir);
 
+	my $cachedir = "$prefix_abs/cachedir";
+	push(@dirs, $cachedir);
+
 	my $binddnsdir = "$prefix_abs/bind-dns";
 	push(@dirs, $binddnsdir);
 
@@ -1702,6 +1705,7 @@ sub provision($$$$$$$$$)
 
 	print CONF "
 [global]
+        dcesrv:fuzz directory = $cachedir/fuzz
 	netbios name = $server
 	interfaces = $interfaces
 	bind interfaces only = yes
diff --git a/selftest/target/Samba4.pm b/selftest/target/Samba4.pm
index 1310e2ff09f..3e6692ce529 100755
--- a/selftest/target/Samba4.pm
+++ b/selftest/target/Samba4.pm
@@ -1332,8 +1332,6 @@ sub provision_promoted_dc($$$)
 					       $dcvars->{SERVER_IP},
 					       $dcvars->{SERVER_IPV6});
 
-	push (@{$ctx->{provision_options}}, "--use-ntvfs");
-
 	$ctx->{smb_conf_extra_options} = "
 	max xmit = 32K
 	server max protocol = SMB2
@@ -1370,7 +1368,7 @@ sub provision_promoted_dc($$$)
 	my $cmd = $self->get_cmd_env_vars($ret);
 	$cmd .= "$samba_tool domain dcpromo $ret->{CONFIGURATION} $dcvars->{REALM} DC --realm=$dcvars->{REALM}";
 	$cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD}";
-	$cmd .= " --machinepass=machine$ret->{PASSWORD} --use-ntvfs --dns-backend=BIND9_DLZ";
+	$cmd .= " --machinepass=machine$ret->{PASSWORD} --dns-backend=BIND9_DLZ";
 
 	unless (system($cmd) == 0) {
 		warn("Join failed\n$cmd");
@@ -1407,8 +1405,6 @@ sub provision_vampire_dc($$$)
 					       $dcvars->{SERVER_IP},
 					       $dcvars->{SERVER_IPV6});
 
-	push (@{$ctx->{provision_options}}, "--use-ntvfs");
-
 	$ctx->{smb_conf_extra_options} = "
 	max xmit = 32K
 	server max protocol = SMB2
@@ -1435,7 +1431,7 @@ sub provision_vampire_dc($$$)
 	my $cmd = $self->get_cmd_env_vars($ret);
 	$cmd .= "$samba_tool domain join $ret->{CONFIGURATION} $dcvars->{REALM} DC --realm=$dcvars->{REALM}";
 	$cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD} --domain-critical-only";
-	$cmd .= " --machinepass=machine$ret->{PASSWORD} --use-ntvfs";
+	$cmd .= " --machinepass=machine$ret->{PASSWORD}";
 	$cmd .= " --backend-store=mdb";
 
 	unless (system($cmd) == 0) {
@@ -1507,7 +1503,7 @@ sub provision_fl2000dc($$)
 	spnego:simulate_w2k=yes
 	ntlmssp_server:force_old_spnego=yes
 ";
-	my $extra_provision_options = ["--use-ntvfs", "--base-schema=2008_R2"];
+	my $extra_provision_options = ["--base-schema=2008_R2"];
 	# This environment uses plain text secrets
 	# i.e. secret attributes are not encrypted on disk.
 	# This allows testing of the --plaintext-secrets option for
@@ -1549,7 +1545,7 @@ sub provision_fl2003dc($$$)
 	dcesrv:header signing = no
 	dcesrv:max auth states = 0
 	dns forwarder = $ip_addr1 $ip_addr2";
-	my $extra_provision_options = ["--use-ntvfs", "--base-schema=2008_R2"];
+	my $extra_provision_options = ["--base-schema=2008_R2"];
 	my $ret = $self->provision($prefix,
 				   "domain controller",
 				   "dc6",
@@ -1599,7 +1595,7 @@ sub provision_fl2008r2dc($$$)
 
 	print "PROVISIONING DC WITH FOREST LEVEL 2008r2...\n";
         my $extra_conf_options = "ldap server require strong auth = no";
-	my $extra_provision_options = ["--use-ntvfs", "--base-schema=2008_R2"];
+	my $extra_provision_options = ["--base-schema=2008_R2"];
 	my $ret = $self->provision($prefix,
 				   "domain controller",
 				   "dc7",
@@ -1645,8 +1641,6 @@ sub provision_rodc($$$)
 		return undef;
 	}
 
-	push (@{$ctx->{provision_options}}, "--use-ntvfs");
-
 	$ctx->{share} = "$ctx->{prefix_abs}/share";
 	push(@{$ctx->{directories}}, "$ctx->{share}");
 
@@ -1681,7 +1675,7 @@ sub provision_rodc($$$)
 	my $cmd = $self->get_cmd_env_vars($ret);
 	$cmd .= "$samba_tool domain join $ret->{CONFIGURATION} $dcvars->{REALM} RODC";
 	$cmd .= " -U$dcvars->{DC_USERNAME}\%$dcvars->{DC_PASSWORD}";
-	$cmd .= " --server=$dcvars->{DC_SERVER} --use-ntvfs";
+	$cmd .= " --server=$dcvars->{DC_SERVER}";
 
 	unless (system($cmd) == 0) {
 		warn("RODC join failed\n$cmd");
@@ -1845,6 +1839,9 @@ sub provision_ad_dc($$$$$$)
 	copy = print1
 [print3]
 	copy = print1
+[print4]
+	copy = print1
+	guest ok = yes
 [lp]
 	copy = print1
 ";
@@ -1888,8 +1885,7 @@ sub provision_chgdcpass($$)
 	allow dcerpc auth level connect:lsarpc = yes
 	dcesrv:max auth states = 8
 ";
-	my $extra_provision_options = ["--use-ntvfs"];
-	push (@{$extra_provision_options}, "--dns-backend=BIND9_DLZ");
+	my $extra_provision_options = ["--dns-backend=BIND9_DLZ"];
 	my $ret = $self->provision($prefix,
 				   "domain controller",
 				   "chgdcpass",
@@ -2078,9 +2074,9 @@ sub check_env($$)
 	labdc                => ["backupfromdc"],
 
 	# aliases in order to split autbuild tasks
-	fl2008dc             => ["ad_dc_ntvfs"],
-	ad_dc_default        => ["ad_dc_ntvfs"],
-	ad_dc_slowtests      => ["ad_dc_ntvfs"],
+	fl2008dc             => ["ad_dc"],
+	ad_dc_default        => ["ad_dc"],
+	ad_dc_slowtests      => ["ad_dc"],
 	ad_dc_backup         => ["ad_dc"],
 
 	schema_dc      => ["dns_hub"],
diff --git a/selftest/tests.py b/selftest/tests.py
index cca2ad02c9e..96d3f8d6317 100644
--- a/selftest/tests.py
+++ b/selftest/tests.py
@@ -90,6 +90,7 @@ planpythontestsuite(
     "none", "wafsamba.tests.test_suite",
     extra_path=[os.path.join(samba4srcdir, "..", "buildtools"),
                 os.path.join(samba4srcdir, "..", "third_party", "waf")])
+planpythontestsuite("fileserver", "samba.tests.smbd_fuzztest")
 
 
 def cmdline(script, *args):
@@ -390,6 +391,8 @@ plantestsuite("samba.unittests.byteorder", "none",
               [os.path.join(bindir(), "default/lib/util/test_byteorder")])
 plantestsuite("samba.unittests.ntlm_check", "none",
               [os.path.join(bindir(), "default/libcli/auth/test_ntlm_check")])
+plantestsuite("samba.unittests.gnutls", "none",
+              [os.path.join(bindir(), "default/libcli/auth/test_gnutls")])
 plantestsuite("samba.unittests.rc4_passwd_buffer", "none",
               [os.path.join(bindir(), "default/libcli/auth/test_rc4_passwd_buffer")])
 plantestsuite("samba.unittests.schannel", "none",
diff --git a/source3/auth/auth.c b/source3/auth/auth.c
index 3b523c0fa18..e8bb9d7821a 100644
--- a/source3/auth/auth.c
+++ b/source3/auth/auth.c
@@ -84,9 +84,6 @@ static struct auth_init_function_entry *auth_find_backend_entry(const char *name
 NTSTATUS auth_get_ntlm_challenge(struct auth_context *auth_context,
 				 uint8_t chal[8])
 {
-	uchar tmp[8];
-
-
 	if (auth_context->challenge.length) {
 		DEBUG(5, ("get_ntlm_challenge (auth subsystem): returning previous challenge by module %s (normal)\n", 
 			  auth_context->challenge_set_by));
@@ -94,9 +91,13 @@ NTSTATUS auth_get_ntlm_challenge(struct auth_context *auth_context,
 		return NT_STATUS_OK;
 	}
 
-	generate_random_buffer(tmp, sizeof(tmp));
-	auth_context->challenge = data_blob_talloc(auth_context,
-						   tmp, sizeof(tmp));
+	auth_context->challenge = data_blob_talloc(auth_context, NULL, 8);
+	if (auth_context->challenge.data == NULL) {
+		DBG_WARNING("data_blob_talloc failed\n");
+		return NT_STATUS_NO_MEMORY;
+	}
+	generate_random_buffer(
+		auth_context->challenge.data, auth_context->challenge.length);
 
 	auth_context->challenge_set_by = "random";
 
@@ -176,7 +177,7 @@ NTSTATUS auth_check_ntlm_password(TALLOC_CTX *mem_ctx,
 	/* if all the modules say 'not for me' this is reasonable */
 	NTSTATUS nt_status = NT_STATUS_NOT_IMPLEMENTED;
 	const char *unix_username;
-	auth_methods *auth_method;
+	struct auth_methods *auth_method;
 	struct auth_serversupplied_info *server_info = NULL;
 	struct dom_sid sid = {0};
 	struct imessaging_context *msg_ctx = NULL;
@@ -403,7 +404,8 @@ static NTSTATUS make_auth_context(TALLOC_CTX *mem_ctx,
 }
 
 bool load_auth_module(struct auth_context *auth_context, 
-		      const char *module, auth_methods **ret) 
+		      const char *module,
+		      struct auth_methods **ret)
 {
 	static bool initialised_static_modules = False;
 
@@ -464,8 +466,8 @@ static NTSTATUS make_auth_context_text_list(TALLOC_CTX *mem_ctx,
 					    struct auth_context **auth_context,
 					    char **text_list)
 {
-	auth_methods *list = NULL;
-	auth_methods *t, *method = NULL;
+	struct auth_methods *list = NULL;
+	struct auth_methods *t, *method = NULL;
 	NTSTATUS nt_status;
 
 	if (!text_list) {
diff --git a/source3/auth/auth_builtin.c b/source3/auth/auth_builtin.c
index 8a5c4b74723..f16b3cc2934 100644
--- a/source3/auth/auth_builtin.c
+++ b/source3/auth/auth_builtin.c
@@ -86,7 +86,10 @@ static NTSTATUS check_anonymous_security(const struct auth_context *auth_context
 
 /* Guest modules initialisation */
 
-static NTSTATUS auth_init_anonymous(struct auth_context *auth_context, const char *options, auth_methods **auth_method)
+static NTSTATUS auth_init_anonymous(
+	struct auth_context *auth_context,
+	const char *options,
+	struct auth_methods **auth_method)
 {
 	struct auth_methods *result;
 
@@ -150,7 +153,10 @@ static NTSTATUS check_name_to_ntstatus_security(const struct auth_context *auth_
 
 /** Module initialisation function */
 
-static NTSTATUS auth_init_name_to_ntstatus(struct auth_context *auth_context, const char *param, auth_methods **auth_method) 
+static NTSTATUS auth_init_name_to_ntstatus(
+	struct auth_context *auth_context,
+	const char *param,
+	struct auth_methods **auth_method)
 {
 	struct auth_methods *result;
 
diff --git a/source3/auth/auth_generic.c b/source3/auth/auth_generic.c
index 167d4e00367..9243a0ba02d 100644
--- a/source3/auth/auth_generic.c
+++ b/source3/auth/auth_generic.c
@@ -197,7 +197,8 @@ static struct auth4_context *make_auth4_context_s3(TALLOC_CTX *mem_ctx, struct a
 	auth4_context->generate_session_info = auth3_generate_session_info;
 	auth4_context->get_ntlm_challenge = auth3_get_challenge;
 	auth4_context->set_ntlm_challenge = auth3_set_challenge;
-	auth4_context->check_ntlm_password = auth3_check_password;
+	auth4_context->check_ntlm_password_send = auth3_check_password_send;
+	auth4_context->check_ntlm_password_recv = auth3_check_password_recv;
 	auth4_context->private_data = talloc_steal(auth4_context, auth_context);
 	return auth4_context;
 }
@@ -414,48 +415,35 @@ NTSTATUS auth_check_password_session_info(struct auth4_context *auth_context,
 	NTSTATUS nt_status;
 	void *server_info;
 	uint8_t authoritative = 0;
+	struct tevent_context *ev = NULL;
+	struct tevent_req *subreq = NULL;
+	bool ok;
 
-	if (auth_context->check_ntlm_password_send != NULL) {
-		struct tevent_context *ev = NULL;
-		struct tevent_req *subreq = NULL;
-		bool ok;
-
-		ev = samba_tevent_context_init(talloc_tos());
-		if (ev == NULL) {
-			return NT_STATUS_NO_MEMORY;
-		}
+	ev = samba_tevent_context_init(talloc_tos());
+	if (ev == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
 
-		subreq = auth_context->check_ntlm_password_send(ev, ev,
-								auth_context,
-								user_info);
-		if (subreq == NULL) {
-			TALLOC_FREE(ev);
-			return NT_STATUS_NO_MEMORY;
-		}
-		ok = tevent_req_poll_ntstatus(subreq, ev, &nt_status);
-		if (!ok) {
-			TALLOC_FREE(ev);
-			return nt_status;
-		}
-		nt_status = auth_context->check_ntlm_password_recv(subreq,
-								   talloc_tos(),
-								   &authoritative,
-								   &server_info,
-								   NULL, NULL);
+	subreq = auth_context->check_ntlm_password_send(ev, ev,
+							auth_context,
+							user_info);
+	if (subreq == NULL) {
 		TALLOC_FREE(ev);
-		if (!NT_STATUS_IS_OK(nt_status)) {
-			return nt_status;
-		}
-	} else {
-		nt_status = auth_context->check_ntlm_password(auth_context,
-							      talloc_tos(),
-							      user_info,
-							      &authoritative,
-							      &server_info,
-							      NULL, NULL);
-		if (!NT_STATUS_IS_OK(nt_status)) {
-			return nt_status;
-		}
+		return NT_STATUS_NO_MEMORY;
+	}
+	ok = tevent_req_poll_ntstatus(subreq, ev, &nt_status);
+	if (!ok) {
+		TALLOC_FREE(ev);
+		return nt_status;
+	}
+	nt_status = auth_context->check_ntlm_password_recv(subreq,
+							   talloc_tos(),
+							   &authoritative,
+							   &server_info,
+							   NULL, NULL);
+	TALLOC_FREE(ev);
+	if (!NT_STATUS_IS_OK(nt_status)) {
+		return nt_status;
 	}
 
 	nt_status = auth_context->generate_session_info(auth_context,
diff --git a/source3/auth/auth_ntlmssp.c b/source3/auth/auth_ntlmssp.c
index 2e345e17571..3e39be30588 100644
--- a/source3/auth/auth_ntlmssp.c
+++ b/source3/auth/auth_ntlmssp.c
@@ -24,6 +24,7 @@
 #include "includes.h"
 #include "auth.h"
 #include "libcli/security/security.h"
+#include "lib/util/tevent_ntstatus.h"
 
 NTSTATUS auth3_generate_session_info(struct auth4_context *auth_context,
 				     TALLOC_CTX *mem_ctx,
@@ -130,24 +131,38 @@ NTSTATUS auth3_set_challenge(struct auth4_context *auth4_context, const uint8_t
  * Return the session keys used on the connection.
  */
 
-NTSTATUS auth3_check_password(struct auth4_context *auth4_context,
-			      TALLOC_CTX *mem_ctx,
-			      const struct auth_usersupplied_info *user_info,
-			      uint8_t *pauthoritative,
-			      void **server_returned_info,
-			      DATA_BLOB *session_key, DATA_BLOB *lm_session_key)
+struct auth3_check_password_state {
+	uint8_t authoritative;
+	void *server_info;
+	DATA_BLOB nt_session_key;
+	DATA_BLOB lm_session_key;
+};
+
+struct tevent_req *auth3_check_password_send(
+	TALLOC_CTX *mem_ctx,
+	struct tevent_context *ev,
+	struct auth4_context *auth4_context,
+	const struct auth_usersupplied_info *user_info)
 {
-	struct auth_context *auth_context = talloc_get_type_abort(auth4_context->private_data,
-								  struct auth_context);
+	struct tevent_req *req = NULL;
+	struct auth3_check_password_state *state = NULL;
+	struct auth_context *auth_context = talloc_get_type_abort(
+		auth4_context->private_data, struct auth_context);
 	struct auth_usersupplied_info *mapped_user_info = NULL;
-	struct auth_serversupplied_info *server_info;
+	struct auth_serversupplied_info *server_info = NULL;
 	NTSTATUS nt_status;
 	bool username_was_mapped;
 
+	req = tevent_req_create(
+		mem_ctx, &state, struct auth3_check_password_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
 	/*
 	 * Be authoritative by default.
 	 */
-	*pauthoritative = 1;
+	state->authoritative = 1;
 
 	/* The client has given us its machine name (which we only get over NBT transport).
 	   We need to possibly reload smb.conf if smb.conf includes depend on the machine name. */
@@ -173,27 +188,27 @@ NTSTATUS auth3_check_password(struct auth4_context *auth4_context,
 				       NULL, NULL, NULL,
 				       AUTH_PASSWORD_RESPONSE);
 
-	if (!NT_STATUS_IS_OK(nt_status)) {
-		return nt_status;
+	if (tevent_req_nterror(req, nt_status)) {
+		return tevent_req_post(req, ev);
 	}
 
 	mapped_user_info->logon_parameters = user_info->logon_parameters;
 
 	mapped_user_info->flags = user_info->flags;
 
-	nt_status = auth_check_ntlm_password(mem_ctx,
+	nt_status = auth_check_ntlm_password(state,
 					     auth_context,
 					     mapped_user_info,
 					     &server_info,
-					     pauthoritative);
+					     &state->authoritative);
 
 	if (!NT_STATUS_IS_OK(nt_status)) {
-		DEBUG(5,("Checking NTLMSSP password for %s\\%s failed: "
-			 "%s, authoritative=%u\n",
+		DBG_INFO("Checking NTLMSSP password for %s\\%s failed: "
+			 "%s, authoritative=%"PRIu8"\n",
 			 user_info->client.domain_name,
 			 user_info->client.account_name,
 			 nt_errstr(nt_status),
-			 *pauthoritative));
+			 state->authoritative);
 	}
 
 	username_was_mapped = mapped_user_info->was_mapped;
@@ -201,16 +216,18 @@ NTSTATUS auth3_check_password(struct auth4_context *auth4_context,
 	TALLOC_FREE(mapped_user_info);
 
 	if (!NT_STATUS_IS_OK(nt_status)) {
-		nt_status = do_map_to_guest_server_info(mem_ctx,
-							nt_status,
-							user_info->client.account_name,
-							user_info->client.domain_name,
-							&server_info);
-		if (NT_STATUS_IS_OK(nt_status)) {
-			*pauthoritative = 1;
-			*server_returned_info = talloc_steal(mem_ctx, server_info);
+		nt_status = do_map_to_guest_server_info(
+			state,
+			nt_status,
+			user_info->client.account_name,
+			user_info->client.domain_name,
+			&server_info);
+		if (!tevent_req_nterror(req, nt_status)) {
+			state->authoritative = 1;
+			tevent_req_done(req);
 		}
-		return nt_status;
+		state->server_info = server_info;
+		return tevent_req_post(req, ev);
 	}
 
 	server_info->nss_token |= username_was_mapped;
@@ -219,21 +236,68 @@ NTSTATUS auth3_check_password(struct auth4_context *auth4_context,
 	 * They will not be used in this form again - instead the
 	 * NTLMSSP code will decide on the final correct session key,
 	 * and supply it to create_local_token() */
-	if (session_key) {
-		DEBUG(10, ("Got NT session key of length %u\n",
-			(unsigned int)server_info->session_key.length));
-		*session_key = server_info->session_key;
-		talloc_steal(mem_ctx, server_info->session_key.data);
-		server_info->session_key = data_blob_null;
+
+	DBG_DEBUG("Got NT session key of length %zu\n",
+		  server_info->session_key.length);
+	state->nt_session_key = (DATA_BLOB) {
+		.data = talloc_move(
+			state, &server_info->session_key.data),
+		.length = server_info->session_key.length,
+	};
+	server_info->session_key = data_blob_null;
+
+	DBG_DEBUG("Got LM session key of length %zu\n",
+		  server_info->lm_session_key.length);
+	state->lm_session_key = (DATA_BLOB) {
+		.data = talloc_move(
+			state, &server_info->lm_session_key.data),
+		.length = server_info->lm_session_key.length,
+	};
+	server_info->lm_session_key = data_blob_null;
+
+	state->server_info = server_info;
+
+	tevent_req_done(req);
+	return tevent_req_post(req, ev);
+}
+
+NTSTATUS auth3_check_password_recv(struct tevent_req *req,
+				   TALLOC_CTX *mem_ctx,
+				   uint8_t *pauthoritative,
+				   void **server_returned_info,
+				   DATA_BLOB *nt_session_key,
+				   DATA_BLOB *lm_session_key)
+{
+	struct auth3_check_password_state *state = tevent_req_data(
+		req, struct auth3_check_password_state);
+	NTSTATUS status;
+
+	if (pauthoritative != NULL) {
+		*pauthoritative = state->authoritative;
 	}
-	if (lm_session_key) {
-		DEBUG(10, ("Got LM session key of length %u\n",
-			(unsigned int)server_info->lm_session_key.length));
-		*lm_session_key = server_info->lm_session_key;
-		talloc_steal(mem_ctx, server_info->lm_session_key.data);
-		server_info->lm_session_key = data_blob_null;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		return status;
 	}
 
-	*server_returned_info = talloc_steal(mem_ctx, server_info);
-	return nt_status;
+	if (server_returned_info != NULL) {
+		*server_returned_info = talloc_move(
+			mem_ctx, &state->server_info);
+	}
+	if (nt_session_key != NULL) {
+		*nt_session_key = (DATA_BLOB) {
+			.data = talloc_move(
+				mem_ctx, &state->nt_session_key.data),
+			.length = state->nt_session_key.length,
+		};
+	}
+	if (lm_session_key != NULL) {
+		*lm_session_key = (DATA_BLOB) {
+			.data = talloc_move(
+				mem_ctx, &state->lm_session_key.data),
+			.length = state->lm_session_key.length,
+		};
+	}
+
+	return NT_STATUS_OK;
 }
diff --git a/source3/auth/auth_sam.c b/source3/auth/auth_sam.c
index 46958c54d3a..3c12f959faf 100644
--- a/source3/auth/auth_sam.c
+++ b/source3/auth/auth_sam.c
@@ -35,12 +35,26 @@ static NTSTATUS auth_sam_ignoredomain_auth(const struct auth_context *auth_conte
 	if (!user_info || !auth_context) {
 		return NT_STATUS_UNSUCCESSFUL;
 	}
+
+	if (user_info->mapped.account_name == NULL ||
+	    user_info->mapped.account_name[0] == '\0')
+	{
+		return NT_STATUS_NOT_IMPLEMENTED;
+	}
+
+	DBG_DEBUG("Check auth for: [%s]\\[%s]\n",
+		  user_info->mapped.domain_name,
+		  user_info->mapped.account_name);
+
 	return check_sam_security(&auth_context->challenge, mem_ctx,
 				  user_info, server_info);
 }
 
 /* module initialisation */
-static NTSTATUS auth_init_sam_ignoredomain(struct auth_context *auth_context, const char *param, auth_methods **auth_method) 
+static NTSTATUS auth_init_sam_ignoredomain(
+	struct auth_context *auth_context,
+	const char *param,
+	struct auth_methods **auth_method)
 {
 	struct auth_methods *result;
 
@@ -66,16 +80,52 @@ static NTSTATUS auth_samstrict_auth(const struct auth_context *auth_context,
 				    const struct auth_usersupplied_info *user_info,
 				    struct auth_serversupplied_info **server_info)
 {
+	const char *effective_domain = NULL;
 	bool is_local_name, is_my_domain;
 
 	if (!user_info || !auth_context) {
 		return NT_STATUS_LOGON_FAILURE;
 	}
+	effective_domain = user_info->mapped.domain_name;
+
+	if (user_info->mapped.account_name == NULL ||
+	    user_info->mapped.account_name[0] == '\0')
+	{
+		return NT_STATUS_NOT_IMPLEMENTED;
+	}
+
+	if (lp_server_role() == ROLE_DOMAIN_MEMBER) {
+		const char *p = NULL;
+
+		p = strchr_m(user_info->mapped.account_name, '@');
+		if (p != NULL) {
+			/*
+			 * This needs to go to the DC,
+			 * even if @ is the last character
+			 */
+			return NT_STATUS_NOT_IMPLEMENTED;
+		}
+	}
+
+	if (effective_domain == NULL) {
+		effective_domain = "";
+	}
 
-	DEBUG(10, ("Check auth for: [%s]\n", user_info->mapped.account_name));
+	DBG_DEBUG("Check auth for: [%s]\\[%s]\n",
+		  effective_domain,
+		  user_info->mapped.account_name);
+
+
+	if (strequal(effective_domain, "") || strequal(effective_domain, ".")) {
+		/*
+		 * An empty domain name or '.' should be handled
+		 * as the local SAM name.
+		 */
+		effective_domain = lp_netbios_name();
+	}
 
-	is_local_name = is_myname(user_info->mapped.domain_name);
-	is_my_domain  = strequal(user_info->mapped.domain_name, lp_workgroup());
+	is_local_name = is_myname(effective_domain);
+	is_my_domain  = strequal(effective_domain, lp_workgroup());
 
 	/* check whether or not we service this domain/workgroup name */
 
@@ -84,21 +134,21 @@ static NTSTATUS auth_samstrict_auth(const struct auth_context *auth_context,
 		case ROLE_DOMAIN_MEMBER:
 			if ( !is_local_name ) {
 				DEBUG(6,("check_samstrict_security: %s is not one of my local names (%s)\n",
-					user_info->mapped.domain_name, (lp_server_role() == ROLE_DOMAIN_MEMBER
+					effective_domain, (lp_server_role() == ROLE_DOMAIN_MEMBER
 					? "ROLE_DOMAIN_MEMBER" : "ROLE_STANDALONE") ));
 				return NT_STATUS_NOT_IMPLEMENTED;
 			}
 
-			FALL_THROUGH;
+			break;
 		case ROLE_DOMAIN_PDC:
 		case ROLE_DOMAIN_BDC:
 			if ( !is_local_name && !is_my_domain ) {
 				DEBUG(6,("check_samstrict_security: %s is not one of my local names or domain name (DC)\n",
-					user_info->mapped.domain_name));
+					effective_domain));
 				return NT_STATUS_NOT_IMPLEMENTED;
 			}
 
-			FALL_THROUGH;
+			break;
 		default: /* name is ok */
 			break;
 	}
@@ -108,7 +158,10 @@ static NTSTATUS auth_samstrict_auth(const struct auth_context *auth_context,
 }
 
 /* module initialisation */
-static NTSTATUS auth_init_sam(struct auth_context *auth_context, const char *param, auth_methods **auth_method) 
+static NTSTATUS auth_init_sam(
+	struct auth_context *auth_context,
+	const char *param,
+	struct auth_methods **auth_method)
 {
 	struct auth_methods *result;
 
@@ -135,14 +188,26 @@ static NTSTATUS auth_sam_netlogon3_auth(const struct auth_context *auth_context,
 					const struct auth_usersupplied_info *user_info,
 					struct auth_serversupplied_info **server_info)
 {
+	const char *effective_domain = NULL;
 	bool is_my_domain;
 
 	if (!user_info || !auth_context) {
 		return NT_STATUS_LOGON_FAILURE;
 	}
+	effective_domain = user_info->mapped.domain_name;
+
+	if (user_info->mapped.account_name == NULL ||
+	    user_info->mapped.account_name[0] == '\0')
+	{
+		return NT_STATUS_NOT_IMPLEMENTED;
+	}
+
+	if (effective_domain == NULL) {
+		effective_domain = "";
+	}
 
 	DBG_DEBUG("Check auth for: [%s]\\[%s]\n",
-		  user_info->mapped.domain_name,
+		  effective_domain,
 		  user_info->mapped.account_name);
 
 	/* check whether or not we service this domain/workgroup name */
@@ -156,10 +221,18 @@ static NTSTATUS auth_sam_netlogon3_auth(const struct auth_context *auth_context,
 		return NT_STATUS_INVALID_SERVER_STATE;
 	}
 
+	if (strequal(effective_domain, "") || strequal(effective_domain, ".")) {
+		/*
+		 * An empty domain name or '.' should be handled
+		 * as the local SAM name.
+		 */
+		effective_domain = lp_workgroup();
+	}
+
 	is_my_domain = strequal(user_info->mapped.domain_name, lp_workgroup());
 	if (!is_my_domain) {
 		DBG_INFO("%s is not our domain name (DC for %s)\n",
-			 user_info->mapped.domain_name, lp_workgroup());
+			 effective_domain, lp_workgroup());
 		return NT_STATUS_NOT_IMPLEMENTED;
 	}
 
@@ -168,8 +241,10 @@ static NTSTATUS auth_sam_netlogon3_auth(const struct auth_context *auth_context,
 }
 
 /* module initialisation */
-static NTSTATUS auth_init_sam_netlogon3(struct auth_context *auth_context,
-					const char *param, auth_methods **auth_method)
+static NTSTATUS auth_init_sam_netlogon3(
+	struct auth_context *auth_context,
+	const char *param,
+	struct auth_methods **auth_method)
 {
 	struct auth_methods *result;
 
diff --git a/source3/auth/auth_samba4.c b/source3/auth/auth_samba4.c
index a71c75631d7..6dee9c6f411 100644
--- a/source3/auth/auth_samba4.c
+++ b/source3/auth/auth_samba4.c
@@ -364,8 +364,8 @@ static NTSTATUS make_auth4_context_s4(const struct auth_context *auth_context,
 
 /* module initialisation */
 static NTSTATUS auth_init_samba4(struct auth_context *auth_context,
-				    const char *param,
-				    auth_methods **auth_method)
+				 const char *param,
+				 struct auth_methods **auth_method)
 {
 	struct auth_methods *result;
 
diff --git a/source3/auth/auth_script.c b/source3/auth/auth_script.c
deleted file mode 100644
index fae55e98c24..00000000000
--- a/source3/auth/auth_script.c
+++ /dev/null
@@ -1,187 +0,0 @@
-/* 
-   Unix SMB/CIFS implementation.
-
-   Call out to a shell script for an authentication check.
-
-   Copyright (C) Jeremy Allison 2005.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "includes.h"
-#include "auth.h"
-
-#undef malloc
-
-#undef DBGC_CLASS
-#define DBGC_CLASS DBGC_AUTH
-
-/* Create a string containing the supplied :
- * domain\n
- * user\n
- * ascii hex challenge\n
- * ascii hex LM response\n
- * ascii hex NT response\n\0
- * and execute a shell script to check this.
- * Allows external programs to create users on demand.
- * Script returns zero on success, non-zero on fail.
- */
-
-static NTSTATUS script_check_user_credentials(const struct auth_context *auth_context,
-					void *my_private_data, 
-					TALLOC_CTX *mem_ctx,
-					const struct auth_usersupplied_info *user_info,
-					struct auth_serversupplied_info **server_info)
-{
-	const char *script = lp_parm_const_string( GLOBAL_SECTION_SNUM, "auth_script", "script", NULL);
-	char *secret_str;
-	size_t secret_str_len;
-	char hex_str[49];
-	int ret, i;
-
-	if (!script) {
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-
-	if (!user_info) {
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-
-	if (!auth_context) {
-		DEBUG(3,("script_check_user_credentials: no auth_info !\n"));
-		return NT_STATUS_INVALID_PARAMETER;
-	}		
-
-	secret_str_len = strlen(user_info->mapped.domain_name) + 1 +
-			strlen(user_info->client.account_name) + 1 +
-			16 + 1 + /* 8 bytes of challenge going to 16 */
-			48 + 1 + /* 24 bytes of challenge going to 48 */
-			48 + 1;
-
-	secret_str = (char *)malloc(secret_str_len);
-	if (!secret_str) {
-		return NT_STATUS_NO_MEMORY;
-	}
-
-	if (strlcpy( secret_str, user_info->mapped.domain_name, secret_str_len) >= secret_str_len) {
-		/* Truncate. */
-		goto cat_out;
-	}
-	if (strlcat( secret_str, "\n", secret_str_len) >= secret_str_len) {
-		/* Truncate. */
-		goto cat_out;
-	}
-	if (strlcat( secret_str, user_info->client.account_name, secret_str_len) >= secret_str_len) {
-		/* Truncate. */
-		goto cat_out;
-	}
-	if (strlcat( secret_str, "\n", secret_str_len) >= secret_str_len) {
-		/* Truncate. */
-		goto cat_out;
-	}
-
-	for (i = 0; i < 8; i++) {
-		slprintf(&hex_str[i*2], 3, "%02X", auth_context->challenge.data[i]);
-	}
-	if (strlcat( secret_str, hex_str, secret_str_len) >= secret_str_len) {
-		/* Truncate. */
-		goto cat_out;
-	}
-	if (strlcat( secret_str, "\n", secret_str_len) >= secret_str_len) {
-		/* Truncate. */
-		goto cat_out;
-	}
-
-	if (user_info->password.response.lanman.data) {
-		for (i = 0; i < 24; i++) {
-			slprintf(&hex_str[i*2], 3, "%02X", user_info->password.response.lanman.data[i]);
-		}
-		if (strlcat( secret_str, hex_str, secret_str_len) >= secret_str_len) {
-			/* Truncate. */
-			goto cat_out;
-		}
-	}
-	if (strlcat( secret_str, "\n", secret_str_len) >= secret_str_len) {
-		/* Truncate. */
-		goto cat_out;
-	}
-
-	if (user_info->password.response.nt.data) {
-		for (i = 0; i < 24; i++) {
-			slprintf(&hex_str[i*2], 3, "%02X", user_info->password.response.nt.data[i]);
-		}
-		if (strlcat( secret_str, hex_str, secret_str_len) >= secret_str_len) {
-			/* Truncate. */
-			goto cat_out;
-		}
-	}
-	if (strlcat( secret_str, "\n", secret_str_len) >= secret_str_len) {
-		/* Truncate. */
-		goto cat_out;
-	}
-
-	DEBUG(10,("script_check_user_credentials: running %s with parameters:\n%s\n",
-		script, secret_str ));
-
-	ret = smbrunsecret( script, secret_str);
-
-	SAFE_FREE(secret_str);
-
-	if (ret) {
-		DEBUG(1,("script_check_user_credentials: failed to authenticate %s\\%s\n",
-			user_info->mapped.domain_name, user_info->client.account_name ));
-		/* auth failed. */
-		return NT_STATUS_NO_SUCH_USER;
-	}
-
-	/* Cause the auth system to keep going.... */
-	return NT_STATUS_NOT_IMPLEMENTED;
-
-  cat_out:
-
-	SAFE_FREE(secret_str);
-	return NT_STATUS_NO_MEMORY;
-}
-
-/* module initialisation */
-static NTSTATUS auth_init_script(struct auth_context *auth_context, const char *param, auth_methods **auth_method) 
-{
-	struct auth_methods *result;
-
-	result = talloc_zero(auth_context, struct auth_methods);
-	if (result == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-	result->name = "script";
-	result->auth = script_check_user_credentials;
-
-	if (param && *param) {
-		/* we load the 'fallback' module - if script isn't here, call this
-		   module */
-		auth_methods *priv;
-		if (!load_auth_module(auth_context, param, &priv)) {
-			return NT_STATUS_UNSUCCESSFUL;
-		}
-		result->private_data = (void *)priv;
-	}
-
-        *auth_method = result;
-	return NT_STATUS_OK;
-}
-
-NTSTATUS auth_script_init(TALLOC_CTX *);
-NTSTATUS auth_script_init(TALLOC_CTX *ctx)
-{
-	return smb_register_auth(AUTH_INTERFACE_VERSION, "script", auth_init_script);
-}
diff --git a/source3/auth/auth_unix.c b/source3/auth/auth_unix.c
index 08d4e002e3d..56fd205a9b8 100644
--- a/source3/auth/auth_unix.c
+++ b/source3/auth/auth_unix.c
@@ -83,7 +83,10 @@ static NTSTATUS check_unix_security(const struct auth_context *auth_context,
 }
 
 /* module initialisation */
-static NTSTATUS auth_init_unix(struct auth_context *auth_context, const char* param, auth_methods **auth_method) 
+static NTSTATUS auth_init_unix(
+	struct auth_context *auth_context,
+	const char* param,
+	struct auth_methods **auth_method)
 {
 	struct auth_methods *result;
 
diff --git a/source3/auth/auth_util.c b/source3/auth/auth_util.c
index 4f9b0a91022..3e0fcea2410 100644
--- a/source3/auth/auth_util.c
+++ b/source3/auth/auth_util.c
@@ -49,10 +49,12 @@
 static int _smb_create_user(const char *domain, const char *unix_username, const char *homedir)
 {
 	TALLOC_CTX *ctx = talloc_tos();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *add_script;
 	int ret;
 
-	add_script = lp_add_user_script(ctx);
+	add_script = lp_add_user_script(ctx, lp_sub);
 	if (!add_script || !*add_script) {
 		return -1;
 	}
@@ -207,6 +209,7 @@ bool make_user_info_netlogon_interactive(TALLOC_CTX *mem_ctx,
 	struct samr_Password nt_pwd;
 	unsigned char local_lm_response[24];
 	unsigned char local_nt_response[24];
+	int rc;
 
 	if (lm_interactive_pwd)
 		memcpy(lm_pwd.hash, lm_interactive_pwd, sizeof(lm_pwd.hash));
@@ -214,13 +217,21 @@ bool make_user_info_netlogon_interactive(TALLOC_CTX *mem_ctx,
 	if (nt_interactive_pwd)
 		memcpy(nt_pwd.hash, nt_interactive_pwd, sizeof(nt_pwd.hash));
 
-	if (lm_interactive_pwd)
-		SMBOWFencrypt(lm_pwd.hash, chal,
-			      local_lm_response);
+	if (lm_interactive_pwd) {
+		rc = SMBOWFencrypt(lm_pwd.hash, chal,
+				   local_lm_response);
+		if (rc != 0) {
+			return false;
+		}
+	}
 
-	if (nt_interactive_pwd)
-		SMBOWFencrypt(nt_pwd.hash, chal,
+	if (nt_interactive_pwd) {
+		rc = SMBOWFencrypt(nt_pwd.hash, chal,
 			      local_nt_response);
+		if (rc != 0) {
+			return false;
+		}
+	}
 
 	{
 		bool ret;
@@ -409,13 +420,15 @@ bool make_user_info_guest(TALLOC_CTX *mem_ctx,
 static NTSTATUS log_nt_token(struct security_token *token)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *command;
 	char *group_sidstr;
 	struct dom_sid_buf buf;
 	size_t i;
 
-	if ((lp_log_nt_token_command(frame) == NULL) ||
-	    (strlen(lp_log_nt_token_command(frame)) == 0)) {
+	if ((lp_log_nt_token_command(frame, lp_sub) == NULL) ||
+	    (strlen(lp_log_nt_token_command(frame, lp_sub)) == 0)) {
 		TALLOC_FREE(frame);
 		return NT_STATUS_OK;
 	}
@@ -428,7 +441,7 @@ static NTSTATUS log_nt_token(struct security_token *token)
 	}
 
 	command = talloc_string_sub(
-		frame, lp_log_nt_token_command(frame),
+		frame, lp_log_nt_token_command(frame, lp_sub),
 		"%s", dom_sid_str_buf(&token->sids[0], &buf));
 	command = talloc_string_sub(frame, command, "%t", group_sidstr);
 
diff --git a/source3/auth/auth_winbind.c b/source3/auth/auth_winbind.c
index 93b832265cf..3b8d1a95769 100644
--- a/source3/auth/auth_winbind.c
+++ b/source3/auth/auth_winbind.c
@@ -178,7 +178,10 @@ static NTSTATUS check_winbind_security(const struct auth_context *auth_context,
 }
 
 /* module initialisation */
-static NTSTATUS auth_init_winbind(struct auth_context *auth_context, const char *param, auth_methods **auth_method) 
+static NTSTATUS auth_init_winbind(
+	struct auth_context *auth_context,
+	const char *param,
+	struct auth_methods **auth_method)
 {
 	struct auth_methods *result;
 
diff --git a/source3/auth/pampass.c b/source3/auth/pampass.c
index 785a0c45b4f..751cee61ce1 100644
--- a/source3/auth/pampass.c
+++ b/source3/auth/pampass.c
@@ -291,6 +291,8 @@ static int smb_pam_passchange_conv(int num_msg,
 	struct smb_pam_userdata *udp = (struct smb_pam_userdata *)appdata_ptr;
 	struct chat_struct *pw_chat;
 	struct chat_struct *t;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	bool found; 
 	*resp = NULL;
 
@@ -299,7 +301,7 @@ static int smb_pam_passchange_conv(int num_msg,
 	if (num_msg <= 0)
 		return PAM_CONV_ERR;
 
-	if ((pw_chat = make_pw_chat(lp_passwd_chat(talloc_tos()))) == NULL)
+	if ((pw_chat = make_pw_chat(lp_passwd_chat(talloc_tos(), lp_sub))) == NULL)
 		return PAM_CONV_ERR;
 
 	/*
diff --git a/source3/auth/proto.h b/source3/auth/proto.h
index 575a3a147cb..097b17fee44 100644
--- a/source3/auth/proto.h
+++ b/source3/auth/proto.h
@@ -37,7 +37,8 @@
 
 NTSTATUS smb_register_auth(int version, const char *name, auth_init_function init);
 bool load_auth_module(struct auth_context *auth_context,
-		      const char *module, auth_methods **ret) ;
+		      const char *module,
+		      struct auth_methods **ret) ;
 NTSTATUS make_auth3_context_for_ntlm(TALLOC_CTX *mem_ctx,
 				     struct auth_context **auth_context);
 NTSTATUS make_auth3_context_for_netlogon(TALLOC_CTX *mem_ctx,
@@ -126,12 +127,17 @@ NTSTATUS auth3_get_challenge(struct auth4_context *auth4_context,
 NTSTATUS auth3_set_challenge(struct auth4_context *auth4_context, const uint8_t *chal,
 			     const char *challenge_set_by);
 
-NTSTATUS auth3_check_password(struct auth4_context *auth4_context,
-			      TALLOC_CTX *mem_ctx,
-			      const struct auth_usersupplied_info *user_info,
-			      uint8_t *pauthoritative,
-			      void **server_returned_info,
-			      DATA_BLOB *session_key, DATA_BLOB *lm_session_key);
+struct tevent_req *auth3_check_password_send(
+	TALLOC_CTX *mem_ctx,
+	struct tevent_context *ev,
+	struct auth4_context *auth4_context,
+	const struct auth_usersupplied_info *user_info);
+NTSTATUS auth3_check_password_recv(struct tevent_req *req,
+				   TALLOC_CTX *mem_ctx,
+				   uint8_t *pauthoritative,
+				   void **server_returned_info,
+				   DATA_BLOB *nt_session_key,
+				   DATA_BLOB *lm_session_key);
 
 /* The following definitions come from auth/auth_sam.c  */
 
diff --git a/source3/auth/user_util.c b/source3/auth/user_util.c
index a76b5d47ba2..f4bdd2d323e 100644
--- a/source3/auth/user_util.c
+++ b/source3/auth/user_util.c
@@ -281,12 +281,14 @@ bool user_in_list(TALLOC_CTX *ctx, const char *user, const char * const *list)
 
 bool map_username(TALLOC_CTX *ctx, const char *user_in, char **p_user_out)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	FILE *f;
-	char *mapfile = lp_username_map(talloc_tos());
+	char *mapfile = lp_username_map(talloc_tos(), lp_sub);
 	char *s;
 	char buf[512];
 	bool mapped_user = False;
-	char *cmd = lp_username_map_script(talloc_tos());
+	char *cmd = lp_username_map_script(talloc_tos(), lp_sub);
 
 	*p_user_out = NULL;
 
diff --git a/source3/auth/wscript_build b/source3/auth/wscript_build
index c1062199aa8..277c4306557 100644
--- a/source3/auth/wscript_build
+++ b/source3/auth/wscript_build
@@ -53,13 +53,6 @@ bld.SAMBA3_MODULE('auth_builtin',
                  init_function='',
                  internal_module=True)
 
-bld.SAMBA3_MODULE('auth_script',
-                 subsystem='auth',
-                 source='auth_script.c',
-                 init_function='',
-                 internal_module=bld.SAMBA3_IS_STATIC_MODULE('auth_script'),
-                 enabled=bld.SAMBA3_IS_ENABLED_MODULE('auth_script'))
-
 bld.SAMBA3_MODULE('auth_samba4',
                   subsystem='auth',
                   source='auth_samba4.c',
diff --git a/source3/client/client.c b/source3/client/client.c
index e1de711c8e4..29754806e63 100644
--- a/source3/client/client.c
+++ b/source3/client/client.c
@@ -39,6 +39,7 @@
 #include "libsmb/nmblib.h"
 #include "include/ntioctl.h"
 #include "../libcli/smb/smbXcli_base.h"
+#include "lib/util/time_basic.h"
 
 #ifndef REGISTER
 #define REGISTER 0
@@ -1812,16 +1813,16 @@ static int do_allinfo(const char *name)
 		return false;
 	}
 
-	tmp = unix_timespec_to_nt_time(b_time);
+	tmp = full_timespec_to_nt_time(&b_time);
 	d_printf("create_time:    %s\n", nt_time_string(talloc_tos(), tmp));
 
-	tmp = unix_timespec_to_nt_time(a_time);
+	tmp = full_timespec_to_nt_time(&a_time);
 	d_printf("access_time:    %s\n", nt_time_string(talloc_tos(), tmp));
 
-	tmp = unix_timespec_to_nt_time(m_time);
+	tmp = full_timespec_to_nt_time(&m_time);
 	d_printf("write_time:     %s\n", nt_time_string(talloc_tos(), tmp));
 
-	tmp = unix_timespec_to_nt_time(c_time);
+	tmp = full_timespec_to_nt_time(&c_time);
 	d_printf("change_time:    %s\n", nt_time_string(talloc_tos(), tmp));
 
 	d_printf("attributes: %s (%x)\n", attr_str(talloc_tos(), mode), mode);
@@ -5189,16 +5190,22 @@ static int cmd_show_connect( void )
  *
  * Update the file times with the ones provided.
  */
-static int set_remote_times(const char *filename, time_t create_time,
-			time_t access_time, time_t write_time,
-			time_t change_time)
+static int set_remote_times(const char *filename,
+			    struct timespec *create_time,
+			    struct timespec *access_time,
+			    struct timespec *write_time,
+			    struct timespec *change_time)
 {
 	extern struct cli_state *cli;
 	NTSTATUS status;
 
-	status = cli_setpathinfo_basic(cli, filename, create_time,
-					access_time, write_time,
-					change_time, -1);
+	status = cli_setpathinfo_ext(cli,
+				filename,
+				create_time,
+				access_time,
+				write_time,
+				change_time,
+				-1);
 	if (!NT_STATUS_IS_OK(status)) {
 		d_printf("cli_setpathinfo_basic failed: %s\n",
 			 nt_errstr(status));
@@ -5219,7 +5226,8 @@ static int cmd_utimes(void)
 	const extern char *cmd_ptr;
 	char *buf;
 	char *fname = NULL;
-	time_t times[4] = {0, 0, 0, 0};
+	struct timespec times[4] = {{0}};
+	struct timeval_buf tbuf[4];
 	int time_count = 0;
 	int err = 0;
 	bool ok;
@@ -5256,10 +5264,11 @@ static int cmd_utimes(void)
 		time_count < 4) {
 		const char *s = buf;
 		struct tm tm = {0,};
+		time_t t;
 		char *ret;
 
 		if (strlen(s) == 2 && strcmp(s, "-1") == 0) {
-			times[time_count] = 0;
+			times[time_count] = make_omit_timespec();
 			time_count++;
 			continue;
 		} else {
@@ -5278,7 +5287,8 @@ static int cmd_utimes(void)
 		}
 
 		/* Convert tm to a time_t */
-		times[time_count] = mktime(&tm);
+		t = mktime(&tm);
+		times[time_count] = (struct timespec){.tv_sec = t};
 		time_count++;
 	}
 
@@ -5293,12 +5303,12 @@ static int cmd_utimes(void)
 	}
 
 	DEBUG(10, ("times\nCreate: %sAccess: %s Write: %sChange: %s\n",
-		talloc_strdup(ctx, ctime(&times[0])),
-		talloc_strdup(ctx, ctime(&times[1])),
-		talloc_strdup(ctx, ctime(&times[2])),
-		talloc_strdup(ctx, ctime(&times[3]))));
+		   timespec_string_buf(&times[0], false, &tbuf[0]),
+		   timespec_string_buf(&times[1], false, &tbuf[1]),
+		   timespec_string_buf(&times[2], false, &tbuf[2]),
+		   timespec_string_buf(&times[3], false, &tbuf[3])));
 
-	set_remote_times(fname, times[0], times[1], times[2], times[3]);
+	set_remote_times(fname, &times[0], &times[1], &times[2], &times[3]);
 out:
 	talloc_free(ctx);
 	return err;
@@ -5609,7 +5619,7 @@ static struct {
   {"scopy",cmd_scopy,"<src> <dest> server-side copy file",{COMPL_REMOTE,COMPL_REMOTE}},
   {"stat",cmd_stat,"<file name> Do a UNIX extensions stat call on a file",{COMPL_REMOTE,COMPL_NONE}},
   {"symlink",cmd_symlink,"<oldname> <newname> create a UNIX symlink",{COMPL_REMOTE,COMPL_REMOTE}},
-  {"tar",cmd_tar,"tar <c|x>[IXFqbgNan] current directory to/from <file name>",{COMPL_NONE,COMPL_NONE}},
+  {"tar",cmd_tar,"tar <c|x>[IXFvbgNan] current directory to/from <file name>",{COMPL_NONE,COMPL_NONE}},
   {"tarmode",cmd_tarmode,"<full|inc|reset|noreset> tar's behaviour towards archive bits",{COMPL_NONE,COMPL_NONE}},
   {"timeout",cmd_timeout,"timeout <number> - set the per-operation timeout in seconds (default 20)",{COMPL_NONE,COMPL_NONE}},
   {"translate",cmd_translate,"toggle text translation for printing",{COMPL_NONE,COMPL_NONE}},
@@ -6406,7 +6416,7 @@ int main(int argc,char *argv[])
 			.arg        = NULL,
 			.val        = 'T',
 			.descrip    = "Command line tar",
-			.argDescrip = "<c|x>IXFqgbNan",
+			.argDescrip = "<c|x>IXFvgbNan",
 		},
 		{
 			.longName   = "directory",
diff --git a/source3/client/clitar.c b/source3/client/clitar.c
index b598bde4ee8..76596067f2d 100644
--- a/source3/client/clitar.c
+++ b/source3/client/clitar.c
@@ -153,6 +153,10 @@ struct tar {
 
 	/* archive handle */
 	struct archive *archive;
+
+	/* counters */
+	uint64_t numdir;
+	uint64_t numfile;
 };
 
 /**
@@ -211,8 +215,7 @@ static int make_remote_path(const char *full_path);
 static int max_token (const char *str);
 static NTSTATUS is_subpath(const char *sub, const char *full,
 			   bool *_subpath_match);
-
-/**
+ /*
  * tar_get_ctx - retrieve global tar context handle
  */
 struct tar *tar_get_ctx()
@@ -285,10 +288,8 @@ int cmd_tarmode(void)
 		{"nosystem",  &tar_ctx.mode.system,      false},
 		{"hidden",    &tar_ctx.mode.hidden,      true },
 		{"nohidden",  &tar_ctx.mode.hidden,      false},
-		{"verbose",   &tar_ctx.mode.verbose,     true },
-		{"noquiet",   &tar_ctx.mode.verbose,     true },
-		{"quiet",     &tar_ctx.mode.verbose,     false},
-		{"noverbose", &tar_ctx.mode.verbose,     false},
+		{"verbose",   &tar_ctx.mode.verbose,     false},
+		{"noverbose", &tar_ctx.mode.verbose,     true },
 	};
 
 	ctx = talloc_new(NULL);
@@ -305,15 +306,15 @@ int cmd_tarmode(void)
 		}
 
 		if (i == ARRAY_SIZE(table))
-			DBG(0, ("tarmode: unrecognised option %s\n", buf));
+			d_printf("tarmode: unrecognised option %s\n", buf);
 	}
 
-	DBG(0, ("tarmode is now %s, %s, %s, %s, %s\n",
+	d_printf("tarmode is now %s, %s, %s, %s, %s\n",
 				tar_ctx.mode.incremental ? "incremental" : "full",
 				tar_ctx.mode.system      ? "system"      : "nosystem",
 				tar_ctx.mode.hidden      ? "hidden"      : "nohidden",
 				tar_ctx.mode.reset       ? "reset"       : "noreset",
-				tar_ctx.mode.verbose     ? "verbose"     : "quiet"));
+				tar_ctx.mode.verbose     ? "verbose"     : "noverbose");
 
 	talloc_free(ctx);
 	return 0;
@@ -342,7 +343,7 @@ int cmd_tar(void)
 
 	ok = next_token_talloc(ctx, &cmd_ptr, &buf, NULL);
 	if (!ok) {
-		DBG(0, ("tar <c|x>[IXFbganN] [options] <tar file> [path list]\n"));
+		d_printf("tar <c|x>[IXFbgvanN] [options] <tar file> [path list]\n");
 		err = 1;
 		goto out;
 	}
@@ -360,14 +361,14 @@ int cmd_tar(void)
 
 	rc = tar_parse_args(&tar_ctx, flag, val, i);
 	if (rc != 0) {
-		DBG(0, ("parse_args failed\n"));
+		d_printf("parse_args failed\n");
 		err = 1;
 		goto out;
 	}
 
 	rc = tar_process(&tar_ctx);
 	if (rc != 0) {
-		DBG(0, ("tar_process failed\n"));
+		d_printf("tar_process failed\n");
 		err = 1;
 		goto out;
 	}
@@ -416,7 +417,7 @@ int tar_parse_args(struct tar* t,
 	int rc;
 
 	if (t == NULL) {
-		DBG(0, ("Invalid tar context\n"));
+		DBG_WARNING("Invalid tar context\n");
 		return 1;
 	}
 
@@ -439,14 +440,14 @@ int tar_parse_args(struct tar* t,
 		/* operation */
 		case 'c':
 			if (t->mode.operation != TAR_NO_OPERATION) {
-				printf("Tar must be followed by only one of c or x.\n");
+				d_printf("Tar must be followed by only one of c or x.\n");
 				return 1;
 			}
 			t->mode.operation = TAR_CREATE;
 			break;
 		case 'x':
 			if (t->mode.operation != TAR_NO_OPERATION) {
-				printf("Tar must be followed by only one of c or x.\n");
+				d_printf("Tar must be followed by only one of c or x.\n");
 				return 1;
 			}
 			t->mode.operation = TAR_EXTRACT;
@@ -455,21 +456,21 @@ int tar_parse_args(struct tar* t,
 			/* selection  */
 		case 'I':
 			if (t->mode.selection != TAR_NO_SELECTION) {
-				DBG(0,("Only one of I,X,F must be specified\n"));
+				d_printf("Only one of I,X,F must be specified\n");
 				return 1;
 			}
 			t->mode.selection = TAR_INCLUDE;
 			break;
 		case 'X':
 			if (t->mode.selection != TAR_NO_SELECTION) {
-				DBG(0,("Only one of I,X,F must be specified\n"));
+				d_printf("Only one of I,X,F must be specified\n");
 				return 1;
 			}
 			t->mode.selection = TAR_EXCLUDE;
 			break;
 		case 'F':
 			if (t->mode.selection != TAR_NO_SELECTION) {
-				DBG(0,("Only one of I,X,F must be specified\n"));
+				d_printf("Only one of I,X,F must be specified\n");
 				return 1;
 			}
 			t->mode.selection = TAR_INCLUDE;
@@ -479,12 +480,12 @@ int tar_parse_args(struct tar* t,
 			/* blocksize */
 		case 'b':
 			if (ival >= valsize) {
-				DBG(0, ("Option b must be followed by a blocksize\n"));
+				d_printf("Option b must be followed by a blocksize\n");
 				return 1;
 			}
 
 			if (tar_set_blocksize(t, atoi(val[ival]))) {
-				DBG(0, ("Option b must be followed by a valid blocksize\n"));
+				d_printf("Option b must be followed by a valid blocksize\n");
 				return 1;
 			}
 
@@ -499,12 +500,12 @@ int tar_parse_args(struct tar* t,
 			/* newer than */
 		case 'N':
 			if (ival >= valsize) {
-				DBG(0, ("Option N must be followed by valid file name\n"));
+				d_printf("Option N must be followed by valid file name\n");
 				return 1;
 			}
 
 			if (tar_set_newer_than(t, val[ival])) {
-				DBG(0,("Error setting newer-than time\n"));
+				d_printf("Error setting newer-than time\n");
 				return 1;
 			}
 
@@ -517,7 +518,7 @@ int tar_parse_args(struct tar* t,
 			break;
 
 			/* verbose */
-		case 'q':
+		case 'v':
 			t->mode.verbose = true;
 			break;
 
@@ -529,16 +530,16 @@ int tar_parse_args(struct tar* t,
 			/* dry run mode */
 		case 'n':
 			if (t->mode.operation != TAR_CREATE) {
-				DBG(0, ("n is only meaningful when creating a tar-file\n"));
+				d_printf("n is only meaningful when creating a tar-file\n");
 				return 1;
 			}
 
 			t->mode.dry = true;
-			DBG(0, ("dry_run set\n"));
+			d_printf("dry_run set\n");
 			break;
 
 		default:
-			DBG(0,("Unknown tar option\n"));
+			d_printf("Unknown tar option\n");
 			return 1;
 		}
 
@@ -551,7 +552,7 @@ int tar_parse_args(struct tar* t,
 	}
 
 	if (valsize - ival < 1) {
-		DBG(0, ("No tar file given.\n"));
+		d_printf("No tar file given.\n");
 		return 1;
 	}
 
@@ -575,7 +576,7 @@ int tar_parse_args(struct tar* t,
 	/* flag F -> read file list */
 	if (do_read_list) {
 		if (valsize - ival != 1) {
-			DBG(0,("Option F must be followed by exactly one filename.\n"));
+			d_printf("Option F must be followed by exactly one filename.\n");
 			return 1;
 		}
 
@@ -611,7 +612,7 @@ int tar_process(struct tar *t)
 	int rc = 0;
 
 	if (t == NULL) {
-		DBG(0, ("Invalid tar context\n"));
+		DBG_WARNING("Invalid tar context\n");
 		return 1;
 	}
 
@@ -623,7 +624,7 @@ int tar_process(struct tar *t)
 		rc = tar_create(t);
 		break;
 	default:
-		DBG(0, ("Invalid tar state\n"));
+		DBG_WARNING("Invalid tar state\n");
 		rc = 1;
 	}
 
@@ -642,18 +643,23 @@ static int tar_create(struct tar* t)
 	int err = 0;
 	NTSTATUS status;
 	const char *mask;
+	struct timespec tp_start, tp_end;
 	TALLOC_CTX *ctx = talloc_new(NULL);
 	if (ctx == NULL) {
 		return 1;
 	}
 
+	clock_gettime_mono(&tp_start);
+
+	t->numfile = 0;
+	t->numdir = 0;
 	t->archive = archive_write_new();
 
 	if (!t->mode.dry) {
 		const int bsize = t->mode.blocksize * TAR_BLOCK_UNIT;
 		r = archive_write_set_bytes_per_block(t->archive, bsize);
 		if (r != ARCHIVE_OK) {
-			DBG(0, ("Can't use a block size of %d bytes", bsize));
+			d_printf("Can't use a block size of %d bytes", bsize);
 			err = 1;
 			goto out;
 		}
@@ -665,8 +671,8 @@ static int tar_create(struct tar* t)
 		 */
 		r = archive_write_set_format_pax_restricted(t->archive);
 		if (r != ARCHIVE_OK) {
-			DBG(0, ("Can't use pax restricted format: %s\n",
-						archive_error_string(t->archive)));
+			d_printf("Can't use pax restricted format: %s\n",
+						archive_error_string(t->archive));
 			err = 1;
 			goto out;
 		}
@@ -678,8 +684,8 @@ static int tar_create(struct tar* t)
 		}
 
 		if (r != ARCHIVE_OK) {
-			DBG(0, ("Can't open %s: %s\n", t->tar_path,
-						archive_error_string(t->archive)));
+			d_printf("Can't open %s: %s\n", t->tar_path,
+						archive_error_string(t->archive));
 			err = 1;
 			goto out_close;
 		}
@@ -713,13 +719,19 @@ static int tar_create(struct tar* t)
 		}
 	}
 
+	clock_gettime_mono(&tp_end);
+	d_printf("tar: dumped %"PRIu64" files and %"PRIu64" directories\n",
+	         t->numfile, t->numdir);
+	d_printf("Total bytes written: %"PRIu64" (%.1f MiB/s)\n",
+		t->total_size,
+		t->total_size/timespec_elapsed2(&tp_start, &tp_end)/1024/1024);
+
 out_close:
-	DBG(0, ("Total bytes received: %" PRIu64 "\n", t->total_size));
 
 	if (!t->mode.dry) {
 		r = archive_write_close(t->archive);
 		if (r != ARCHIVE_OK) {
-			DBG(0, ("Fatal: %s\n", archive_error_string(t->archive)));
+			d_printf("Fatal: %s\n", archive_error_string(t->archive));
 			err = 1;
 			goto out;
 		}
@@ -823,8 +835,11 @@ static NTSTATUS get_file_callback(struct cli_state *cli,
 {
 	NTSTATUS status = NT_STATUS_OK;
 	char *remote_name;
+	char *old_dir = NULL;
+	char *new_dir = NULL;
 	const char *initial_dir = client_get_cur_dir();
 	bool skip = false;
+	bool isdir;
 	int rc;
 	TALLOC_CTX *ctx = talloc_new(NULL);
 	if (ctx == NULL) {
@@ -846,7 +861,19 @@ static NTSTATUS get_file_callback(struct cli_state *cli,
 		goto out;
 	}
 
-	status = tar_create_skip_path(&tar_ctx, remote_name, finfo, &skip);
+	isdir = finfo->mode & FILE_ATTRIBUTE_DIRECTORY;
+	if (isdir) {
+		old_dir = talloc_strdup(ctx, initial_dir);
+		new_dir = talloc_asprintf(ctx, "%s\\", remote_name);
+		if ((old_dir == NULL) || (new_dir == NULL)) {
+			status = NT_STATUS_NO_MEMORY;
+			goto out;
+		}
+	}
+
+	status = tar_create_skip_path(&tar_ctx,
+	                              isdir ? new_dir : remote_name,
+	                              finfo, &skip);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto out;
 	}
@@ -857,18 +884,8 @@ static NTSTATUS get_file_callback(struct cli_state *cli,
 		goto out;
 	}
 
-	if (finfo->mode & FILE_ATTRIBUTE_DIRECTORY) {
-		char *old_dir;
-		char *new_dir;
+	if (isdir) {
 		char *mask;
-
-		old_dir = talloc_strdup(ctx, initial_dir);
-		new_dir = talloc_asprintf(ctx, "%s%s\\",
-					  initial_dir, finfo->name);
-		if ((old_dir == NULL) || (new_dir == NULL)) {
-			status = NT_STATUS_NO_MEMORY;
-			goto out;
-		}
 		mask = talloc_asprintf(ctx, "%s*", new_dir);
 		if (mask == NULL) {
 			status = NT_STATUS_NO_MEMORY;
@@ -889,6 +906,7 @@ static NTSTATUS get_file_callback(struct cli_state *cli,
 		client_set_cur_dir(new_dir);
 		do_list(mask, TAR_DO_LIST_ATTR, get_file_callback, false, true);
 		client_set_cur_dir(old_dir);
+		tar_ctx.numdir++;
 	} else {
 		rc = tar_get_file(&tar_ctx, remote_name, finfo);
 		if (rc != 0) {
@@ -922,6 +940,7 @@ static int tar_get_file(struct tar *t,
 	int err = 0, r;
 	const bool isdir = finfo->mode & FILE_ATTRIBUTE_DIRECTORY;
 	TALLOC_CTX *ctx = talloc_new(NULL);
+
 	if (ctx == NULL) {
 		return 1;
 	}
@@ -963,36 +982,50 @@ static int tar_get_file(struct tar *t,
 	 * signed size. Very unlikely problem (>9 exabyte file)
 	 */
 	if (finfo->size > INT64_MAX) {
-		DBG(0, ("Remote file %s too big\n", full_dos_path));
+		d_printf("Remote file %s too big\n", full_dos_path);
 		goto out_entry;
 	}
 
 	archive_entry_set_size(entry, (int64_t)finfo->size);
 
-	r = archive_write_header(t->archive, entry);
-	if (r != ARCHIVE_OK) {
-		DBG(0, ("Fatal: %s\n", archive_error_string(t->archive)));
-		err = 1;
-		goto out_entry;
-	}
-
 	if (isdir) {
+		/* It's a directory just write a header */
+		r = archive_write_header(t->archive, entry);
+		if (r != ARCHIVE_OK) {
+			d_printf("Fatal: %s\n", archive_error_string(t->archive));
+			err = 1;
+		}
+		if (t->mode.verbose) {
+			d_printf("a %s\\\n", full_dos_path);
+		}
 		DBG(5, ("get_file skip dir %s\n", full_dos_path));
 		goto out_entry;
 	}
 
 	status = cli_open(cli, full_dos_path, O_RDONLY, DENY_NONE, &remote_fd);
 	if (!NT_STATUS_IS_OK(status)) {
-		DBG(0,("%s opening remote file %s\n",
-					nt_errstr(status), full_dos_path));
+		d_printf("%s opening remote file %s\n",
+					nt_errstr(status), full_dos_path);
 		goto out_entry;
 	}
 
+	/* don't make tar file entry until after the file is open */
+	r = archive_write_header(t->archive, entry);
+	if (r != ARCHIVE_OK) {
+		d_printf("Fatal: %s\n", archive_error_string(t->archive));
+		err = 1;
+		goto out_entry;
+	}
+
+	if (t->mode.verbose) {
+		d_printf("a %s\n", full_dos_path);
+	}
+
 	do {
 		status = cli_read(cli, remote_fd, buf, off, sizeof(buf), &len);
 		if (!NT_STATUS_IS_OK(status)) {
-			DBG(0,("Error reading file %s : %s\n",
-						full_dos_path, nt_errstr(status)));
+			d_printf("Error reading file %s : %s\n",
+						full_dos_path, nt_errstr(status));
 			err = 1;
 			goto out_close;
 		}
@@ -1001,12 +1034,13 @@ static int tar_get_file(struct tar *t,
 
 		r = archive_write_data(t->archive, buf, len);
 		if (r < 0) {
-			DBG(0, ("Fatal: %s\n", archive_error_string(t->archive)));
+			d_printf("Fatal: %s\n", archive_error_string(t->archive));
 			err = 1;
 			goto out_close;
 		}
 
 	} while (off < finfo->size);
+	t->numfile++;
 
 out_close:
 	cli_close(cli, remote_fd);
@@ -1043,8 +1077,8 @@ static int tar_extract(struct tar *t)
 	}
 
 	if (r != ARCHIVE_OK) {
-		DBG(0, ("Can't open %s : %s\n", t->tar_path,
-					archive_error_string(t->archive)));
+		d_printf("Can't open %s : %s\n", t->tar_path,
+					archive_error_string(t->archive));
 		err = 1;
 		goto out;
 	}
@@ -1057,10 +1091,10 @@ static int tar_extract(struct tar *t)
 			break;
 		}
 		if (r == ARCHIVE_WARN) {
-			DBG(0, ("Warning: %s\n", archive_error_string(t->archive)));
+			d_printf("Warning: %s\n", archive_error_string(t->archive));
 		}
 		if (r == ARCHIVE_FATAL) {
-			DBG(0, ("Fatal: %s\n", archive_error_string(t->archive)));
+			d_printf("Fatal: %s\n", archive_error_string(t->archive));
 			err = 1;
 			goto out;
 		}
@@ -1074,9 +1108,12 @@ static int tar_extract(struct tar *t)
 			DBG(5, ("--- %s\n", archive_entry_pathname(entry)));
 			continue;
 		}
-
 		DBG(5, ("+++ %s\n", archive_entry_pathname(entry)));
 
+		if (t->mode.verbose) {
+			d_printf("x %s\n", archive_entry_pathname(entry));
+		}
+
 		rc = tar_send_file(t, entry);
 		if (rc != 0) {
 			err = 1;
@@ -1091,8 +1128,8 @@ out:
 	r = archive_read_finish(t->archive);
 #endif
 	if (r != ARCHIVE_OK) {
-		DBG(0, ("Can't close %s : %s\n", t->tar_path,
-					archive_error_string(t->archive)));
+		d_printf("Can't close %s : %s\n", t->tar_path,
+					archive_error_string(t->archive));
 		err = 1;
 	}
 	return err;
@@ -1145,7 +1182,7 @@ static int tar_send_file(struct tar *t, struct archive_entry *entry)
 	}
 
 	if (mode != AE_IFREG && mode != AE_IFDIR) {
-		DBG(0, ("Skipping non-dir & non-regular file %s\n", full_path));
+		d_printf("Skipping non-dir & non-regular file %s\n", full_path);
 		goto out;
 	}
 
@@ -1161,8 +1198,8 @@ static int tar_send_file(struct tar *t, struct archive_entry *entry)
 
 	status = cli_open(cli, full_path, flags, DENY_NONE, &remote_fd);
 	if (!NT_STATUS_IS_OK(status)) {
-		DBG(0, ("Error opening remote file %s: %s\n",
-					full_path, nt_errstr(status)));
+		d_printf("Error opening remote file %s: %s\n",
+					full_path, nt_errstr(status));
 		err = 1;
 		goto out;
 	}
@@ -1178,18 +1215,18 @@ static int tar_send_file(struct tar *t, struct archive_entry *entry)
 			break;
 		}
 		if (r == ARCHIVE_WARN) {
-			DBG(0, ("Warning: %s\n", archive_error_string(t->archive)));
+			d_printf("Warning: %s\n", archive_error_string(t->archive));
 		}
 		if (r == ARCHIVE_FATAL) {
-			DBG(0, ("Fatal: %s\n", archive_error_string(t->archive)));
+			d_printf("Fatal: %s\n", archive_error_string(t->archive));
 			err = 1;
 			goto close_out;
 		}
 
 		status = cli_writeall(cli, remote_fd, 0, buf, off, len, NULL);
 		if (!NT_STATUS_IS_OK(status)) {
-			DBG(0, ("Error writing remote file %s: %s\n",
-						full_path, nt_errstr(status)));
+			d_printf("Error writing remote file %s: %s\n",
+						full_path, nt_errstr(status));
 			err = 1;
 			goto close_out;
 		}
@@ -1198,8 +1235,8 @@ static int tar_send_file(struct tar *t, struct archive_entry *entry)
 close_out:
 	status = cli_close(cli, remote_fd);
 	if (!NT_STATUS_IS_OK(status)) {
-		DBG(0, ("Error losing remote file %s: %s\n",
-					full_path, nt_errstr(status)));
+		d_printf("Error closing remote file %s: %s\n",
+					full_path, nt_errstr(status));
 		err = 1;
 	}
 
@@ -1269,7 +1306,7 @@ static int tar_set_newer_than(struct tar *t, const char *filename)
 
 	rc = sys_stat(filename, &stbuf, false);
 	if (rc != 0) {
-		DBG(0, ("Error setting newer-than time\n"));
+		d_printf("Error setting newer-than time\n");
 		return 1;
 	}
 
@@ -1296,7 +1333,7 @@ static int tar_read_inclusion_file(struct tar *t, const char* filename)
 
 	fd = open(filename, O_RDONLY);
 	if (fd < 0) {
-		DBG(0, ("Can't open inclusion file '%s': %s\n", filename, strerror(errno)));
+		d_printf("Can't open inclusion file '%s': %s\n", filename, strerror(errno));
 		err = 1;
 		goto out;
 	}
@@ -1489,7 +1526,7 @@ static NTSTATUS tar_create_skip_path(struct tar *t,
 bool tar_to_process(struct tar *t)
 {
 	if (t == NULL) {
-		DBG(0, ("Invalid tar context\n"));
+		DBG_WARNING("Invalid tar context\n");
 		return false;
 	}
 	return t->to_process;
@@ -1636,7 +1673,7 @@ static int make_remote_path(const char *full_path)
 		if (!NT_STATUS_IS_OK(status)) {
 			status = cli_mkdir(cli, subpath);
 			if (!NT_STATUS_IS_OK(status)) {
-				DBG(0, ("Can't mkdir %s: %s\n", subpath, nt_errstr(status)));
+				d_printf("Can't mkdir %s: %s\n", subpath, nt_errstr(status));
 				err = 1;
 				goto out;
 			}
diff --git a/source3/client/smbspool.c b/source3/client/smbspool.c
index 36f7f67ca94..5e2d230ab8b 100644
--- a/source3/client/smbspool.c
+++ b/source3/client/smbspool.c
@@ -287,7 +287,7 @@ main(int argc,			/* I - Number of command-line arguments */
 
 	auth_info_required = getenv("AUTH_INFO_REQUIRED");
 	if (auth_info_required == NULL) {
-		auth_info_required = "none";
+		auth_info_required = "samba";
 	}
 
 	/*
@@ -699,8 +699,8 @@ smb_connect(struct cli_state **output_cli,
 	if (strcmp(auth_info_required, "negotiate") == 0) {
 		if (!kerberos_ccache_is_valid()) {
 			fprintf(stderr,
-				"ERROR: No valid Kerberos credential cache "
-				"found!\n");
+				"ERROR: No valid Kerberos credential cache found! "
+				"Using smbspool_krb5_wrapper may help.\n");
 			return NT_STATUS_LOGON_FAILURE;
 		}
 		user = jobusername;
@@ -718,7 +718,9 @@ smb_connect(struct cli_state **output_cli,
 
 		fprintf(stderr,
 			"DEBUG: Try to connect using username/password ...\n");
-	} else {
+	} else if (strcmp(auth_info_required, "none") == 0) {
+		goto anonymous;
+	} else if (strcmp(auth_info_required, "samba") == 0) {
 		if (username != NULL) {
 			flags |= CLI_FULL_CONNECTION_FALLBACK_AFTER_KERBEROS;
 		} else if (kerberos_ccache_is_valid()) {
@@ -731,6 +733,8 @@ smb_connect(struct cli_state **output_cli,
 				"DEBUG: This backend requires credentials!\n");
 			return NT_STATUS_ACCESS_DENIED;
 		}
+	} else {
+		return NT_STATUS_ACCESS_DENIED;
 	}
 
 	nt_status = smb_complete_connection(&cli,
@@ -780,6 +784,7 @@ smb_connect(struct cli_state **output_cli,
          * last try. Use anonymous authentication
          */
 
+anonymous:
 	nt_status = smb_complete_connection(&cli,
 					    myname,
 					    server,
diff --git a/source3/client/smbspool_krb5_wrapper.c b/source3/client/smbspool_krb5_wrapper.c
index bff1df417e8..6a3e444f480 100644
--- a/source3/client/smbspool_krb5_wrapper.c
+++ b/source3/client/smbspool_krb5_wrapper.c
@@ -145,36 +145,62 @@ int main(int argc, char *argv[])
 		snprintf(device_uri, sizeof(device_uri), "%s", env);
 	}
 
-	/* Check if AuthInfoRequired is set to negotiate */
+	/* We must handle the following values of AUTH_INFO_REQUIRED:
+	 *  none: Anonymous/guest printing
+	 *  username,password: A username (of the form "username" or "DOMAIN\username")
+	 *                     and password are required
+	 *  negotiate: Kerberos authentication
+	 *  NULL (not set): will never happen when called from cupsd
+	 * https://www.cups.org/doc/spec-ipp.html#auth-info-required
+	 * https://github.com/apple/cups/issues/5674
+	 */
 	env = getenv("AUTH_INFO_REQUIRED");
 
         /* If not set, then just call smbspool. */
 	if (env == NULL || env[0] == 0) {
 		CUPS_SMB_DEBUG("AUTH_INFO_REQUIRED is not set - "
-			       "execute smbspool");
+			       "executing smbspool");
+		/* Pass this printing task to smbspool without Kerberos auth */
 		goto smbspool;
 	} else {
 		CUPS_SMB_DEBUG("AUTH_INFO_REQUIRED=%s", env);
 
-		snprintf(auth_info_required,
-			 sizeof(auth_info_required),
-			 "%s",
-			 env);
+		/* First test the value of AUTH_INFO_REQUIRED
+		 * against known possible values
+		 */
+		cmp = strcmp(env, "none");
+		if (cmp == 0) {
+			CUPS_SMB_DEBUG("Authenticate using none (anonymous) - "
+				       "executing smbspool");
+			goto smbspool;
+		}
 
 		cmp = strcmp(env, "username,password");
 		if (cmp == 0) {
 			CUPS_SMB_DEBUG("Authenticate using username/password - "
-				       "execute smbspool");
+				       "executing smbspool");
 			goto smbspool;
 		}
 
-		/* if AUTH_INFO_REQUIRED=none */
+		/* Now, if 'goto smbspool' still has not happened,
+		 * there are only two variants left:
+		 * 1) AUTH_INFO_REQUIRED is "negotiate" and then
+		 *    we have to continue working
+		 * 2) or it is something not known to us, then Kerberos
+		 *    authentication is not required, so just also pass
+		 *    this task to smbspool
+		 */
 		cmp = strcmp(env, "negotiate");
 		if (cmp != 0) {
-			CUPS_SMB_ERROR("Authentication unsupported");
-			fprintf(stderr, "ATTR: auth-info-required=negotiate\n");
-			return CUPS_BACKEND_AUTH_REQUIRED;
+			CUPS_SMB_DEBUG("Value of AUTH_INFO_REQUIRED is not known "
+				       "to smbspool_krb5_wrapper, executing smbspool");
+			goto smbspool;
 		}
+
+		snprintf(auth_info_required,
+			 sizeof(auth_info_required),
+			 "%s",
+			 env);
 	}
 
 	uid = getuid();
@@ -208,6 +234,11 @@ int main(int argc, char *argv[])
 	}
 	uid = (uid_t)tmp;
 
+	/* If we are printing as the root user, we're done here. */
+	if (uid == 0) {
+		goto smbspool;
+	}
+
 	pwd = getpwuid(uid);
 	if (pwd == NULL) {
 		CUPS_SMB_ERROR("Failed to find system user: %u - %s",
diff --git a/source3/groupdb/mapping.c b/source3/groupdb/mapping.c
index ed57955edc9..4a2e17d8bee 100644
--- a/source3/groupdb/mapping.c
+++ b/source3/groupdb/mapping.c
@@ -205,6 +205,8 @@ bool get_domain_group_from_sid(struct dom_sid sid, GROUP_MAP *map)
 
 int smb_create_group(const char *unix_group, gid_t *new_gid)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *add_script = NULL;
 	int 	ret = -1;
 	int 	fd = 0;
@@ -214,11 +216,11 @@ int smb_create_group(const char *unix_group, gid_t *new_gid)
 
 	/* defer to scripts */
 
-	if ( *lp_add_group_script(talloc_tos()) ) {
+	if ( *lp_add_group_script(talloc_tos(), lp_sub) ) {
 		TALLOC_CTX *ctx = talloc_tos();
 
 		add_script = talloc_strdup(ctx,
-					lp_add_group_script(ctx));
+					lp_add_group_script(ctx, lp_sub));
 		if (!add_script) {
 			return -1;
 		}
@@ -278,16 +280,18 @@ int smb_create_group(const char *unix_group, gid_t *new_gid)
 
 int smb_delete_group(const char *unix_group)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *del_script = NULL;
 	int ret = -1;
 
 	/* defer to scripts */
 
-	if ( *lp_delete_group_script(talloc_tos()) ) {
+	if ( *lp_delete_group_script(talloc_tos(), lp_sub) ) {
 		TALLOC_CTX *ctx = talloc_tos();
 
 		del_script = talloc_strdup(ctx,
-				lp_delete_group_script(ctx));
+				lp_delete_group_script(ctx, lp_sub));
 		if (!del_script) {
 			return -1;
 		}
@@ -313,16 +317,18 @@ int smb_delete_group(const char *unix_group)
 
 int smb_set_primary_group(const char *unix_group, const char* unix_user)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *add_script = NULL;
 	int ret = -1;
 
 	/* defer to scripts */
 
-	if ( *lp_set_primary_group_script(talloc_tos()) ) {
+	if ( *lp_set_primary_group_script(talloc_tos(), lp_sub) ) {
 		TALLOC_CTX *ctx = talloc_tos();
 
 		add_script = talloc_strdup(ctx,
-				lp_set_primary_group_script(ctx));
+				lp_set_primary_group_script(ctx, lp_sub));
 		if (!add_script) {
 			return -1;
 		}
@@ -355,16 +361,18 @@ int smb_set_primary_group(const char *unix_group, const char* unix_user)
 
 int smb_add_user_group(const char *unix_group, const char *unix_user)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *add_script = NULL;
 	int ret = -1;
 
 	/* defer to scripts */
 
-	if ( *lp_add_user_to_group_script(talloc_tos()) ) {
+	if ( *lp_add_user_to_group_script(talloc_tos(), lp_sub) ) {
 		TALLOC_CTX *ctx = talloc_tos();
 
 		add_script = talloc_strdup(ctx,
-				lp_add_user_to_group_script(ctx));
+				lp_add_user_to_group_script(ctx, lp_sub));
 		if (!add_script) {
 			return -1;
 		}
@@ -395,16 +403,18 @@ int smb_add_user_group(const char *unix_group, const char *unix_user)
 
 int smb_delete_user_group(const char *unix_group, const char *unix_user)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *del_script = NULL;
 	int ret = -1;
 
 	/* defer to scripts */
 
-	if ( *lp_delete_user_from_group_script(talloc_tos()) ) {
+	if ( *lp_delete_user_from_group_script(talloc_tos(), lp_sub) ) {
 		TALLOC_CTX *ctx = talloc_tos();
 
 		del_script = talloc_strdup(ctx,
-				lp_delete_user_from_group_script(ctx));
+				lp_delete_user_from_group_script(ctx, lp_sub));
 		if (!del_script) {
 			return -1;
 		}
diff --git a/source3/include/auth.h b/source3/include/auth.h
index 0facb8668cd..69e53bb7083 100644
--- a/source3/include/auth.h
+++ b/source3/include/auth.h
@@ -98,7 +98,7 @@ struct auth_context {
 	const char *forced_samba4_methods;
 };
 
-typedef struct auth_methods
+struct auth_methods
 {
 	struct auth_methods *prev, *next;
 	const char *name; /* What name got this module */
@@ -117,7 +117,7 @@ typedef struct auth_methods
 
 	uint32_t flags;
 
-} auth_methods;
+};
 
 typedef NTSTATUS (*auth_init_function)(struct auth_context *, const char *, struct auth_methods **);
 
diff --git a/source3/include/g_lock.h b/source3/include/g_lock.h
index 782a2e9d160..54f60e410ba 100644
--- a/source3/include/g_lock.h
+++ b/source3/include/g_lock.h
@@ -26,15 +26,16 @@ struct g_lock_ctx;
 struct messaging_context;
 
 enum g_lock_type {
-	G_LOCK_READ = 0,
-	G_LOCK_WRITE = 1,
-};
-
-struct g_lock_rec {
-	enum g_lock_type lock_type;
-	struct server_id pid;
+	G_LOCK_READ,
+	G_LOCK_WRITE,
+	G_LOCK_UPGRADE,
+	G_LOCK_DOWNGRADE,
 };
 
+struct g_lock_ctx *g_lock_ctx_init_backend(
+	TALLOC_CTX *mem_ctx,
+	struct messaging_context *msg,
+	struct db_context **backend);
 struct g_lock_ctx *g_lock_ctx_init(TALLOC_CTX *mem_ctx,
 				   struct messaging_context *msg);
 
@@ -54,9 +55,11 @@ NTSTATUS g_lock_write_data(struct g_lock_ctx *ctx, TDB_DATA key,
 int g_lock_locks(struct g_lock_ctx *ctx,
 		 int (*fn)(TDB_DATA key, void *private_data),
 		 void *private_data);
-NTSTATUS g_lock_dump(struct g_lock_ctx *ctx, TDB_DATA key,
-		     void (*fn)(const struct g_lock_rec *locks,
-				size_t num_locks,
+NTSTATUS g_lock_dump(struct g_lock_ctx *ctx,
+		     TDB_DATA key,
+		     void (*fn)(struct server_id exclusive,
+				size_t num_shared,
+				struct server_id *shared,
 				const uint8_t *data,
 				size_t datalen,
 				void *private_data),
diff --git a/source3/include/includes.h b/source3/include/includes.h
index abe12ac0930..2dafc65f41a 100644
--- a/source3/include/includes.h
+++ b/source3/include/includes.h
@@ -339,8 +339,6 @@ typedef char fstring[FSTRING_LEN];
 
 
 /* add varargs prototypes with printf checking */
-/*PRINTFLIKE2 */
-int fdprintf(int , const char *, ...) PRINTF_ATTRIBUTE(2,3);
 /*PRINTFLIKE1 */
 int d_printf(const char *, ...) PRINTF_ATTRIBUTE(1,2);
 /*PRINTFLIKE2 */
@@ -349,8 +347,6 @@ int d_fprintf(FILE *f, const char *, ...) PRINTF_ATTRIBUTE(2,3);
 /* PRINTFLIKE2 */
 int fstr_sprintf(fstring s, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);
 
-int smb_xvasprintf(char **ptr, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);
-
 int asprintf_strupper_m(char **strp, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);
 char *talloc_asprintf_strupper_m(TALLOC_CTX *t, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);
 
diff --git a/source3/include/libsmb_internal.h b/source3/include/libsmb_internal.h
index bfb3e064297..21a11c1a024 100644
--- a/source3/include/libsmb_internal.h
+++ b/source3/include/libsmb_internal.h
@@ -76,6 +76,7 @@ typedef struct DOS_ATTR_DESC {
 struct _SMBCSRV {
 	struct cli_state *cli;
 	dev_t dev;
+	bool try_posixinfo;
 	bool no_pathinfo;
 	bool no_pathinfo2;
 	bool no_pathinfo3;
@@ -407,13 +408,7 @@ bool
 SMBC_getatr(SMBCCTX * context,
             SMBCSRV *srv,
             const char *path,
-            uint16_t *mode,
-            off_t *size,
-            struct timespec *create_time_ts,
-            struct timespec *access_time_ts,
-            struct timespec *write_time_ts,
-            struct timespec *change_time_ts,
-            SMB_INO_T *ino);
+	    struct stat *sbuf);
 
 bool
 SMBC_setatr(SMBCCTX * context, SMBCSRV *srv, char *path,
@@ -537,6 +532,9 @@ void setup_stat(struct stat *st,
 		struct timespec access_time_ts,
 		struct timespec change_time_ts,
 		struct timespec write_time_ts);
+void setup_stat_from_stat_ex(const struct stat_ex *stex,
+			     const char *fname,
+			     struct stat *st);
 
 int
 SMBC_stat_ctx(SMBCCTX *context,
diff --git a/source3/include/libsmbclient.h b/source3/include/libsmbclient.h
index 835c832b76a..5846550eb29 100644
--- a/source3/include/libsmbclient.h
+++ b/source3/include/libsmbclient.h
@@ -1647,7 +1647,7 @@ int smbc_getdents(unsigned int dh, struct smbc_dirent *dirp, int count);
 struct smbc_dirent* smbc_readdir(unsigned int dh);
 
 /**@ingroup directory
- * Works similar as smbc_readdir but returns more information about file.
+ * Works similar as smbc_readdir() but returns more information about file.
  *
  * @param dh        Valid directory as returned by smbc_opendir()
  *
@@ -1661,7 +1661,7 @@ struct smbc_dirent* smbc_readdir(unsigned int dh);
 const struct libsmb_file_info *smbc_readdirplus(unsigned int dh);
 
 /**@ingroup directory
- * Works similar as smbc_readdirplus as well as fills up stat structure if
+ * Works similar as smbc_readdirplus() as well as fills up stat structure if
  * provided.
  *
  * @param dh        Valid directory as returned by smbc_opendir()
diff --git a/source3/include/msdfs.h b/source3/include/msdfs.h
index 333a84082d6..6a851cb3330 100644
--- a/source3/include/msdfs.h
+++ b/source3/include/msdfs.h
@@ -53,7 +53,7 @@ struct junction_map {
 	char *service_name;
 	char *volume_name;
 	const char *comment;
-	int referral_count;
+	size_t referral_count;
 	struct referral* referral_list;
 };
 
diff --git a/source3/include/proto.h b/source3/include/proto.h
index 332a4132424..6818361d78e 100644
--- a/source3/include/proto.h
+++ b/source3/include/proto.h
@@ -138,12 +138,13 @@ struct named_mutex *grab_named_mutex(TALLOC_CTX *mem_ctx, const char *name,
 
 /* The following definitions come from lib/sharesec.c  */
 
-bool share_info_db_init(void);
+NTSTATUS share_info_db_init(void);
 struct security_descriptor *get_share_security_default( TALLOC_CTX *ctx, size_t *psize, uint32_t def_access);
 struct security_descriptor *get_share_security( TALLOC_CTX *ctx, const char *servicename,
 			      size_t *psize);
-bool set_share_security(const char *share_name, struct security_descriptor *psd);
-bool delete_share_security(const char *servicename);
+NTSTATUS set_share_security(const char *share_name,
+			    struct security_descriptor *psd);
+NTSTATUS delete_share_security(const char *servicename);
 bool share_access_check(const struct security_token *token,
 			const char *sharename,
 			uint32_t desired_access,
@@ -234,7 +235,7 @@ int sys_lstat(const char *fname,SMB_STRUCT_STAT *sbuf,
 	      bool fake_dir_create_times);
 int sys_posix_fallocate(int fd, off_t offset, off_t len);
 int sys_fallocate(int fd, uint32_t mode, off_t offset, off_t len);
-void kernel_flock(int fd, uint32_t share_mode, uint32_t access_mask);
+void kernel_flock(int fd, uint32_t share_access, uint32_t access_mask);
 DIR *sys_fdopendir(int fd);
 int sys_mknod(const char *path, mode_t mode, SMB_DEV_T dev);
 int sys_mknodat(int dirfd, const char *path, mode_t mode, SMB_DEV_T dev);
@@ -266,7 +267,8 @@ bool getgroups_unix_user(TALLOC_CTX *mem_ctx, const char *user,
 
 /* The following definitions come from lib/tallocmsg.c  */
 
-void register_msg_pool_usage(struct messaging_context *msg_ctx);
+void register_msg_pool_usage(TALLOC_CTX *mem_ctx,
+			     struct messaging_context *msg_ctx);
 
 /* The following definitions come from lib/time.c  */
 
@@ -286,6 +288,10 @@ void srv_put_dos_date2(char *buf,int offset, time_t unixdate);
 void srv_put_dos_date3(char *buf,int offset,time_t unixdate);
 void round_timespec(enum timestamp_set_resolution res, struct timespec *ts);
 void put_long_date_timespec(enum timestamp_set_resolution res, char *p, struct timespec ts);
+void put_long_date_full_timespec(enum timestamp_set_resolution res,
+				 char *p,
+				 const struct timespec *ts);
+struct timespec pull_long_date_full_timespec(const char *p);
 void put_long_date(char *p, time_t t);
 void dos_filetime_timespec(struct timespec *tsp);
 time_t make_unix_date(const void *date_ptr, int zone_offset);
@@ -299,7 +305,6 @@ void TimeInit(void);
 void get_process_uptime(struct timeval *ret_time);
 void get_startup_time(struct timeval *ret_time);
 time_t nt_time_to_unix_abs(const NTTIME *nt);
-time_t uint64s_nt_time_to_unix_abs(const uint64_t *src);
 void unix_to_nt_time_abs(NTTIME *nt, time_t t);
 const char *time_to_asc(const time_t t);
 const char *display_time(NTTIME nttime);
@@ -619,9 +624,6 @@ size_t strlen_m(const char *s);
 size_t strlen_m_term(const char *s);
 size_t strlen_m_term_null(const char *s);
 int fstr_sprintf(fstring s, const char *fmt, ...);
-bool str_list_sub_basic( char **list, const char *smb_name,
-			 const char *domain_name );
-bool str_list_substitute(char **list, const char *pattern, const char *insert);
 
 char *ipstr_list_make(char **ipstr_list,
 			const struct ip_service *ip_list,
@@ -733,9 +735,18 @@ NTSTATUS trust_pw_change(struct netlogon_creds_cli_context *context,
 
 /* The following definitions come from param/loadparm.c  */
 
+const struct loadparm_substitution *loadparm_s3_global_substitution(void);
+
+char *lp_parm_substituted_string(TALLOC_CTX *mem_ctx,
+				 const struct loadparm_substitution *lp_sub,
+				 int snum,
+				 const char *type,
+				 const char *option,
+				 const char *def);
+
 #include "source3/param/param_proto.h"
 
-char *lp_servicename(TALLOC_CTX *ctx, int);
+char *lp_servicename(TALLOC_CTX *ctx, const struct loadparm_substitution *, int);
 const char *lp_const_servicename(int);
 bool lp_autoloaded(int);
 const char *lp_dnsdomain(void);
@@ -762,7 +773,6 @@ int lp_wi_scan_global_parametrics(
 		   void *private_data),
 	void *private_data);
 
-char *lp_parm_talloc_string(TALLOC_CTX *ctx, int snum, const char *type, const char *option, const char *def);
 const char *lp_parm_const_string(int snum, const char *type, const char *option, const char *def);
 struct loadparm_service;
 const char *lp_parm_const_string_service(struct loadparm_service *service, const char *type,
@@ -854,7 +864,9 @@ bool lp_preferred_master(void);
 void lp_remove_service(int snum);
 void lp_copy_service(int snum, const char *new_name);
 int lp_default_server_announce(void);
-const char *lp_printername(TALLOC_CTX *ctx, int snum);
+const char *lp_printername(TALLOC_CTX *ctx,
+			   const struct loadparm_substitution *lp_sub,
+			   int snum);
 void lp_set_logfile(const char *name);
 int lp_maxprintjobs(int snum);
 const char *lp_printcapname(void);
@@ -862,7 +874,6 @@ bool lp_disable_spoolss( void );
 void lp_set_spoolss_state( uint32_t state );
 uint32_t lp_get_spoolss_state( void );
 struct smb_signing_state;
-bool lp_use_sendfile(int snum, struct smb_signing_state *signing_state);
 void set_use_sendfile(int snum, bool val);
 void lp_set_mangling_method(const char *new_method);
 bool lp_posix_pathnames(void);
@@ -870,7 +881,6 @@ void lp_set_posix_pathnames(void);
 enum brl_flavour lp_posix_cifsu_locktype(files_struct *fsp);
 void lp_set_posix_default_cifsx_readwrite_locktype(enum brl_flavour val);
 int lp_min_receive_file_size(void);
-char* lp_perfcount_module(TALLOC_CTX *ctx);
 void widelinks_warning(int snum);
 const char *lp_ncalrpc_dir(void);
 void _lp_set_server_role(int server_role);
@@ -902,11 +912,6 @@ NTSTATUS sessionid_traverse_read(int (*fn)(const char *key,
 					   void *private_data),
 				 void *private_data);
 
-/* The following definitions come from utils/passwd_util.c  */
-
-char *stdin_new_passwd( void);
-char *get_pass( const char *prompt, bool stdin_get);
-
 /* The following definitions come from lib/avahi.c */
 
 struct AvahiPoll *tevent_avahi_poll(TALLOC_CTX *mem_ctx,
diff --git a/source3/include/smb.h b/source3/include/smb.h
index 162cdcc1a32..311490d699e 100644
--- a/source3/include/smb.h
+++ b/source3/include/smb.h
@@ -30,7 +30,7 @@
 #include "libds/common/roles.h"
 
 /* logged when starting the various Samba daemons */
-#define COPYRIGHT_STARTUP_MESSAGE	"Copyright Andrew Tridgell and the Samba Team 1992-2019"
+#define COPYRIGHT_STARTUP_MESSAGE	"Copyright Andrew Tridgell and the Samba Team 1992-2020"
 
 #define SAFETY_MARGIN 1024
 #define LARGE_WRITEX_HDR_SIZE 65
diff --git a/source3/include/smb_macros.h b/source3/include/smb_macros.h
index 06d24744960..266c17427e8 100644
--- a/source3/include/smb_macros.h
+++ b/source3/include/smb_macros.h
@@ -43,14 +43,6 @@
 /* these are useful macros for checking validity of handles */
 #define IS_IPC(conn)       ((conn) && (conn)->ipc)
 #define IS_PRINT(conn)       ((conn) && (conn)->printer)
-/* you must add the following extern declaration to files using this macro
- * (do not add it to the macro as that causes nested extern declaration warnings)
- * extern struct current_user current_user;
- */
-#define FSP_BELONGS_CONN(fsp,conn) do {\
-			if (!((fsp) && (conn) && ((conn)==(fsp)->conn) && (current_user.vuid==(fsp)->vuid))) \
-				return ERROR_NT(NT_STATUS_INVALID_HANDLE); \
-			} while(0)
 
 #define CHECK_READ(fsp,req) (((fsp)->fh->fd != -1) && ((fsp)->can_read || \
 			((req->flags2 & FLAGS2_READ_PERMIT_EXECUTE) && \
diff --git a/source3/include/vfs.h b/source3/include/vfs.h
index a6c57c6bcbc..fec38f20644 100644
--- a/source3/include/vfs.h
+++ b/source3/include/vfs.h
@@ -287,6 +287,9 @@
 		Use SMB_VFS_UNLINKAT(.., AT_REMOVEDIR) instead. */
 /* Version 42 - Remove SMB_VFS_CHOWN */
 /* Version 42 - Remove struct write_cache *wcp from files_struct */
+/* Version 42 - SMB_VFS_NTIMES() receives null times based on UTIMES_OMIT */
+/* Version 42 - Add SMB_VFS_CREATE_DFS_PATHAT() */
+/* Version 42 - Add SMB_VFS_READ_DFS_PATHAT() */
 
 #define SMB_VFS_INTERFACE_VERSION 42
 
@@ -546,6 +549,7 @@ typedef struct connection_struct {
 
 struct smbd_smb2_request;
 struct privilege_paths;
+struct referral;
 
 struct smb_request {
 	uint8_t cmd;
@@ -577,6 +581,13 @@ struct smb_request {
 	connection_struct *conn;
 	struct smbd_server_connection *sconn;
 	struct smbXsrv_connection *xconn;
+
+	/*
+	 * Pointer to session, can be NULL,
+	 * eg during negprot and session setup.
+	 */
+	struct smbXsrv_session *session;
+
 	struct smb_perfcount_data pcd;
 
 	/*
@@ -701,6 +712,17 @@ struct vfs_fn_pointers {
 	 */
 	NTSTATUS (*get_dfs_referrals_fn)(struct vfs_handle_struct *handle,
 					 struct dfs_GetDFSReferral *r);
+	NTSTATUS (*create_dfs_pathat_fn)(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count);
+	NTSTATUS (*read_dfs_pathat_fn)(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count);
 
 	/* Directory operations */
 
@@ -807,7 +829,7 @@ struct vfs_fn_pointers {
 			    off_t len);
 	bool (*lock_fn)(struct vfs_handle_struct *handle, struct files_struct *fsp, int op, off_t offset, off_t count, int type);
 	int (*kernel_flock_fn)(struct vfs_handle_struct *handle, struct files_struct *fsp,
-			       uint32_t share_mode, uint32_t access_mask);
+			       uint32_t share_access, uint32_t access_mask);
 	int (*fcntl_fn)(struct vfs_handle_struct *handle,
 			struct files_struct *fsp, int cmd, va_list cmd_arg);
 	int (*linux_setlease_fn)(struct vfs_handle_struct *handle, struct files_struct *fsp, int leasetype);
@@ -1204,6 +1226,17 @@ uint32_t smb_vfs_call_fs_capabilities(struct vfs_handle_struct *handle,
  */
 NTSTATUS smb_vfs_call_get_dfs_referrals(struct vfs_handle_struct *handle,
 					struct dfs_GetDFSReferral *r);
+NTSTATUS smb_vfs_call_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count);
+NTSTATUS smb_vfs_call_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count);
 DIR *smb_vfs_call_opendir(struct vfs_handle_struct *handle,
 			const struct smb_filename *smb_fname,
 			const char *mask,
@@ -1337,7 +1370,7 @@ bool smb_vfs_call_lock(struct vfs_handle_struct *handle,
 		       struct files_struct *fsp, int op, off_t offset,
 		       off_t count, int type);
 int smb_vfs_call_kernel_flock(struct vfs_handle_struct *handle,
-			      struct files_struct *fsp, uint32_t share_mode,
+			      struct files_struct *fsp, uint32_t share_access,
 			      uint32_t access_mask);
 int smb_vfs_call_fcntl(struct vfs_handle_struct *handle,
 		       struct files_struct *fsp, int cmd, ...);
@@ -1641,6 +1674,17 @@ uint32_t vfs_not_implemented_fs_capabilities(struct vfs_handle_struct *handle,
 				enum timestamp_set_resolution *p_ts_res);
 NTSTATUS vfs_not_implemented_get_dfs_referrals(struct vfs_handle_struct *handle,
 					       struct dfs_GetDFSReferral *r);
+NTSTATUS vfs_not_implemented_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count);
+NTSTATUS vfs_not_implemented_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count);
 DIR *vfs_not_implemented_opendir(vfs_handle_struct *handle,
 			const struct smb_filename *smb_fname,
 			const char *mask,
@@ -1769,7 +1813,7 @@ bool vfs_not_implemented_lock(vfs_handle_struct *handle, files_struct *fsp, int
 			      off_t offset, off_t count, int type);
 int vfs_not_implemented_kernel_flock(struct vfs_handle_struct *handle,
 				     struct files_struct *fsp,
-				     uint32_t share_mode, uint32_t access_mask);
+				     uint32_t share_access, uint32_t access_mask);
 int vfs_not_implemented_fcntl(struct vfs_handle_struct *handle,
 			      struct files_struct *fsp, int cmd, va_list cmd_arg);
 int vfs_not_implemented_linux_setlease(struct vfs_handle_struct *handle,
diff --git a/source3/include/vfs_macros.h b/source3/include/vfs_macros.h
index 6a7cbf2275d..112169ab83b 100644
--- a/source3/include/vfs_macros.h
+++ b/source3/include/vfs_macros.h
@@ -78,6 +78,33 @@
 #define SMB_VFS_NEXT_GET_DFS_REFERRALS(handle, r) \
 	smb_vfs_call_get_dfs_referrals((handle)->next, (r))
 
+#define SMB_VFS_CREATE_DFS_PATHAT(conn, dirfsp, smb_fname, reflist, count) \
+	smb_vfs_call_create_dfs_pathat((conn)->vfs_handles, \
+		(dirfsp), \
+		(smb_fname), \
+		(reflist), \
+		(count))
+#define SMB_VFS_NEXT_CREATE_DFS_PATHAT(handle, dirfsp, smb_fname, reflist, count) \
+	smb_vfs_call_create_dfs_pathat((handle)->next, \
+		(dirfsp), \
+		(smb_fname), \
+		(reflist), \
+		(count))
+#define SMB_VFS_READ_DFS_PATHAT(conn, mem_ctx, dirfsp, smb_fname, ppreflist, pcount) \
+	smb_vfs_call_read_dfs_pathat((conn)->vfs_handles, \
+		(mem_ctx), \
+		(dirfsp), \
+		(smb_fname), \
+		(ppreflist), \
+		(pcount))
+#define SMB_VFS_NEXT_READ_DFS_PATHAT(handle, mem_ctx, dirfsp, smb_fname, ppreflist, pcount) \
+        smb_vfs_call_read_dfs_pathat((handle)->next, \
+		(mem_ctx), \
+                (dirfsp), \
+                (smb_fname), \
+                (ppreflist), \
+                (pcount))
+
 /* Directory operations */
 #define SMB_VFS_OPENDIR(conn, smb_fname, mask, attr) \
 	smb_vfs_call_opendir((conn)->vfs_handles, (smb_fname), (mask), (attr))
@@ -271,10 +298,10 @@
 #define SMB_VFS_NEXT_LOCK(handle, fsp, op, offset, count, type) \
 	smb_vfs_call_lock((handle)->next, (fsp), (op), (offset), (count), (type))
 
-#define SMB_VFS_KERNEL_FLOCK(fsp, share_mode, access_mask) \
-	smb_vfs_call_kernel_flock((fsp)->conn->vfs_handles, (fsp), (share_mode), (access_mask))
-#define SMB_VFS_NEXT_KERNEL_FLOCK(handle, fsp, share_mode, access_mask)	\
-	smb_vfs_call_kernel_flock((handle)->next, (fsp), (share_mode), (access_mask))
+#define SMB_VFS_KERNEL_FLOCK(fsp, share_access, access_mask) \
+	smb_vfs_call_kernel_flock((fsp)->conn->vfs_handles, (fsp), (share_access), (access_mask))
+#define SMB_VFS_NEXT_KERNEL_FLOCK(handle, fsp, share_access, access_mask)	\
+	smb_vfs_call_kernel_flock((handle)->next, (fsp), (share_access), (access_mask))
 
 #define SMB_VFS_FCNTL(fsp, cmd, ...) \
 	smb_vfs_call_fcntl((fsp)->conn->vfs_handles, (fsp), (cmd), (__VA_ARGS__))
diff --git a/source3/lib/dbwrap/dbwrap_ctdb.c b/source3/lib/dbwrap/dbwrap_ctdb.c
index 0e108920f58..6d2a8c839eb 100644
--- a/source3/lib/dbwrap/dbwrap_ctdb.c
+++ b/source3/lib/dbwrap/dbwrap_ctdb.c
@@ -534,6 +534,7 @@ static struct db_record *db_ctdb_fetch_locked_transaction(struct db_ctdb_ctx *ct
 	}
 	if (pull_newest_from_marshall_buffer(ctx->transaction->m_write, key,
 					     NULL, result, &result->value)) {
+		result->value_valid = true;
 		return result;
 	}
 
@@ -541,6 +542,7 @@ static struct db_record *db_ctdb_fetch_locked_transaction(struct db_ctdb_ctx *ct
 	if (ctdb_data.dptr == NULL) {
 		/* create the record */
 		result->value = tdb_null;
+		result->value_valid = true;
 		return result;
 	}
 
@@ -553,7 +555,9 @@ static struct db_record *db_ctdb_fetch_locked_transaction(struct db_ctdb_ctx *ct
 			 result->value.dsize))) {
 		DEBUG(0, ("talloc failed\n"));
 		TALLOC_FREE(result);
+		return NULL;
 	}
+	result->value_valid = true;
 
 	SAFE_FREE(ctdb_data.dptr);
 
@@ -1244,8 +1248,10 @@ again:
 		if (result->value.dptr == NULL) {
 			DBG_ERR("talloc failed\n");
 			TALLOC_FREE(result);
+			return NULL;
 		}
 	}
+	result->value_valid = true;
 
 	SAFE_FREE(ctdb_data.dptr);
 
@@ -1715,6 +1721,7 @@ static void traverse_read_callback(TDB_DATA key, TDB_DATA data, void *private_da
 	rec.storev = db_ctdb_storev_deny;
 	rec.delete_rec = db_ctdb_delete_deny;
 	rec.private_data = NULL;
+	rec.value_valid = true;
 	state->fn(&rec, state->private_data);
 	state->count++;
 }
@@ -1739,6 +1746,7 @@ static int traverse_persistent_callback_read(TDB_CONTEXT *tdb, TDB_DATA kbuf, TD
 	rec.db = state->db;
 	rec.key = kbuf;
 	rec.value = dbuf;
+	rec.value_valid = true;
 	rec.storev = db_ctdb_storev_deny;
 	rec.delete_rec = db_ctdb_delete_deny;
 	rec.private_data = NULL;
diff --git a/source3/lib/dbwrap/dbwrap_watch.c b/source3/lib/dbwrap/dbwrap_watch.c
index c5d55a3c93d..96e88a1e4a3 100644
--- a/source3/lib/dbwrap/dbwrap_watch.c
+++ b/source3/lib/dbwrap/dbwrap_watch.c
@@ -28,164 +28,109 @@
 #include "server_id_watch.h"
 #include "lib/dbwrap/dbwrap_private.h"
 
-static ssize_t dbwrap_record_watchers_key(struct db_context *db,
-					  struct db_record *rec,
-					  uint8_t *wkey, size_t wkey_len)
-{
-	size_t db_id_len = dbwrap_db_id(db, NULL, 0);
-	uint8_t db_id[db_id_len];
-	size_t needed;
-	TDB_DATA key;
-
-	dbwrap_db_id(db, db_id, db_id_len);
-
-	key = dbwrap_record_get_key(rec);
-
-	needed = sizeof(uint32_t) + db_id_len;
-	if (needed < sizeof(uint32_t)) {
-		return -1;
-	}
-
-	needed += key.dsize;
-	if (needed < key.dsize) {
-		return -1;
-	}
-
-	if (wkey != NULL && wkey_len >= needed) {
-		SIVAL(wkey, 0, db_id_len);
-		memcpy(wkey + sizeof(uint32_t), db_id, db_id_len);
-		memcpy(wkey + sizeof(uint32_t) + db_id_len,
-		       key.dptr, key.dsize);
-	}
-
-	return needed;
-}
-
-static bool dbwrap_record_watchers_key_parse(
-	TDB_DATA wkey, uint8_t **p_db_id, size_t *p_db_id_len, TDB_DATA *key)
-{
-	size_t db_id_len;
+struct dbwrap_watcher {
+	/*
+	 * Process watching this record
+	 */
+	struct server_id pid;
+	/*
+	 * Individual instance inside the waiter, incremented each
+	 * time a watcher is created
+	 */
+	uint64_t instance;
+};
 
-	if (wkey.dsize < sizeof(uint32_t)) {
-		DBG_WARNING("Invalid watchers key, dsize=%zu\n", wkey.dsize);
-		return false;
-	}
-	db_id_len = IVAL(wkey.dptr, 0);
-	if (db_id_len > (wkey.dsize - sizeof(uint32_t))) {
-		DBG_WARNING("Invalid watchers key, wkey.dsize=%zu, "
-			    "db_id_len=%zu\n", wkey.dsize, db_id_len);
-		return false;
-	}
-	if (p_db_id != NULL) {
-		*p_db_id = wkey.dptr + sizeof(uint32_t);
-	}
-	if (p_db_id_len != NULL) {
-		*p_db_id_len = db_id_len;
-	}
-	if (key != NULL) {
-		key->dptr = wkey.dptr + sizeof(uint32_t) + db_id_len;
-		key->dsize = wkey.dsize - sizeof(uint32_t) - db_id_len;
-	}
-	return true;
-}
+#define DBWRAP_WATCHER_BUF_LENGTH (SERVER_ID_BUF_LENGTH + sizeof(uint64_t))
 
 /*
  * Watched records contain a header of:
  *
  * [uint32] num_records | deleted bit
- * 0 [SERVER_ID_BUF_LENGTH]                   \
- * 1 [SERVER_ID_BUF_LENGTH]                   |
+ * 0 [DBWRAP_WATCHER_BUF_LENGTH]              \
+ * 1 [DBWRAP_WATCHER_BUF_LENGTH]              |
  * ..                                         |- Array of watchers
- * (num_records-1)[SERVER_ID_BUF_LENGTH]      /
+ * (num_records-1)[DBWRAP_WATCHER_BUF_LENGTH] /
  *
  * [Remainder of record....]
  *
  * If this header is absent then this is a
  * fresh record of length zero (no watchers).
- *
- * Note that a record can be deleted with
- * watchers present. If so the deleted bit
- * is set and the watcher server_id's are
- * woken to allow them to remove themselves
- * from the watcher array. The record is left
- * present marked with the deleted bit until all
- * watchers are removed, then the record itself
- * is deleted.
  */
 
-#define NUM_WATCHERS_DELETED_BIT (1UL<<31)
-#define NUM_WATCHERS_MASK (NUM_WATCHERS_DELETED_BIT-1)
-
-struct dbwrap_watch_rec {
-	uint8_t *watchers;
-	size_t num_watchers;
-	bool deleted;
-	TDB_DATA data;
-};
-
-static bool dbwrap_watch_rec_parse(TDB_DATA data,
-				   struct dbwrap_watch_rec *wrec)
+static bool dbwrap_watch_rec_parse(
+	TDB_DATA data,
+	uint8_t **pwatchers,
+	size_t *pnum_watchers,
+	TDB_DATA *pdata)
 {
 	size_t num_watchers;
-	bool deleted;
-	TDB_DATA userdata = { 0 };
+
+	if (data.dsize == 0) {
+		/* Fresh record */
+		if (pwatchers != NULL) {
+			*pwatchers = NULL;
+		}
+		if (pnum_watchers != NULL) {
+			*pnum_watchers = 0;
+		}
+		if (pdata != NULL) {
+			*pdata = (TDB_DATA) { .dptr = NULL };
+		}
+		return true;
+	}
 
 	if (data.dsize < sizeof(uint32_t)) {
-		/* Fresh or invalid record */
+		/* Invalid record */
 		return false;
 	}
 
 	num_watchers = IVAL(data.dptr, 0);
 
-	deleted = num_watchers & NUM_WATCHERS_DELETED_BIT;
-	num_watchers &= NUM_WATCHERS_MASK;
-
 	data.dptr += sizeof(uint32_t);
 	data.dsize -= sizeof(uint32_t);
 
-	if (num_watchers > data.dsize/SERVER_ID_BUF_LENGTH) {
+	if (num_watchers > data.dsize/DBWRAP_WATCHER_BUF_LENGTH) {
 		/* Invalid record */
 		return false;
 	}
 
-	if (!deleted) {
-		size_t watchers_len = num_watchers * SERVER_ID_BUF_LENGTH;
-		userdata = (TDB_DATA) {
+	if (pwatchers != NULL) {
+		*pwatchers = data.dptr;
+	}
+	if (pnum_watchers != NULL) {
+		*pnum_watchers = num_watchers;
+	}
+	if (pdata != NULL) {
+		size_t watchers_len = num_watchers * DBWRAP_WATCHER_BUF_LENGTH;
+		*pdata = (TDB_DATA) {
 			.dptr = data.dptr + watchers_len,
 			.dsize = data.dsize - watchers_len
 		};
 	}
 
-	*wrec = (struct dbwrap_watch_rec) {
-		.watchers = data.dptr, .num_watchers = num_watchers,
-		.deleted = deleted, .data = userdata
-	};
-
 	return true;
 }
 
-static void dbwrap_watch_rec_get_watcher(
-	struct dbwrap_watch_rec *wrec, size_t i, struct server_id *watcher)
+static void dbwrap_watcher_get(struct dbwrap_watcher *w,
+			       const uint8_t buf[DBWRAP_WATCHER_BUF_LENGTH])
 {
-	if (i >= wrec->num_watchers) {
-		abort();
-	}
-	server_id_get(watcher, wrec->watchers + i * SERVER_ID_BUF_LENGTH);
+	server_id_get(&w->pid, buf);
+	w->instance = BVAL(buf, SERVER_ID_BUF_LENGTH);
 }
 
-static void dbwrap_watch_rec_del_watcher(struct dbwrap_watch_rec *wrec,
-					 size_t i)
+static void dbwrap_watcher_put(uint8_t buf[DBWRAP_WATCHER_BUF_LENGTH],
+			       const struct dbwrap_watcher *w)
 {
-	if (i >= wrec->num_watchers) {
-		abort();
-	}
-	wrec->num_watchers -= 1;
-	if (i < wrec->num_watchers) {
-		uint8_t *wptr = wrec->watchers + i*SERVER_ID_BUF_LENGTH;
-		memcpy(wptr,
-		       wrec->watchers+wrec->num_watchers*SERVER_ID_BUF_LENGTH,
-		       SERVER_ID_BUF_LENGTH);
-	}
+	server_id_put(buf, w->pid);
+	SBVAL(buf, SERVER_ID_BUF_LENGTH, w->instance);
+}
+
+static void dbwrap_watch_log_invalid_record(
+	struct db_context *db, TDB_DATA key, TDB_DATA value)
+{
+	DBG_ERR("Found invalid record in %s\n", dbwrap_name(db));
+	dump_data(1, key.dptr, key.dsize);
+	dump_data(1, value.dptr, value.dsize);
 }
 
 struct db_watched_ctx {
@@ -195,8 +140,7 @@ struct db_watched_ctx {
 
 struct db_watched_subrec {
 	struct db_record *subrec;
-	struct dbwrap_watch_rec wrec;
-	bool added_watcher;
+	struct dbwrap_watcher added;
 };
 
 static NTSTATUS dbwrap_watched_subrec_storev(
@@ -210,11 +154,7 @@ static NTSTATUS dbwrap_watched_storev(struct db_record *rec,
 static NTSTATUS dbwrap_watched_delete(struct db_record *rec);
 static void dbwrap_watched_subrec_wakeup(
 	struct db_record *rec, struct db_watched_subrec *subrec);
-static NTSTATUS dbwrap_watched_save(struct db_record *rec,
-				    struct dbwrap_watch_rec *wrec,
-				    const TDB_DATA *databufs,
-				    size_t num_databufs,
-				    int flags);
+static int db_watched_subrec_destructor(struct db_watched_subrec *s);
 
 static struct db_record *dbwrap_watched_fetch_locked(
 	struct db_context *db, TALLOC_CTX *mem_ctx, TDB_DATA key)
@@ -223,7 +163,6 @@ static struct db_record *dbwrap_watched_fetch_locked(
 		db->private_data, struct db_watched_ctx);
 	struct db_record *rec;
 	struct db_watched_subrec *subrec;
-	uint8_t *watchers = NULL;
 	TDB_DATA subrec_value;
 	bool ok;
 
@@ -236,6 +175,7 @@ static struct db_record *dbwrap_watched_fetch_locked(
 		TALLOC_FREE(rec);
 		return NULL;
 	}
+	talloc_set_destructor(subrec, db_watched_subrec_destructor);
 	rec->private_data = subrec;
 
 	subrec->subrec = dbwrap_fetch_locked(ctx->backend, subrec, key);
@@ -251,35 +191,107 @@ static struct db_record *dbwrap_watched_fetch_locked(
 
 	subrec_value = dbwrap_record_get_value(subrec->subrec);
 
-	ok = dbwrap_watch_rec_parse(subrec_value, &subrec->wrec);
+	ok = dbwrap_watch_rec_parse(subrec_value, NULL, NULL, &rec->value);
 	if (!ok) {
-		return rec;	/* fresh record */
+		dbwrap_watch_log_invalid_record(db, rec->key, subrec_value);
+		/* wipe invalid data */
+		rec->value = (TDB_DATA) { .dptr = NULL, .dsize = 0 };
 	}
-	rec->value = subrec->wrec.data;
+	rec->value_valid = true;
 
-	/*
-	 * subrec->wrec.watchers points *directly* into the
-	 * returned data in the record. We need to talloc a
-	 * copy of this so it belongs to subrec.
-	 */
+	return rec;
+}
 
-	watchers = talloc_memdup(
-		subrec,
-		subrec->wrec.watchers,
-		subrec->wrec.num_watchers * SERVER_ID_BUF_LENGTH);
-	if (watchers == NULL) {
-		TALLOC_FREE(rec);
-		return NULL;
+struct dbwrap_watched_add_watcher_state {
+	struct dbwrap_watcher w;
+	NTSTATUS status;
+};
+
+static void dbwrap_watched_add_watcher(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
+{
+	struct dbwrap_watched_add_watcher_state *state = private_data;
+	size_t num_watchers = 0;
+	bool ok;
+
+	uint8_t num_watchers_buf[4];
+	uint8_t add_buf[DBWRAP_WATCHER_BUF_LENGTH];
+
+	TDB_DATA dbufs[4] = {
+		{
+			.dptr = num_watchers_buf,
+			.dsize = sizeof(num_watchers_buf),
+		},
+		{ 0 },		/* filled in with existing watchers */
+		{
+			.dptr = add_buf,
+			.dsize = sizeof(add_buf),
+		},
+		{ 0 },		/* filled in with existing data */
+	};
+
+	dbwrap_watcher_put(add_buf, &state->w);
+
+	ok = dbwrap_watch_rec_parse(
+		value, &dbufs[1].dptr, &num_watchers, &dbufs[3]);
+	if (!ok) {
+		struct db_context *db = dbwrap_record_get_db(rec);
+		TDB_DATA key = dbwrap_record_get_key(rec);
+
+		dbwrap_watch_log_invalid_record(db, key, value);
+
+		/* wipe invalid data */
+		num_watchers = 0;
+		dbufs[3] = (TDB_DATA) { .dptr = NULL, .dsize = 0 };
 	}
-	subrec->wrec.watchers = watchers;
 
-	return rec;
+	dbufs[1].dsize = num_watchers * DBWRAP_WATCHER_BUF_LENGTH;
+
+	if (num_watchers >= UINT32_MAX) {
+		DBG_DEBUG("Can't handle %zu watchers\n",
+			  num_watchers+1);
+		state->status = NT_STATUS_INSUFFICIENT_RESOURCES;
+		return;
+	}
+
+	num_watchers += 1;
+	SIVAL(num_watchers_buf, 0, num_watchers);
+
+	state->status = dbwrap_record_storev(rec, dbufs, ARRAY_SIZE(dbufs), 0);
+}
+
+static int db_watched_subrec_destructor(struct db_watched_subrec *s)
+{
+	struct dbwrap_watched_add_watcher_state state = { .w = s->added };
+	struct db_context *backend = dbwrap_record_get_db(s->subrec);
+	NTSTATUS status;
+
+	if (s->added.pid.pid == 0) {
+		return 0;
+	}
+
+	status = dbwrap_do_locked(
+		backend, s->subrec->key, dbwrap_watched_add_watcher, &state);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_WARNING("dbwrap_do_locked failed: %s\n",
+			    nt_errstr(status));
+		return 0;
+	}
+	if (!NT_STATUS_IS_OK(state.status)) {
+		DBG_WARNING("dbwrap_watched_add_watcher failed: %s\n",
+			    nt_errstr(state.status));
+		return 0;
+	}
+	return 0;
 }
 
 struct dbwrap_watched_do_locked_state {
-	TALLOC_CTX *mem_ctx;
 	struct db_context *db;
-	void (*fn)(struct db_record *rec, void *private_data);
+	void (*fn)(struct db_record *rec,
+		   TDB_DATA value,
+		   void *private_data);
 	void *private_data;
 
 	struct db_watched_subrec subrec;
@@ -310,64 +322,54 @@ static NTSTATUS dbwrap_watched_do_locked_delete(struct db_record *rec)
 	return status;
 }
 
-static void dbwrap_watched_do_locked_fn(struct db_record *subrec,
-					void *private_data)
+static void dbwrap_watched_do_locked_fn(
+	struct db_record *subrec,
+	TDB_DATA subrec_value,
+	void *private_data)
 {
 	struct dbwrap_watched_do_locked_state *state =
 		(struct dbwrap_watched_do_locked_state *)private_data;
-	TDB_DATA subrec_value = dbwrap_record_get_value(subrec);
-	struct db_record rec;
-	bool ok;
-
-	rec = (struct db_record) {
-		.db = state->db, .key = dbwrap_record_get_key(subrec),
+	TDB_DATA value = {0};
+	struct db_record rec = {
+		.db = state->db,
+		.key = dbwrap_record_get_key(subrec),
 		.storev = dbwrap_watched_do_locked_storev,
 		.delete_rec = dbwrap_watched_do_locked_delete,
 		.private_data = state
 	};
+	bool ok;
 
 	state->subrec = (struct db_watched_subrec) {
 		.subrec = subrec
 	};
 
-	ok = dbwrap_watch_rec_parse(subrec_value, &state->subrec.wrec);
-	if (ok) {
-		uint8_t *watchers = NULL;
-
-		/*
-		 * state->subrec.wrec.watchers points *directly* into the
-		 * returned data in the record. We need to talloc a
-		 * copy of this so it belongs to state->mem_ctx.
-		 */
-		watchers = talloc_memdup(
-			state->mem_ctx,
-			state->subrec.wrec.watchers,
-			state->subrec.wrec.num_watchers * SERVER_ID_BUF_LENGTH);
-		SMB_ASSERT(watchers != NULL);
-		state->subrec.wrec.watchers = watchers;
-
-		rec.value = state->subrec.wrec.data;
+	ok = dbwrap_watch_rec_parse(subrec_value, NULL, NULL, &value);
+	if (!ok) {
+		dbwrap_watch_log_invalid_record(rec.db, rec.key, subrec_value);
+		/* wipe invalid data */
+		value = (TDB_DATA) { .dptr = NULL, .dsize = 0 };
 	}
 
-	state->fn(&rec, state->private_data);
+	state->fn(&rec, value, state->private_data);
+
+	db_watched_subrec_destructor(&state->subrec);
 }
 
 static NTSTATUS dbwrap_watched_do_locked(struct db_context *db, TDB_DATA key,
 					 void (*fn)(struct db_record *rec,
+						    TDB_DATA value,
 						    void *private_data),
 					 void *private_data)
 {
 	struct db_watched_ctx *ctx = talloc_get_type_abort(
 		db->private_data, struct db_watched_ctx);
 	struct dbwrap_watched_do_locked_state state = {
-		.mem_ctx = talloc_stackframe(),
 		.db = db, .fn = fn, .private_data = private_data
 	};
 	NTSTATUS status;
 
 	status = dbwrap_do_locked(
 		ctx->backend, key, dbwrap_watched_do_locked_fn, &state);
-	TALLOC_FREE(state.mem_ctx);
 	if (!NT_STATUS_IS_OK(status)) {
 		DBG_DEBUG("dbwrap_do_locked returned %s\n", nt_errstr(status));
 		return status;
@@ -379,115 +381,108 @@ static NTSTATUS dbwrap_watched_do_locked(struct db_context *db, TDB_DATA key,
 	return state.status;
 }
 
-static void dbwrap_watched_subrec_wakeup(
-	struct db_record *rec, struct db_watched_subrec *subrec)
-{
-	struct dbwrap_watch_rec *wrec = &subrec->wrec;
-	struct db_context *db = rec->db;
-	struct db_watched_ctx *ctx = talloc_get_type_abort(
-		db->private_data, struct db_watched_ctx);
-	size_t i, num_to_wakeup;
-	size_t db_id_len = dbwrap_db_id(db, NULL, 0);
-	uint8_t db_id[db_id_len];
-	uint8_t len_buf[4];
-	struct iovec iov[3];
-
-	SIVAL(len_buf, 0, db_id_len);
-
-	iov[0] = (struct iovec) { .iov_base = len_buf,
-				  .iov_len = sizeof(len_buf) };
-	iov[1] = (struct iovec) { .iov_base = db_id, .iov_len = db_id_len };
-	iov[2] = (struct iovec) { .iov_base = rec->key.dptr,
-				  .iov_len = rec->key.dsize };
-
-	dbwrap_db_id(db, db_id, db_id_len);
+struct dbwrap_watched_subrec_wakeup_state {
+	struct messaging_context *msg_ctx;
+};
 
-	i = 0;
+static void dbwrap_watched_subrec_wakeup_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
+{
+	struct dbwrap_watched_subrec_wakeup_state *state = private_data;
+	uint8_t *watchers;
+	size_t num_watchers = 0;
+	size_t i;
+	bool ok;
 
-	num_to_wakeup = wrec->num_watchers;
+	ok = dbwrap_watch_rec_parse(value, &watchers, &num_watchers, NULL);
+	if (!ok) {
+		struct db_context *db = dbwrap_record_get_db(rec);
+		TDB_DATA key = dbwrap_record_get_key(rec);
+		dbwrap_watch_log_invalid_record(db, key, value);
+		return;
+	}
 
-	if (subrec->added_watcher) {
-		/*
-		 * Don't alert our own watcher that we just added to
-		 * the end of the array.
-		 */
-		num_to_wakeup -= 1;
+	if (num_watchers == 0) {
+		DBG_DEBUG("No watchers\n");
+		return;
 	}
 
-	while (i < num_to_wakeup) {
-		struct server_id watcher;
-		NTSTATUS status;
+	for (i=0; i<num_watchers; i++) {
+		struct dbwrap_watcher watcher;
 		struct server_id_buf tmp;
+		uint8_t instance_buf[8];
+		NTSTATUS status;
+
+		dbwrap_watcher_get(
+			&watcher, watchers + i*DBWRAP_WATCHER_BUF_LENGTH);
 
-		dbwrap_watch_rec_get_watcher(wrec, i, &watcher);
+		DBG_DEBUG("Alerting %s:%"PRIu64"\n",
+			  server_id_str_buf(watcher.pid, &tmp),
+			  watcher.instance);
 
-		DBG_DEBUG("Alerting %s\n", server_id_str_buf(watcher, &tmp));
+		SBVAL(instance_buf, 0, watcher.instance);
 
-		status = messaging_send_iov(ctx->msg, watcher,
-					    MSG_DBWRAP_MODIFIED,
-					    iov, ARRAY_SIZE(iov), NULL, 0);
+		status = messaging_send_buf(
+			state->msg_ctx,
+			watcher.pid,
+			MSG_DBWRAP_MODIFIED,
+			instance_buf,
+			sizeof(instance_buf));
 		if (!NT_STATUS_IS_OK(status)) {
-			DBG_DEBUG("messaging_send_iov to %s failed: %s\n",
-				  server_id_str_buf(watcher, &tmp),
+			DBG_DEBUG("messaging_send_buf to %s failed: %s\n",
+				  server_id_str_buf(watcher.pid, &tmp),
 				  nt_errstr(status));
 		}
-		if (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_NOT_FOUND)) {
-			dbwrap_watch_rec_del_watcher(wrec, i);
-			num_to_wakeup -= 1;
-			continue;
-		}
-
-		i += 1;
 	}
 }
 
-static NTSTATUS dbwrap_watched_save(struct db_record *rec,
-				    struct dbwrap_watch_rec *wrec,
-				    const TDB_DATA *databufs,
-				    size_t num_databufs,
-				    int flags)
+static void dbwrap_watched_subrec_wakeup(
+	struct db_record *rec, struct db_watched_subrec *subrec)
 {
-	uint32_t num_watchers_buf;
-	uint8_t sizebuf[4];
-	NTSTATUS status;
-	struct TDB_DATA dbufs[num_databufs+2];
-
-	dbufs[0] = (TDB_DATA) {
-		.dptr = sizebuf, .dsize = sizeof(sizebuf)
-	};
-
-	dbufs[1] = (TDB_DATA) {
-		.dptr = wrec->watchers,
-		.dsize = wrec->num_watchers * SERVER_ID_BUF_LENGTH
+	struct db_context *backend = dbwrap_record_get_db(subrec->subrec);
+	struct db_context *db = dbwrap_record_get_db(rec);
+	struct db_watched_ctx *ctx = talloc_get_type_abort(
+		db->private_data, struct db_watched_ctx);
+	struct dbwrap_watched_subrec_wakeup_state state = {
+		.msg_ctx = ctx->msg,
 	};
+	NTSTATUS status;
 
-	if (num_databufs != 0) {
-		memcpy(&dbufs[2], databufs, sizeof(TDB_DATA) * num_databufs);
-	}
-
-	num_watchers_buf = wrec->num_watchers;
-	if (wrec->deleted) {
-		num_watchers_buf |= NUM_WATCHERS_DELETED_BIT;
+	status = dbwrap_do_locked(
+		backend,
+		subrec->subrec->key,
+		dbwrap_watched_subrec_wakeup_fn,
+		&state);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("dbwrap_record_modify failed: %s\n",
+			  nt_errstr(status));
 	}
-
-	SIVAL(sizebuf, 0, num_watchers_buf);
-
-	status = dbwrap_record_storev(rec, dbufs, ARRAY_SIZE(dbufs), flags);
-	return status;
 }
 
 static NTSTATUS dbwrap_watched_subrec_storev(
 	struct db_record *rec, struct db_watched_subrec *subrec,
 	const TDB_DATA *dbufs, int num_dbufs, int flags)
 {
+	uint8_t num_watchers_buf[4] = { 0 };
+	TDB_DATA my_dbufs[num_dbufs+1];
 	NTSTATUS status;
 
 	dbwrap_watched_subrec_wakeup(rec, subrec);
 
-	subrec->wrec.deleted = false;
+	/*
+	 * Watchers only informed once, set num_watchers to 0
+	 */
+	my_dbufs[0] = (TDB_DATA) {
+		.dptr = num_watchers_buf, .dsize = sizeof(num_watchers_buf),
+	};
+	if (num_dbufs != 0) {
+		memcpy(my_dbufs+1, dbufs, num_dbufs * sizeof(*dbufs));
+	}
 
-	status = dbwrap_watched_save(
-		subrec->subrec, &subrec->wrec, dbufs, num_dbufs, flags);
+	status = dbwrap_record_storev(
+		subrec->subrec, my_dbufs, ARRAY_SIZE(my_dbufs), flags);
 	return status;
 }
 
@@ -511,14 +506,10 @@ static NTSTATUS dbwrap_watched_subrec_delete(
 
 	dbwrap_watched_subrec_wakeup(rec, subrec);
 
-	if (subrec->wrec.num_watchers == 0) {
-		return dbwrap_record_delete(subrec->subrec);
-	}
-
-	subrec->wrec.deleted = true;
-
-	status = dbwrap_watched_save(
-		subrec->subrec, &subrec->wrec, NULL, 0, 0);
+	/*
+	 * Watchers were informed, we can throw away the record now
+	 */
+	status = dbwrap_record_delete(subrec->subrec);
 	return status;
 }
 
@@ -542,15 +533,13 @@ static int dbwrap_watched_traverse_fn(struct db_record *rec,
 {
 	struct dbwrap_watched_traverse_state *state = private_data;
 	struct db_record prec = *rec;
-	struct dbwrap_watch_rec wrec;
 	bool ok;
 
-	ok = dbwrap_watch_rec_parse(rec->value, &wrec);
-	if (!ok || wrec.deleted) {
+	ok = dbwrap_watch_rec_parse(rec->value, NULL, NULL, &prec.value);
+	if (!ok) {
 		return 0;
 	}
-
-	prec.value = wrec.data;
+	prec.value_valid = true;
 
 	return state->fn(&prec, state->private_data);
 }
@@ -624,25 +613,25 @@ static int dbwrap_watched_transaction_cancel(struct db_context *db)
 }
 
 struct dbwrap_watched_parse_record_state {
+	struct db_context *db;
 	void (*parser)(TDB_DATA key, TDB_DATA data, void *private_data);
 	void *private_data;
-	bool deleted;
+	bool ok;
 };
 
 static void dbwrap_watched_parse_record_parser(TDB_DATA key, TDB_DATA data,
 					       void *private_data)
 {
 	struct dbwrap_watched_parse_record_state *state = private_data;
-	struct dbwrap_watch_rec wrec;
-	bool ok;
+	TDB_DATA userdata;
 
-	ok = dbwrap_watch_rec_parse(data, &wrec);
-	if ((!ok) || (wrec.deleted)) {
-		state->deleted = true;
+	state->ok = dbwrap_watch_rec_parse(data, NULL, NULL, &userdata);
+	if (!state->ok) {
+		dbwrap_watch_log_invalid_record(state->db, key, data);
 		return;
 	}
 
-	state->parser(key, wrec.data, state->private_data);
+	state->parser(key, userdata, state->private_data);
 }
 
 static NTSTATUS dbwrap_watched_parse_record(
@@ -653,9 +642,9 @@ static NTSTATUS dbwrap_watched_parse_record(
 	struct db_watched_ctx *ctx = talloc_get_type_abort(
 		db->private_data, struct db_watched_ctx);
 	struct dbwrap_watched_parse_record_state state = {
+		.db = db,
 		.parser = parser,
 		.private_data = private_data,
-		.deleted = false
 	};
 	NTSTATUS status;
 
@@ -664,7 +653,7 @@ static NTSTATUS dbwrap_watched_parse_record(
 	if (!NT_STATUS_IS_OK(status)) {
 		return status;
 	}
-	if (state.deleted) {
+	if (!state.ok) {
 		return NT_STATUS_NOT_FOUND;
 	}
 	return NT_STATUS_OK;
@@ -697,7 +686,7 @@ static struct tevent_req *dbwrap_watched_parse_record_send(
 	*state = (struct dbwrap_watched_parse_record_state) {
 		.parser = parser,
 		.private_data = private_data,
-		.deleted = false,
+		.ok = true,
 	};
 
 	subreq = dbwrap_parse_record_send(state,
@@ -730,7 +719,7 @@ static void dbwrap_watched_parse_record_done(struct tevent_req *subreq)
 		return;
 	}
 
-	if (state->deleted) {
+	if (!state->ok) {
 		tevent_req_nterror(req, NT_STATUS_NOT_FOUND);
 		return;
 	}
@@ -769,20 +758,58 @@ static size_t dbwrap_watched_id(struct db_context *db, uint8_t *id,
 	return dbwrap_db_id(ctx->backend, id, idlen);
 }
 
-void dbwrap_watched_wakeup(struct db_record *rec)
+static void dbwrap_watched_wakeup_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
-	struct db_watched_subrec *subrec = NULL;
+	uint8_t num_watchers_buf[4] = { 0 };
+	TDB_DATA dbufs[2] = {
+		{
+			.dptr = num_watchers_buf,
+			.dsize = sizeof(num_watchers_buf),
+		},
+		{ 0 },		/* filled in with existing data */
+	};
+	NTSTATUS status;
+	bool ok;
 
-	if (rec->storev == dbwrap_watched_do_locked_storev) {
-		struct dbwrap_watched_do_locked_state *state =
-			rec->private_data;
-		subrec = &state->subrec;
-	} else {
-		subrec = talloc_get_type_abort(
-			rec->private_data, struct db_watched_subrec);
+	dbwrap_watched_subrec_wakeup_fn(rec, value, private_data);
+
+	/*
+	 * Watchers are informed only once: Store the existing data
+	 * without any watchers
+	 */
+
+	ok = dbwrap_watch_rec_parse(value, NULL, NULL, &dbufs[1]);
+	if (!ok) {
+		DBG_DEBUG("dbwrap_watch_rec_parse failed\n");
+		return;
 	}
 
-	dbwrap_watched_subrec_wakeup(rec, subrec);
+	status = dbwrap_record_storev(rec, dbufs, ARRAY_SIZE(dbufs), 0);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("dbwrap_record_storev() failed: %s\n",
+			  nt_errstr(status));
+	}
+}
+
+void dbwrap_watched_wakeup(struct db_record *rec)
+{
+	struct db_context *db = dbwrap_record_get_db(rec);
+	struct db_watched_ctx *ctx = talloc_get_type_abort(
+		db->private_data, struct db_watched_ctx);
+	struct dbwrap_watched_subrec_wakeup_state state = {
+		.msg_ctx = ctx->msg,
+	};
+	NTSTATUS status;
+
+	status = dbwrap_do_locked(
+		ctx->backend, rec->key, dbwrap_watched_wakeup_fn, &state);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("dbwrap_do_locked failed: %s\n",
+			  nt_errstr(status));
+	}
 }
 
 struct db_context *db_open_watched(TALLOC_CTX *mem_ctx,
@@ -829,8 +856,8 @@ struct db_context *db_open_watched(TALLOC_CTX *mem_ctx,
 
 struct dbwrap_watched_watch_state {
 	struct db_context *db;
-	struct server_id me;
-	TDB_DATA w_key;
+	TDB_DATA key;
+	struct dbwrap_watcher watcher;
 	struct server_id blocker;
 	bool blockerdead;
 };
@@ -851,12 +878,10 @@ struct tevent_req *dbwrap_watched_watch_send(TALLOC_CTX *mem_ctx,
 	struct db_watched_ctx *ctx = talloc_get_type_abort(
 		db->private_data, struct db_watched_ctx);
 	struct db_watched_subrec *subrec = NULL;
-	struct dbwrap_watch_rec *wrec = NULL;
-	uint8_t *watchers = NULL;
 	struct tevent_req *req, *subreq;
 	struct dbwrap_watched_watch_state *state;
-	ssize_t needed;
-	NTSTATUS status;
+
+	static uint64_t instance = 1;
 
 	req = tevent_req_create(mem_ctx, &state,
 				struct dbwrap_watched_watch_state);
@@ -890,22 +915,21 @@ struct tevent_req *dbwrap_watched_watch_send(TALLOC_CTX *mem_ctx,
 		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
 		return tevent_req_post(req, ev);
 	}
-
-	state->me = messaging_server_id(ctx->msg);
-
-	needed = dbwrap_record_watchers_key(db, rec, NULL, 0);
-	if (needed == -1) {
-		tevent_req_nterror(req, NT_STATUS_INSUFFICIENT_RESOURCES);
+	if (subrec->added.pid.pid != 0) {
+		tevent_req_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
 		return tevent_req_post(req, ev);
 	}
-	state->w_key.dsize = needed;
 
-	state->w_key.dptr = talloc_array(state, uint8_t, state->w_key.dsize);
-	if (tevent_req_nomem(state->w_key.dptr, req)) {
+	state->watcher = (struct dbwrap_watcher) {
+		.pid = messaging_server_id(ctx->msg),
+		.instance = instance++,
+	};
+	subrec->added = state->watcher;
+
+	state->key = tdb_data_talloc_copy(state, rec->key);
+	if (tevent_req_nomem(state->key.dptr, req)) {
 		return tevent_req_post(req, ev);
 	}
-	dbwrap_record_watchers_key(db, rec, state->w_key.dptr,
-				   state->w_key.dsize);
 
 	subreq = messaging_filtered_read_send(
 		state, ev, ctx->msg, dbwrap_watched_msg_filter, state);
@@ -914,32 +938,10 @@ struct tevent_req *dbwrap_watched_watch_send(TALLOC_CTX *mem_ctx,
 	}
 	tevent_req_set_callback(subreq, dbwrap_watched_watch_done, req);
 
-	wrec = &subrec->wrec;
-
-	watchers = talloc_realloc(
-		NULL,
-		wrec->watchers,
-		uint8_t,
-		(wrec->num_watchers + 1) * SERVER_ID_BUF_LENGTH);
-	if (tevent_req_nomem(watchers, req)) {
-		return tevent_req_post(req, ev);
-	}
-	server_id_put(&watchers[wrec->num_watchers * SERVER_ID_BUF_LENGTH],
-		      state->me);
-	wrec->watchers = watchers;
-	wrec->num_watchers += 1;
-	subrec->added_watcher = true;
-
-	status = dbwrap_watched_save(
-		subrec->subrec, wrec, &wrec->data, 1, 0);
-	if (tevent_req_nterror(req, status)) {
-		return tevent_req_post(req, ev);
-	}
-
 	talloc_set_destructor(state, dbwrap_watched_watch_state_destructor);
 
 	if (blocker.pid != 0) {
-		subreq = server_id_watch_send(state, ev, ctx->msg, blocker);
+		subreq = server_id_watch_send(state, ev, blocker);
 		if (tevent_req_nomem(subreq, req)) {
 			return tevent_req_post(req, ev);
 		}
@@ -968,67 +970,114 @@ static void dbwrap_watched_watch_blocker_died(struct tevent_req *subreq)
 	tevent_req_done(req);
 }
 
-static bool dbwrap_watched_remove_waiter(struct dbwrap_watch_rec *wrec,
-					 struct server_id id)
+static void dbwrap_watched_watch_state_destructor_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
+	struct dbwrap_watched_watch_state *state = talloc_get_type_abort(
+		private_data, struct dbwrap_watched_watch_state);
+	uint8_t *watchers;
+	size_t num_watchers = 0;
 	size_t i;
+	bool ok;
+	NTSTATUS status;
+
+	uint8_t num_watchers_buf[4];
+
+	TDB_DATA dbufs[4] = {
+		{
+			.dptr = num_watchers_buf,
+			.dsize = sizeof(num_watchers_buf),
+		},
+		{ 0 },		/* watchers "before" state->w */
+		{ 0 },		/* watchers "behind" state->w */
+		{ 0 },		/* filled in with data */
+	};
+
+	ok = dbwrap_watch_rec_parse(
+		value, &watchers, &num_watchers, &dbufs[3]);
+	if (!ok) {
+		status = dbwrap_record_delete(rec);
+		if (!NT_STATUS_IS_OK(status)) {
+			DBG_DEBUG("dbwrap_record_delete failed: %s\n",
+				  nt_errstr(status));
+		}
+		return;
+	}
 
-	for (i=0; i<wrec->num_watchers; i++) {
-		struct server_id watcher;
-		dbwrap_watch_rec_get_watcher(wrec, i, &watcher);
-		if (server_id_equal(&id, &watcher)) {
+	for (i=0; i<num_watchers; i++) {
+		struct dbwrap_watcher watcher;
+
+		dbwrap_watcher_get(
+			&watcher, watchers + i*DBWRAP_WATCHER_BUF_LENGTH);
+
+		if ((state->watcher.instance == watcher.instance) &&
+		    server_id_equal(&state->watcher.pid, &watcher.pid)) {
 			break;
 		}
 	}
 
-	if (i == wrec->num_watchers) {
+	if (i == num_watchers) {
 		struct server_id_buf buf;
-		DBG_WARNING("Did not find %s in state->watchers\n",
-			    server_id_str_buf(id, &buf));
-		return false;
+		DBG_DEBUG("Watcher %s:%"PRIu64" not found\n",
+			  server_id_str_buf(state->watcher.pid, &buf),
+			  state->watcher.instance);
+		return;
 	}
 
-	dbwrap_watch_rec_del_watcher(wrec, i);
-	return true;
-}
-
-static int dbwrap_watched_watch_state_destructor(
-	struct dbwrap_watched_watch_state *state)
-{
-	struct db_record *rec;
-	struct db_watched_subrec *subrec;
-	struct dbwrap_watch_rec *wrec = NULL;
-	TDB_DATA key;
-	bool ok;
-
-	ok = dbwrap_record_watchers_key_parse(state->w_key, NULL, NULL, &key);
-	if (!ok) {
-		DBG_WARNING("dbwrap_record_watchers_key_parse failed\n");
-		return 0;
+	if (i > 0) {
+		dbufs[1] = (TDB_DATA) {
+			.dptr = watchers,
+			.dsize = i * DBWRAP_WATCHER_BUF_LENGTH,
+		};
 	}
 
-	rec = dbwrap_fetch_locked(state->db, state, key);
-	if (rec == NULL) {
-		DBG_WARNING("dbwrap_fetch_locked failed\n");
-		return 0;
+	if (i < (num_watchers - 1)) {
+		size_t behind = (num_watchers - 1 - i);
+
+		dbufs[2] = (TDB_DATA) {
+			.dptr = watchers + (i+1) * DBWRAP_WATCHER_BUF_LENGTH,
+			.dsize = behind * DBWRAP_WATCHER_BUF_LENGTH,
+		};
 	}
 
-	subrec = talloc_get_type_abort(
-		rec->private_data, struct db_watched_subrec);
-	wrec = &subrec->wrec;
+	num_watchers -= 1;
 
-	ok = dbwrap_watched_remove_waiter(wrec, state->me);
-	if (ok) {
-		NTSTATUS status;
-		status = dbwrap_watched_save(
-			subrec->subrec, wrec, &wrec->data, 1, 0);
+	if ((num_watchers == 0) && (dbufs[3].dsize == 0)) {
+		status = dbwrap_record_delete(rec);
 		if (!NT_STATUS_IS_OK(status)) {
-			DBG_WARNING("dbwrap_watched_save failed: %s\n",
-				    nt_errstr(status));
+			DBG_DEBUG("dbwrap_record_delete() failed: %s\n",
+				  nt_errstr(status));
 		}
+		return;
+	}
+
+	SIVAL(num_watchers_buf, 0, num_watchers);
+
+	status = dbwrap_record_storev(rec, dbufs, ARRAY_SIZE(dbufs), 0);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("dbwrap_record_storev() failed: %s\n",
+			  nt_errstr(status));
 	}
+}
 
-	TALLOC_FREE(rec);
+static int dbwrap_watched_watch_state_destructor(
+	struct dbwrap_watched_watch_state *state)
+{
+	struct db_watched_ctx *ctx = talloc_get_type_abort(
+		state->db->private_data, struct db_watched_ctx);
+	NTSTATUS status;
+
+	status = dbwrap_do_locked(
+		ctx->backend,
+		state->key,
+		dbwrap_watched_watch_state_destructor_fn,
+		state);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("dbwrap_do_locked failed: %s\n",
+			  nt_errstr(status));
+	}
 	return 0;
 }
 
@@ -1037,7 +1086,7 @@ static bool dbwrap_watched_msg_filter(struct messaging_rec *rec,
 {
 	struct dbwrap_watched_watch_state *state = talloc_get_type_abort(
 		private_data, struct dbwrap_watched_watch_state);
-	int cmp;
+	uint64_t instance;
 
 	if (rec->msg_type != MSG_DBWRAP_MODIFIED) {
 		return false;
@@ -1045,19 +1094,32 @@ static bool dbwrap_watched_msg_filter(struct messaging_rec *rec,
 	if (rec->num_fds != 0) {
 		return false;
 	}
-	if (rec->buf.length != state->w_key.dsize) {
+
+	if (rec->buf.length != sizeof(instance)) {
+		DBG_DEBUG("Got size %zu, expected %zu\n",
+			  rec->buf.length,
+			  sizeof(instance));
 		return false;
 	}
 
-	cmp = memcmp(rec->buf.data, state->w_key.dptr, rec->buf.length);
+	instance = BVAL(rec->buf.data, 0);
 
-	return (cmp == 0);
+	if (instance != state->watcher.instance) {
+		DBG_DEBUG("Got instance %"PRIu64", expected %"PRIu64"\n",
+			  instance,
+			  state->watcher.instance);
+		return false;
+	}
+
+	return true;
 }
 
 static void dbwrap_watched_watch_done(struct tevent_req *subreq)
 {
 	struct tevent_req *req = tevent_req_callback_data(
 		subreq, struct tevent_req);
+	struct dbwrap_watched_watch_state *state = tevent_req_data(
+		req, struct dbwrap_watched_watch_state);
 	struct messaging_rec *rec;
 	int ret;
 
@@ -1067,6 +1129,11 @@ static void dbwrap_watched_watch_done(struct tevent_req *subreq)
 		tevent_req_nterror(req, map_nt_error_from_unix(ret));
 		return;
 	}
+	/*
+	 * No need to remove ourselves anymore, we've been removed by
+	 * dbwrap_watched_subrec_wakeup().
+	 */
+	talloc_set_destructor(state, NULL);
 	tevent_req_done(req);
 }
 
diff --git a/source3/lib/errmap_unix.c b/source3/lib/errmap_unix.c
index 9eb30f7b814..33b48cadcb5 100644
--- a/source3/lib/errmap_unix.c
+++ b/source3/lib/errmap_unix.c
@@ -118,6 +118,7 @@ static const struct {
 #ifdef EOVERFLOW
 	{ EOVERFLOW,      NT_STATUS_ALLOTTED_SPACE_EXCEEDED },
 #endif
+	{ EINPROGRESS,	NT_STATUS_MORE_PROCESSING_REQUIRED },
 };
 
 /*********************************************************************
@@ -126,7 +127,7 @@ static const struct {
 
 NTSTATUS map_nt_error_from_unix(int unix_error)
 {
-	int i = 0;
+	size_t i = 0;
 
 	if (unix_error == 0) {
 		/* we map this to an error, not success, as this
@@ -264,7 +265,7 @@ static const struct {
 
 int map_errno_from_nt_status(NTSTATUS status)
 {
-	int i;
+	size_t i;
 	DEBUG(10,("map_errno_from_nt_status: 32 bit codes: code=%08x\n",
 		NT_STATUS_V(status)));
 
diff --git a/source3/lib/g_lock.c b/source3/lib/g_lock.c
index b01bb591f77..4bf30188a43 100644
--- a/source3/lib/g_lock.c
+++ b/source3/lib/g_lock.c
@@ -38,120 +38,117 @@ struct g_lock_ctx {
 	struct messaging_context *msg;
 };
 
-/*
- * The "g_lock.tdb" file contains records, indexed by the 0-terminated
- * lockname. The record contains an array of "struct g_lock_rec"
- * structures.
- */
-
-#define G_LOCK_REC_LENGTH (SERVER_ID_BUF_LENGTH+1)
-
-static void g_lock_rec_put(uint8_t buf[G_LOCK_REC_LENGTH],
-			   const struct g_lock_rec rec)
-{
-	SCVAL(buf, 0, rec.lock_type);
-	server_id_put(buf+1, rec.pid);
-}
-
-static void g_lock_rec_get(struct g_lock_rec *rec,
-			   const uint8_t buf[G_LOCK_REC_LENGTH])
-{
-	rec->lock_type = CVAL(buf, 0);
-	server_id_get(&rec->pid, buf+1);
-}
-
 struct g_lock {
-	uint8_t *recsbuf;
-	size_t num_recs;
-	uint8_t *data;
+	struct server_id exclusive;
+	size_t num_shared;
+	uint8_t *shared;
 	size_t datalen;
+	uint8_t *data;
 };
 
 static bool g_lock_parse(uint8_t *buf, size_t buflen, struct g_lock *lck)
 {
-	size_t found_recs, data_ofs;
+	struct server_id exclusive;
+	size_t num_shared, shared_len;
 
-	if (buflen < sizeof(uint32_t)) {
-		*lck = (struct g_lock) {0};
+	if (buflen < (SERVER_ID_BUF_LENGTH + sizeof(uint32_t))) {
+		*lck = (struct g_lock) { .exclusive.pid = 0 };
 		return true;
 	}
 
-	found_recs = IVAL(buf, 0);
+	server_id_get(&exclusive, buf);
+	buf += SERVER_ID_BUF_LENGTH;
+	buflen -= SERVER_ID_BUF_LENGTH;
 
+	num_shared = IVAL(buf, 0);
 	buf += sizeof(uint32_t);
 	buflen -= sizeof(uint32_t);
-	if (found_recs > buflen/G_LOCK_REC_LENGTH) {
+
+	if (num_shared > buflen/SERVER_ID_BUF_LENGTH) {
 		return false;
 	}
 
-	data_ofs = found_recs * G_LOCK_REC_LENGTH;
+	shared_len = num_shared * SERVER_ID_BUF_LENGTH;
 
 	*lck = (struct g_lock) {
-		.recsbuf = buf, .num_recs = found_recs,
-		.data = buf+data_ofs, .datalen = buflen-data_ofs
+		.exclusive = exclusive,
+		.num_shared = num_shared,
+		.shared = buf,
+		.datalen = buflen-shared_len,
+		.data = buf+shared_len,
 	};
 
 	return true;
 }
 
-static void g_lock_get_rec(const struct g_lock *lck,
-			   size_t i,
-			   struct g_lock_rec *rec)
+static void g_lock_get_shared(const struct g_lock *lck,
+			      size_t i,
+			      struct server_id *shared)
 {
-	if (i >= lck->num_recs) {
+	if (i >= lck->num_shared) {
 		abort();
 	}
-	g_lock_rec_get(rec, lck->recsbuf + i*G_LOCK_REC_LENGTH);
+	server_id_get(shared, lck->shared + i*SERVER_ID_BUF_LENGTH);
 }
 
-static void g_lock_rec_del(struct g_lock *lck, size_t i)
+static void g_lock_del_shared(struct g_lock *lck, size_t i)
 {
-	if (i >= lck->num_recs) {
+	if (i >= lck->num_shared) {
 		abort();
 	}
-	lck->num_recs -= 1;
-	if (i < lck->num_recs) {
-		uint8_t *recptr = lck->recsbuf + i*G_LOCK_REC_LENGTH;
-		memcpy(recptr, lck->recsbuf + lck->num_recs*G_LOCK_REC_LENGTH,
-		       G_LOCK_REC_LENGTH);
+	lck->num_shared -= 1;
+	if (i < lck->num_shared) {
+		memcpy(lck->shared + i*SERVER_ID_BUF_LENGTH,
+		       lck->shared + lck->num_shared*SERVER_ID_BUF_LENGTH,
+		       SERVER_ID_BUF_LENGTH);
 	}
 }
 
-static NTSTATUS g_lock_store(struct db_record *rec, struct g_lock *lck,
-			     struct g_lock_rec *add)
+static NTSTATUS g_lock_store(
+	struct db_record *rec,
+	struct g_lock *lck,
+	struct server_id *new_shared)
 {
-	uint8_t sizebuf[4];
-	uint8_t addbuf[G_LOCK_REC_LENGTH];
+	uint8_t exclusive[SERVER_ID_BUF_LENGTH];
+	uint8_t sizebuf[sizeof(uint32_t)];
+	uint8_t shared[SERVER_ID_BUF_LENGTH];
 
 	struct TDB_DATA dbufs[] = {
+		{ .dptr = exclusive, .dsize = sizeof(exclusive) },
 		{ .dptr = sizebuf, .dsize = sizeof(sizebuf) },
-		{ .dptr = lck->recsbuf,
-		  .dsize = lck->num_recs * G_LOCK_REC_LENGTH },
+		{ .dptr = lck->shared,
+		  .dsize = lck->num_shared * SERVER_ID_BUF_LENGTH },
 		{ 0 },
 		{ .dptr = lck->data, .dsize = lck->datalen }
 	};
 
-	if (add != NULL) {
-		g_lock_rec_put(addbuf, *add);
+	server_id_put(exclusive, lck->exclusive);
+
+	if (new_shared != NULL) {
+		if (lck->num_shared >= UINT32_MAX) {
+			return NT_STATUS_BUFFER_OVERFLOW;
+		}
+
+		server_id_put(shared, *new_shared);
 
-		dbufs[2] = (TDB_DATA) {
-			.dptr = addbuf, .dsize = G_LOCK_REC_LENGTH
+		dbufs[3] = (TDB_DATA) {
+			.dptr = shared, .dsize = sizeof(shared),
 		};
 
-		lck->num_recs += 1;
+		lck->num_shared += 1;
 	}
 
-	SIVAL(sizebuf, 0, lck->num_recs);
+	SIVAL(sizebuf, 0, lck->num_shared);
 
 	return dbwrap_record_storev(rec, dbufs, ARRAY_SIZE(dbufs), 0);
 }
 
-struct g_lock_ctx *g_lock_ctx_init(TALLOC_CTX *mem_ctx,
-				   struct messaging_context *msg)
+struct g_lock_ctx *g_lock_ctx_init_backend(
+	TALLOC_CTX *mem_ctx,
+	struct messaging_context *msg,
+	struct db_context **backend)
 {
 	struct g_lock_ctx *result;
-	struct db_context *backend;
-	char *db_path;
 
 	result = talloc(mem_ctx, struct g_lock_ctx);
 	if (result == NULL) {
@@ -159,210 +156,385 @@ struct g_lock_ctx *g_lock_ctx_init(TALLOC_CTX *mem_ctx,
 	}
 	result->msg = msg;
 
-	db_path = lock_path(talloc_tos(), "g_lock.tdb");
-	if (db_path == NULL) {
+	result->db = db_open_watched(result, backend, msg);
+	if (result->db == NULL) {
+		DBG_WARNING("db_open_watched failed\n");
 		TALLOC_FREE(result);
 		return NULL;
 	}
+	return result;
+}
+
+struct g_lock_ctx *g_lock_ctx_init(TALLOC_CTX *mem_ctx,
+				   struct messaging_context *msg)
+{
+	char *db_path = NULL;
+	struct db_context *backend = NULL;
+	struct g_lock_ctx *ctx = NULL;
+
+	db_path = lock_path(mem_ctx, "g_lock.tdb");
+	if (db_path == NULL) {
+		return NULL;
+	}
 
-	backend = db_open(result, db_path, 0,
-			  TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
-			  O_RDWR|O_CREAT, 0600,
-			  DBWRAP_LOCK_ORDER_3,
-			  DBWRAP_FLAG_NONE);
+	backend = db_open(
+		mem_ctx,
+		db_path,
+		0,
+		TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
+		O_RDWR|O_CREAT,
+		0600,
+		DBWRAP_LOCK_ORDER_3,
+		DBWRAP_FLAG_NONE);
 	TALLOC_FREE(db_path);
 	if (backend == NULL) {
 		DBG_WARNING("Could not open g_lock.tdb\n");
-		TALLOC_FREE(result);
 		return NULL;
 	}
 
-	result->db = db_open_watched(result, &backend, msg);
-	if (result->db == NULL) {
-		DBG_WARNING("db_open_watched failed\n");
-		TALLOC_FREE(result);
-		return NULL;
+	ctx = g_lock_ctx_init_backend(mem_ctx, msg, &backend);
+	return ctx;
+}
+
+static NTSTATUS g_lock_cleanup_dead(
+	struct db_record *rec,
+	struct g_lock *lck,
+	struct server_id *dead_blocker)
+{
+	bool modified = false;
+	bool exclusive_died;
+	NTSTATUS status = NT_STATUS_OK;
+	struct server_id_buf tmp;
+
+	if (dead_blocker == NULL) {
+		return NT_STATUS_OK;
 	}
-	return result;
+
+	exclusive_died = server_id_equal(dead_blocker, &lck->exclusive);
+
+	if (exclusive_died) {
+		DBG_DEBUG("Exclusive holder %s died\n",
+			  server_id_str_buf(lck->exclusive, &tmp));
+		lck->exclusive.pid = 0;
+		modified = true;
+	}
+
+	if (lck->num_shared != 0) {
+		bool shared_died;
+		struct server_id shared;
+
+		g_lock_get_shared(lck, 0, &shared);
+		shared_died = server_id_equal(dead_blocker, &shared);
+
+		if (shared_died) {
+			DBG_DEBUG("Shared holder %s died\n",
+				  server_id_str_buf(shared, &tmp));
+			g_lock_del_shared(lck, 0);
+			modified = true;
+		}
+	}
+
+	if (modified) {
+		status = g_lock_store(rec, lck, NULL);
+		if (!NT_STATUS_IS_OK(status)) {
+			DBG_DEBUG("g_lock_store() failed: %s\n",
+				  nt_errstr(status));
+		}
+	}
+
+	return status;
 }
 
-static bool g_lock_conflicts(enum g_lock_type l1, enum g_lock_type l2)
+static ssize_t g_lock_find_shared(
+	struct g_lock *lck,
+	const struct server_id *self)
 {
+	size_t i;
+
+	for (i=0; i<lck->num_shared; i++) {
+		struct server_id shared;
+		bool same;
+
+		g_lock_get_shared(lck, i, &shared);
+
+		same = server_id_equal(self, &shared);
+		if (same) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static void g_lock_cleanup_shared(struct g_lock *lck)
+{
+	size_t i;
+	struct server_id check;
+	bool exists;
+
+	if (lck->num_shared == 0) {
+		return;
+	}
+
 	/*
-	 * Only tested write locks so far. Very likely this routine
-	 * needs to be fixed for read locks....
+	 * Read locks can stay around forever if the process dies. Do
+	 * a heuristic check for process existence: Check one random
+	 * process for existence. Hopefully this will keep runaway
+	 * read locks under control.
 	 */
-	if ((l1 == G_LOCK_READ) && (l2 == G_LOCK_READ)) {
-		return false;
+	i = generate_random() % lck->num_shared;
+	g_lock_get_shared(lck, i, &check);
+
+	exists = serverid_exists(&check);
+	if (!exists) {
+		struct server_id_buf tmp;
+		DBG_DEBUG("Shared locker %s died -- removing\n",
+			  server_id_str_buf(check, &tmp));
+		g_lock_del_shared(lck, i);
 	}
-	return true;
 }
 
-static NTSTATUS g_lock_trylock(struct db_record *rec, struct server_id self,
-			       enum g_lock_type type,
-			       struct server_id *blocker)
+struct g_lock_lock_state {
+	struct tevent_context *ev;
+	struct g_lock_ctx *ctx;
+	TDB_DATA key;
+	enum g_lock_type type;
+	bool retry;
+};
+
+struct g_lock_lock_fn_state {
+	struct g_lock_lock_state *req_state;
+	struct server_id *dead_blocker;
+
+	struct tevent_req *watch_req;
+	NTSTATUS status;
+};
+
+static int g_lock_lock_state_destructor(struct g_lock_lock_state *s);
+
+static NTSTATUS g_lock_trylock(
+	struct db_record *rec,
+	struct g_lock_lock_fn_state *state,
+	TDB_DATA data,
+	struct server_id *blocker)
 {
-	TDB_DATA data;
-	size_t i;
-	struct g_lock lck;
-	struct g_lock_rec mylock = {0};
+	struct g_lock_lock_state *req_state = state->req_state;
+	struct server_id self = messaging_server_id(req_state->ctx->msg);
+	enum g_lock_type type = req_state->type;
+	bool retry = req_state->retry;
+	struct g_lock lck = { .exclusive.pid = 0 };
+	struct server_id_buf tmp;
 	NTSTATUS status;
-	bool modified = false;
 	bool ok;
 
-	data = dbwrap_record_get_value(rec);
-
 	ok = g_lock_parse(data.dptr, data.dsize, &lck);
 	if (!ok) {
+		DBG_DEBUG("g_lock_parse failed\n");
 		return NT_STATUS_INTERNAL_DB_CORRUPTION;
 	}
 
-	if ((type == G_LOCK_READ) && (lck.num_recs > 0)) {
-		struct g_lock_rec check_rec;
+	status = g_lock_cleanup_dead(rec, &lck, state->dead_blocker);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("g_lock_cleanup_dead() failed: %s\n",
+			  nt_errstr(status));
+		return status;
+	}
 
-		/*
-		 * Read locks can stay around forever if the process
-		 * dies. Do a heuristic check for process existence:
-		 * Check one random process for existence. Hopefully
-		 * this will keep runaway read locks under control.
-		 */
-		i = generate_random() % lck.num_recs;
+	if (lck.exclusive.pid != 0) {
+		bool self_exclusive = server_id_equal(&self, &lck.exclusive);
 
-		g_lock_get_rec(&lck, i, &check_rec);
+		if (!self_exclusive) {
+			bool exists = serverid_exists(&lck.exclusive);
+			if (!exists) {
+				lck.exclusive = (struct server_id) { .pid=0 };
+				goto noexclusive;
+			}
 
-		if ((check_rec.lock_type == G_LOCK_READ) &&
-		    !serverid_exists(&check_rec.pid)) {
-			g_lock_rec_del(&lck, i);
-			modified = true;
-		}
-	}
+			DBG_DEBUG("%s has an exclusive lock\n",
+				  server_id_str_buf(lck.exclusive, &tmp));
 
-	/*
-	 * For the lock upgrade/downgrade case, remove ourselves from
-	 * the list. We re-add ourselves later after we checked the
-	 * other entries for conflict.
-	 */
+			if (type == G_LOCK_DOWNGRADE) {
+				struct server_id_buf tmp2;
+				DBG_DEBUG("%s: Trying to downgrade %s\n",
+					  server_id_str_buf(self, &tmp),
+					  server_id_str_buf(
+						  lck.exclusive, &tmp2));
+				return NT_STATUS_NOT_LOCKED;
+			}
 
-	for (i=0; i<lck.num_recs; i++) {
-		struct g_lock_rec lock;
+			if (type == G_LOCK_UPGRADE) {
+				ssize_t shared_idx;
+				shared_idx = g_lock_find_shared(&lck, &self);
+
+				if (shared_idx == -1) {
+					DBG_DEBUG("Trying to upgrade %s "
+						  "without "
+						  "existing shared lock\n",
+						  server_id_str_buf(
+							  self, &tmp));
+					return NT_STATUS_NOT_LOCKED;
+				}
+
+				/*
+				 * We're trying to upgrade, and the
+				 * exlusive lock is taken by someone
+				 * else. This means that someone else
+				 * is waiting for us to give up our
+				 * shared lock. If we now also wait
+				 * for someone to give their shared
+				 * lock, we will deadlock.
+				 */
+
+				DBG_DEBUG("Trying to upgrade %s while "
+					  "someone else is also "
+					  "trying to upgrade\n",
+					  server_id_str_buf(self, &tmp));
+				return NT_STATUS_POSSIBLE_DEADLOCK;
+			}
 
-		g_lock_get_rec(&lck, i, &lock);
+			*blocker = lck.exclusive;
+			return NT_STATUS_LOCK_NOT_GRANTED;
+		}
 
-		if (server_id_equal(&self, &lock.pid)) {
-			if (lock.lock_type == type) {
-				status = NT_STATUS_WAS_LOCKED;
-				goto done;
-			}
+		if (type == G_LOCK_DOWNGRADE) {
+			DBG_DEBUG("Downgrading %s from WRITE to READ\n",
+				  server_id_str_buf(self, &tmp));
 
-			mylock = lock;
-			g_lock_rec_del(&lck, i);
-			modified = true;
-			break;
+			lck.exclusive = (struct server_id) { .pid = 0 };
+			goto do_shared;
 		}
-	}
 
-	/*
-	 * Check for conflicts with everybody else. Not a for-loop
-	 * because we remove stale entries in the meantime,
-	 * decrementing lck.num_recs.
-	 */
+		if (!retry) {
+			DBG_DEBUG("%s already locked by self\n",
+				  server_id_str_buf(self, &tmp));
+			return NT_STATUS_WAS_LOCKED;
+		}
 
-	i = 0;
+		if (lck.num_shared != 0) {
+			g_lock_get_shared(&lck, 0, blocker);
 
-	while (i < lck.num_recs) {
-		struct g_lock_rec lock;
+			DBG_DEBUG("Continue waiting for shared lock %s\n",
+				  server_id_str_buf(*blocker, &tmp));
 
-		g_lock_get_rec(&lck, i, &lock);
+			return NT_STATUS_LOCK_NOT_GRANTED;
+		}
 
-		if (g_lock_conflicts(type, lock.lock_type)) {
-			struct server_id pid = lock.pid;
+		talloc_set_destructor(req_state, NULL);
 
-			/*
-			 * As the serverid_exists might recurse into
-			 * the g_lock code, we use
-			 * SERVERID_UNIQUE_ID_NOT_TO_VERIFY to avoid the loop
-			 */
-			pid.unique_id = SERVERID_UNIQUE_ID_NOT_TO_VERIFY;
+		/*
+		 * Retry after a conflicting lock was released
+		 */
+		return NT_STATUS_OK;
+	}
 
-			if (serverid_exists(&pid)) {
-				status = NT_STATUS_LOCK_NOT_GRANTED;
-				*blocker = lock.pid;
-				goto done;
-			}
+noexclusive:
 
-			/*
-			 * Delete stale conflicting entry
-			 */
-			g_lock_rec_del(&lck, i);
-			modified = true;
-			continue;
+	if (type == G_LOCK_UPGRADE) {
+		ssize_t shared_idx = g_lock_find_shared(&lck, &self);
+
+		if (shared_idx == -1) {
+			DBG_DEBUG("Trying to upgrade %s without "
+				  "existing shared lock\n",
+				  server_id_str_buf(self, &tmp));
+			return NT_STATUS_NOT_LOCKED;
 		}
-		i++;
+
+		g_lock_del_shared(&lck, shared_idx);
+		type = G_LOCK_WRITE;
 	}
 
-	modified = true;
+	if (type == G_LOCK_WRITE) {
+		ssize_t shared_idx = g_lock_find_shared(&lck, &self);
 
-	mylock = (struct g_lock_rec) {
-		.pid = self,
-		.lock_type = type
-	};
+		if (shared_idx != -1) {
+			DBG_DEBUG("Trying to writelock existing shared %s\n",
+				  server_id_str_buf(self, &tmp));
+			return NT_STATUS_WAS_LOCKED;
+		}
 
-	status = NT_STATUS_OK;
-done:
-	if (modified) {
-		NTSTATUS store_status;
+		lck.exclusive = self;
 
-		/*
-		 * (Re-)add ourselves if needed via non-NULL
-		 * g_lock_store argument
-		 */
+		status = g_lock_store(rec, &lck, NULL);
+		if (!NT_STATUS_IS_OK(status)) {
+			DBG_DEBUG("g_lock_store() failed: %s\n",
+				  nt_errstr(status));
+			return status;
+		}
 
-		store_status = g_lock_store(
-			rec,
-			&lck,
-			mylock.pid.pid != 0 ? &mylock : NULL);
+		if (lck.num_shared != 0) {
+			talloc_set_destructor(
+				req_state, g_lock_lock_state_destructor);
 
-		if (!NT_STATUS_IS_OK(store_status)) {
-			DBG_WARNING("g_lock_record_store failed: %s\n",
-				    nt_errstr(store_status));
-			status = store_status;
+			g_lock_get_shared(&lck, 0, blocker);
+
+			DBG_DEBUG("Waiting for %zu shared locks, "
+				  "picking blocker %s\n",
+				  lck.num_shared,
+				  server_id_str_buf(*blocker, &tmp));
+
+			return NT_STATUS_LOCK_NOT_GRANTED;
 		}
+
+		talloc_set_destructor(req_state, NULL);
+
+		return NT_STATUS_OK;
 	}
-	return status;
-}
 
-struct g_lock_lock_state {
-	struct tevent_context *ev;
-	struct g_lock_ctx *ctx;
-	TDB_DATA key;
-	enum g_lock_type type;
-};
+do_shared:
 
-static void g_lock_lock_retry(struct tevent_req *subreq);
+	if (lck.num_shared == 0) {
+		status = g_lock_store(rec, &lck, &self);
+		if (!NT_STATUS_IS_OK(status)) {
+			DBG_DEBUG("g_lock_store() failed: %s\n",
+				  nt_errstr(status));
+		}
 
-struct g_lock_lock_fn_state {
-	struct g_lock_lock_state *state;
-	struct server_id self;
+		return status;
+	}
 
-	struct tevent_req *watch_req;
-	NTSTATUS status;
-};
+	g_lock_cleanup_shared(&lck);
 
-static void g_lock_lock_fn(struct db_record *rec, void *private_data)
+	status = g_lock_store(rec, &lck, &self);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("g_lock_store() failed: %s\n",
+			  nt_errstr(status));
+		return status;
+	}
+
+	return NT_STATUS_OK;
+}
+
+static void g_lock_lock_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
 	struct g_lock_lock_fn_state *state = private_data;
 	struct server_id blocker = {0};
 
-	state->status = g_lock_trylock(rec, state->self, state->state->type,
-				       &blocker);
+	state->status = g_lock_trylock(rec, state, value, &blocker);
 	if (!NT_STATUS_EQUAL(state->status, NT_STATUS_LOCK_NOT_GRANTED)) {
 		return;
 	}
 
 	state->watch_req = dbwrap_watched_watch_send(
-		state->state, state->state->ev, rec, blocker);
+		state->req_state, state->req_state->ev, rec, blocker);
+	if (state->watch_req == NULL) {
+		state->status = NT_STATUS_NO_MEMORY;
+	}
+}
+
+static int g_lock_lock_state_destructor(struct g_lock_lock_state *s)
+{
+	NTSTATUS status = g_lock_unlock(s->ctx, s->key);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("g_lock_unlock failed: %s\n", nt_errstr(status));
+	}
+	return 0;
 }
 
+static void g_lock_lock_retry(struct tevent_req *subreq);
+
 struct tevent_req *g_lock_lock_send(TALLOC_CTX *mem_ctx,
 				    struct tevent_context *ev,
 				    struct g_lock_ctx *ctx,
@@ -373,6 +545,7 @@ struct tevent_req *g_lock_lock_send(TALLOC_CTX *mem_ctx,
 	struct g_lock_lock_state *state;
 	struct g_lock_lock_fn_state fn_state;
 	NTSTATUS status;
+	bool ok;
 
 	req = tevent_req_create(mem_ctx, &state, struct g_lock_lock_state);
 	if (req == NULL) {
@@ -384,7 +557,7 @@ struct tevent_req *g_lock_lock_send(TALLOC_CTX *mem_ctx,
 	state->type = type;
 
 	fn_state = (struct g_lock_lock_fn_state) {
-		.state = state, .self = messaging_server_id(ctx->msg)
+		.req_state = state,
 	};
 
 	status = dbwrap_do_locked(ctx->db, key, g_lock_lock_fn, &fn_state);
@@ -407,12 +580,16 @@ struct tevent_req *g_lock_lock_send(TALLOC_CTX *mem_ctx,
 		return tevent_req_post(req, ev);
 	}
 
-	if (!tevent_req_set_endtime(
-		    fn_state.watch_req, state->ev,
-		    timeval_current_ofs(5 + generate_random() % 5, 0))) {
+	ok = tevent_req_set_endtime(
+		fn_state.watch_req,
+		state->ev,
+		timeval_current_ofs(5 + generate_random() % 5, 0));
+	if (!ok) {
+		tevent_req_oom(req);
 		return tevent_req_post(req, ev);
 	}
 	tevent_req_set_callback(fn_state.watch_req, g_lock_lock_retry, req);
+
 	return req;
 }
 
@@ -423,9 +600,11 @@ static void g_lock_lock_retry(struct tevent_req *subreq)
 	struct g_lock_lock_state *state = tevent_req_data(
 		req, struct g_lock_lock_state);
 	struct g_lock_lock_fn_state fn_state;
+	struct server_id blocker;
+	bool blockerdead;
 	NTSTATUS status;
 
-	status = dbwrap_watched_watch_recv(subreq, NULL, NULL);
+	status = dbwrap_watched_watch_recv(subreq, &blockerdead, &blocker);
 	DBG_DEBUG("watch_recv returned %s\n", nt_errstr(status));
 	TALLOC_FREE(subreq);
 
@@ -435,8 +614,11 @@ static void g_lock_lock_retry(struct tevent_req *subreq)
 		return;
 	}
 
+	state->retry = true;
+
 	fn_state = (struct g_lock_lock_fn_state) {
-		.state = state, .self = messaging_server_id(state->ctx->msg)
+		.req_state = state,
+		.dead_blocker = blockerdead ? &blocker : NULL,
 	};
 
 	status = dbwrap_do_locked(state->ctx->db, state->key,
@@ -473,14 +655,98 @@ NTSTATUS g_lock_lock_recv(struct tevent_req *req)
 	return tevent_req_simple_recv_ntstatus(req);
 }
 
+struct g_lock_lock_simple_state {
+	struct server_id me;
+	enum g_lock_type type;
+	NTSTATUS status;
+};
+
+static void g_lock_lock_simple_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
+{
+	struct g_lock_lock_simple_state *state = private_data;
+	struct g_lock lck = { .exclusive.pid = 0 };
+	bool ok;
+
+	ok = g_lock_parse(value.dptr, value.dsize, &lck);
+	if (!ok) {
+		DBG_DEBUG("g_lock_parse failed\n");
+		state->status = NT_STATUS_INTERNAL_DB_CORRUPTION;
+		return;
+	}
+
+	if (lck.exclusive.pid != 0) {
+		goto not_granted;
+	}
+
+	if (state->type == G_LOCK_WRITE) {
+		if (lck.num_shared != 0) {
+			goto not_granted;
+		}
+		lck.exclusive = state->me;
+		state->status = g_lock_store(rec, &lck, NULL);
+		return;
+	}
+
+	if (state->type == G_LOCK_READ) {
+		g_lock_cleanup_shared(&lck);
+		state->status = g_lock_store(rec, &lck, &state->me);
+		return;
+	}
+
+not_granted:
+	state->status = NT_STATUS_LOCK_NOT_GRANTED;
+}
+
 NTSTATUS g_lock_lock(struct g_lock_ctx *ctx, TDB_DATA key,
 		     enum g_lock_type type, struct timeval timeout)
 {
-	TALLOC_CTX *frame = talloc_stackframe();
+	TALLOC_CTX *frame;
 	struct tevent_context *ev;
 	struct tevent_req *req;
 	struct timeval end;
-	NTSTATUS status = NT_STATUS_NO_MEMORY;
+	NTSTATUS status;
+
+	if ((type == G_LOCK_READ) || (type == G_LOCK_WRITE)) {
+		/*
+		 * This is an abstraction violation: Normally we do
+		 * the sync wrappers around async functions with full
+		 * nested event contexts. However, this is used in
+		 * very hot code paths, so avoid the event context
+		 * creation for the good path where there's no lock
+		 * contention. My benchmark gave a factor of 2
+		 * improvement for lock/unlock.
+		 */
+		struct g_lock_lock_simple_state state = {
+			.me = messaging_server_id(ctx->msg),
+			.type = type,
+		};
+		status = dbwrap_do_locked(
+			ctx->db, key, g_lock_lock_simple_fn, &state);
+		if (!NT_STATUS_IS_OK(status)) {
+			DBG_DEBUG("dbwrap_do_locked() failed: %s\n",
+				  nt_errstr(status));
+			return status;
+		}
+		if (NT_STATUS_IS_OK(state.status)) {
+			return NT_STATUS_OK;
+		}
+		if (!NT_STATUS_EQUAL(
+			    state.status, NT_STATUS_LOCK_NOT_GRANTED)) {
+			return state.status;
+		}
+
+		/*
+		 * Fall back to the full g_lock_trylock logic,
+		 * g_lock_lock_simple_fn() called above only covers
+		 * the uncontended path.
+		 */
+	}
+
+	frame = talloc_stackframe();
+	status = NT_STATUS_NO_MEMORY;
 
 	ev = samba_tevent_context_init(frame);
 	if (ev == NULL) {
@@ -504,57 +770,72 @@ NTSTATUS g_lock_lock(struct g_lock_ctx *ctx, TDB_DATA key,
 }
 
 struct g_lock_unlock_state {
-	TDB_DATA key;
 	struct server_id self;
 	NTSTATUS status;
 };
 
-static void g_lock_unlock_fn(struct db_record *rec,
-			     void *private_data)
+static void g_lock_unlock_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
 	struct g_lock_unlock_state *state = private_data;
-	TDB_DATA value;
+	struct server_id_buf tmp;
 	struct g_lock lck;
 	size_t i;
-	bool ok;
-
-	value = dbwrap_record_get_value(rec);
+	bool ok, exclusive;
 
 	ok = g_lock_parse(value.dptr, value.dsize, &lck);
 	if (!ok) {
-		DBG_DEBUG("g_lock_parse for %s failed\n",
-			  hex_encode_talloc(talloc_tos(),
-					    state->key.dptr,
-					    state->key.dsize));
-		state->status = NT_STATUS_FILE_INVALID;
+		DBG_DEBUG("g_lock_parse() failed\n");
+		state->status = NT_STATUS_INTERNAL_DB_CORRUPTION;
 		return;
 	}
-	for (i=0; i<lck.num_recs; i++) {
-		struct g_lock_rec lockrec;
-		g_lock_get_rec(&lck, i, &lockrec);
-		if (server_id_equal(&state->self, &lockrec.pid)) {
+
+	exclusive = server_id_equal(&state->self, &lck.exclusive);
+
+	for (i=0; i<lck.num_shared; i++) {
+		struct server_id shared;
+		g_lock_get_shared(&lck, i, &shared);
+		if (server_id_equal(&state->self, &shared)) {
 			break;
 		}
 	}
-	if (i == lck.num_recs) {
-		DBG_DEBUG("Lock not found, num_rec=%zu\n", lck.num_recs);
-		state->status = NT_STATUS_NOT_FOUND;
-		return;
-	}
 
-	g_lock_rec_del(&lck, i);
+	if (i < lck.num_shared) {
+		if (exclusive) {
+			DBG_DEBUG("%s both exclusive and shared (%zu)\n",
+				  server_id_str_buf(state->self, &tmp),
+				  i);
+			state->status = NT_STATUS_INTERNAL_DB_CORRUPTION;
+			return;
+		}
+		g_lock_del_shared(&lck, i);
+	} else {
+		if (!exclusive) {
+			DBG_DEBUG("Lock %s not found, num_rec=%zu\n",
+				  server_id_str_buf(state->self, &tmp),
+				  lck.num_shared);
+			state->status = NT_STATUS_NOT_FOUND;
+			return;
+		}
+		lck.exclusive = (struct server_id) { .pid = 0 };
+	}
 
-	if ((lck.num_recs == 0) && (lck.datalen == 0)) {
+	if ((lck.exclusive.pid == 0) &&
+	    (lck.num_shared == 0) &&
+	    (lck.datalen == 0)) {
 		state->status = dbwrap_record_delete(rec);
 		return;
 	}
+
 	state->status = g_lock_store(rec, &lck, NULL);
 }
 
 NTSTATUS g_lock_unlock(struct g_lock_ctx *ctx, TDB_DATA key)
 {
 	struct g_lock_unlock_state state = {
-		.self = messaging_server_id(ctx->msg), .key = key
+		.self = messaging_server_id(ctx->msg),
 	};
 	NTSTATUS status;
 
@@ -581,17 +862,16 @@ struct g_lock_write_data_state {
 	NTSTATUS status;
 };
 
-static void g_lock_write_data_fn(struct db_record *rec,
-				 void *private_data)
+static void g_lock_write_data_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
 	struct g_lock_write_data_state *state = private_data;
-	TDB_DATA value;
 	struct g_lock lck;
-	size_t i;
+	bool exclusive;
 	bool ok;
 
-	value = dbwrap_record_get_value(rec);
-
 	ok = g_lock_parse(value.dptr, value.dsize, &lck);
 	if (!ok) {
 		DBG_DEBUG("g_lock_parse for %s failed\n",
@@ -601,15 +881,16 @@ static void g_lock_write_data_fn(struct db_record *rec,
 		state->status = NT_STATUS_INTERNAL_DB_CORRUPTION;
 		return;
 	}
-	for (i=0; i<lck.num_recs; i++) {
-		struct g_lock_rec lockrec;
-		g_lock_get_rec(&lck, i, &lockrec);
-		if ((lockrec.lock_type == G_LOCK_WRITE) &&
-		    server_id_equal(&state->self, &lockrec.pid)) {
-			break;
-		}
-	}
-	if (i == lck.num_recs) {
+
+	exclusive = server_id_equal(&state->self, &lck.exclusive);
+
+	/*
+	 * Make sure we're really exclusive. We are marked as
+	 * exclusive when we are waiting for an exclusive lock
+	 */
+	exclusive &= (lck.num_shared == 0);
+
+	if (!exclusive) {
 		DBG_DEBUG("Not locked by us\n");
 		state->status = NT_STATUS_NOT_LOCKED;
 		return;
@@ -680,8 +961,9 @@ int g_lock_locks(struct g_lock_ctx *ctx,
 struct g_lock_dump_state {
 	TALLOC_CTX *mem_ctx;
 	TDB_DATA key;
-	void (*fn)(const struct g_lock_rec *locks,
-		   size_t num_locks,
+	void (*fn)(struct server_id exclusive,
+		   size_t num_shared,
+		   struct server_id *shared,
 		   const uint8_t *data,
 		   size_t datalen,
 		   void *private_data);
@@ -693,8 +975,8 @@ static void g_lock_dump_fn(TDB_DATA key, TDB_DATA data,
 			   void *private_data)
 {
 	struct g_lock_dump_state *state = private_data;
-	struct g_lock_rec *recs;
-	struct g_lock lck;
+	struct g_lock lck = (struct g_lock) { .exclusive.pid = 0 };
+	struct server_id *shared = NULL;
 	size_t i;
 	bool ok;
 
@@ -708,28 +990,34 @@ static void g_lock_dump_fn(TDB_DATA key, TDB_DATA data,
 		return;
 	}
 
-	recs = talloc_array(state->mem_ctx, struct g_lock_rec, lck.num_recs);
-	if (recs == NULL) {
+	shared = talloc_array(
+		state->mem_ctx, struct server_id, lck.num_shared);
+	if (shared == NULL) {
 		DBG_DEBUG("talloc failed\n");
 		state->status = NT_STATUS_NO_MEMORY;
 		return;
 	}
 
-	for (i=0; i<lck.num_recs; i++) {
-		g_lock_get_rec(&lck, i, &recs[i]);
+	for (i=0; i<lck.num_shared; i++) {
+		g_lock_get_shared(&lck, i, &shared[i]);
 	}
 
-	state->fn(recs, lck.num_recs, lck.data, lck.datalen,
+	state->fn(lck.exclusive,
+		  lck.num_shared,
+		  shared,
+		  lck.data,
+		  lck.datalen,
 		  state->private_data);
 
-	TALLOC_FREE(recs);
+	TALLOC_FREE(shared);
 
 	state->status = NT_STATUS_OK;
 }
 
 NTSTATUS g_lock_dump(struct g_lock_ctx *ctx, TDB_DATA key,
-		     void (*fn)(const struct g_lock_rec *locks,
-				size_t num_locks,
+		     void (*fn)(struct server_id exclusive,
+				size_t num_shared,
+				struct server_id *shared,
 				const uint8_t *data,
 				size_t datalen,
 				void *private_data),
diff --git a/source3/lib/messages.c b/source3/lib/messages.c
index a6bf99578b6..63d6362e0c9 100644
--- a/source3/lib/messages.c
+++ b/source3/lib/messages.c
@@ -97,10 +97,9 @@ struct messaging_context {
 	struct tevent_req **waiters;
 	size_t num_waiters;
 
-	void *msg_dgm_ref;
-	void *msg_ctdb_ref;
-
 	struct server_id_db *names_db;
+
+	TALLOC_CTX *per_process_talloc_ctx;
 };
 
 static struct messaging_rec *messaging_rec_dup(TALLOC_CTX *mem_ctx,
@@ -484,6 +483,7 @@ static NTSTATUS messaging_init_internal(TALLOC_CTX *mem_ctx,
 	int ret;
 	const char *lck_path;
 	const char *priv_path;
+	void *ref;
 	bool ok;
 
 	/*
@@ -537,21 +537,28 @@ static NTSTATUS messaging_init_internal(TALLOC_CTX *mem_ctx,
 
 	ctx->event_ctx = ev;
 
+	ctx->per_process_talloc_ctx = talloc_new(ctx);
+	if (ctx->per_process_talloc_ctx == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto done;
+	}
+
 	ok = messaging_register_event_context(ctx, ev);
 	if (!ok) {
 		status = NT_STATUS_NO_MEMORY;
 		goto done;
 	}
 
-	ctx->msg_dgm_ref = messaging_dgm_ref(ctx,
-					     ctx->event_ctx,
-					     &ctx->id.unique_id,
-					     priv_path,
-					     lck_path,
-					     messaging_recv_cb,
-					     ctx,
-					     &ret);
-	if (ctx->msg_dgm_ref == NULL) {
+	ref = messaging_dgm_ref(
+		ctx->per_process_talloc_ctx,
+		ctx->event_ctx,
+		&ctx->id.unique_id,
+		priv_path,
+		lck_path,
+		messaging_recv_cb,
+		ctx,
+		&ret);
+	if (ref == NULL) {
 		DEBUG(2, ("messaging_dgm_ref failed: %s\n", strerror(ret)));
 		status = map_nt_error_from_unix(ret);
 		goto done;
@@ -560,11 +567,16 @@ static NTSTATUS messaging_init_internal(TALLOC_CTX *mem_ctx,
 
 #ifdef CLUSTER_SUPPORT
 	if (lp_clustering()) {
-		ctx->msg_ctdb_ref = messaging_ctdb_ref(
-			ctx, ctx->event_ctx,
-			lp_ctdbd_socket(), lp_ctdb_timeout(),
-			ctx->id.unique_id, messaging_recv_cb, ctx, &ret);
-		if (ctx->msg_ctdb_ref == NULL) {
+		ref = messaging_ctdb_ref(
+			ctx->per_process_talloc_ctx,
+			ctx->event_ctx,
+			lp_ctdbd_socket(),
+			lp_ctdb_timeout(),
+			ctx->id.unique_id,
+			messaging_recv_cb,
+			ctx,
+			&ret);
+		if (ref == NULL) {
 			DBG_NOTICE("messaging_ctdb_ref failed: %s\n",
 				   strerror(ret));
 			status = map_nt_error_from_unix(ret);
@@ -590,7 +602,7 @@ static NTSTATUS messaging_init_internal(TALLOC_CTX *mem_ctx,
 
 	/* Register some debugging related messages */
 
-	register_msg_pool_usage(ctx);
+	register_msg_pool_usage(ctx->per_process_talloc_ctx, ctx);
 	register_dmalloc_msgs(ctx);
 	debug_register_msgs(ctx);
 
@@ -636,9 +648,14 @@ NTSTATUS messaging_reinit(struct messaging_context *msg_ctx)
 {
 	int ret;
 	char *lck_path;
+	void *ref;
+
+	TALLOC_FREE(msg_ctx->per_process_talloc_ctx);
 
-	TALLOC_FREE(msg_ctx->msg_dgm_ref);
-	TALLOC_FREE(msg_ctx->msg_ctdb_ref);
+	msg_ctx->per_process_talloc_ctx = talloc_new(msg_ctx);
+	if (msg_ctx->per_process_talloc_ctx == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
 
 	msg_ctx->id = (struct server_id) {
 		.pid = getpid(), .vnn = msg_ctx->id.vnn
@@ -649,23 +666,32 @@ NTSTATUS messaging_reinit(struct messaging_context *msg_ctx)
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	msg_ctx->msg_dgm_ref = messaging_dgm_ref(
-		msg_ctx, msg_ctx->event_ctx, &msg_ctx->id.unique_id,
-		private_path("msg.sock"), lck_path,
-		messaging_recv_cb, msg_ctx, &ret);
+	ref = messaging_dgm_ref(
+		msg_ctx->per_process_talloc_ctx,
+		msg_ctx->event_ctx,
+		&msg_ctx->id.unique_id,
+		private_path("msg.sock"),
+		lck_path,
+		messaging_recv_cb,
+		msg_ctx,
+		&ret);
 
-	if (msg_ctx->msg_dgm_ref == NULL) {
+	if (ref == NULL) {
 		DEBUG(2, ("messaging_dgm_ref failed: %s\n", strerror(ret)));
 		return map_nt_error_from_unix(ret);
 	}
 
 	if (lp_clustering()) {
-		msg_ctx->msg_ctdb_ref = messaging_ctdb_ref(
-			msg_ctx, msg_ctx->event_ctx,
-			lp_ctdbd_socket(), lp_ctdb_timeout(),
-			msg_ctx->id.unique_id, messaging_recv_cb, msg_ctx,
+		ref = messaging_ctdb_ref(
+			msg_ctx->per_process_talloc_ctx,
+			msg_ctx->event_ctx,
+			lp_ctdbd_socket(),
+			lp_ctdb_timeout(),
+			msg_ctx->id.unique_id,
+			messaging_recv_cb,
+			msg_ctx,
 			&ret);
-		if (msg_ctx->msg_ctdb_ref == NULL) {
+		if (ref == NULL) {
 			DBG_NOTICE("messaging_ctdb_ref failed: %s\n",
 				   strerror(ret));
 			return map_nt_error_from_unix(ret);
@@ -673,6 +699,7 @@ NTSTATUS messaging_reinit(struct messaging_context *msg_ctx)
 	}
 
 	server_id_db_reinit(msg_ctx->names_db, msg_ctx->id);
+	register_msg_pool_usage(msg_ctx->per_process_talloc_ctx, msg_ctx);
 
 	return NT_STATUS_OK;
 }
diff --git a/source3/lib/messages_dgm.c b/source3/lib/messages_dgm.c
index 11cb6969e73..661e032b908 100644
--- a/source3/lib/messages_dgm.c
+++ b/source3/lib/messages_dgm.c
@@ -322,7 +322,6 @@ static int messaging_dgm_out_get(struct messaging_dgm_context *ctx, pid_t pid,
 		}
 	}
 
-	messaging_dgm_out_rearm_idle_timer(out);
 	/*
 	 * shouldn't be possible, should be set if messaging_dgm_out_create
 	 * succeeded. This check is to satisfy static checker
@@ -330,6 +329,7 @@ static int messaging_dgm_out_get(struct messaging_dgm_context *ctx, pid_t pid,
 	if (out == NULL) {
 		return EINVAL;
 	}
+	messaging_dgm_out_rearm_idle_timer(out);
 
 	*pout = out;
 	return 0;
diff --git a/source3/lib/netapi/serverinfo.c b/source3/lib/netapi/serverinfo.c
index 7d9cc481c8c..cb5d9a29f17 100644
--- a/source3/lib/netapi/serverinfo.c
+++ b/source3/lib/netapi/serverinfo.c
@@ -34,6 +34,8 @@
 static WERROR NetServerGetInfo_l_101(struct libnetapi_ctx *ctx,
 				     uint8_t **buffer)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct SERVER_INFO_101 i;
 
 	i.sv101_platform_id	= PLATFORM_ID_NT;
@@ -41,7 +43,7 @@ static WERROR NetServerGetInfo_l_101(struct libnetapi_ctx *ctx,
 	i.sv101_version_major	= SAMBA_MAJOR_NBT_ANNOUNCE_VERSION;
 	i.sv101_version_minor	= SAMBA_MINOR_NBT_ANNOUNCE_VERSION;
 	i.sv101_type		= lp_default_server_announce();
-	i.sv101_comment		= lp_server_string(ctx);
+	i.sv101_comment		= lp_server_string(ctx, lp_sub);
 
 	*buffer = (uint8_t *)talloc_memdup(ctx, &i, sizeof(i));
 	if (!*buffer) {
@@ -57,9 +59,11 @@ static WERROR NetServerGetInfo_l_101(struct libnetapi_ctx *ctx,
 static WERROR NetServerGetInfo_l_1005(struct libnetapi_ctx *ctx,
 				      uint8_t **buffer)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct SERVER_INFO_1005 info1005;
 
-	info1005.sv1005_comment = lp_server_string(ctx);
+	info1005.sv1005_comment = lp_server_string(ctx, lp_sub);
 	*buffer = (uint8_t *)talloc_memdup(ctx, &info1005, sizeof(info1005));
 	if (!*buffer) {
 		return WERR_NOT_ENOUGH_MEMORY;
diff --git a/source3/lib/popt_common.c b/source3/lib/popt_common.c
index fa21668000e..d5b60c69ef7 100644
--- a/source3/lib/popt_common.c
+++ b/source3/lib/popt_common.c
@@ -101,7 +101,9 @@ static void popt_common_callback(poptContext con,
 		}
 
 		if (override_logfile) {
-			char *logfile = lp_logfile(mem_ctx);
+			const struct loadparm_substitution *lp_sub =
+				loadparm_s3_global_substitution();
+			char *logfile = lp_logfile(mem_ctx, lp_sub);
 			if (logfile == NULL) {
 				talloc_free(mem_ctx);
 				exit(1);
diff --git a/source3/lib/server_id_watch.c b/source3/lib/server_id_watch.c
index d38241fbf10..f0189e0e896 100644
--- a/source3/lib/server_id_watch.c
+++ b/source3/lib/server_id_watch.c
@@ -22,7 +22,6 @@
 #include <talloc.h>
 #include "serverid.h"
 #include "server_id_watch.h"
-#include "messages.h"
 #include "lib/util/tevent_unix.h"
 
 struct server_id_watch_state {
@@ -34,7 +33,6 @@ static void server_id_watch_waited(struct tevent_req *subreq);
 
 struct tevent_req *server_id_watch_send(TALLOC_CTX *mem_ctx,
 					struct tevent_context *ev,
-					struct messaging_context *msg,
 					struct server_id pid)
 {
 	struct tevent_req *req, *subreq;
@@ -52,7 +50,8 @@ struct tevent_req *server_id_watch_send(TALLOC_CTX *mem_ctx,
 		return tevent_req_post(req, ev);
 	}
 
-	subreq = tevent_wakeup_send(state, ev, timeval_current_ofs(0, 500000));
+	subreq = tevent_wakeup_send(
+		state, ev, tevent_timeval_current_ofs(0, 500000));
 	if (tevent_req_nomem(subreq, req)) {
 		return tevent_req_post(req, ev);
 	}
@@ -81,8 +80,8 @@ static void server_id_watch_waited(struct tevent_req *subreq)
 		return;
 	}
 
-	subreq = tevent_wakeup_send(state, state->ev,
-				    timeval_current_ofs(0, 500000));
+	subreq = tevent_wakeup_send(
+		state, state->ev, tevent_timeval_current_ofs(0, 500000));
 	if (tevent_req_nomem(subreq, req)) {
 		return;
 	}
diff --git a/source3/lib/server_id_watch.h b/source3/lib/server_id_watch.h
index 917dfeb519d..7e88cb4df27 100644
--- a/source3/lib/server_id_watch.h
+++ b/source3/lib/server_id_watch.h
@@ -25,11 +25,8 @@
 #include <talloc.h>
 #include "librpc/gen_ndr/server_id.h"
 
-struct messaging_context;
-
 struct tevent_req *server_id_watch_send(TALLOC_CTX *mem_ctx,
 					struct tevent_context *ev,
-					struct messaging_context *msg,
 					struct server_id pid);
 int server_id_watch_recv(struct tevent_req *req, struct server_id *pid);
 
diff --git a/source3/lib/sharesec.c b/source3/lib/sharesec.c
index 58a2dee3bcf..acbdd8b5df9 100644
--- a/source3/lib/sharesec.c
+++ b/source3/lib/sharesec.c
@@ -24,6 +24,7 @@
 #include "dbwrap/dbwrap.h"
 #include "dbwrap/dbwrap_open.h"
 #include "util_tdb.h"
+#include "libcli/util/ntstatus.h"
 
 /*******************************************************************
  Create the share security tdb.
@@ -136,7 +137,7 @@ static int upgrade_v2_to_v3(struct db_record *rec, void *priv)
 	return 0;
 }
 
-bool share_info_db_init(void)
+NTSTATUS share_info_db_init(void)
 {
 	const char *vstring = "INFO/version";
 	int32_t vers_id = 0;
@@ -145,12 +146,12 @@ bool share_info_db_init(void)
 	char *db_path;
 
 	if (share_db != NULL) {
-		return True;
+		return NT_STATUS_OK;
 	}
 
 	db_path = state_path(talloc_tos(), "share_info.tdb");
 	if (db_path == NULL) {
-		return false;
+		return NT_STATUS_NO_MEMORY;
 	}
 
 	share_db = db_open(NULL, db_path, 0,
@@ -160,7 +161,7 @@ bool share_info_db_init(void)
 		DEBUG(0,("Failed to open share info database %s (%s)\n",
 			 db_path, strerror(errno)));
 		TALLOC_FREE(db_path);
-		return False;
+		return map_nt_error_from_unix_common(errno);
 	}
 	TALLOC_FREE(db_path);
 
@@ -170,13 +171,13 @@ bool share_info_db_init(void)
 	}
 
 	if (vers_id == SHARE_DATABASE_VERSION_V3) {
-		return true;
+		return NT_STATUS_OK;
 	}
 
 	if (dbwrap_transaction_start(share_db) != 0) {
 		DEBUG(0, ("transaction_start failed\n"));
 		TALLOC_FREE(share_db);
-		return false;
+		return NT_STATUS_INTERNAL_DB_ERROR;
 	}
 
 	status = dbwrap_fetch_int32_bystring(share_db, vstring, &vers_id);
@@ -191,7 +192,7 @@ bool share_info_db_init(void)
 		if (dbwrap_transaction_cancel(share_db)) {
 			smb_panic("transaction_cancel failed");
 		}
-		return true;
+		return NT_STATUS_OK;
 	}
 
 	/* Move to at least V2. */
@@ -228,10 +229,16 @@ bool share_info_db_init(void)
 	/* Finally upgrade to version 3, with canonicalized sharenames. */
 
 	status = dbwrap_traverse(share_db, upgrade_v2_to_v3, &upgrade_ok, NULL);
-	if (!NT_STATUS_IS_OK(status) || upgrade_ok == false) {
+	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0, ("traverse failed\n"));
 		goto cancel;
 	}
+	if (!upgrade_ok) {
+		DBG_ERR("upgrade failed.\n");
+		status = NT_STATUS_INTERNAL_ERROR;
+		goto cancel;
+	}
+
 	status = dbwrap_store_int32_bystring(
 		share_db, vstring, SHARE_DATABASE_VERSION_V3);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -242,17 +249,17 @@ bool share_info_db_init(void)
 
 	if (dbwrap_transaction_commit(share_db) != 0) {
 		DEBUG(0, ("transaction_commit failed\n"));
-		return false;
+		return NT_STATUS_INTERNAL_ERROR;
 	}
 
-	return true;
+	return NT_STATUS_OK;
 
  cancel:
 	if (dbwrap_transaction_cancel(share_db)) {
 		smb_panic("transaction_cancel failed");
 	}
 
-	return false;
+	return status;
 }
 
 /*******************************************************************
@@ -304,7 +311,8 @@ struct security_descriptor *get_share_security( TALLOC_CTX *ctx, const char *ser
 		return NULL;
 	}
 
-	if (!share_info_db_init()) {
+	status = share_info_db_init();
+	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(c_servicename);
 		return NULL;
 	}
@@ -349,20 +357,22 @@ struct security_descriptor *get_share_security( TALLOC_CTX *ctx, const char *ser
  Store a security descriptor in the share db.
  ********************************************************************/
 
-bool set_share_security(const char *share_name, struct security_descriptor *psd)
+NTSTATUS set_share_security(const char *share_name,
+			    struct security_descriptor *psd)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
 	char *key;
-	bool ret = False;
 	TDB_DATA blob;
 	NTSTATUS status;
 	char *c_share_name = canonicalize_servicename(frame, share_name);
 
-	if (!c_share_name) {
+	if (c_share_name == NULL) {
+		status = NT_STATUS_INVALID_PARAMETER;
 		goto out;
 	}
 
-	if (!share_info_db_init()) {
+	status = share_info_db_init();
+	if (!NT_STATUS_IS_OK(status)) {
 		goto out;
 	}
 
@@ -376,6 +386,7 @@ bool set_share_security(const char *share_name, struct security_descriptor *psd)
 
 	if (!(key = talloc_asprintf(frame, SHARE_SECURITY_DB_KEY_PREFIX_STR "%s", c_share_name))) {
 		DEBUG(0, ("talloc_asprintf failed\n"));
+		status = NT_STATUS_NO_MEMORY;
 		goto out;
 	}
 
@@ -388,37 +399,38 @@ bool set_share_security(const char *share_name, struct security_descriptor *psd)
 	}
 
 	DEBUG(5,("set_share_security: stored secdesc for %s\n", share_name ));
-	ret = True;
+	status = NT_STATUS_OK;
 
  out:
 	TALLOC_FREE(frame);
-	return ret;
+	return status;
 }
 
 /*******************************************************************
  Delete a security descriptor.
 ********************************************************************/
 
-bool delete_share_security(const char *servicename)
+NTSTATUS delete_share_security(const char *servicename)
 {
 	TDB_DATA kbuf;
 	char *key;
 	NTSTATUS status;
 	char *c_servicename = canonicalize_servicename(talloc_tos(), servicename);
 
-	if (!c_servicename) {
-		return NULL;
+	if (c_servicename == NULL) {
+		return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	if (!share_info_db_init()) {
+	status = share_info_db_init();
+	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(c_servicename);
-		return False;
+		return status;
 	}
 
 	if (!(key = talloc_asprintf(talloc_tos(), SHARE_SECURITY_DB_KEY_PREFIX_STR "%s",
 				    c_servicename))) {
 		TALLOC_FREE(c_servicename);
-		return False;
+		return NT_STATUS_NO_MEMORY;
 	}
 	kbuf = string_term_tdb_data(key);
 
@@ -427,11 +439,11 @@ bool delete_share_security(const char *servicename)
 		DEBUG(0, ("delete_share_security: Failed to delete entry for "
 			  "share %s: %s\n", c_servicename, nt_errstr(status)));
 		TALLOC_FREE(c_servicename);
-		return False;
+		return status;
 	}
 
 	TALLOC_FREE(c_servicename);
-	return True;
+	return NT_STATUS_OK;
 }
 
 /*******************************************************************
diff --git a/source3/lib/smbldap.c b/source3/lib/smbldap.c
index 7a96714ad1a..34c841f9243 100644
--- a/source3/lib/smbldap.c
+++ b/source3/lib/smbldap.c
@@ -1689,7 +1689,7 @@ int smbldap_search_suffix (struct smbldap_state *ldap_state,
 			   const char *filter, const char **search_attr,
 			   LDAPMessage ** result)
 {
-	return smbldap_search(ldap_state, lp_ldap_suffix(talloc_tos()),
+	return smbldap_search(ldap_state, lp_ldap_suffix(),
 			      LDAP_SCOPE_SUBTREE,
 			      filter, search_attr, 0, result);
 }
diff --git a/source3/lib/smbrun.c b/source3/lib/smbrun.c
index 3b7ed542ab2..8e3675fdc22 100644
--- a/source3/lib/smbrun.c
+++ b/source3/lib/smbrun.c
@@ -181,14 +181,9 @@ static int smbrun_internal(const char *cmd, int *outfd, bool sanitize,
 		}
 	}
 
-#ifndef __INSURE__
 	/* close all other file descriptors, leaving only 0, 1 and 2. 0 and
 	   2 point to /dev/null from the startup code */
-	{
-	int fd;
-	for (fd=3;fd<256;fd++) close(fd);
-	}
-#endif
+	closefrom(3);
 
 	{
 		char *newcmd = NULL;
@@ -347,14 +342,9 @@ int smbrunsecret(const char *cmd, const char *secret)
 		}
 	}
 
-#ifndef __INSURE__
 	/* close all other file descriptors, leaving only 0, 1 and 2. 0 and
 	   2 point to /dev/null from the startup code */
-	{
-		int fd;
-		for (fd = 3; fd < 256; fd++) close(fd);
-	}
-#endif
+	closefrom(3);
 
 	execl("/bin/sh", "sh", "-c", cmd, NULL);  
 
diff --git a/source3/lib/substitute.c b/source3/lib/substitute.c
index f3f2e1bc0e1..b5e08e0aa55 100644
--- a/source3/lib/substitute.c
+++ b/source3/lib/substitute.c
@@ -880,32 +880,3 @@ char *talloc_sub_full(TALLOC_CTX *ctx,
 	TALLOC_FREE(a_string);
 	return ret_string;
 }
-
-/******************************************************************************
- version of standard_sub_basic() for string lists; uses talloc_sub_basic()
- for the work
- *****************************************************************************/
-
-bool str_list_sub_basic( char **list, const char *smb_name,
-			 const char *domain_name )
-{
-	TALLOC_CTX *ctx = list;
-	char *s, *tmpstr;
-
-	while ( *list ) {
-		s = *list;
-		tmpstr = talloc_sub_basic(ctx, smb_name, domain_name, s);
-		if ( !tmpstr ) {
-			DEBUG(0,("str_list_sub_basic: "
-				"talloc_sub_basic() return NULL!\n"));
-			return false;
-		}
-
-		TALLOC_FREE(*list);
-		*list = tmpstr;
-
-		list++;
-	}
-
-	return true;
-}
diff --git a/source3/lib/sysquotas.c b/source3/lib/sysquotas.c
index 66436e86efd..64e41f740a3 100644
--- a/source3/lib/sysquotas.c
+++ b/source3/lib/sysquotas.c
@@ -244,10 +244,12 @@ static struct {
 
 static int command_get_quota(const char *path, enum SMB_QUOTA_TYPE qtype, unid_t id, SMB_DISK_QUOTA *dp)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char *get_quota_command;
 	char **lines = NULL;
 
-	get_quota_command = lp_get_quota_command(talloc_tos());
+	get_quota_command = lp_get_quota_command(talloc_tos(), lp_sub);
 	if (get_quota_command && *get_quota_command) {
 		const char *p;
 		char *p2;
@@ -423,9 +425,11 @@ invalid_param:
 
 static int command_set_quota(const char *path, enum SMB_QUOTA_TYPE qtype, unid_t id, SMB_DISK_QUOTA *dp)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char *set_quota_command;
 
-	set_quota_command = lp_set_quota_command(talloc_tos());
+	set_quota_command = lp_set_quota_command(talloc_tos(), lp_sub);
 	if (set_quota_command && *set_quota_command) {
 		char **lines = NULL;
 		int _id = -1;
diff --git a/source3/lib/system.c b/source3/lib/system.c
index 679332255c0..f1265e0c43f 100644
--- a/source3/lib/system.c
+++ b/source3/lib/system.c
@@ -575,15 +575,15 @@ int sys_fallocate(int fd, uint32_t mode, off_t offset, off_t len)
  A flock() wrapper that will perform the kernel flock.
 ********************************************************************/
 
-void kernel_flock(int fd, uint32_t share_mode, uint32_t access_mask)
+void kernel_flock(int fd, uint32_t share_access, uint32_t access_mask)
 {
 #ifdef HAVE_KERNEL_SHARE_MODES
 	int kernel_mode = 0;
-	if (share_mode == FILE_SHARE_WRITE) {
+	if (share_access == FILE_SHARE_WRITE) {
 		kernel_mode = LOCK_MAND|LOCK_WRITE;
-	} else if (share_mode == FILE_SHARE_READ) {
+	} else if (share_access == FILE_SHARE_READ) {
 		kernel_mode = LOCK_MAND|LOCK_READ;
-	} else if (share_mode == FILE_SHARE_NONE) {
+	} else if (share_access == FILE_SHARE_NONE) {
 		kernel_mode = LOCK_MAND;
 	}
 	if (kernel_mode) {
diff --git a/source3/lib/tallocmsg.c b/source3/lib/tallocmsg.c
index 1e243e77781..bc0fa132e32 100644
--- a/source3/lib/tallocmsg.c
+++ b/source3/lib/tallocmsg.c
@@ -25,6 +25,9 @@
 
 static bool pool_usage_filter(struct messaging_rec *rec, void *private_data)
 {
+	FILE *f = NULL;
+	int fd;
+
 	if (rec->msg_type != MSG_REQ_POOL_USAGE) {
 		return false;
 	}
@@ -36,63 +39,43 @@ static bool pool_usage_filter(struct messaging_rec *rec, void *private_data)
 		return false;
 	}
 
-	return true;
-}
-
-
-static void msg_pool_usage_do(struct tevent_req *req)
-{
-	struct messaging_context *msg_ctx = tevent_req_callback_data(
-		req, struct messaging_context);
-	struct messaging_rec *rec = NULL;
-	FILE *f = NULL;
-	int ret;
-
-	ret = messaging_filtered_read_recv(req, talloc_tos(), &rec);
-	TALLOC_FREE(req);
-	if (ret != 0) {
-		DBG_DEBUG("messaging_filtered_read_recv returned %s\n",
-			  strerror(ret));
-		return;
+	fd = dup(rec->fds[0]);
+	if (fd == -1) {
+		DBG_DEBUG("dup(%"PRIi64") failed: %s\n",
+			  rec->fds[0],
+			  strerror(errno));
+		return false;
 	}
 
-	f = fdopen(rec->fds[0], "w");
+	f = fdopen(fd, "w");
 	if (f == NULL) {
-		close(rec->fds[0]);
-		TALLOC_FREE(rec);
 		DBG_DEBUG("fdopen failed: %s\n", strerror(errno));
-		return;
+		close(fd);
+		return false;
 	}
 
-	TALLOC_FREE(rec);
-
 	talloc_full_report_printf(NULL, f);
 
 	fclose(f);
-	f = NULL;
-
-	req = messaging_filtered_read_send(
-		msg_ctx,
-		messaging_tevent_context(msg_ctx),
-		msg_ctx,
-		pool_usage_filter,
-		NULL);
-	if (req == NULL) {
-		DBG_WARNING("messaging_filtered_read_send failed\n");
-		return;
-	}
-	tevent_req_set_callback(req, msg_pool_usage_do, msg_ctx);
+	/*
+	 * Returning false, means messaging_dispatch_waiters()
+	 * won't call messaging_filtered_read_done() and
+	 * our messaging_filtered_read_send() stays alive
+	 * and will get messages.
+	 */
+	return false;
 }
 
 /**
  * Register handler for MSG_REQ_POOL_USAGE
  **/
-void register_msg_pool_usage(struct messaging_context *msg_ctx)
+void register_msg_pool_usage(
+	TALLOC_CTX *mem_ctx, struct messaging_context *msg_ctx)
 {
 	struct tevent_req *req = NULL;
 
 	req = messaging_filtered_read_send(
-		msg_ctx,
+		mem_ctx,
 		messaging_tevent_context(msg_ctx),
 		msg_ctx,
 		pool_usage_filter,
@@ -101,6 +84,5 @@ void register_msg_pool_usage(struct messaging_context *msg_ctx)
 		DBG_WARNING("messaging_filtered_read_send failed\n");
 		return;
 	}
-	tevent_req_set_callback(req, msg_pool_usage_do, msg_ctx);
 	DEBUG(2, ("Registered MSG_REQ_POOL_USAGE\n"));
 }
diff --git a/source3/lib/time.c b/source3/lib/time.c
index 6b864253a91..c61c523952a 100644
--- a/source3/lib/time.c
+++ b/source3/lib/time.c
@@ -141,6 +141,10 @@ void srv_put_dos_date3(char *buf,int offset,time_t unixdate)
 
 void round_timespec(enum timestamp_set_resolution res, struct timespec *ts)
 {
+	if (is_omit_timespec(ts)) {
+		return;
+	}
+
 	switch (res) {
 		case TIMESTAMP_SET_SECONDS:
 			round_timespec_to_sec(ts);
@@ -167,6 +171,25 @@ void put_long_date_timespec(enum timestamp_set_resolution res, char *p, struct t
 	SBVAL(p, 0, nt);
 }
 
+void put_long_date_full_timespec(enum timestamp_set_resolution res,
+				 char *p,
+				 const struct timespec *_ts)
+{
+	struct timespec ts = *_ts;
+	NTTIME nt;
+
+	round_timespec(res, &ts);
+	nt = full_timespec_to_nt_time(&ts);
+	SBVAL(p, 0, nt);
+}
+
+struct timespec pull_long_date_full_timespec(const char *p)
+{
+	NTTIME nt = BVAL(p, 0);
+
+	return nt_time_to_full_timespec(nt);
+}
+
 void put_long_date(char *p, time_t t)
 {
 	struct timespec ts;
@@ -241,7 +264,7 @@ struct timespec interpret_long_date(const char *p)
 		ret.tv_nsec = 0;
 		return ret;
 	}
-	return nt_time_to_unix_timespec(nt);
+	return nt_time_to_full_timespec(nt);
 }
 
 /*******************************************************************
@@ -334,13 +357,6 @@ time_t nt_time_to_unix_abs(const NTTIME *nt)
 	return (time_t)d;
 }
 
-time_t uint64s_nt_time_to_unix_abs(const uint64_t *src)
-{
-	NTTIME nttime;
-	nttime = *src;
-	return nt_time_to_unix_abs(&nttime);
-}
-
 /****************************************************************************
  Convert a time_t to a NTTIME structure
 
diff --git a/source3/lib/util.c b/source3/lib/util.c
index 8bafcbb83d7..e9a7368b290 100644
--- a/source3/lib/util.c
+++ b/source3/lib/util.c
@@ -630,9 +630,11 @@ static char *strip_mount_options(TALLOC_CTX *ctx, const char *str)
 #ifdef WITH_NISPLUS_HOME
 char *automount_lookup(TALLOC_CTX *ctx, const char *user_name)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *value = NULL;
 
-	char *nis_map = (char *)lp_homedir_map();
+	char *nis_map = (char *)lp_homedir_map(talloc_tos(), lp_sub);
 
 	char buffer[NIS_MAXATTRVAL + 1];
 	nis_result *result;
@@ -678,13 +680,15 @@ char *automount_lookup(TALLOC_CTX *ctx, const char *user_name)
 
 char *automount_lookup(TALLOC_CTX *ctx, const char *user_name)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *value = NULL;
 
 	int nis_error;        /* returned by yp all functions */
 	char *nis_result;     /* yp_match inits this */
 	int nis_result_len;  /* and set this */
 	char *nis_domain;     /* yp_get_default_domain inits this */
-	char *nis_map = lp_homedir_map(talloc_tos());
+	char *nis_map = lp_homedir_map(talloc_tos(), lp_sub);
 
 	if ((nis_error = yp_get_default_domain(&nis_domain)) != 0) {
 		DEBUG(3, ("YP Error: %s\n", yperr_string(nis_error)));
@@ -817,6 +821,8 @@ gid_t nametogid(const char *name)
 
 void smb_panic_s3(const char *why)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *cmd;
 	int result;
 
@@ -831,7 +837,7 @@ void smb_panic_s3(const char *why)
 	prctl(PR_SET_PTRACER, getpid(), 0, 0, 0);
 #endif
 
-	cmd = lp_panic_action(talloc_tos());
+	cmd = lp_panic_action(talloc_tos(), lp_sub);
 	if (cmd && *cmd) {
 		DEBUG(0, ("smb_panic(): calling panic action [%s]\n", cmd));
 		result = system(cmd);
@@ -1510,25 +1516,6 @@ void *smb_xmalloc_array(size_t size, unsigned int count)
 	return p;
 }
 
-/*
-  vasprintf that aborts on malloc fail
-*/
-
- int smb_xvasprintf(char **ptr, const char *format, va_list ap)
-{
-	int n;
-	va_list ap2;
-
-	va_copy(ap2, ap);
-
-	n = vasprintf(ptr, format, ap2);
-	va_end(ap2);
-	if (n == -1 || ! *ptr) {
-		smb_panic("smb_xvasprintf: out of memory");
-	}
-	return n;
-}
-
 /*****************************************************************
  Get local hostname and cache result.
 *****************************************************************/
diff --git a/source3/lib/util_path.c b/source3/lib/util_path.c
index d9fed29c2a5..63d01b81000 100644
--- a/source3/lib/util_path.c
+++ b/source3/lib/util_path.c
@@ -26,6 +26,7 @@
 #include "lib/util/samba_util.h"
 #include "lib/util_path.h"
 
+struct loadparm_substitution;
 struct share_params;
 #include "source3/param/param_proto.h"
 
diff --git a/source3/lib/util_str.c b/source3/lib/util_str.c
index e660e295c33..5d1d1291011 100644
--- a/source3/lib/util_str.c
+++ b/source3/lib/util_str.c
@@ -570,80 +570,6 @@ int fstr_sprintf(fstring s, const char *fmt, ...)
 	return ret;
 }
 
-/**
- List of Strings manipulation functions
-**/
-
-#define S_LIST_ABS 16 /* List Allocation Block Size */
-
-/******************************************************************************
- substitute a specific pattern in a string list
- *****************************************************************************/
-
-bool str_list_substitute(char **list, const char *pattern, const char *insert)
-{
-	TALLOC_CTX *ctx = list;
-	char *p, *s, *t;
-	ssize_t ls, lp, li, ld, i, d;
-
-	if (!list)
-		return false;
-	if (!pattern)
-		return false;
-	if (!insert)
-		return false;
-
-	lp = (ssize_t)strlen(pattern);
-	li = (ssize_t)strlen(insert);
-	ld = li -lp;
-
-	while (*list) {
-		s = *list;
-		ls = (ssize_t)strlen(s);
-
-		while ((p = strstr_m(s, pattern))) {
-			t = *list;
-			d = p -t;
-			if (ld) {
-				t = talloc_array(ctx, char, ls +ld +1);
-				if (!t) {
-					DEBUG(0,("str_list_substitute: "
-						"Unable to allocate memory"));
-					return false;
-				}
-				memcpy(t, *list, d);
-				memcpy(t +d +li, p +lp, ls -d -lp +1);
-				TALLOC_FREE(*list);
-				*list = t;
-				ls += ld;
-				s = t +d +li;
-			}
-
-			for (i = 0; i < li; i++) {
-				switch (insert[i]) {
-					case '`':
-					case '"':
-					case '\'':
-					case ';':
-					case '$':
-					case '%':
-					case '\r':
-					case '\n':
-						t[d +i] = '_';
-						break;
-					default:
-						t[d +i] = insert[i];
-				}
-			}
-		}
-
-		list++;
-	}
-
-	return true;
-}
-
-
 #define IPSTR_LIST_SEP	","
 #define IPSTR_LIST_CHAR	','
 
diff --git a/source3/libnet/libnet_dssync_passdb.c b/source3/libnet/libnet_dssync_passdb.c
index 4b559f15e75..ac668bc3b47 100644
--- a/source3/libnet/libnet_dssync_passdb.c
+++ b/source3/libnet/libnet_dssync_passdb.c
@@ -663,6 +663,8 @@ static NTSTATUS smb_create_user(TALLOC_CTX *mem_ctx,
 				const char *account,
 				struct passwd **passwd_p)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct passwd *passwd;
 	char *add_script = NULL;
 
@@ -674,11 +676,11 @@ static NTSTATUS smb_create_user(TALLOC_CTX *mem_ctx,
 
 	/* Create appropriate user */
 	if (acct_flags & ACB_NORMAL) {
-		add_script = lp_add_user_script(mem_ctx);
+		add_script = lp_add_user_script(mem_ctx, lp_sub);
 	} else if ( (acct_flags & ACB_WSTRUST) ||
 		    (acct_flags & ACB_SVRTRUST) ||
 		    (acct_flags & ACB_DOMTRUST) ) {
-		add_script = lp_add_machine_script(mem_ctx);
+		add_script = lp_add_machine_script(mem_ctx, lp_sub);
 	} else {
 		DEBUG(1, ("Unknown user type: %s\n",
 			  pdb_encode_acct_ctrl(acct_flags, NEW_PW_FORMAT_SPACE_PADDED_LEN)));
diff --git a/source3/librpc/crypto/gse.c b/source3/librpc/crypto/gse.c
index 6329b194a27..6675f4dc597 100644
--- a/source3/librpc/crypto/gse.c
+++ b/source3/librpc/crypto/gse.c
@@ -214,6 +214,16 @@ static NTSTATUS gse_context_init(TALLOC_CTX *mem_ctx,
 		goto err_out;
 	}
 
+#ifdef SAMBA4_USES_HEIMDAL
+	k5ret = gsskrb5_set_dns_canonicalize(false);
+	if (k5ret) {
+		DBG_ERR("gsskrb5_set_dns_canonicalize() failed (%s)\n",
+			error_message(k5ret));
+		status = NT_STATUS_INTERNAL_ERROR;
+		goto err_out;
+	}
+#endif
+
 	if (!ccache_name) {
 		ccache_name = krb5_cc_default_name(gse_ctx->k5ctx);
 	}
diff --git a/source3/librpc/idl/open_files.idl b/source3/librpc/idl/open_files.idl
index d3e537a9d42..432c1e71bc0 100644
--- a/source3/librpc/idl/open_files.idl
+++ b/source3/librpc/idl/open_files.idl
@@ -58,14 +58,13 @@ interface open_files
 		[string,charset(UTF8)] char *servicepath;
 		[string,charset(UTF8)] char *base_name;
 		[string,charset(UTF8)] char *stream_name;
-		uint32 num_share_modes;
 		uint32 num_delete_tokens;
 		[size_is(num_delete_tokens)] delete_token delete_tokens[];
-		timespec old_write_time;
-		timespec changed_write_time;
+		NTTIME old_write_time;
+		NTTIME changed_write_time;
 		[skip] boolean8 fresh;
 		[skip] boolean8 modified;
-		[ignore] db_record *record;
+		[skip] boolean8 have_share_modes;
 		[ignore] file_id id; /* In memory key used to lookup cache. */
 	} share_mode_data;
 
@@ -106,7 +105,7 @@ interface open_files
 		boolean8 update_write_time_triggered;
 		boolean8 update_write_time_on_close;
 		boolean8 write_time_forced;
-		timespec close_write_time;
+		NTTIME close_write_time;
 		vfs_default_durable_stat stat_info;
 	} vfs_default_durable_cookie;
 
diff --git a/source3/librpc/idl/smbXsrv.idl b/source3/librpc/idl/smbXsrv.idl
index b8f3dc679ea..c6ce9c48789 100644
--- a/source3/librpc/idl/smbXsrv.idl
+++ b/source3/librpc/idl/smbXsrv.idl
@@ -290,8 +290,8 @@ interface smbXsrv
 		hyper					nonce_high_max;
 		hyper					nonce_high;
 		hyper					nonce_low;
-		[ignore] user_struct			*compat;
 		[ignore] smbXsrv_tcon_table		*tcon_table;
+		[ignore] uint32				homes_snum;
 		smbXsrv_session_auth0			*pending_auth;
 	} smbXsrv_session;
 
diff --git a/source3/librpc/wscript_build b/source3/librpc/wscript_build
index 34cd96bebda..c1fa54c0f53 100644
--- a/source3/librpc/wscript_build
+++ b/source3/librpc/wscript_build
@@ -24,7 +24,7 @@ bld.SAMBA3_SUBSYSTEM('NDR_SMBXSRV',
 
 bld.SAMBA3_SUBSYSTEM('NDR_LEASES_DB',
 	source='gen_ndr/ndr_leases_db.c',
-	public_deps='ndr'
+	public_deps='ndr NDR_SMB2_LEASE_STRUCT NDR_FILE_ID'
 	)
 
 bld.SAMBA3_SUBSYSTEM('NDR_SECRETS',
diff --git a/source3/libsmb/clirap.c b/source3/libsmb/clirap.c
index 9fcda53573c..71c7b97ad54 100644
--- a/source3/libsmb/clirap.c
+++ b/source3/libsmb/clirap.c
@@ -568,7 +568,11 @@ bool cli_oem_change_password(struct cli_state *cli, const char *user, const char
 	 */
 	E_deshash(new_password, new_pw_hash);
 
-	E_old_pw_hash( new_pw_hash, old_pw_hash, (uchar *)&data[516]);
+	rc = E_old_pw_hash( new_pw_hash, old_pw_hash, (uchar *)&data[516]);
+	if (rc != 0) {
+		DBG_ERR("E_old_pw_hash failed: %s\n", gnutls_strerror(rc));
+		return false;
+	}
 
 	data_len = 532;
 
@@ -791,6 +795,70 @@ NTSTATUS cli_setpathinfo_basic(struct cli_state *cli, const char *fname,
 			       (uint8_t *)data, data_len);
 }
 
+NTSTATUS cli_setpathinfo_ext(struct cli_state *cli, const char *fname,
+			     const struct timespec *create_time,
+			     const struct timespec *access_time,
+			     const struct timespec *write_time,
+			     const struct timespec *change_time,
+			     uint16_t mode)
+{
+	unsigned int data_len = 0;
+	char data[40];
+	char *p;
+
+	p = data;
+
+	/*
+	 * Add the create, last access, modification, and status change times
+	 */
+	put_long_date_full_timespec(TIMESTAMP_SET_NT_OR_BETTER, p, create_time);
+	p += 8;
+
+	put_long_date_full_timespec(TIMESTAMP_SET_NT_OR_BETTER, p, access_time);
+	p += 8;
+
+	put_long_date_full_timespec(TIMESTAMP_SET_NT_OR_BETTER, p, write_time);
+	p += 8;
+
+	put_long_date_full_timespec(TIMESTAMP_SET_NT_OR_BETTER, p, change_time);
+	p += 8;
+
+	if (mode == (uint16_t)-1 || mode == FILE_ATTRIBUTE_NORMAL) {
+		/* No change. */
+		mode = 0;
+	} else if (mode == 0) {
+		/* Clear all existing attributes. */
+		mode = FILE_ATTRIBUTE_NORMAL;
+	}
+
+	/* Add attributes */
+	SIVAL(p, 0, mode);
+
+	p += 4;
+
+	/* Add padding */
+	SIVAL(p, 0, 0);
+	p += 4;
+
+	data_len = PTR_DIFF(p, data);
+
+	if (smbXcli_conn_protocol(cli->conn) >= PROTOCOL_SMB2_02) {
+		DATA_BLOB in_data = data_blob_const(data, data_len);
+		/*
+		 * Split out SMB2 here as we need to select
+		 * the correct info type and level.
+		 */
+		return cli_smb2_setpathinfo(cli,
+				fname,
+				1, /* SMB2_SETINFO_FILE */
+				SMB_FILE_BASIC_INFORMATION - 1000,
+				&in_data);
+	}
+
+	return cli_setpathinfo(cli, SMB_FILE_BASIC_INFORMATION, fname,
+			       (uint8_t *)data, data_len);
+}
+
 /****************************************************************************
  Send a qpathinfo call with the SMB_QUERY_FILE_ALL_INFO info level.
 ****************************************************************************/
diff --git a/source3/libsmb/clirap.h b/source3/libsmb/clirap.h
index 9140fb68f6a..b259feffd70 100644
--- a/source3/libsmb/clirap.h
+++ b/source3/libsmb/clirap.h
@@ -64,6 +64,12 @@ NTSTATUS cli_setpathinfo_basic(struct cli_state *cli, const char *fname,
 			       time_t write_time,
 			       time_t change_time,
 			       uint16_t mode);
+NTSTATUS cli_setpathinfo_ext(struct cli_state *cli, const char *fname,
+			     const struct timespec *create_time,
+			     const struct timespec *access_time,
+			     const struct timespec *write_time,
+			     const struct timespec *change_time,
+			     uint16_t mode);
 struct tevent_req *cli_qpathinfo2_send(TALLOC_CTX *mem_ctx,
 				       struct tevent_context *ev,
 				       struct cli_state *cli,
diff --git a/source3/libsmb/errormap.c b/source3/libsmb/errormap.c
index ce3bb952207..ba8bc659bab 100644
--- a/source3/libsmb/errormap.c
+++ b/source3/libsmb/errormap.c
@@ -283,7 +283,7 @@ convert a dos eclas/ecode to a NT status32 code
  *****************************************************************************/
 NTSTATUS dos_to_ntstatus(uint8_t eclass, uint32_t ecode)
 {
-	int i;
+	size_t i;
 	if (eclass == 0) return NT_STATUS_OK;
 	for (i=0; i < ARRAY_SIZE(dos_to_ntstatus_map); i++) {
 		if (eclass == dos_to_ntstatus_map[i].dos_class &&
diff --git a/source3/libsmb/libsmb_dir.c b/source3/libsmb/libsmb_dir.c
index 8eecde0668e..00d2a878e84 100644
--- a/source3/libsmb/libsmb_dir.c
+++ b/source3/libsmb/libsmb_dir.c
@@ -475,7 +475,6 @@ SMBC_opendir_ctx(SMBCCTX *context,
 	char *workgroup = NULL;
 	char *path = NULL;
 	size_t path_len = 0;
-        uint16_t mode;
 	uint16_t port = 0;
 	SMBCSRV *srv  = NULL;
 	SMBCFILE *dir = NULL;
@@ -962,6 +961,7 @@ SMBC_opendir_ctx(SMBCCTX *context,
 				saved_errno = SMBC_errno(context, targetcli);
 
                                 if (saved_errno == EINVAL) {
+					struct stat sb = {0};
                                         /*
                                          * See if they asked to opendir
                                          * something other than a directory.
@@ -971,11 +971,11 @@ SMBC_opendir_ctx(SMBCCTX *context,
                                          */
                                         path[path_len] = '\0'; /* restore original path */
 
-                                        if (SMBC_getatr(context, srv, path,
-                                                        &mode, NULL,
-                                                        NULL, NULL, NULL, NULL,
-                                                        NULL) &&
-                                            ! IS_DOS_DIR(mode)) {
+                                        if (SMBC_getatr(context,
+							srv,
+							path,
+							&sb) &&
+                                            !S_ISDIR(sb.st_mode)) {
 
                                                 /* It is.  Correct the error value */
                                                 saved_errno = ENOTDIR;
@@ -1276,6 +1276,15 @@ const struct libsmb_file_info *SMBC_readdirplus2_ctx(SMBCCTX *context,
 	struct smbc_dirplus_list *dp_list = NULL;
 	ino_t ino;
 	char *full_pathname = NULL;
+	char *workgroup = NULL;
+	char *server = NULL;
+	uint16_t port = 0;
+	char *share = NULL;
+	char *path = NULL;
+	char *user = NULL;
+	char *password = NULL;
+	char *options = NULL;
+	int rc;
 	TALLOC_CTX *frame = NULL;
 
 	/*
@@ -1333,8 +1342,25 @@ const struct libsmb_file_info *SMBC_readdirplus2_ctx(SMBCCTX *context,
 		return NULL;
 	}
 
+	rc = SMBC_parse_path(frame,
+			     context,
+			     full_pathname,
+			     &workgroup,
+			     &server,
+			     &port,
+			     &share,
+			     &path,
+			     &user,
+			     &password,
+			     &options);
+	if (rc != 0) {
+		TALLOC_FREE(frame);
+		errno = ENOENT;
+		return NULL;
+	}
+
 	setup_stat(st,
-		full_pathname,
+		path,
 		smb_finfo->size,
 		smb_finfo->attrs,
 		ino,
@@ -2198,20 +2224,11 @@ SMBC_unlink_ctx(SMBCCTX *context,
 		if (errno == EACCES) { /* Check if the file is a directory */
 
 			int saverr = errno;
-			off_t size = 0;
-			uint16_t mode = 0;
-			struct timespec write_time_ts;
-                        struct timespec access_time_ts;
-                        struct timespec change_time_ts;
-			SMB_INO_T ino = 0;
-
-			if (!SMBC_getatr(context, srv, path, &mode, &size,
-					 NULL,
-                                         &access_time_ts,
-                                         &write_time_ts,
-                                         &change_time_ts,
-                                         &ino)) {
+			struct stat sb = {0};
+			bool ok;
 
+			ok = SMBC_getatr(context, srv, path, &sb);
+			if (!ok) {
 				/* Hmmm, bad error ... What? */
 
 				errno = SMBC_errno(context, targetcli);
@@ -2221,7 +2238,7 @@ SMBC_unlink_ctx(SMBCCTX *context,
 			}
 			else {
 
-				if (IS_DOS_DIR(mode))
+				if (S_ISDIR(sb.st_mode))
 					errno = EISDIR;
 				else
 					errno = saverr;  /* Restore this */
diff --git a/source3/libsmb/libsmb_file.c b/source3/libsmb/libsmb_file.c
index be9bcd936b2..1577010e490 100644
--- a/source3/libsmb/libsmb_file.c
+++ b/source3/libsmb/libsmb_file.c
@@ -452,18 +452,19 @@ bool
 SMBC_getatr(SMBCCTX * context,
             SMBCSRV *srv,
             const char *path,
-            uint16_t *mode,
-            off_t *size,
-            struct timespec *create_time_ts,
-            struct timespec *access_time_ts,
-            struct timespec *write_time_ts,
-            struct timespec *change_time_ts,
-            SMB_INO_T *ino)
+	    struct stat *sb)
 {
 	char *fixedpath = NULL;
 	char *targetpath = NULL;
 	struct cli_state *targetcli = NULL;
-	time_t write_time;
+	uint16_t mode = 0;
+	off_t size = 0;
+	struct timespec create_time_ts = {0};
+	struct timespec access_time_ts = {0};
+	struct timespec write_time_ts = {0};
+	struct timespec change_time_ts = {0};
+	time_t write_time = 0;
+	SMB_INO_T ino = 0;
 	TALLOC_CTX *frame = talloc_stackframe();
 	NTSTATUS status;
 
@@ -503,28 +504,56 @@ SMBC_getatr(SMBCCTX * context,
 		return False;
 	}
 
-	if (!srv->no_pathinfo2 &&
-            NT_STATUS_IS_OK(cli_qpathinfo2(targetcli, targetpath,
-                           create_time_ts,
-                           access_time_ts,
-                           write_time_ts,
-                           change_time_ts,
-			   size, mode, ino))) {
-		TALLOC_FREE(frame);
-		return True;
+	if (srv->try_posixinfo) {
+		SMB_STRUCT_STAT sbuf;
+
+		status = cli_posix_stat(targetcli, frame, &sbuf);
+		if (NT_STATUS_IS_OK(status)) {
+			setup_stat_from_stat_ex(&sbuf, path, sb);
+
+			TALLOC_FREE(frame);
+			return true;
+		}
+		if (NT_STATUS_EQUAL(status, NT_STATUS_NOT_IMPLEMENTED) ||
+		    NT_STATUS_EQUAL(status, NT_STATUS_INVALID_LEVEL)) {
+			/*
+			 * Turn this off if the server doesn't
+			 * support it.
+			 */
+			srv->try_posixinfo = false;
+		}
+	}
+
+	if (!srv->no_pathinfo2) {
+		status = cli_qpathinfo2(targetcli,
+					targetpath,
+					&create_time_ts,
+					&access_time_ts,
+					&write_time_ts,
+					&change_time_ts,
+					&size,
+					&mode,
+					&ino);
+		if (NT_STATUS_IS_OK(status)) {
+			goto setup_stat;
+		}
         }
 
 	srv->no_pathinfo2 = True;
 
-	if (!srv->no_pathinfo3 &&
-            NT_STATUS_IS_OK(cli_qpathinfo3(targetcli, targetpath,
-                           create_time_ts,
-                           access_time_ts,
-                           write_time_ts,
-                           change_time_ts,
-			   size, mode, ino))) {
-		TALLOC_FREE(frame);
-		return True;
+	if (!srv->no_pathinfo3) {
+		status = cli_qpathinfo3(targetcli,
+					targetpath,
+					&create_time_ts,
+					&access_time_ts,
+					&write_time_ts,
+					&change_time_ts,
+					&size,
+					&mode,
+					&ino);
+		if (NT_STATUS_IS_OK(status)) {
+			goto setup_stat;
+		}
         }
 
 	srv->no_pathinfo3 = True;
@@ -534,29 +563,30 @@ SMBC_getatr(SMBCCTX * context,
 		goto all_failed;
         }
 
-	if (NT_STATUS_IS_OK(cli_getatr(targetcli, targetpath, mode, size, &write_time))) {
-                struct timespec w_time_ts;
+	status = cli_getatr(targetcli, targetpath, &mode, &size, &write_time);
+	if (NT_STATUS_IS_OK(status)) {
+		struct timespec w_time_ts =
+			convert_time_t_to_timespec(write_time);
 
-                w_time_ts = convert_time_t_to_timespec(write_time);
-                if (write_time_ts != NULL) {
-			*write_time_ts = w_time_ts;
-                }
-                if (create_time_ts != NULL) {
-                        *create_time_ts = w_time_ts;
-                }
-                if (access_time_ts != NULL) {
-                        *access_time_ts = w_time_ts;
-                }
-                if (change_time_ts != NULL) {
-                        *change_time_ts = w_time_ts;
-                }
-		if (ino) {
-			*ino = 0;
-		}
-		TALLOC_FREE(frame);
-		return True;
+		access_time_ts = change_time_ts = write_time_ts = w_time_ts;
+
+		goto setup_stat;
 	}
 
+setup_stat:
+	setup_stat(sb,
+		   path,
+		   size,
+		   mode,
+		   ino,
+		   srv->dev,
+		   access_time_ts,
+		   change_time_ts,
+		   write_time_ts);
+
+	TALLOC_FREE(frame);
+	return true;
+
 all_failed:
 	srv->no_pathinfo2 = False;
 	srv->no_pathinfo3 = False;
diff --git a/source3/libsmb/libsmb_server.c b/source3/libsmb/libsmb_server.c
index 0067df48cac..d4f71d8c8b7 100644
--- a/source3/libsmb/libsmb_server.c
+++ b/source3/libsmb/libsmb_server.c
@@ -657,6 +657,15 @@ SMBC_server_internal(TALLOC_CTX *ctx,
 	ZERO_STRUCTP(srv);
 	DLIST_ADD(srv->cli, c);
 	srv->dev = (dev_t)(str_checksum(server) ^ str_checksum(share));
+	srv->try_posixinfo = false;
+	/*
+	 * Until SMB2 POSIX is done, only
+	 * try POSIX stat on SMB1 with POSIX capabilities.
+	 */
+	if ((smbXcli_conn_protocol(c->conn) < PROTOCOL_SMB2_02) &&
+	    (smb1cli_conn_capabilities(c->conn) & CAP_UNIX)) {
+		srv->try_posixinfo = true;
+	}
         srv->no_pathinfo = False;
         srv->no_pathinfo2 = False;
 	srv->no_pathinfo3 = False;
diff --git a/source3/libsmb/libsmb_stat.c b/source3/libsmb/libsmb_stat.c
index 0db9be3677b..f20f79579e2 100644
--- a/source3/libsmb/libsmb_stat.c
+++ b/source3/libsmb/libsmb_stat.c
@@ -107,6 +107,43 @@ void setup_stat(struct stat *st,
 	st->st_mtime = convert_timespec_to_time_t(write_time_ts);
 }
 
+void setup_stat_from_stat_ex(const struct stat_ex *stex,
+			     const char *fname,
+			     struct stat *st)
+{
+	st->st_atime = convert_timespec_to_time_t(stex->st_ex_atime);
+	st->st_ctime = convert_timespec_to_time_t(stex->st_ex_ctime);
+	st->st_mtime = convert_timespec_to_time_t(stex->st_ex_mtime);
+
+	st->st_mode = stex->st_ex_mode;
+	st->st_size = stex->st_ex_size;
+#ifdef HAVE_STAT_ST_BLKSIZE
+	st->st_blksize = 512;
+#endif
+#ifdef HAVE_STAT_ST_BLOCKS
+	st->st_blocks = (st->st_size + 511) / 512;
+#endif
+#ifdef HAVE_STRUCT_STAT_ST_RDEV
+	st->st_rdev = 0;
+#endif
+	st->st_uid = stex->st_ex_uid;
+	st->st_gid = stex->st_ex_gid;
+
+	st->st_nlink = stex->st_ex_nlink;
+
+	if (stex->st_ex_ino == 0) {
+		st->st_ino = 0;
+		if (fname != NULL) {
+			st->st_ino = generate_inode(fname);
+		}
+	} else {
+		st->st_ino = stex->st_ex_ino;
+	}
+
+	st->st_dev = stex->st_ex_dev;
+
+}
+
 /*
  * Routine to stat a file given a name
  */
@@ -123,13 +160,7 @@ SMBC_stat_ctx(SMBCCTX *context,
 	char *password = NULL;
 	char *workgroup = NULL;
 	char *path = NULL;
-	struct timespec write_time_ts;
-        struct timespec access_time_ts;
-        struct timespec change_time_ts;
-	off_t size = 0;
-	uint16_t mode = 0;
 	uint16_t port = 0;
-	SMB_INO_T ino = 0;
 	TALLOC_CTX *frame = talloc_stackframe();
 
 	if (!context || !context->internal->initialized) {
@@ -178,27 +209,12 @@ SMBC_stat_ctx(SMBCCTX *context,
 		return -1;  /* errno set by SMBC_server */
 	}
 
-	if (!SMBC_getatr(context, srv, path, &mode, &size,
-			 NULL,
-                         &access_time_ts,
-                         &write_time_ts,
-                         &change_time_ts,
-                         &ino)) {
+	if (!SMBC_getatr(context, srv, path, st)) {
 		errno = SMBC_errno(context, srv->cli);
 		TALLOC_FREE(frame);
 		return -1;
 	}
 
-	setup_stat(st,
-		fname,
-		size,
-		mode,
-		ino,
-		srv->dev,
-		access_time_ts,
-		change_time_ts,
-		write_time_ts);
-
 	TALLOC_FREE(frame);
 	return 0;
 }
@@ -296,7 +312,7 @@ SMBC_fstat_ctx(SMBCCTX *context,
 	}
 
 	setup_stat(st,
-		file->fname,
+		path,
 		size,
 		mode,
 		ino,
diff --git a/source3/libsmb/libsmb_xattr.c b/source3/libsmb/libsmb_xattr.c
index 442b45f2435..06a1d0c601d 100644
--- a/source3/libsmb/libsmb_xattr.c
+++ b/source3/libsmb/libsmb_xattr.c
@@ -552,13 +552,7 @@ dos_attr_query(SMBCCTX *context,
                const char *filename,
                SMBCSRV *srv)
 {
-        struct timespec create_time_ts;
-        struct timespec write_time_ts;
-        struct timespec access_time_ts;
-        struct timespec change_time_ts;
-        off_t size = 0;
-        uint16_t mode = 0;
-	SMB_INO_T inode = 0;
+	struct stat sb = {0};
         DOS_ATTR_DESC *ret;
 
         ret = talloc(ctx, DOS_ATTR_DESC);
@@ -568,26 +562,20 @@ dos_attr_query(SMBCCTX *context,
         }
 
         /* Obtain the DOS attributes */
-        if (!SMBC_getatr(context, srv, filename,
-                         &mode, &size,
-                         &create_time_ts,
-                         &access_time_ts,
-                         &write_time_ts,
-                         &change_time_ts,
-                         &inode)) {
+        if (!SMBC_getatr(context, srv, filename, &sb)) {
                 errno = SMBC_errno(context, srv->cli);
                 DEBUG(5, ("dos_attr_query Failed to query old attributes\n"));
 		TALLOC_FREE(ret);
                 return NULL;
         }
 
-        ret->mode = mode;
-        ret->size = size;
-        ret->create_time = convert_timespec_to_time_t(create_time_ts);
-        ret->access_time = convert_timespec_to_time_t(access_time_ts);
-        ret->write_time = convert_timespec_to_time_t(write_time_ts);
-        ret->change_time = convert_timespec_to_time_t(change_time_ts);
-        ret->inode = inode;
+        ret->mode = sb.st_mode;
+        ret->size = sb.st_size;
+        ret->create_time = sb.st_ctime;
+        ret->access_time = sb.st_atime;
+        ret->write_time = sb.st_mtime;
+        ret->change_time = sb.st_mtime;
+        ret->inode = sb.st_ino;
 
         return ret;
 }
@@ -736,17 +724,6 @@ cacl_get(SMBCCTX *context,
         char *name;
         char *pExclude;
         char *p;
-        struct timespec create_time_ts;
-	struct timespec write_time_ts;
-        struct timespec access_time_ts;
-        struct timespec change_time_ts;
-	time_t create_time = (time_t)0;
-	time_t write_time = (time_t)0;
-        time_t access_time = (time_t)0;
-        time_t change_time = (time_t)0;
-	off_t size = 0;
-	uint16_t mode = 0;
-	SMB_INO_T ino = 0;
 	struct cli_state *cli = srv->cli;
         struct {
                 const char * create_time_attr;
@@ -1155,25 +1132,31 @@ cacl_get(SMBCCTX *context,
         }
 
         if (all || some_dos) {
+		struct stat sb = {0};
+		time_t create_time = (time_t)0;
+		time_t write_time = (time_t)0;
+		time_t access_time = (time_t)0;
+		time_t change_time = (time_t)0;
+		off_t size = 0;
+		uint16_t mode = 0;
+		SMB_INO_T ino = 0;
+
                 /* Point to the portion after "system.dos_attr." */
                 name += 16;     /* if (all) this will be invalid but unused */
 
                 /* Obtain the DOS attributes */
-                if (!SMBC_getatr(context, srv, filename, &mode, &size, 
-                                 &create_time_ts,
-                                 &access_time_ts,
-                                 &write_time_ts,
-                                 &change_time_ts,
-                                 &ino)) {
-
+                if (!SMBC_getatr(context, srv, filename, &sb)) {
                         errno = SMBC_errno(context, srv->cli);
                         return -1;
                 }
 
-                create_time = convert_timespec_to_time_t(create_time_ts);
-                access_time = convert_timespec_to_time_t(access_time_ts);
-                write_time = convert_timespec_to_time_t(write_time_ts);
-                change_time = convert_timespec_to_time_t(change_time_ts);
+		create_time = sb.st_ctime;
+		access_time = sb.st_atime;
+		write_time  = sb.st_mtime;
+		change_time = sb.st_mtime;
+		size        = sb.st_size;
+		mode        = sb.st_mode;
+		ino         = sb.st_ino;
 
                 if (! exclude_dos_mode) {
                         if (all || all_dos) {
diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 5d4fca70b20..e27b60b0398 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -1221,6 +1221,7 @@ struct name_query_state {
 	struct sockaddr_storage my_addr;
 	struct sockaddr_storage addr;
 	bool bcast;
+	bool bcast_star_query;
 
 
 	uint8_t buf[1024];
@@ -1288,6 +1289,16 @@ struct tevent_req *name_query_send(TALLOC_CTX *mem_ctx,
 	nmb->header.nscount = 0;
 	nmb->header.arcount = 0;
 
+	if (bcast && (strcmp(name, "*")==0)) {
+		/*
+		 * We're doing a broadcast query for all
+		 * names in the area. Remember this so
+		 * we will wait for all names within
+		 * the timeout period.
+		 */
+		state->bcast_star_query = true;
+	}
+
 	make_nmb_name(&nmb->question.question_name,name,name_type);
 
 	nmb->question.question_type = 0x20;
@@ -1445,9 +1456,12 @@ static bool name_query_validator(struct packet_struct *p, void *private_data)
 	if (state->bcast) {
 		/*
 		 * We have to collect all entries coming in from broadcast
-		 * queries. If we got a unique name, we're done.
+		 * queries. If we got a unique name and we are not querying
+		 * all names registered within broadcast area (query
+		 * for the name '*', so state->bcast_star_query is set),
+		 * we're done.
 		 */
-		return got_unique_netbios_name;
+		return (got_unique_netbios_name && !state->bcast_star_query);
 	}
 	/*
 	 * WINS responses are accepted when they are received
diff --git a/source3/libsmb/nmblib.c b/source3/libsmb/nmblib.c
index b6dca800e94..84cbb054b8e 100644
--- a/source3/libsmb/nmblib.c
+++ b/source3/libsmb/nmblib.c
@@ -192,10 +192,14 @@ static int parse_nmb_name(char *inbuf,int ofs,int length, struct nmb_name *name)
 
 	m = ubuf[offset];
 
-	if (!m)
-		return(0);
-	if ((m & 0xC0) || offset+m+2 > length)
-		return(0);
+	/* m must be 32 to exactly fill in the 16 bytes of the netbios name */
+	if (m != 32) {
+		return 0;
+	}
+	/* Cannot go past length. */
+	if (offset+m+2 > length) {
+		return 0;
+	}
 
 	memset((char *)name,'\0',sizeof(*name));
 
diff --git a/source3/locking/leases_db.c b/source3/locking/leases_db.c
index 19c5a612ecc..a12b421d260 100644
--- a/source3/locking/leases_db.c
+++ b/source3/locking/leases_db.c
@@ -97,10 +97,12 @@ struct leases_db_do_locked_state {
 	NTSTATUS status;
 };
 
-static void leases_db_do_locked_fn(struct db_record *rec, void *private_data)
+static void leases_db_do_locked_fn(
+	struct db_record *rec,
+	TDB_DATA db_value,
+	void *private_data)
 {
 	struct leases_db_do_locked_state *state = private_data;
-	TDB_DATA db_value = dbwrap_record_get_value(rec);
 	DATA_BLOB blob = { .data = db_value.dptr, .length = db_value.dsize };
 	struct leases_db_value *value = NULL;
 	enum ndr_err_code ndr_err;
diff --git a/source3/locking/locking.c b/source3/locking/locking.c
index 7822c2b3665..1220cb3a2be 100644
--- a/source3/locking/locking.c
+++ b/source3/locking/locking.c
@@ -36,6 +36,7 @@
 */
 
 #include "includes.h"
+#include "lib/util/time_basic.h"
 #include "system/filesys.h"
 #include "lib/util/server_id.h"
 #include "locking/proto.h"
@@ -637,7 +638,7 @@ void get_file_infos(struct file_id id,
 	}
 
 	if (write_time) {
-		ZERO_STRUCTP(write_time);
+		*write_time = make_omit_timespec();
 	}
 
 	if (!(lck = fetch_share_mode_unlocked(talloc_tos(), id))) {
@@ -990,10 +991,11 @@ bool set_sticky_write_time(struct file_id fileid, struct timespec write_time)
 {
 	struct share_mode_lock *lck;
 	struct file_id_buf ftmp;
+	struct timeval_buf tbuf;
+	NTTIME nt = full_timespec_to_nt_time(&write_time);
 
 	DBG_INFO("%s id=%s\n",
-		 timestring(talloc_tos(),
-			    convert_timespec_to_time_t(write_time)),
+		 timespec_string_buf(&write_time, true, &tbuf),
 		 file_id_str_buf(fileid, &ftmp));
 
 	lck = get_existing_share_mode_lock(talloc_tos(), fileid);
@@ -1001,9 +1003,9 @@ bool set_sticky_write_time(struct file_id fileid, struct timespec write_time)
 		return False;
 	}
 
-	if (timespec_compare(&lck->data->changed_write_time, &write_time) != 0) {
+	if (lck->data->changed_write_time != nt) {
 		lck->data->modified = True;
-		lck->data->changed_write_time = write_time;
+		lck->data->changed_write_time = nt;
 	}
 
 	TALLOC_FREE(lck);
@@ -1014,10 +1016,11 @@ bool set_write_time(struct file_id fileid, struct timespec write_time)
 {
 	struct share_mode_lock *lck;
 	struct file_id_buf idbuf;
+	struct timeval_buf tbuf;
+	NTTIME nt = full_timespec_to_nt_time(&write_time);
 
 	DBG_INFO("%s id=%s\n",
-		 timestring(talloc_tos(),
-			    convert_timespec_to_time_t(write_time)),
+		 timespec_string_buf(&write_time, true, &tbuf),
 		 file_id_str_buf(fileid, &idbuf));
 
 	lck = get_existing_share_mode_lock(talloc_tos(), fileid);
@@ -1025,9 +1028,9 @@ bool set_write_time(struct file_id fileid, struct timespec write_time)
 		return False;
 	}
 
-	if (timespec_compare(&lck->data->old_write_time, &write_time) != 0) {
+	if (lck->data->old_write_time != nt) {
 		lck->data->modified = True;
-		lck->data->old_write_time = write_time;
+		lck->data->old_write_time = nt;
 	}
 
 	TALLOC_FREE(lck);
@@ -1038,10 +1041,10 @@ struct timespec get_share_mode_write_time(struct share_mode_lock *lck)
 {
 	struct share_mode_data *d = lck->data;
 
-	if (!null_timespec(d->changed_write_time)) {
-		return d->changed_write_time;
+	if (!null_nttime(d->changed_write_time)) {
+		return nt_time_to_full_timespec(d->changed_write_time);
 	}
-	return d->old_write_time;
+	return nt_time_to_full_timespec(d->old_write_time);
 }
 
 struct file_has_open_streams_state {
diff --git a/source3/locking/posix.c b/source3/locking/posix.c
index 91485133eb2..e74f48636ec 100644
--- a/source3/locking/posix.c
+++ b/source3/locking/posix.c
@@ -513,11 +513,13 @@ struct add_fd_to_close_entry_state {
 };
 
 static void add_fd_to_close_entry_fn(
-	struct db_record *rec, void *private_data)
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
 	struct add_fd_to_close_entry_state *state = private_data;
 	TDB_DATA values[] = {
-		dbwrap_record_get_value(rec),
+		value,
 		{ .dptr = (uint8_t *)&(state->fsp->fh->fd),
 		  .dsize = sizeof(state->fsp->fh->fd) },
 	};
@@ -551,9 +553,10 @@ static void add_fd_to_close_entry(const files_struct *fsp)
 }
 
 static void fd_close_posix_fn(
-	struct db_record *rec, void *private_data)
+	struct db_record *rec,
+	TDB_DATA data,
+	void *private_data)
 {
-	TDB_DATA data = dbwrap_record_get_value(rec);
 	size_t num_fds, i;
 
 	SMB_ASSERT((data.dsize % sizeof(int)) == 0);
diff --git a/source3/locking/proto.h b/source3/locking/proto.h
index fc11ef8863c..b7098c1e788 100644
--- a/source3/locking/proto.h
+++ b/source3/locking/proto.h
@@ -149,6 +149,15 @@ NTSTATUS share_mode_do_locked(
 		   void *private_data),
 	void *private_data);
 NTSTATUS share_mode_wakeup_waiters(struct file_id id);
+bool share_mode_have_entries(struct share_mode_lock *lck);
+
+struct tevent_req *share_mode_watch_send(
+	TALLOC_CTX *mem_ctx,
+	struct tevent_context *ev,
+	struct file_id id,
+	struct server_id blocker);
+NTSTATUS share_mode_watch_recv(
+	struct tevent_req *req, bool *blockerdead, struct server_id *blocker);
 
 struct share_mode_lock *fetch_share_mode_unlocked(TALLOC_CTX *mem_ctx,
 						  struct file_id id);
@@ -236,6 +245,7 @@ bool share_mode_forall_entries(
 		   void *private_data),
 	void *private_data);
 
+NTSTATUS share_mode_count_entries(struct file_id fid, size_t *num_share_modes);
 
 /* The following definitions come from locking/posix.c  */
 
diff --git a/source3/locking/share_mode_lock.c b/source3/locking/share_mode_lock.c
index 234dd90c1d0..ce22ce540cf 100644
--- a/source3/locking/share_mode_lock.c
+++ b/source3/locking/share_mode_lock.c
@@ -404,6 +404,14 @@ static struct share_mode_data *parse_share_modes(TALLOC_CTX *mem_ctx,
 		NDR_PRINT_DEBUG(share_mode_data, d);
 	}
 
+	/*
+	 * We have a non-zero locking.tdb record that was correctly
+	 * parsed. This means a share_entries.tdb entry exists,
+	 * otherwise we'd have paniced before in
+	 * share_mode_data_store()
+	 */
+	d->have_share_modes = true;
+
 	return d;
 fail:
 	TALLOC_FREE(d);
@@ -414,7 +422,8 @@ fail:
  If modified, store the share_mode_data back into the database.
 ********************************************************************/
 
-static NTSTATUS share_mode_data_store(struct share_mode_data *d)
+static NTSTATUS share_mode_data_store(
+	struct share_mode_data *d, struct db_record *rec)
 {
 	DATA_BLOB blob;
 	enum ndr_err_code ndr_err;
@@ -432,7 +441,12 @@ static NTSTATUS share_mode_data_store(struct share_mode_data *d)
 
 	d->sequence_number += 1;
 
-	if (d->num_share_modes == 0) {
+	if (!d->have_share_modes) {
+		TDB_DATA key = dbwrap_record_get_key(rec);
+		bool share_entries_exist;
+		share_entries_exist = dbwrap_exists(share_entries_db, key);
+		SMB_ASSERT(!share_entries_exist);
+
 		TALLOC_FREE(d->delete_tokens);
 		d->num_delete_tokens = 0;
 
@@ -440,7 +454,7 @@ static NTSTATUS share_mode_data_store(struct share_mode_data *d)
 			DBG_DEBUG("Ignoring fresh empty record\n");
 			return NT_STATUS_OK;
 		}
-		status = dbwrap_record_delete(d->record);
+		status = dbwrap_record_delete(rec);
 		return status;
 	}
 
@@ -453,7 +467,7 @@ static NTSTATUS share_mode_data_store(struct share_mode_data *d)
 	}
 
 	status = dbwrap_record_store(
-		d->record,
+		rec,
 		(TDB_DATA) { .dptr = blob.data, .dsize = blob.length },
 		TDB_REPLACE);
 	TALLOC_FREE(blob.data);
@@ -504,7 +518,7 @@ static struct share_mode_data *fresh_share_mode_lock(
 	if (d->servicepath == NULL) {
 		goto fail;
 	}
-	d->old_write_time = *old_write_time;
+	d->old_write_time = full_timespec_to_nt_time(old_write_time);
 	d->modified = false;
 	d->fresh = true;
 	return d;
@@ -528,6 +542,7 @@ static size_t static_share_mode_data_refcount = 0;
  * need to share with a nested get_share_mode_lock call.
  */
 static struct db_record *static_share_mode_record = NULL;
+static TDB_DATA static_share_mode_record_value = {0};
 static bool static_share_mode_record_talloced = false;
 
 /*******************************************************************
@@ -551,6 +566,9 @@ static NTSTATUS get_static_share_mode_data(
 		d = fresh_share_mode_lock(
 			lock_db, servicepath, smb_fname, old_write_time);
 		if (d == NULL) {
+			if (smb_fname == NULL) {
+				return NT_STATUS_NOT_FOUND;
+			}
 			return NT_STATUS_NO_MEMORY;
 		}
 	} else {
@@ -562,7 +580,6 @@ static NTSTATUS get_static_share_mode_data(
 	}
 
 	d->id = id;
-	d->record = rec;
 
 	static_share_mode_data = d;
 
@@ -611,19 +628,9 @@ struct share_mode_lock *get_share_mode_lock(
 			goto fail;
 		}
 		static_share_mode_record_talloced = true;
+		static_share_mode_record_value = dbwrap_record_get_value(
+			static_share_mode_record);
 
-		status = get_static_share_mode_data(
-			static_share_mode_record,
-			id,
-			servicepath,
-			smb_fname,
-			old_write_time);
-		if (!NT_STATUS_IS_OK(status)) {
-			DBG_DEBUG("get_static_share_mode_data failed: %s\n",
-				  nt_errstr(status));
-			TALLOC_FREE(static_share_mode_record);
-			goto fail;
-		}
 	} else {
 		TDB_DATA static_key;
 		int cmp;
@@ -636,18 +643,18 @@ struct share_mode_lock *get_share_mode_lock(
 				    "simultaneously\n");
 			return NULL;
 		}
+	}
 
-		status = get_static_share_mode_data(
-			static_share_mode_record,
-			id,
-			servicepath,
-			smb_fname,
-			old_write_time);
-		if (!NT_STATUS_IS_OK(status)) {
-			DBG_WARNING("get_static_share_mode_data failed: %s\n",
-				    nt_errstr(status));
-			goto fail;
-		}
+	status = get_static_share_mode_data(static_share_mode_record,
+					    id,
+					    servicepath,
+					    smb_fname,
+					    old_write_time);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("get_static_share_mode_data failed: %s\n",
+			  nt_errstr(status));
+		TALLOC_FREE(static_share_mode_record);
+		goto fail;
 	}
 
 done:
@@ -673,25 +680,19 @@ static int share_mode_lock_destructor(struct share_mode_lock *lck)
 		return 0;
 	}
 
-	status = share_mode_data_store(static_share_mode_data);
+	status = share_mode_data_store(
+		static_share_mode_data, static_share_mode_record);
 	if (!NT_STATUS_IS_OK(status)) {
 		DBG_ERR("share_mode_data_store failed: %s\n",
 			nt_errstr(status));
 		smb_panic("Could not store share mode data\n");
 	}
 
-	/*
-	 * Drop the locking.tdb lock before moving the share_mode_data
-	 * to memcache
-	 */
-	SMB_ASSERT(static_share_mode_data->record == static_share_mode_record);
-	static_share_mode_data->record = NULL;
-
 	if (static_share_mode_record_talloced) {
 		TALLOC_FREE(static_share_mode_record);
 	}
 
-	if (static_share_mode_data->num_share_modes != 0) {
+	if (static_share_mode_data->have_share_modes) {
 		/*
 		 * This is worth keeping. Without share modes,
 		 * share_mode_data_store above has left nothing in the
@@ -720,16 +721,18 @@ struct share_mode_do_locked_state {
 	void *private_data;
 };
 
-static void share_mode_do_locked_fn(struct db_record *rec,
-				    void *private_data)
+static void share_mode_do_locked_fn(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
 	struct share_mode_do_locked_state *state = private_data;
 	bool modified_dependent = false;
 	bool reset_static_share_mode_record = false;
-	TDB_DATA value = dbwrap_record_get_value(rec);
 
 	if (static_share_mode_record == NULL) {
 		static_share_mode_record = rec;
+		static_share_mode_record_value = value;
 		static_share_mode_record_talloced = false;
 		reset_static_share_mode_record = true;
 	} else {
@@ -759,7 +762,7 @@ NTSTATUS share_mode_do_locked(
 
 	if (static_share_mode_record != NULL) {
 		bool modified_dependent = false;
-		TDB_DATA static_key, static_value;
+		TDB_DATA static_key;
 		int cmp;
 
 		static_key = dbwrap_record_get_key(static_share_mode_record);
@@ -771,9 +774,9 @@ NTSTATUS share_mode_do_locked(
 			return NT_STATUS_INVALID_LOCK_SEQUENCE;
 		}
 
-		static_value = dbwrap_record_get_value(static_share_mode_record);
-
-		fn(static_value, &modified_dependent, private_data);
+		fn(static_share_mode_record_value,
+		   &modified_dependent,
+		   private_data);
 
 		if (modified_dependent) {
 			dbwrap_watched_wakeup(static_share_mode_record);
@@ -810,6 +813,94 @@ NTSTATUS share_mode_wakeup_waiters(struct file_id id)
 	return share_mode_do_locked(id, share_mode_wakeup_waiters_fn, NULL);
 }
 
+bool share_mode_have_entries(struct share_mode_lock *lck)
+{
+	return lck->data->have_share_modes;
+}
+
+struct share_mode_watch_state {
+	struct tevent_context *ev;
+	bool blockerdead;
+	struct server_id blocker;
+	struct tevent_req *subreq;
+};
+
+static void share_mode_watch_fn(
+	TDB_DATA value, bool *modified_dependent, void *private_data)
+{
+	struct share_mode_watch_state *state = talloc_get_type_abort(
+		private_data, struct share_mode_watch_state);
+
+	state->subreq = dbwrap_watched_watch_send(
+		state, state->ev, static_share_mode_record, state->blocker);
+}
+
+static void share_mode_watch_done(struct tevent_req *subreq);
+
+struct tevent_req *share_mode_watch_send(
+	TALLOC_CTX *mem_ctx,
+	struct tevent_context *ev,
+	struct file_id id,
+	struct server_id blocker)
+{
+	struct tevent_req *req = NULL;
+	struct share_mode_watch_state *state = NULL;
+	NTSTATUS status;
+
+	req = tevent_req_create(
+		mem_ctx, &state, struct share_mode_watch_state);
+	if (req == NULL) {
+		return NULL;
+	}
+	state->ev = ev;
+	state->blocker = blocker;
+
+	status = share_mode_do_locked(id, share_mode_watch_fn, state);
+	if (tevent_req_nterror(req, status)) {
+		return tevent_req_post(req, ev);
+	}
+	if (tevent_req_nomem(state->subreq, req)) {
+		return tevent_req_post(req, ev);
+	}
+	tevent_req_set_callback(state->subreq, share_mode_watch_done, req);
+	return req;
+}
+
+static void share_mode_watch_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct share_mode_watch_state *state = tevent_req_data(
+		req, struct share_mode_watch_state);
+	NTSTATUS status;
+
+	status = dbwrap_watched_watch_recv(
+		subreq, &state->blockerdead, &state->blocker);
+	if (tevent_req_nterror(req, status)) {
+		return;
+	}
+	tevent_req_done(req);
+}
+
+NTSTATUS share_mode_watch_recv(
+	struct tevent_req *req, bool *blockerdead, struct server_id *blocker)
+{
+	struct share_mode_watch_state *state = tevent_req_data(
+		req, struct share_mode_watch_state);
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		return status;
+	}
+	if (blockerdead != NULL) {
+		*blockerdead = state->blockerdead;
+	}
+	if (blocker != NULL) {
+		*blocker = state->blocker;
+	}
+	return NT_STATUS_OK;
+}
+
 struct fetch_share_mode_unlocked_state {
 	TALLOC_CTX *mem_ctx;
 	struct share_mode_lock *lck;
@@ -1119,6 +1210,7 @@ int share_entry_forall(int (*fn)(struct file_id fid,
 struct cleanup_disconnected_state {
 	struct share_mode_lock *lck;
 	uint64_t open_persistent_id;
+	size_t num_disconnected;
 	bool found_connected;
 };
 
@@ -1139,7 +1231,7 @@ static bool cleanup_disconnected_lease(struct share_mode_entry *e,
 	return false;
 }
 
-static bool share_mode_cleanup_disconnected_fn(
+static bool share_mode_find_connected_fn(
 	struct share_mode_entry *e,
 	bool *modified,
 	void *private_data)
@@ -1187,6 +1279,8 @@ static bool share_mode_cleanup_disconnected_fn(
 		return true;
 	}
 
+	state->num_disconnected += 1;
+
 	return false;
 }
 
@@ -1200,6 +1294,7 @@ bool share_mode_cleanup_disconnected(struct file_id fid,
 	bool ret = false;
 	TALLOC_CTX *frame = talloc_stackframe();
 	struct file_id_buf idbuf;
+	NTSTATUS status;
 	bool ok;
 
 	state.lck = get_existing_share_mode_lock(frame, fid);
@@ -1211,7 +1306,7 @@ bool share_mode_cleanup_disconnected(struct file_id fid,
 	data = state.lck->data;
 
 	ok = share_mode_forall_entries(
-		state.lck, share_mode_cleanup_disconnected_fn, &state);
+		state.lck, share_mode_find_connected_fn, &state);
 	if (!ok) {
 		DBG_DEBUG("share_mode_forall_entries failed\n");
 		goto done;
@@ -1255,11 +1350,11 @@ bool share_mode_cleanup_disconnected(struct file_id fid,
 		goto done;
 	}
 
-	DBG_DEBUG("cleaning up %u entries for file "
+	DBG_DEBUG("cleaning up %zu entries for file "
 		  "(file-id='%s', servicepath='%s', "
 		  "base_name='%s%s%s') "
 		  "from open_persistent_id %"PRIu64"\n",
-		  data->num_share_modes,
+		  state.num_disconnected,
 		  file_id_str_buf(fid, &idbuf),
 		  data->servicepath,
 		  data->base_name,
@@ -1269,7 +1364,17 @@ bool share_mode_cleanup_disconnected(struct file_id fid,
 		  ? "" : data->stream_name,
 		  open_persistent_id);
 
-	data->num_share_modes = 0;
+	/*
+	 * No connected share entries left, wipe them all
+	 */
+	status = dbwrap_delete(share_entries_db, locking_key(&fid));
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("dbwrap_delete failed: %s\n",
+			  nt_errstr(status));
+		goto done;
+	}
+
+	data->have_share_modes = false;
 	data->modified = true;
 
 	ret = true;
@@ -1411,14 +1516,16 @@ static size_t share_mode_entry_find(
 
 struct set_share_mode_state {
 	struct share_mode_entry e;
-	uint32_t num_share_modes;
+	bool created_share_mode_record;
 	NTSTATUS status;
 };
 
-static void set_share_mode_fn(struct db_record *rec, void *private_data)
+static void set_share_mode_fn(
+	struct db_record *rec,
+	TDB_DATA data,
+	void *private_data)
 {
 	struct set_share_mode_state *state = private_data;
-	TDB_DATA data = dbwrap_record_get_value(rec);
 	size_t idx, num_share_modes;
 	struct share_mode_entry tmp;
 	struct share_mode_entry_buf buf;
@@ -1489,7 +1596,7 @@ static void set_share_mode_fn(struct db_record *rec, void *private_data)
 		}
 	}
 
-	state->num_share_modes = num_share_modes+1;
+	state->created_share_mode_record = (num_share_modes == 0);
 	state->status = dbwrap_record_storev(rec, dbufs, num_dbufs, 0);
 }
 
@@ -1542,8 +1649,10 @@ bool set_share_mode(struct share_mode_lock *lck,
 		return false;
 	}
 
-	d->num_share_modes = state.num_share_modes;
-	d->modified = true;
+	if (state.created_share_mode_record) {
+		d->have_share_modes = true;
+		d->modified = true;
+	}
 
 	return true;
 }
@@ -1554,7 +1663,6 @@ struct share_mode_forall_entries_state {
 		   bool *modified,
 		   void *private_data);
 	void *private_data;
-	size_t num_share_modes;
 	bool ok;
 };
 
@@ -1651,11 +1759,12 @@ static bool share_mode_for_one_entry(
 }
 
 static void share_mode_forall_entries_fn(
-	struct db_record *rec, void *private_data)
+	struct db_record *rec,
+	TDB_DATA data,
+	void *private_data)
 {
 	struct share_mode_forall_entries_state *state = private_data;
 	struct share_mode_data *d = state->lck->data;
-	struct TDB_DATA data = dbwrap_record_get_value(rec);
 	size_t num_share_modes;
 	bool writeback = false;
 	NTSTATUS status;
@@ -1688,12 +1797,11 @@ static void share_mode_forall_entries_fn(
 		return;
 	}
 
-	if (num_share_modes != d->num_share_modes) {
-		d->num_share_modes = num_share_modes;
-		d->modified = true;
-	}
-
 	if (num_share_modes == 0) {
+		if (data.dsize != 0) {
+			d->have_share_modes = false;
+			d->modified = true;
+		}
 		status = dbwrap_record_delete(rec);
 	} else {
 		TDB_DATA value = {
@@ -1738,7 +1846,7 @@ bool share_mode_forall_entries(
 		state.ok = true;
 	}
 	if (!NT_STATUS_IS_OK(status)) {
-		DBG_DEBUG("dbwrap_parse_record returned %s\n",
+		DBG_DEBUG("dbwrap_do_locked failed: %s\n",
 			  nt_errstr(status));
 		return false;
 	}
@@ -1746,10 +1854,57 @@ bool share_mode_forall_entries(
 	return state.ok;
 }
 
+struct share_mode_count_entries_state {
+	size_t num_share_modes;
+	NTSTATUS status;
+};
+
+static void share_mode_count_entries_fn(
+	TDB_DATA key, TDB_DATA data, void *private_data)
+{
+	struct share_mode_count_entries_state *state = private_data;
+
+	if ((data.dsize % SHARE_MODE_ENTRY_SIZE) != 0) {
+		DBG_WARNING("Invalid data size %zu\n", data.dsize);
+		state->status = NT_STATUS_INTERNAL_DB_CORRUPTION;
+		return;
+	}
+	state->num_share_modes = data.dsize / SHARE_MODE_ENTRY_SIZE;
+	state->status = NT_STATUS_OK;
+}
+
+NTSTATUS share_mode_count_entries(struct file_id fid, size_t *num_share_modes)
+{
+	struct share_mode_count_entries_state state = {
+		.status = NT_STATUS_NOT_FOUND,
+	};
+	NTSTATUS status;
+
+	status = dbwrap_parse_record(
+		share_entries_db,
+		locking_key(&fid),
+		share_mode_count_entries_fn,
+		&state);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("dbwrap_parse_record failed: %s\n",
+			  nt_errstr(status));
+		return status;
+	}
+	if (!NT_STATUS_IS_OK(state.status)) {
+		DBG_DEBUG("share_mode_forall_entries_fn failed: %s\n",
+			  nt_errstr(state.status));
+		return state.status;
+	}
+
+	*num_share_modes = state.num_share_modes;
+	return NT_STATUS_OK;
+}
+
 struct share_mode_entry_do_state {
 	struct server_id pid;
 	uint64_t share_file_id;
 	void (*fn)(struct share_mode_entry *e,
+		   size_t num_share_modes,
 		   bool *modified,
 		   void *private_data);
 	void *private_data;
@@ -1757,10 +1912,12 @@ struct share_mode_entry_do_state {
 	NTSTATUS status;
 };
 
-static void share_mode_entry_do_fn(struct db_record *rec, void *private_data)
+static void share_mode_entry_do_fn(
+	struct db_record *rec,
+	TDB_DATA data,
+	void *private_data)
 {
 	struct share_mode_entry_do_state *state = private_data;
-	struct TDB_DATA data = dbwrap_record_get_value(rec);
 	size_t idx;
 	bool found = false;
 	bool modified;
@@ -1792,7 +1949,7 @@ static void share_mode_entry_do_fn(struct db_record *rec, void *private_data)
 		return;
 	}
 
-	state->fn(&e, &modified, state->private_data);
+	state->fn(&e, state->num_share_modes, &modified, state->private_data);
 
 	if (!e.stale && !modified) {
 		state->status = NT_STATUS_OK;
@@ -1836,6 +1993,15 @@ static void share_mode_entry_do_fn(struct db_record *rec, void *private_data)
 		state->num_share_modes -= 1;
 	}
 
+	if (state->num_share_modes == 0) {
+		state->status = dbwrap_record_delete(rec);
+		if (!NT_STATUS_IS_OK(state->status)) {
+			DBG_DEBUG("dbwrap_record_delete failed: %s\n",
+				  nt_errstr(state->status));
+		}
+		return;
+	}
+
 	state->status = dbwrap_record_storev(rec, dbufs, num_dbufs, 0);
 	if (!NT_STATUS_IS_OK(state->status)) {
 		DBG_DEBUG("dbwrap_record_storev failed: %s\n",
@@ -1849,6 +2015,7 @@ static bool share_mode_entry_do(
 	struct server_id pid,
 	uint64_t share_file_id,
 	void (*fn)(struct share_mode_entry *e,
+		   size_t num_share_modes,
 		   bool *modified,
 		   void *private_data),
 	void *private_data)
@@ -1861,6 +2028,7 @@ static bool share_mode_entry_do(
 		.private_data = private_data,
 	};
 	NTSTATUS status;
+	bool have_share_modes;
 
 	status = dbwrap_do_locked(
 		share_entries_db,
@@ -1878,8 +2046,9 @@ static bool share_mode_entry_do(
 		return false;
 	}
 
-	if (d->num_share_modes != state.num_share_modes) {
-		d->num_share_modes = state.num_share_modes;
+	have_share_modes = (state.num_share_modes != 0);
+	if (d->have_share_modes != have_share_modes) {
+		d->have_share_modes = have_share_modes;
 		d->modified = true;
 	}
 
@@ -1892,6 +2061,7 @@ struct del_share_mode_state {
 
 static void del_share_mode_fn(
 	struct share_mode_entry *e,
+	size_t num_share_modes,
 	bool *modified,
 	void *private_data)
 {
@@ -1928,6 +2098,7 @@ struct remove_share_oplock_state {
 
 static void remove_share_oplock_fn(
 	struct share_mode_entry *e,
+	size_t num_share_modes,
 	bool *modified,
 	void *private_data)
 {
@@ -1965,7 +2136,7 @@ bool remove_share_oplock(struct share_mode_lock *lck, files_struct *fsp)
 			&fsp->lease->lease.lease_key);
 	}
 
-	lck->data->modified = true; /* signal watchers */
+	share_mode_wakeup_waiters(fsp->file_id);
 
 	return true;
 }
@@ -1976,6 +2147,7 @@ struct downgrade_share_oplock_state {
 
 static void downgrade_share_oplock_fn(
 	struct share_mode_entry *e,
+	size_t num_share_modes,
 	bool *modified,
 	void *private_data)
 {
@@ -2019,10 +2191,17 @@ struct mark_share_mode_disconnected_state {
 
 static void mark_share_mode_disconnected_fn(
 	struct share_mode_entry *e,
+	size_t num_share_modes,
 	bool *modified,
 	void *private_data)
 {
 	struct mark_share_mode_disconnected_state *state = private_data;
+
+	if (num_share_modes != 1) {
+		state->ok = false;
+		return;
+	}
+
 	server_id_set_disconnected(&e->pid);
 	e->share_file_id = state->open_persistent_id;
 	*modified = true;
@@ -2035,10 +2214,6 @@ bool mark_share_mode_disconnected(struct share_mode_lock *lck,
 	struct mark_share_mode_disconnected_state state;
 	bool ok;
 
-	if (lck->data->num_share_modes != 1) {
-		return false;
-	}
-
 	if (fsp->op == NULL) {
 		return false;
 	}
@@ -2071,6 +2246,7 @@ bool mark_share_mode_disconnected(struct share_mode_lock *lck,
 
 static void reset_share_mode_entry_del_fn(
 	struct share_mode_entry *e,
+	size_t num_share_modes,
 	bool *modified,
 	void *private_data)
 {
@@ -2132,9 +2308,7 @@ bool reset_share_mode_entry(
 			    nt_errstr(state.status));
 		return false;
 	}
-
-	d->num_share_modes = state.num_share_modes;
-	d->modified = true;
+	d->have_share_modes = true;
 
 	return true;
 }
diff --git a/source3/modules/nfs4acl_xattr_xdr.c b/source3/modules/nfs4acl_xattr_xdr.c
index b2878f2b637..ff5b667cbc7 100644
--- a/source3/modules/nfs4acl_xattr_xdr.c
+++ b/source3/modules/nfs4acl_xattr_xdr.c
@@ -286,7 +286,7 @@ static NTSTATUS nfs4acli_to_smb4acl(struct vfs_handle_struct *handle,
 	unsigned nfsacl41_flag = 0;
 	uint16_t smb4acl_flags = 0;
 	unsigned naces = nfs4acli_get_naces(nacl);
-	int i;
+	unsigned i;
 
 	SMB_VFS_HANDLE_GET_DATA(handle, config,
 				struct nfs4acl_config,
diff --git a/source3/modules/offload_token.c b/source3/modules/offload_token.c
index 05528da46b5..3fb84dabdff 100644
--- a/source3/modules/offload_token.c
+++ b/source3/modules/offload_token.c
@@ -83,110 +83,137 @@ static int fsp_token_link_destructor(struct fsp_token_link *link)
 	return 0;
 }
 
+struct vfs_offload_token_db_store_fsp_state {
+	const struct files_struct *fsp;
+	const DATA_BLOB *token_blob;
+	NTSTATUS status;
+};
+
+static void vfs_offload_token_db_store_fsp_fn(
+	struct db_record *rec, TDB_DATA value, void *private_data)
+{
+	struct vfs_offload_token_db_store_fsp_state *state = private_data;
+	const struct files_struct *fsp = state->fsp;
+	const DATA_BLOB *token_blob = state->token_blob;
+	files_struct *token_db_fsp = NULL;
+	void *ptr = NULL;
+
+	if (value.dsize == 0) {
+		value = make_tdb_data((uint8_t *)&fsp, sizeof(files_struct *));
+		state->status = dbwrap_record_store(rec, value, 0);
+		return;
+	}
+
+	if (value.dsize != sizeof(ptr)) {
+		DBG_ERR("Bad db entry for token:\n");
+		dump_data(1, token_blob->data, token_blob->length);
+		state->status = NT_STATUS_INTERNAL_ERROR;
+		return;
+	}
+	memcpy(&ptr, value.dptr, value.dsize);
+
+	token_db_fsp = talloc_get_type_abort(ptr, struct files_struct);
+	if (token_db_fsp != fsp) {
+		DBG_ERR("token for fsp [%s] matches already known "
+			"but different fsp [%s]:\n",
+			fsp_str_dbg(fsp),
+			fsp_str_dbg(token_db_fsp));
+		dump_data(1, token_blob->data, token_blob->length);
+		state->status = NT_STATUS_INTERNAL_ERROR;
+		return;
+	}
+}
+
 NTSTATUS vfs_offload_token_db_store_fsp(struct vfs_offload_ctx *ctx,
 					const files_struct *fsp,
 					const DATA_BLOB *token_blob)
 {
-	struct db_record *rec = NULL;
+	struct vfs_offload_token_db_store_fsp_state state = {
+		.fsp = fsp, .token_blob = token_blob,
+	};
 	struct fsp_token_link *link = NULL;
 	TDB_DATA key = make_tdb_data(token_blob->data, token_blob->length);
-	TDB_DATA value;
 	NTSTATUS status;
 
-	rec = dbwrap_fetch_locked(ctx->db_ctx, talloc_tos(), key);
-	if (rec == NULL) {
-		return NT_STATUS_INTERNAL_ERROR;
-	}
-
-	value = dbwrap_record_get_value(rec);
-	if (value.dsize != 0) {
-		void *ptr = NULL;
-		files_struct *token_db_fsp = NULL;
-
-		if (value.dsize != sizeof(ptr)) {
-			DBG_ERR("Bad db entry for token:\n");
-			dump_data(1, token_blob->data, token_blob->length);
-			TALLOC_FREE(rec);
-			return NT_STATUS_INTERNAL_ERROR;
-		}
-		memcpy(&ptr, value.dptr, value.dsize);
-		TALLOC_FREE(rec);
-
-		token_db_fsp = talloc_get_type_abort(ptr, struct files_struct);
-		if (token_db_fsp != fsp) {
-			DBG_ERR("token for fsp [%s] matches already known "
-				"but different fsp [%s]:\n",
-				fsp_str_dbg(fsp), fsp_str_dbg(token_db_fsp));
-			dump_data(1, token_blob->data, token_blob->length);
-			return NT_STATUS_INTERNAL_ERROR;
-		}
-
-		return NT_STATUS_OK;
-	}
-
-	link = talloc_zero(fsp, struct fsp_token_link);
+	link = talloc(fsp, struct fsp_token_link);
 	if (link == NULL) {
 		return NT_STATUS_NO_MEMORY;
 	}
-	link->ctx = ctx;
-	link->token_blob = data_blob_talloc(link, token_blob->data,
-					    token_blob->length);
+	*link = (struct fsp_token_link) {
+		.ctx = ctx,
+		.token_blob = data_blob_dup_talloc(link, *token_blob),
+	};
 	if (link->token_blob.data == NULL) {
 		TALLOC_FREE(link);
 		return NT_STATUS_NO_MEMORY;
 	}
-	talloc_set_destructor(link, fsp_token_link_destructor);
-
-	value = make_tdb_data((uint8_t *)&fsp, sizeof(files_struct *));
 
-	status = dbwrap_record_store(rec, value, 0);
+	status = dbwrap_do_locked(
+		ctx->db_ctx,
+		key,
+		vfs_offload_token_db_store_fsp_fn,
+		&state);
 	if (!NT_STATUS_IS_OK(status)) {
-		DBG_ERR("dbwrap_record_store for [%s] failed: %s. Token\n",
-			fsp_str_dbg(fsp), nt_errstr(status));
-		dump_data(0, token_blob->data, token_blob->length);
+		DBG_DEBUG("dbwrap_do_locked failed: %s\n",
+			  nt_errstr(status));
+		TALLOC_FREE(link);
+		return status;
+	}
+	if (!NT_STATUS_IS_OK(state.status)) {
+		DBG_DEBUG("vfs_offload_token_db_store_fsp_fn failed: %s\n",
+			  nt_errstr(status));
 		TALLOC_FREE(link);
-		TALLOC_FREE(rec);
 		return status;
 	}
 
-	TALLOC_FREE(rec);
+	talloc_set_destructor(link, fsp_token_link_destructor);
 	return NT_STATUS_OK;
 }
 
+struct vfs_offload_token_db_fetch_fsp_state {
+	struct files_struct **fsp;
+	NTSTATUS status;
+};
+
+static void vfs_offload_token_db_fetch_fsp_fn(
+	TDB_DATA key, TDB_DATA value, void *private_data)
+{
+	struct vfs_offload_token_db_fetch_fsp_state *state = private_data;
+	void *ptr;
+
+	if (value.dsize != sizeof(ptr)) {
+		DBG_ERR("Bad db entry for token:\n");
+		dump_data(1, key.dptr, key.dsize);
+		state->status = NT_STATUS_INTERNAL_ERROR;
+		return;
+	}
+
+	memcpy(&ptr, value.dptr, value.dsize);
+	*state->fsp = talloc_get_type_abort(ptr, struct files_struct);
+}
+
 NTSTATUS vfs_offload_token_db_fetch_fsp(struct vfs_offload_ctx *ctx,
 					const DATA_BLOB *token_blob,
 					files_struct **fsp)
 {
-	struct db_record *rec = NULL;
+	struct vfs_offload_token_db_fetch_fsp_state state = { .fsp = fsp };
 	TDB_DATA key = make_tdb_data(token_blob->data, token_blob->length);
-	TDB_DATA value;
-	void *ptr = NULL;
+	NTSTATUS status;
 
-	rec = dbwrap_fetch_locked(ctx->db_ctx, talloc_tos(), key);
-	if (rec == NULL) {
-		return NT_STATUS_INTERNAL_ERROR;
+	status = dbwrap_parse_record(
+		ctx->db_ctx,
+		key,
+		vfs_offload_token_db_fetch_fsp_fn,
+		&state);
+	if (NT_STATUS_EQUAL(status, NT_STATUS_NOT_FOUND)) {
+		status = NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
-
-	value = dbwrap_record_get_value(rec);
-	if (value.dsize == 0) {
+	if (!NT_STATUS_IS_OK(status)) {
 		DBG_DEBUG("Unknown token:\n");
 		dump_data(10, token_blob->data, token_blob->length);
-		TALLOC_FREE(rec);
-		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
-	}
-
-	if (value.dsize != sizeof(ptr)) {
-		DBG_ERR("Bad db entry for token:\n");
-		dump_data(1, token_blob->data, token_blob->length);
-		TALLOC_FREE(rec);
-		return NT_STATUS_INTERNAL_ERROR;
+		return status;
 	}
-
-	memcpy(&ptr, value.dptr, value.dsize);
-	TALLOC_FREE(rec);
-
-	*fsp = talloc_get_type_abort(ptr, struct files_struct);
-	return NT_STATUS_OK;
+	return state.status;
 }
 
 NTSTATUS vfs_offload_token_create_blob(TALLOC_CTX *mem_ctx,
diff --git a/source3/modules/vfs_aio_pthread.c b/source3/modules/vfs_aio_pthread.c
index a7d97223dbd..d13ce2fdc63 100644
--- a/source3/modules/vfs_aio_pthread.c
+++ b/source3/modules/vfs_aio_pthread.c
@@ -318,7 +318,7 @@ static int open_async(const files_struct *fsp,
 		opd->fname));
 
 	/* Cause the calling code to reschedule us. */
-	errno = EINTR; /* Maps to NT_STATUS_RETRY. */
+	errno = EINPROGRESS; /* Maps to NT_STATUS_MORE_PROCESSING_REQUIRED. */
 	return -1;
 }
 
diff --git a/source3/modules/vfs_cap.c b/source3/modules/vfs_cap.c
index f1ec5807b49..e67cb750e0f 100644
--- a/source3/modules/vfs_cap.c
+++ b/source3/modules/vfs_cap.c
@@ -976,6 +976,73 @@ static int cap_fsetxattr(vfs_handle_struct *handle, struct files_struct *fsp, co
         return SMB_VFS_NEXT_FSETXATTR(handle, fsp, cappath, value, size, flags);
 }
 
+static NTSTATUS cap_create_dfs_pathat(vfs_handle_struct *handle,
+			files_struct *dirfsp,
+			const struct smb_filename *smb_fname,
+			const struct referral *reflist,
+			size_t referral_count)
+{
+	char *cappath = capencode(talloc_tos(), smb_fname->base_name);
+	struct smb_filename *cap_smb_fname = NULL;
+	NTSTATUS status;
+
+	if (cappath == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	cap_smb_fname = synthetic_smb_fname(talloc_tos(),
+					cappath,
+					NULL,
+					NULL,
+					smb_fname->flags);
+	if (cap_smb_fname == NULL) {
+		TALLOC_FREE(cappath);
+		return NT_STATUS_NO_MEMORY;
+	}
+	status = SMB_VFS_NEXT_CREATE_DFS_PATHAT(handle,
+			dirfsp,
+			cap_smb_fname,
+			reflist,
+			referral_count);
+	TALLOC_FREE(cappath);
+	TALLOC_FREE(cap_smb_fname);
+	return status;
+}
+
+static NTSTATUS cap_read_dfs_pathat(struct vfs_handle_struct *handle,
+			TALLOC_CTX *mem_ctx,
+			struct files_struct *dirfsp,
+			const struct smb_filename *smb_fname,
+			struct referral **ppreflist,
+			size_t *preferral_count)
+{
+	char *cappath = capencode(talloc_tos(), smb_fname->base_name);
+	struct smb_filename *cap_smb_fname = NULL;
+	NTSTATUS status;
+
+	if (cappath == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	cap_smb_fname = synthetic_smb_fname(talloc_tos(),
+				cappath,
+				NULL,
+				NULL,
+				smb_fname->flags);
+	if (cap_smb_fname == NULL) {
+		TALLOC_FREE(cappath);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	status = SMB_VFS_NEXT_READ_DFS_PATHAT(handle,
+			mem_ctx,
+			dirfsp,
+			cap_smb_fname,
+			ppreflist,
+			preferral_count);
+	TALLOC_FREE(cappath);
+	TALLOC_FREE(cap_smb_fname);
+	return status;
+}
+
 static struct vfs_fn_pointers vfs_cap_fns = {
 	.disk_free_fn = cap_disk_free,
 	.get_quota_fn = cap_get_quota,
@@ -1007,7 +1074,9 @@ static struct vfs_fn_pointers vfs_cap_fns = {
 	.removexattr_fn = cap_removexattr,
 	.fremovexattr_fn = cap_fremovexattr,
 	.setxattr_fn = cap_setxattr,
-	.fsetxattr_fn = cap_fsetxattr
+	.fsetxattr_fn = cap_fsetxattr,
+	.create_dfs_pathat_fn = cap_create_dfs_pathat,
+	.read_dfs_pathat_fn = cap_read_dfs_pathat
 };
 
 static_decl_vfs;
diff --git a/source3/modules/vfs_catia.c b/source3/modules/vfs_catia.c
index 3880f16b10c..5bb55cf89f6 100644
--- a/source3/modules/vfs_catia.c
+++ b/source3/modules/vfs_catia.c
@@ -2072,7 +2072,7 @@ static bool catia_lock(vfs_handle_struct *handle,
 
 static int catia_kernel_flock(struct vfs_handle_struct *handle,
 			      struct files_struct *fsp,
-			      uint32_t share_mode,
+			      uint32_t share_access,
 			      uint32_t access_mask)
 {
 	struct catia_cache *cc = NULL;
@@ -2083,7 +2083,7 @@ static int catia_kernel_flock(struct vfs_handle_struct *handle,
 		return -1;
 	}
 
-	ret = SMB_VFS_NEXT_KERNEL_FLOCK(handle, fsp, share_mode, access_mask);
+	ret = SMB_VFS_NEXT_KERNEL_FLOCK(handle, fsp, share_access, access_mask);
 
 	CATIA_FETCH_FSP_POST_NEXT(&cc, fsp);
 
@@ -2365,6 +2365,86 @@ static NTSTATUS catia_set_dos_attributes(struct vfs_handle_struct *handle,
 	return status;
 }
 
+static NTSTATUS catia_create_dfs_pathat(struct vfs_handle_struct *handle,
+			struct files_struct *dirfsp,
+			const struct smb_filename *smb_fname,
+			const struct referral *reflist,
+			size_t referral_count)
+{
+	char *mapped_name = NULL;
+	const char *path = smb_fname->base_name;
+	struct smb_filename *mapped_smb_fname = NULL;
+	NTSTATUS status;
+
+	status = catia_string_replace_allocate(handle->conn,
+					path,
+					&mapped_name,
+					vfs_translate_to_unix);
+	if (!NT_STATUS_IS_OK(status)) {
+		errno = map_errno_from_nt_status(status);
+		return status;
+	}
+	mapped_smb_fname = synthetic_smb_fname(talloc_tos(),
+					mapped_name,
+					NULL,
+					&smb_fname->st,
+					smb_fname->flags);
+	if (mapped_smb_fname == NULL) {
+		TALLOC_FREE(mapped_name);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	status = SMB_VFS_NEXT_CREATE_DFS_PATHAT(handle,
+					dirfsp,
+					mapped_smb_fname,
+					reflist,
+					referral_count);
+	TALLOC_FREE(mapped_name);
+	TALLOC_FREE(mapped_smb_fname);
+	return status;
+}
+
+static NTSTATUS catia_read_dfs_pathat(struct vfs_handle_struct *handle,
+			TALLOC_CTX *mem_ctx,
+			struct files_struct *dirfsp,
+			const struct smb_filename *smb_fname,
+			struct referral **ppreflist,
+			size_t *preferral_count)
+{
+	char *mapped_name = NULL;
+	const char *path = smb_fname->base_name;
+	struct smb_filename *mapped_smb_fname = NULL;
+	NTSTATUS status;
+
+	status = catia_string_replace_allocate(handle->conn,
+					path,
+					&mapped_name,
+					vfs_translate_to_unix);
+	if (!NT_STATUS_IS_OK(status)) {
+		errno = map_errno_from_nt_status(status);
+		return status;
+	}
+	mapped_smb_fname = synthetic_smb_fname(talloc_tos(),
+					mapped_name,
+					NULL,
+					&smb_fname->st,
+					smb_fname->flags);
+	if (mapped_smb_fname == NULL) {
+		TALLOC_FREE(mapped_name);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	status = SMB_VFS_NEXT_READ_DFS_PATHAT(handle,
+					mem_ctx,
+					dirfsp,
+					mapped_smb_fname,
+					ppreflist,
+					preferral_count);
+	TALLOC_FREE(mapped_name);
+	TALLOC_FREE(mapped_smb_fname);
+	return status;
+}
+
 static struct vfs_fn_pointers vfs_catia_fns = {
 	.connect_fn = catia_connect,
 
@@ -2415,6 +2495,8 @@ static struct vfs_fn_pointers vfs_catia_fns = {
 	.fget_dos_attributes_fn = catia_fget_dos_attributes,
 	.get_compression_fn = catia_get_compression,
 	.set_compression_fn = catia_set_compression,
+	.create_dfs_pathat_fn = catia_create_dfs_pathat,
+	.read_dfs_pathat_fn = catia_read_dfs_pathat,
 
 	/* NT ACL operations. */
 	.get_nt_acl_fn = catia_get_nt_acl,
diff --git a/source3/modules/vfs_ceph.c b/source3/modules/vfs_ceph.c
index 8864b424008..76393a84152 100644
--- a/source3/modules/vfs_ceph.c
+++ b/source3/modules/vfs_ceph.c
@@ -294,11 +294,7 @@ static uint32_t cephwrap_fs_capabilities(struct vfs_handle_struct *handle,
 {
 	uint32_t caps = FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES;
 
-#ifdef HAVE_CEPH_STATX
 	*p_ts_res = TIMESTAMP_SET_NT_OR_BETTER;
-#else
-	*p_ts_res = TIMESTAMP_SET_MSEC;
-#endif
 
 	return caps;
 }
@@ -612,6 +608,9 @@ static int cephwrap_renameat(struct vfs_handle_struct *handle,
 		return result;
 	}
 
+	SMB_ASSERT(srcfsp == srcfsp->conn->cwd_fsp);
+	SMB_ASSERT(dstfsp == dstfsp->conn->cwd_fsp);
+
 	result = ceph_rename(handle->data, smb_fname_src->base_name, smb_fname_dst->base_name);
 	WRAP_RETURN(result);
 }
@@ -666,7 +665,6 @@ static int cephwrap_fsync_recv(struct tevent_req *req,
 	return 0;
 }
 
-#ifdef HAVE_CEPH_STATX
 #define SAMBA_STATX_ATTR_MASK	(CEPH_STATX_BASIC_STATS|CEPH_STATX_BTIME)
 
 static void init_stat_ex_from_ceph_statx(struct stat_ex *dst, const struct ceph_statx *stx)
@@ -782,15 +780,15 @@ static int cephwrap_ntimes(struct vfs_handle_struct *handle,
 	int result;
 	int mask = 0;
 
-	if (!null_timespec(ft->atime)) {
+	if (!is_omit_timespec(&ft->atime)) {
 		stx.stx_atime = ft->atime;
 		mask |= CEPH_SETATTR_ATIME;
 	}
-	if (!null_timespec(ft->mtime)) {
+	if (!is_omit_timespec(&ft->mtime)) {
 		stx.stx_mtime = ft->mtime;
 		mask |= CEPH_SETATTR_MTIME;
 	}
-	if (!null_timespec(ft->create_time)) {
+	if (!is_omit_timespec(&ft->create_time)) {
 		stx.stx_btime = ft->create_time;
 		mask |= CEPH_SETATTR_BTIME;
 	}
@@ -806,126 +804,6 @@ static int cephwrap_ntimes(struct vfs_handle_struct *handle,
 	return result;
 }
 
-#else /* HAVE_CEPH_STATX */
-
-static int cephwrap_stat(struct vfs_handle_struct *handle,
-			struct smb_filename *smb_fname)
-{
-	int result = -1;
-	struct stat stbuf;
-
-	DBG_DEBUG("[CEPH] stat(%p, %s)\n", handle, smb_fname_str_dbg(smb_fname));
-
-	if (smb_fname->stream_name) {
-		errno = ENOENT;
-		return result;
-	}
-
-	result = ceph_stat(handle->data, smb_fname->base_name, (struct stat *) &stbuf);
-	DBG_DEBUG("[CEPH] stat(...) = %d\n", result);
-	if (result < 0) {
-		WRAP_RETURN(result);
-	}
-
-	DBG_DEBUG("[CEPH]\tstbuf = {dev = %llu, ino = %llu, mode = 0x%x, nlink = %llu, "
-		   "uid = %d, gid = %d, rdev = %llu, size = %llu, blksize = %llu, "
-		   "blocks = %llu, atime = %llu, mtime = %llu, ctime = %llu}\n",
-		   llu(stbuf.st_dev), llu(stbuf.st_ino), stbuf.st_mode, llu(stbuf.st_nlink),
-		   stbuf.st_uid, stbuf.st_gid, llu(stbuf.st_rdev), llu(stbuf.st_size), llu(stbuf.st_blksize),
-		   llu(stbuf.st_blocks), llu(stbuf.st_atime), llu(stbuf.st_mtime), llu(stbuf.st_ctime));
-
-	init_stat_ex_from_stat(
-			&smb_fname->st, &stbuf,
-			lp_fake_directory_create_times(SNUM(handle->conn)));
-	DBG_DEBUG("[CEPH] mode = 0x%x\n", smb_fname->st.st_ex_mode);
-	return result;
-}
-
-static int cephwrap_fstat(struct vfs_handle_struct *handle, files_struct *fsp, SMB_STRUCT_STAT *sbuf)
-{
-	int result = -1;
-	struct stat stbuf;
-
-	DBG_DEBUG("[CEPH] fstat(%p, %d)\n", handle, fsp->fh->fd);
-	result = ceph_fstat(handle->data, fsp->fh->fd, (struct stat *) &stbuf);
-	DBG_DEBUG("[CEPH] fstat(...) = %d\n", result);
-	if (result < 0) {
-		WRAP_RETURN(result);
-	}
-
-	DBG_DEBUG("[CEPH]\tstbuf = {dev = %llu, ino = %llu, mode = 0x%x, nlink = %llu, "
-		   "uid = %d, gid = %d, rdev = %llu, size = %llu, blksize = %llu, "
-		   "blocks = %llu, atime = %llu, mtime = %llu, ctime = %llu}\n",
-		   llu(stbuf.st_dev), llu(stbuf.st_ino), stbuf.st_mode, llu(stbuf.st_nlink),
-		   stbuf.st_uid, stbuf.st_gid, llu(stbuf.st_rdev), llu(stbuf.st_size), llu(stbuf.st_blksize),
-		   llu(stbuf.st_blocks), llu(stbuf.st_atime), llu(stbuf.st_mtime), llu(stbuf.st_ctime));
-
-	init_stat_ex_from_stat(
-			sbuf, &stbuf,
-			lp_fake_directory_create_times(SNUM(handle->conn)));
-	DBG_DEBUG("[CEPH] mode = 0x%x\n", sbuf->st_ex_mode);
-	return result;
-}
-
-static int cephwrap_lstat(struct vfs_handle_struct *handle,
-			 struct smb_filename *smb_fname)
-{
-	int result = -1;
-	struct stat stbuf;
-
-	DBG_DEBUG("[CEPH] lstat(%p, %s)\n", handle, smb_fname_str_dbg(smb_fname));
-
-	if (smb_fname->stream_name) {
-		errno = ENOENT;
-		return result;
-	}
-
-	result = ceph_lstat(handle->data, smb_fname->base_name, &stbuf);
-	DBG_DEBUG("[CEPH] lstat(...) = %d\n", result);
-	if (result < 0) {
-		WRAP_RETURN(result);
-	}
-
-	init_stat_ex_from_stat(
-			&smb_fname->st, &stbuf,
-			lp_fake_directory_create_times(SNUM(handle->conn)));
-	return result;
-}
-
-static int cephwrap_ntimes(struct vfs_handle_struct *handle,
-			 const struct smb_filename *smb_fname,
-			 struct smb_file_time *ft)
-{
-	struct utimbuf buf;
-	int result;
-
-	if (null_timespec(ft->atime)) {
-		buf.actime = smb_fname->st.st_ex_atime.tv_sec;
-	} else {
-		buf.actime = ft->atime.tv_sec;
-	}
-	if (null_timespec(ft->mtime)) {
-		buf.modtime = smb_fname->st.st_ex_mtime.tv_sec;
-	} else {
-		buf.modtime = ft->mtime.tv_sec;
-	}
-	if (!null_timespec(ft->create_time)) {
-		set_create_timespec_ea(handle->conn, smb_fname,
-				       ft->create_time);
-	}
-	if (buf.actime == smb_fname->st.st_ex_atime.tv_sec &&
-	    buf.modtime == smb_fname->st.st_ex_mtime.tv_sec) {
-		return 0;
-	}
-
-	result = ceph_utime(handle->data, smb_fname->base_name, &buf);
-	DBG_DEBUG("[CEPH] ntimes(%p, %s, {%ld, %ld, %ld, %ld}) = %d\n", handle, smb_fname_str_dbg(smb_fname),
-				ft->mtime.tv_sec, ft->atime.tv_sec, ft->ctime.tv_sec,
-				ft->create_time.tv_sec, result);
-	return result;
-}
-#endif /* HAVE_CEPH_STATX */
-
 static int cephwrap_unlinkat(struct vfs_handle_struct *handle,
 			struct files_struct *dirfsp,
 			const struct smb_filename *smb_fname,
@@ -1085,8 +963,10 @@ static bool cephwrap_lock(struct vfs_handle_struct *handle, files_struct *fsp, i
 	return true;
 }
 
-static int cephwrap_kernel_flock(struct vfs_handle_struct *handle, files_struct *fsp,
-				uint32_t share_mode, uint32_t access_mask)
+static int cephwrap_kernel_flock(struct vfs_handle_struct *handle,
+				 files_struct *fsp,
+				 uint32_t share_access,
+				 uint32_t access_mask)
 {
 	DBG_ERR("[CEPH] flock unsupported! Consider setting "
 		"\"kernel share modes = no\"\n");
@@ -1095,6 +975,34 @@ static int cephwrap_kernel_flock(struct vfs_handle_struct *handle, files_struct
 	return -1;
 }
 
+static int cephwrap_fcntl(vfs_handle_struct *handle,
+			  files_struct *fsp, int cmd, va_list cmd_arg)
+{
+	/*
+	 * SMB_VFS_FCNTL() is currently only called by vfs_set_blocking() to
+	 * clear O_NONBLOCK, etc for LOCK_MAND and FIFOs. Ignore it.
+	 */
+	if (cmd == F_GETFL) {
+		return 0;
+	} else if (cmd == F_SETFL) {
+		va_list dup_cmd_arg;
+		int opt;
+
+		va_copy(dup_cmd_arg, cmd_arg);
+		opt = va_arg(dup_cmd_arg, int);
+		va_end(dup_cmd_arg);
+		if (opt == 0) {
+			return 0;
+		}
+		DBG_ERR("unexpected fcntl SETFL(%d)\n", opt);
+		goto err_out;
+	}
+	DBG_ERR("unexpected fcntl: %d\n", cmd);
+err_out:
+	errno = EINVAL;
+	return -1;
+}
+
 static bool cephwrap_getlock(struct vfs_handle_struct *handle, files_struct *fsp, off_t *poffset, off_t *pcount, int *ptype, pid_t *ppid)
 {
 	DBG_DEBUG("[CEPH] getlock returning false and errno=0\n");
@@ -1287,11 +1195,7 @@ static ssize_t cephwrap_fgetxattr(struct vfs_handle_struct *handle, struct files
 {
 	int ret;
 	DBG_DEBUG("[CEPH] fgetxattr(%p, %p, %s, %p, %llu)\n", handle, fsp, name, value, llu(size));
-#if LIBCEPHFS_VERSION_CODE >= LIBCEPHFS_VERSION(0, 94, 0)
 	ret = ceph_fgetxattr(handle->data, fsp->fh->fd, name, value, size);
-#else
-	ret = ceph_getxattr(handle->data, fsp->fsp_name->base_name, name, value, size);
-#endif
 	DBG_DEBUG("[CEPH] fgetxattr(...) = %d\n", ret);
 	if (ret < 0) {
 		WRAP_RETURN(ret);
@@ -1320,11 +1224,7 @@ static ssize_t cephwrap_flistxattr(struct vfs_handle_struct *handle, struct file
 	int ret;
 	DBG_DEBUG("[CEPH] flistxattr(%p, %p, %p, %llu)\n",
 		  handle, fsp, list, llu(size));
-#if LIBCEPHFS_VERSION_CODE >= LIBCEPHFS_VERSION(0, 94, 0)
 	ret = ceph_flistxattr(handle->data, fsp->fh->fd, list, size);
-#else
-	ret = ceph_listxattr(handle->data, fsp->fsp_name->base_name, list, size);
-#endif
 	DBG_DEBUG("[CEPH] flistxattr(...) = %d\n", ret);
 	if (ret < 0) {
 		WRAP_RETURN(ret);
@@ -1348,11 +1248,7 @@ static int cephwrap_fremovexattr(struct vfs_handle_struct *handle, struct files_
 {
 	int ret;
 	DBG_DEBUG("[CEPH] fremovexattr(%p, %p, %s)\n", handle, fsp, name);
-#if LIBCEPHFS_VERSION_CODE >= LIBCEPHFS_VERSION(0, 94, 0)
 	ret = ceph_fremovexattr(handle->data, fsp->fh->fd, name);
-#else
-	ret = ceph_removexattr(handle->data, fsp->fsp_name->base_name, name);
-#endif
 	DBG_DEBUG("[CEPH] fremovexattr(...) = %d\n", ret);
 	WRAP_RETURN(ret);
 }
@@ -1377,12 +1273,8 @@ static int cephwrap_fsetxattr(struct vfs_handle_struct *handle, struct files_str
 {
 	int ret;
 	DBG_DEBUG("[CEPH] fsetxattr(%p, %p, %s, %p, %llu, %d)\n", handle, fsp, name, value, llu(size), flags);
-#if LIBCEPHFS_VERSION_CODE >= LIBCEPHFS_VERSION(0, 94, 0)
 	ret = ceph_fsetxattr(handle->data, fsp->fh->fd,
 			     name, value, size, flags);
-#else
-	ret = ceph_setxattr(handle->data, fsp->fsp_name->base_name, name, value, size, flags);
-#endif
 	DBG_DEBUG("[CEPH] fsetxattr(...) = %d\n", ret);
 	WRAP_RETURN(ret);
 }
@@ -1399,6 +1291,145 @@ static bool cephwrap_aio_force(struct vfs_handle_struct *handle, struct files_st
 	return false;
 }
 
+static NTSTATUS cephwrap_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	TALLOC_CTX *frame = talloc_stackframe();
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+	int ret;
+	char *msdfs_link = NULL;
+
+	SMB_ASSERT(dirfsp == dirfsp->conn->cwd_fsp);
+
+	/* Form the msdfs_link contents */
+	msdfs_link = msdfs_link_string(frame,
+					reflist,
+					referral_count);
+	if (msdfs_link == NULL) {
+		goto out;
+	}
+
+	ret = ceph_symlink(handle->data,
+			msdfs_link,
+			smb_fname->base_name);
+	if (ret == 0) {
+		status = NT_STATUS_OK;
+	} else {
+		status = map_nt_error_from_unix(-ret);
+        }
+
+  out:
+
+	DBG_DEBUG("[CEPH] create_dfs_pathat(%s) = %s\n",
+			smb_fname->base_name,
+			nt_errstr(status));
+
+	TALLOC_FREE(frame);
+	return status;
+}
+
+/*
+ * Read and return the contents of a DFS redirect given a
+ * pathname. A caller can pass in NULL for ppreflist and
+ * preferral_count but still determine if this was a
+ * DFS redirect point by getting NT_STATUS_OK back
+ * without incurring the overhead of reading and parsing
+ * the referral contents.
+ */
+
+static NTSTATUS cephwrap_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count)
+{
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+	size_t bufsize;
+	char *link_target = NULL;
+	int referral_len;
+	bool ok;
+#if defined(HAVE_BROKEN_READLINK)
+	char link_target_buf[PATH_MAX];
+#else
+	char link_target_buf[7];
+#endif
+
+	SMB_ASSERT(dirfsp == dirfsp->conn->cwd_fsp);
+
+	if (ppreflist == NULL && preferral_count == NULL) {
+		/*
+		 * We're only checking if this is a DFS
+		 * redirect. We don't need to return data.
+		 */
+		bufsize = sizeof(link_target_buf);
+		link_target = link_target_buf;
+	} else {
+		bufsize = PATH_MAX;
+		link_target = talloc_array(mem_ctx, char, bufsize);
+		if (!link_target) {
+			goto err;
+		}
+	}
+
+        referral_len = ceph_readlink(handle->data,
+                                smb_fname->base_name,
+                                link_target,
+                                bufsize - 1);
+        if (referral_len < 0) {
+		/* ceph errors are -errno. */
+		if (-referral_len == EINVAL) {
+			DBG_INFO("%s is not a link.\n",
+				smb_fname->base_name);
+			status = NT_STATUS_OBJECT_TYPE_MISMATCH;
+		} else {
+	                status = map_nt_error_from_unix(-referral_len);
+			DBG_ERR("Error reading "
+				"msdfs link %s: %s\n",
+				smb_fname->base_name,
+			strerror(errno));
+		}
+                goto err;
+        }
+        link_target[referral_len] = '\0';
+
+        DBG_INFO("%s -> %s\n",
+                        smb_fname->base_name,
+                        link_target);
+
+        if (!strnequal(link_target, "msdfs:", 6)) {
+                status = NT_STATUS_OBJECT_TYPE_MISMATCH;
+                goto err;
+        }
+
+        if (ppreflist == NULL && preferral_count == NULL) {
+                /* Early return for checking if this is a DFS link. */
+                return NT_STATUS_OK;
+        }
+
+        ok = parse_msdfs_symlink(mem_ctx,
+                        lp_msdfs_shuffle_referrals(SNUM(handle->conn)),
+                        link_target,
+                        ppreflist,
+                        preferral_count);
+
+        if (ok) {
+                status = NT_STATUS_OK;
+        } else {
+                status = NT_STATUS_NO_MEMORY;
+        }
+
+  err:
+
+        if (link_target != link_target_buf) {
+                TALLOC_FREE(link_target);
+        }
+        return status;
+}
+
 static struct vfs_fn_pointers ceph_fns = {
 	/* Disk operations */
 
@@ -1423,6 +1454,8 @@ static struct vfs_fn_pointers ceph_fns = {
 
 	/* File operations */
 
+	.create_dfs_pathat_fn = cephwrap_create_dfs_pathat,
+	.read_dfs_pathat_fn = cephwrap_read_dfs_pathat,
 	.open_fn = cephwrap_open,
 	.close_fn = cephwrap_close,
 	.pread_fn = cephwrap_pread,
@@ -1452,6 +1485,7 @@ static struct vfs_fn_pointers ceph_fns = {
 	.fallocate_fn = cephwrap_fallocate,
 	.lock_fn = cephwrap_lock,
 	.kernel_flock_fn = cephwrap_kernel_flock,
+	.fcntl_fn = cephwrap_fcntl,
 	.linux_setlease_fn = cephwrap_linux_setlease,
 	.getlock_fn = cephwrap_getlock,
 	.symlinkat_fn = cephwrap_symlinkat,
diff --git a/source3/modules/vfs_ceph_snapshots.c b/source3/modules/vfs_ceph_snapshots.c
index ce364ae83dc..64f195f4add 100644
--- a/source3/modules/vfs_ceph_snapshots.c
+++ b/source3/modules/vfs_ceph_snapshots.c
@@ -390,8 +390,12 @@ static int ceph_snap_get_shadow_copy_data(struct vfs_handle_struct *handle,
 		parent_dir = tmp;
 	}
 
-	ret = snprintf(snaps_path, sizeof(snaps_path), "%s/%s",
-		       parent_dir, snapdir);
+	if (strlen(parent_dir) == 0) {
+		ret = strlcpy(snaps_path, snapdir, sizeof(snaps_path));
+	} else {
+		ret = snprintf(snaps_path, sizeof(snaps_path), "%s/%s",
+			       parent_dir, snapdir);
+	}
 	if (ret >= sizeof(snaps_path)) {
 		ret = -EINVAL;
 		goto err_out;
@@ -534,7 +538,11 @@ static int ceph_snap_gmt_convert_dir(struct vfs_handle_struct *handle,
 	/*
 	 * Temporally use the caller's return buffer for this.
 	 */
-	ret = snprintf(_converted_buf, buflen, "%s/%s", name, snapdir);
+	if (strlen(name) == 0) {
+		ret = strlcpy(_converted_buf, snapdir, buflen);
+	} else {
+		ret = snprintf(_converted_buf, buflen, "%s/%s", name, snapdir);
+	}
 	if (ret >= buflen) {
 		ret = -EINVAL;
 		goto err_out;
diff --git a/source3/modules/vfs_default.c b/source3/modules/vfs_default.c
index 421772da377..37b59d8c3c0 100644
--- a/source3/modules/vfs_default.c
+++ b/source3/modules/vfs_default.c
@@ -123,6 +123,8 @@ static int vfswrap_statvfs(struct vfs_handle_struct *handle,
 static uint32_t vfswrap_fs_capabilities(struct vfs_handle_struct *handle,
 		enum timestamp_set_resolution *p_ts_res)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	connection_struct *conn = handle->conn;
 	uint32_t caps = FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES;
 	struct smb_filename *smb_fname_cpath = NULL;
@@ -174,7 +176,7 @@ static uint32_t vfswrap_fs_capabilities(struct vfs_handle_struct *handle,
 			"resolution of %s "
 			"available on share %s, directory %s\n",
 			*p_ts_res == TIMESTAMP_SET_MSEC ? "msec" : "sec",
-			lp_servicename(talloc_tos(), conn->params->service),
+			lp_servicename(talloc_tos(), lp_sub, conn->params->service),
 			conn->connectpath ));
 	}
 	TALLOC_FREE(smb_fname_cpath);
@@ -190,7 +192,7 @@ static NTSTATUS vfswrap_get_dfs_referrals(struct vfs_handle_struct *handle,
 	char *pathnamep = NULL;
 	char *local_dfs_path = NULL;
 	NTSTATUS status;
-	int i;
+	size_t i;
 	uint16_t max_referral_level = r->in.req.max_referral_level;
 
 	if (DEBUGLVL(10)) {
@@ -223,7 +225,9 @@ static NTSTATUS vfswrap_get_dfs_referrals(struct vfs_handle_struct *handle,
 	}
 
 	/* The following call can change cwd. */
-	status = get_referred_path(r, pathnamep,
+	status = get_referred_path(r,
+				   handle->conn->session_info,
+				   pathnamep,
 				   handle->conn->sconn->remote_address,
 				   handle->conn->sconn->local_address,
 				   !handle->conn->sconn->using_smb2,
@@ -364,6 +368,144 @@ static NTSTATUS vfswrap_get_dfs_referrals(struct vfs_handle_struct *handle,
 	return NT_STATUS_OK;
 }
 
+static NTSTATUS vfswrap_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	TALLOC_CTX *frame = talloc_stackframe();
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+	int ret;
+	char *msdfs_link = NULL;
+
+	SMB_ASSERT(dirfsp == dirfsp->conn->cwd_fsp);
+
+	/* Form the msdfs_link contents */
+	msdfs_link = msdfs_link_string(frame,
+					reflist,
+					referral_count);
+	if (msdfs_link == NULL) {
+		goto out;
+	}
+
+	ret = symlinkat(msdfs_link,
+			dirfsp->fh->fd,
+			smb_fname->base_name);
+	if (ret == 0) {
+		status = NT_STATUS_OK;
+	} else {
+		status = map_nt_error_from_unix(errno);
+	}
+
+  out:
+
+	TALLOC_FREE(frame);
+	return status;
+}
+
+/*
+ * Read and return the contents of a DFS redirect given a
+ * pathname. A caller can pass in NULL for ppreflist and
+ * preferral_count but still determine if this was a
+ * DFS redirect point by getting NT_STATUS_OK back
+ * without incurring the overhead of reading and parsing
+ * the referral contents.
+ */
+
+static NTSTATUS vfswrap_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count)
+{
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+	size_t bufsize;
+	char *link_target = NULL;
+	int referral_len;
+	bool ok;
+#if defined(HAVE_BROKEN_READLINK)
+	char link_target_buf[PATH_MAX];
+#else
+	char link_target_buf[7];
+#endif
+
+	SMB_ASSERT(dirfsp == dirfsp->conn->cwd_fsp);
+
+	if (ppreflist == NULL && preferral_count == NULL) {
+		/*
+		 * We're only checking if this is a DFS
+		 * redirect. We don't need to return data.
+		 */
+		bufsize = sizeof(link_target_buf);
+		link_target = link_target_buf;
+	} else {
+		bufsize = PATH_MAX;
+		link_target = talloc_array(mem_ctx, char, bufsize);
+		if (!link_target) {
+			goto err;
+		}
+	}
+
+	referral_len = readlinkat(dirfsp->fh->fd,
+				smb_fname->base_name,
+				link_target,
+				bufsize - 1);
+	if (referral_len == -1) {
+		if (errno == EINVAL) {
+			/*
+			 * If the path isn't a link, readlinkat
+			 * returns EINVAL. Allow the caller to
+			 * detect this.
+			 */
+			DBG_INFO("%s is not a link.\n", smb_fname->base_name);
+			status = NT_STATUS_OBJECT_TYPE_MISMATCH;
+		} else {
+			status = map_nt_error_from_unix(errno);
+			DBG_ERR("Error reading "
+				"msdfs link %s: %s\n",
+				smb_fname->base_name,
+				strerror(errno));
+		}
+                goto err;
+        }
+	link_target[referral_len] = '\0';
+
+	DBG_INFO("%s -> %s\n",
+			smb_fname->base_name,
+			link_target);
+
+	if (!strnequal(link_target, "msdfs:", 6)) {
+		status = NT_STATUS_OBJECT_TYPE_MISMATCH;
+		goto err;
+	}
+
+	if (ppreflist == NULL && preferral_count == NULL) {
+		/* Early return for checking if this is a DFS link. */
+		return NT_STATUS_OK;
+	}
+
+	ok = parse_msdfs_symlink(mem_ctx,
+			lp_msdfs_shuffle_referrals(SNUM(handle->conn)),
+			link_target,
+			ppreflist,
+			preferral_count);
+
+	if (ok) {
+		status = NT_STATUS_OK;
+	} else {
+		status = NT_STATUS_NO_MEMORY;
+	}
+
+  err:
+
+	if (link_target != link_target_buf) {
+		TALLOC_FREE(link_target);
+	}
+	return status;
+}
+
 static NTSTATUS vfswrap_snap_check_path(struct vfs_handle_struct *handle,
 					TALLOC_CTX *mem_ctx,
 					const char *service_path,
@@ -2330,15 +2472,15 @@ static int vfswrap_ntimes(vfs_handle_struct *handle,
 	}
 
 	if (ft != NULL) {
-		if (null_timespec(ft->atime)) {
+		if (is_omit_timespec(&ft->atime)) {
 			ft->atime= smb_fname->st.st_ex_atime;
 		}
 
-		if (null_timespec(ft->mtime)) {
+		if (is_omit_timespec(&ft->mtime)) {
 			ft->mtime = smb_fname->st.st_ex_mtime;
 		}
 
-		if (!null_timespec(ft->create_time)) {
+		if (!is_omit_timespec(&ft->create_time)) {
 			set_create_timespec_ea(handle->conn,
 					       smb_fname,
 					       ft->create_time);
@@ -2583,10 +2725,10 @@ static bool vfswrap_lock(vfs_handle_struct *handle, files_struct *fsp, int op, o
 }
 
 static int vfswrap_kernel_flock(vfs_handle_struct *handle, files_struct *fsp,
-				uint32_t share_mode, uint32_t access_mask)
+				uint32_t share_access, uint32_t access_mask)
 {
 	START_PROFILE(syscall_kernel_flock);
-	kernel_flock(fsp->fh->fd, share_mode, access_mask);
+	kernel_flock(fsp->fh->fd, share_access, access_mask);
 	END_PROFILE(syscall_kernel_flock);
 	return 0;
 }
@@ -3476,6 +3618,8 @@ static struct vfs_fn_pointers vfs_default_fns = {
 	.statvfs_fn = vfswrap_statvfs,
 	.fs_capabilities_fn = vfswrap_fs_capabilities,
 	.get_dfs_referrals_fn = vfswrap_get_dfs_referrals,
+	.create_dfs_pathat_fn = vfswrap_create_dfs_pathat,
+	.read_dfs_pathat_fn = vfswrap_read_dfs_pathat,
 	.snap_check_path_fn = vfswrap_snap_check_path,
 	.snap_create_fn = vfswrap_snap_create,
 	.snap_delete_fn = vfswrap_snap_delete,
diff --git a/source3/modules/vfs_dfs_samba4.c b/source3/modules/vfs_dfs_samba4.c
index 1c7b50e99c6..2900c29156e 100644
--- a/source3/modules/vfs_dfs_samba4.c
+++ b/source3/modules/vfs_dfs_samba4.c
@@ -97,8 +97,11 @@ static int dfs_samba4_connect(struct vfs_handle_struct *handle,
 
 static void dfs_samba4_disconnect(struct vfs_handle_struct *handle)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
 	DEBUG(10,("dfs_samba4_disconnect() connect to service[%s].\n",
-		  lp_servicename(talloc_tos(), SNUM(handle->conn))));
+		  lp_servicename(talloc_tos(), lp_sub, SNUM(handle->conn))));
 
 	SMB_VFS_NEXT_DISCONNECT(handle);
 }
diff --git a/source3/modules/vfs_error_inject.c b/source3/modules/vfs_error_inject.c
index c8c3ea4701f..c7a99370b2a 100644
--- a/source3/modules/vfs_error_inject.c
+++ b/source3/modules/vfs_error_inject.c
@@ -29,6 +29,7 @@ struct unix_error_map {
 } unix_error_map_array[] = {
 	{	"ESTALE",	ESTALE	},
 	{	"EBADF",	EBADF	},
+	{	"EINTR",	EINTR	},
 };
 
 static int find_unix_error_from_string(const char *err_str)
@@ -106,9 +107,25 @@ static ssize_t vfs_error_inject_pwrite(vfs_handle_struct *handle,
 	return SMB_VFS_NEXT_PWRITE(handle, fsp, data, n, offset);
 }
 
+static int vfs_error_inject_open(
+	struct vfs_handle_struct *handle,
+	struct smb_filename *smb_fname,
+	files_struct *fsp,
+	int flags,
+	mode_t mode)
+{
+	int error = inject_unix_error("open", handle);
+	if (error != 0) {
+		errno = error;
+		return -1;
+	}
+	return SMB_VFS_NEXT_OPEN(handle, smb_fname, fsp, flags, mode);
+}
+
 static struct vfs_fn_pointers vfs_error_inject_fns = {
 	.chdir_fn = vfs_error_inject_chdir,
 	.pwrite_fn = vfs_error_inject_pwrite,
+	.open_fn = vfs_error_inject_open,
 };
 
 static_decl_vfs;
diff --git a/source3/modules/vfs_expand_msdfs.c b/source3/modules/vfs_expand_msdfs.c
index 23ea136620c..6845b81b0cb 100644
--- a/source3/modules/vfs_expand_msdfs.c
+++ b/source3/modules/vfs_expand_msdfs.c
@@ -112,6 +112,8 @@ static char *expand_msdfs_target(TALLOC_CTX *ctx,
 				connection_struct *conn,
 				char *target)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *mapfilename = NULL;
 	char *filename_start = strchr_m(target, '@');
 	char *filename_end = NULL;
@@ -155,7 +157,7 @@ static char *expand_msdfs_target(TALLOC_CTX *ctx,
 	}
 
 	targethost = talloc_sub_full(ctx,
-				lp_servicename(talloc_tos(), SNUM(conn)),
+				lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 				conn->session_info->unix_info->unix_name,
 				conn->connectpath,
 				conn->session_info->unix_token->gid,
diff --git a/source3/modules/vfs_fileid.c b/source3/modules/vfs_fileid.c
index d7e9090bc18..4157e1d1b40 100644
--- a/source3/modules/vfs_fileid.c
+++ b/source3/modules/vfs_fileid.c
@@ -467,8 +467,11 @@ static int fileid_connect(struct vfs_handle_struct *handle,
 
 static void fileid_disconnect(struct vfs_handle_struct *handle)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
 	DEBUG(10,("fileid_disconnect() connect to service[%s].\n",
-		  lp_servicename(talloc_tos(), SNUM(handle->conn))));
+		  lp_servicename(talloc_tos(), lp_sub, SNUM(handle->conn))));
 
 	SMB_VFS_NEXT_DISCONNECT(handle);
 }
diff --git a/source3/modules/vfs_fruit.c b/source3/modules/vfs_fruit.c
index 02aaa34da88..ebf3e18af2f 100644
--- a/source3/modules/vfs_fruit.c
+++ b/source3/modules/vfs_fruit.c
@@ -1254,6 +1254,8 @@ static int fruit_connect(vfs_handle_struct *handle,
 	int rc;
 	char *list = NULL, *newlist = NULL;
 	struct fruit_config_data *config;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	DEBUG(10, ("fruit_connect\n"));
 
@@ -1271,7 +1273,7 @@ static int fruit_connect(vfs_handle_struct *handle,
 				struct fruit_config_data, return -1);
 
 	if (config->veto_appledouble) {
-		list = lp_veto_files(talloc_tos(), SNUM(handle->conn));
+		list = lp_veto_files(talloc_tos(), lp_sub, SNUM(handle->conn));
 
 		if (list) {
 			if (strstr(list, "/" ADOUBLE_NAME_PREFIX "*/") == NULL) {
@@ -3799,7 +3801,7 @@ static int fruit_ntimes(vfs_handle_struct *handle,
 				return -1);
 
 	if ((config->meta != FRUIT_META_NETATALK) ||
-	    null_timespec(ft->create_time))
+	    is_omit_timespec(&ft->create_time))
 	{
 		return SMB_VFS_NEXT_NTIMES(handle, smb_fname, ft);
 	}
diff --git a/source3/modules/vfs_full_audit.c b/source3/modules/vfs_full_audit.c
index b89996b7a56..5c8267dea9f 100644
--- a/source3/modules/vfs_full_audit.c
+++ b/source3/modules/vfs_full_audit.c
@@ -101,6 +101,8 @@ typedef enum _vfs_op_type {
 	SMB_VFS_OP_STATVFS,
 	SMB_VFS_OP_FS_CAPABILITIES,
 	SMB_VFS_OP_GET_DFS_REFERRALS,
+	SMB_VFS_OP_CREATE_DFS_PATHAT,
+	SMB_VFS_OP_READ_DFS_PATHAT,
 
 	/* Directory operations */
 
@@ -249,6 +251,8 @@ static struct {
 	{ SMB_VFS_OP_STATVFS,	"statvfs" },
 	{ SMB_VFS_OP_FS_CAPABILITIES,	"fs_capabilities" },
 	{ SMB_VFS_OP_GET_DFS_REFERRALS,	"get_dfs_referrals" },
+	{ SMB_VFS_OP_CREATE_DFS_PATHAT,	"create_dfs_pathat" },
+	{ SMB_VFS_OP_READ_DFS_PATHAT,	"read_dfs_pathat" },
 	{ SMB_VFS_OP_OPENDIR,	"opendir" },
 	{ SMB_VFS_OP_FDOPENDIR,	"fdopendir" },
 	{ SMB_VFS_OP_READDIR,	"readdir" },
@@ -475,6 +479,8 @@ static int audit_syslog_priority(vfs_handle_struct *handle)
 
 static char *audit_prefix(TALLOC_CTX *ctx, connection_struct *conn)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *prefix = NULL;
 	char *result;
 
@@ -485,7 +491,7 @@ static char *audit_prefix(TALLOC_CTX *ctx, connection_struct *conn)
 		return NULL;
 	}
 	result = talloc_sub_full(ctx,
-			lp_servicename(talloc_tos(), SNUM(conn)),
+			lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 			conn->session_info->unix_info->unix_name,
 			conn->connectpath,
 			conn->session_info->unix_token->gid,
@@ -771,10 +777,13 @@ static int smb_full_audit_connect(vfs_handle_struct *handle,
 
 static void smb_full_audit_disconnect(vfs_handle_struct *handle)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
 	SMB_VFS_NEXT_DISCONNECT(handle);
 
 	do_log(SMB_VFS_OP_DISCONNECT, True, handle,
-	       "%s", lp_servicename(talloc_tos(), SNUM(handle->conn)));
+	       "%s", lp_servicename(talloc_tos(), lp_sub, SNUM(handle->conn)));
 
 	/* The bitmaps will be disconnected when the private
 	   data is deleted. */
@@ -885,6 +894,54 @@ static NTSTATUS smb_full_audit_get_dfs_referrals(
 	return status;
 }
 
+static NTSTATUS smb_full_audit_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	NTSTATUS status;
+
+	status = SMB_VFS_NEXT_CREATE_DFS_PATHAT(handle,
+			dirfsp,
+			smb_fname,
+			reflist,
+			referral_count);
+
+	do_log(SMB_VFS_OP_CREATE_DFS_PATHAT,
+		NT_STATUS_IS_OK(status),
+		handle,
+		"%s",
+		smb_fname_str_do_log(handle->conn, smb_fname));
+
+	return status;
+}
+
+static NTSTATUS smb_full_audit_read_dfs_pathat(struct vfs_handle_struct *handle,
+			TALLOC_CTX *mem_ctx,
+			struct files_struct *dirfsp,
+			const struct smb_filename *smb_fname,
+			struct referral **ppreflist,
+			size_t *preferral_count)
+{
+	NTSTATUS status;
+
+	status = SMB_VFS_NEXT_READ_DFS_PATHAT(handle,
+			mem_ctx,
+			dirfsp,
+			smb_fname,
+			ppreflist,
+			preferral_count);
+
+	do_log(SMB_VFS_OP_READ_DFS_PATHAT,
+		NT_STATUS_IS_OK(status),
+		handle,
+		"%s",
+		smb_fname_str_do_log(handle->conn, smb_fname));
+
+	return status;
+}
+
 static NTSTATUS smb_full_audit_snap_check_path(struct vfs_handle_struct *handle,
 					       TALLOC_CTX *mem_ctx,
 					       const char *service_path,
@@ -1688,11 +1745,15 @@ static bool smb_full_audit_lock(vfs_handle_struct *handle, files_struct *fsp,
 
 static int smb_full_audit_kernel_flock(struct vfs_handle_struct *handle,
 				       struct files_struct *fsp,
-				       uint32_t share_mode, uint32_t access_mask)
+				       uint32_t share_access,
+				       uint32_t access_mask)
 {
 	int result;
 
-	result = SMB_VFS_NEXT_KERNEL_FLOCK(handle, fsp, share_mode, access_mask);
+	result = SMB_VFS_NEXT_KERNEL_FLOCK(handle,
+					   fsp,
+					   share_access,
+					   access_mask);
 
 	do_log(SMB_VFS_OP_KERNEL_FLOCK, (result >= 0), handle, "%s",
 	       fsp_str_do_log(fsp));
@@ -2926,6 +2987,8 @@ static struct vfs_fn_pointers vfs_full_audit_fns = {
 	.statvfs_fn = smb_full_audit_statvfs,
 	.fs_capabilities_fn = smb_full_audit_fs_capabilities,
 	.get_dfs_referrals_fn = smb_full_audit_get_dfs_referrals,
+	.create_dfs_pathat_fn = smb_full_audit_create_dfs_pathat,
+	.read_dfs_pathat_fn = smb_full_audit_read_dfs_pathat,
 	.opendir_fn = smb_full_audit_opendir,
 	.fdopendir_fn = smb_full_audit_fdopendir,
 	.readdir_fn = smb_full_audit_readdir,
diff --git a/source3/modules/vfs_glusterfs.c b/source3/modules/vfs_glusterfs.c
index a28b48dae45..d4b68fba376 100644
--- a/source3/modules/vfs_glusterfs.c
+++ b/source3/modules/vfs_glusterfs.c
@@ -268,6 +268,8 @@ static int vfs_gluster_connect(struct vfs_handle_struct *handle,
 			       const char *service,
 			       const char *user)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char *volfile_servers;
 	const char *volume;
 	char *logfile;
@@ -281,14 +283,21 @@ static int vfs_gluster_connect(struct vfs_handle_struct *handle,
 		ret = -1;
 		goto done;
 	}
-	logfile = lp_parm_talloc_string(tmp_ctx, SNUM(handle->conn), "glusterfs",
-				       "logfile", NULL);
+	logfile = lp_parm_substituted_string(tmp_ctx,
+					     lp_sub,
+					     SNUM(handle->conn),
+					     "glusterfs",
+					     "logfile",
+					     NULL);
 
 	loglevel = lp_parm_int(SNUM(handle->conn), "glusterfs", "loglevel", -1);
 
-	volfile_servers = lp_parm_talloc_string(tmp_ctx, SNUM(handle->conn),
-					       "glusterfs", "volfile_server",
-					       NULL);
+	volfile_servers = lp_parm_substituted_string(tmp_ctx,
+						     lp_sub,
+						     SNUM(handle->conn),
+						     "glusterfs",
+						     "volfile_server",
+						     NULL);
 	if (volfile_servers == NULL) {
 		volfile_servers = DEFAULT_VOLFILE_SERVER;
 	}
@@ -564,7 +573,10 @@ static struct dirent *vfs_gluster_readdir(struct vfs_handle_struct *handle,
 	}
 
 	if (sbuf != NULL) {
-		smb_stat_ex_from_stat(sbuf, &stat);
+		SET_STAT_INVALID(*sbuf);
+		if (!S_ISLNK(stat.st_mode)) {
+			smb_stat_ex_from_stat(sbuf, &stat);
+		}
 	}
 
 	END_PROFILE(syscall_readdir);
@@ -1409,7 +1421,7 @@ static int vfs_gluster_ntimes(struct vfs_handle_struct *handle,
 
 	START_PROFILE(syscall_ntimes);
 
-	if (null_timespec(ft->atime)) {
+	if (is_omit_timespec(&ft->atime)) {
 		times[0].tv_sec = smb_fname->st.st_ex_atime.tv_sec;
 		times[0].tv_nsec = smb_fname->st.st_ex_atime.tv_nsec;
 	} else {
@@ -1417,7 +1429,7 @@ static int vfs_gluster_ntimes(struct vfs_handle_struct *handle,
 		times[0].tv_nsec = ft->atime.tv_nsec;
 	}
 
-	if (null_timespec(ft->mtime)) {
+	if (is_omit_timespec(&ft->mtime)) {
 		times[1].tv_sec = smb_fname->st.st_ex_mtime.tv_sec;
 		times[1].tv_nsec = smb_fname->st.st_ex_mtime.tv_nsec;
 	} else {
@@ -1592,13 +1604,41 @@ out:
 }
 
 static int vfs_gluster_kernel_flock(struct vfs_handle_struct *handle,
-				    files_struct *fsp, uint32_t share_mode,
+				    files_struct *fsp, uint32_t share_access,
 				    uint32_t access_mask)
 {
 	errno = ENOSYS;
 	return -1;
 }
 
+static int vfs_gluster_fcntl(vfs_handle_struct *handle,
+			     files_struct *fsp, int cmd, va_list cmd_arg)
+{
+	/*
+	 * SMB_VFS_FCNTL() is currently only called by vfs_set_blocking() to
+	 * clear O_NONBLOCK, etc for LOCK_MAND and FIFOs. Ignore it.
+	 */
+	if (cmd == F_GETFL) {
+		return 0;
+	} else if (cmd == F_SETFL) {
+		va_list dup_cmd_arg;
+		int opt;
+
+		va_copy(dup_cmd_arg, cmd_arg);
+		opt = va_arg(dup_cmd_arg, int);
+		va_end(dup_cmd_arg);
+		if (opt == 0) {
+			return 0;
+		}
+		DBG_ERR("unexpected fcntl SETFL(%d)\n", opt);
+		goto err_out;
+	}
+	DBG_ERR("unexpected fcntl: %d\n", cmd);
+err_out:
+	errno = EINVAL;
+	return -1;
+}
+
 static int vfs_gluster_linux_setlease(struct vfs_handle_struct *handle,
 				      files_struct *fsp, int leasetype)
 {
@@ -1857,6 +1897,139 @@ static bool vfs_gluster_aio_force(struct vfs_handle_struct *handle,
 	return false;
 }
 
+static NTSTATUS vfs_gluster_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	TALLOC_CTX *frame = talloc_stackframe();
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+	int ret;
+	char *msdfs_link = NULL;
+
+	SMB_ASSERT(dirfsp == dirfsp->conn->cwd_fsp);
+
+	/* Form the msdfs_link contents */
+	msdfs_link = msdfs_link_string(frame,
+					reflist,
+					referral_count);
+	if (msdfs_link == NULL) {
+		goto out;
+	}
+
+	ret = glfs_symlink(handle->data,
+			msdfs_link,
+			smb_fname->base_name);
+	if (ret == 0) {
+		status = NT_STATUS_OK;
+	} else {
+		status = map_nt_error_from_unix(errno);
+	}
+
+  out:
+
+	TALLOC_FREE(frame);
+	return status;
+}
+
+/*
+ * Read and return the contents of a DFS redirect given a
+ * pathname. A caller can pass in NULL for ppreflist and
+ * preferral_count but still determine if this was a
+ * DFS redirect point by getting NT_STATUS_OK back
+ * without incurring the overhead of reading and parsing
+ * the referral contents.
+ */
+
+static NTSTATUS vfs_gluster_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count)
+{
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+	size_t bufsize;
+	char *link_target = NULL;
+	int referral_len;
+	bool ok;
+#if defined(HAVE_BROKEN_READLINK)
+	char link_target_buf[PATH_MAX];
+#else
+	char link_target_buf[7];
+#endif
+
+	SMB_ASSERT(dirfsp == dirfsp->conn->cwd_fsp);
+
+	if (ppreflist == NULL && preferral_count == NULL) {
+		/*
+		 * We're only checking if this is a DFS
+		 * redirect. We don't need to return data.
+		 */
+		bufsize = sizeof(link_target_buf);
+		link_target = link_target_buf;
+	} else {
+		bufsize = PATH_MAX;
+		link_target = talloc_array(mem_ctx, char, bufsize);
+		if (!link_target) {
+			goto err;
+		}
+	}
+
+	referral_len = glfs_readlink(handle->data,
+				smb_fname->base_name,
+				link_target,
+				bufsize - 1);
+	if (referral_len < 0) {
+		if (errno == EINVAL) {
+			DBG_INFO("%s is not a link.\n", smb_fname->base_name);
+			status = NT_STATUS_OBJECT_TYPE_MISMATCH;
+		} else {
+			status = map_nt_error_from_unix(errno);
+			DBG_ERR("Error reading "
+				"msdfs link %s: %s\n",
+				smb_fname->base_name,
+				strerror(errno));
+		}
+		goto err;
+	}
+	link_target[referral_len] = '\0';
+
+	DBG_INFO("%s -> %s\n",
+			smb_fname->base_name,
+			link_target);
+
+	if (!strnequal(link_target, "msdfs:", 6)) {
+		status = NT_STATUS_OBJECT_TYPE_MISMATCH;
+		goto err;
+	}
+
+	if (ppreflist == NULL && preferral_count == NULL) {
+		/* Early return for checking if this is a DFS link. */
+		return NT_STATUS_OK;
+	}
+
+	ok = parse_msdfs_symlink(mem_ctx,
+			lp_msdfs_shuffle_referrals(SNUM(handle->conn)),
+			link_target,
+			ppreflist,
+			preferral_count);
+
+	if (ok) {
+		status = NT_STATUS_OK;
+	} else {
+		status = NT_STATUS_NO_MEMORY;
+	}
+
+  err:
+
+	if (link_target != link_target_buf) {
+		TALLOC_FREE(link_target);
+	}
+	return status;
+}
+
 static struct vfs_fn_pointers glusterfs_fns = {
 
 	/* Disk Operations */
@@ -1917,6 +2090,7 @@ static struct vfs_fn_pointers glusterfs_fns = {
 	.fallocate_fn = vfs_gluster_fallocate,
 	.lock_fn = vfs_gluster_lock,
 	.kernel_flock_fn = vfs_gluster_kernel_flock,
+	.fcntl_fn = vfs_gluster_fcntl,
 	.linux_setlease_fn = vfs_gluster_linux_setlease,
 	.getlock_fn = vfs_gluster_getlock,
 	.symlinkat_fn = vfs_gluster_symlinkat,
@@ -1929,6 +2103,8 @@ static struct vfs_fn_pointers glusterfs_fns = {
 	.streaminfo_fn = NULL,
 	.get_real_filename_fn = vfs_gluster_get_real_filename,
 	.connectpath_fn = vfs_gluster_connectpath,
+	.create_dfs_pathat_fn = vfs_gluster_create_dfs_pathat,
+	.read_dfs_pathat_fn = vfs_gluster_read_dfs_pathat,
 
 	.brl_lock_windows_fn = NULL,
 	.brl_unlock_windows_fn = NULL,
diff --git a/source3/modules/vfs_gpfs.c b/source3/modules/vfs_gpfs.c
index 558f57c2417..de18d32ac23 100644
--- a/source3/modules/vfs_gpfs.c
+++ b/source3/modules/vfs_gpfs.c
@@ -77,62 +77,84 @@ static inline gpfs_ace_v4_t *gpfs_ace_ptr(gpfs_acl_t *gacl, unsigned int i)
 	return &gacl->ace_v4[i];
 }
 
-static bool set_gpfs_sharemode(files_struct *fsp, uint32_t access_mask,
-			       uint32_t share_access)
+static unsigned int vfs_gpfs_access_mask_to_allow(uint32_t access_mask)
 {
 	unsigned int allow = GPFS_SHARE_NONE;
-	unsigned int deny = GPFS_DENY_NONE;
-	int result;
 
-	if ((fsp == NULL) || (fsp->fh == NULL) || (fsp->fh->fd < 0)) {
-		/* No real file, don't disturb */
-		return True;
+	if (access_mask & (FILE_WRITE_DATA|FILE_APPEND_DATA)) {
+		allow |= GPFS_SHARE_WRITE;
+	}
+	if (access_mask & (FILE_READ_DATA|FILE_EXECUTE)) {
+		allow |= GPFS_SHARE_READ;
 	}
 
-	allow |= (access_mask & (FILE_WRITE_DATA|FILE_APPEND_DATA)) ?
-		GPFS_SHARE_WRITE : 0;
-	allow |= (access_mask & (FILE_READ_DATA|FILE_EXECUTE)) ?
-		GPFS_SHARE_READ : 0;
+	return allow;
+}
+
+static unsigned int vfs_gpfs_share_access_to_deny(uint32_t share_access)
+{
+	unsigned int deny = GPFS_DENY_NONE;
 
-	if (allow == GPFS_SHARE_NONE) {
-		DEBUG(10, ("special case am=no_access:%x\n",access_mask));
+	if (!(share_access & FILE_SHARE_WRITE)) {
+		deny |= GPFS_DENY_WRITE;
+	}
+	if (!(share_access & FILE_SHARE_READ)) {
+		deny |= GPFS_DENY_READ;
 	}
-	else {
-		deny |= (share_access & FILE_SHARE_WRITE) ?
-			0 : GPFS_DENY_WRITE;
-		deny |= (share_access & (FILE_SHARE_READ)) ?
-			0 : GPFS_DENY_READ;
 
-		/*
-		 * GPFS_DENY_DELETE can only be set together with either
-		 * GPFS_DENY_WRITE or GPFS_DENY_READ.
-		 */
-		if (deny & (GPFS_DENY_WRITE|GPFS_DENY_READ)) {
-			deny |= (share_access & (FILE_SHARE_DELETE)) ?
-				0 : GPFS_DENY_DELETE;
-		}
+	/*
+	 * GPFS_DENY_DELETE can only be set together with either
+	 * GPFS_DENY_WRITE or GPFS_DENY_READ.
+	 */
+	if ((deny & (GPFS_DENY_WRITE|GPFS_DENY_READ)) &&
+	    !(share_access & FILE_SHARE_DELETE)) {
+		deny |= GPFS_DENY_DELETE;
 	}
-	DEBUG(10, ("am=%x, allow=%d, sa=%x, deny=%d\n",
-		   access_mask, allow, share_access, deny));
+
+	return deny;
+}
+
+static int set_gpfs_sharemode(files_struct *fsp, uint32_t access_mask,
+			      uint32_t share_access)
+{
+	unsigned int allow = GPFS_SHARE_NONE;
+	unsigned int deny = GPFS_DENY_NONE;
+	int result;
+
+	if (access_mask == 0) {
+		DBG_DEBUG("Clearing file system share mode.\n");
+	} else {
+		allow = vfs_gpfs_access_mask_to_allow(access_mask);
+		deny = vfs_gpfs_share_access_to_deny(share_access);
+	}
+	DBG_DEBUG("access_mask=0x%x, allow=0x%x, share_access=0x%x, "
+		  "deny=0x%x\n", access_mask, allow, share_access, deny);
 
 	result = gpfswrap_set_share(fsp->fh->fd, allow, deny);
-	if (result != 0) {
-		if (errno == ENOSYS) {
-			DEBUG(5, ("VFS module vfs_gpfs loaded, but gpfs "
-				  "set_share function support not available. "
-				  "Allowing access\n"));
-			return True;
-		} else {
-			DEBUG(10, ("gpfs_set_share failed: %s\n",
-				   strerror(errno)));
-		}
+	if (result == 0) {
+		return 0;
+	}
+
+	if (errno == EACCES) {
+		DBG_NOTICE("GPFS share mode denied for %s/%s.\n",
+			   fsp->conn->connectpath,
+			   fsp->fsp_name->base_name);
+	} else if (errno == EPERM) {
+		DBG_ERR("Samba requested GPFS sharemode for %s/%s, but the "
+			"GPFS file system is not configured accordingly. "
+			"Configure file system with mmchfs -D nfs4 or "
+			"set gpfs:sharemodes=no in Samba.\n",
+			fsp->conn->connectpath,
+			fsp->fsp_name->base_name);
+	} else {
+		DBG_ERR("gpfs_set_share failed: %s\n", strerror(errno));
 	}
 
-	return (result == 0);
+	return result;
 }
 
 static int vfs_gpfs_kernel_flock(vfs_handle_struct *handle, files_struct *fsp,
-				 uint32_t share_mode, uint32_t access_mask)
+				 uint32_t share_access, uint32_t access_mask)
 {
 
 	struct gpfs_config_data *config;
@@ -154,15 +176,15 @@ static int vfs_gpfs_kernel_flock(vfs_handle_struct *handle, files_struct *fsp,
 	 * kernel_flock and set_gpfs_sharemode for stream.
 	 */
 	if (is_named_stream(fsp->fsp_name)) {
-		DEBUG(2,("%s: kernel_flock on stream\n", fsp_str_dbg(fsp)));
+		DBG_NOTICE("Not requesting GPFS sharemode on stream: %s/%s\n",
+			   fsp->conn->connectpath,
+			   fsp_str_dbg(fsp));
 		return 0;
 	}
 
-	kernel_flock(fsp->fh->fd, share_mode, access_mask);
+	kernel_flock(fsp->fh->fd, share_access, access_mask);
 
-	if (!set_gpfs_sharemode(fsp, access_mask, share_mode)) {
-		ret = -1;
-	}
+	ret = set_gpfs_sharemode(fsp, access_mask, share_access);
 
 	END_PROFILE(syscall_kernel_flock);
 
@@ -178,8 +200,20 @@ static int vfs_gpfs_close(vfs_handle_struct *handle, files_struct *fsp)
 				struct gpfs_config_data,
 				return -1);
 
-	if (config->sharemodes && (fsp->fh != NULL) && (fsp->fh->fd != -1)) {
-		set_gpfs_sharemode(fsp, 0, 0);
+	if (config->sharemodes && fsp->kernel_share_modes_taken) {
+		/*
+		 * Always clear GPFS sharemode in case the actual
+		 * close gets deferred due to outstanding POSIX locks
+		 * (see fd_close_posix)
+		 */
+		int ret = gpfswrap_set_share(fsp->fh->fd, 0, 0);
+		if (ret != 0) {
+			DBG_ERR("Clearing GPFS sharemode on close failed for "
+				" %s/%s: %s\n",
+				fsp->conn->connectpath,
+				fsp->fsp_name->base_name,
+				strerror(errno));
+		}
 	}
 
 	return SMB_VFS_NEXT_CLOSE(handle, fsp);
@@ -1934,7 +1968,7 @@ static int vfs_gpfs_lstat(struct vfs_handle_struct *handle,
 static void timespec_to_gpfs_time(struct timespec ts, gpfs_timestruc_t *gt,
 				  int idx, int *flags)
 {
-	if (!null_timespec(ts)) {
+	if (!is_omit_timespec(&ts)) {
 		*flags |= 1 << idx;
 		gt[idx].tv_sec = ts.tv_sec;
 		gt[idx].tv_nsec = ts.tv_nsec;
@@ -2004,7 +2038,7 @@ static int vfs_gpfs_ntimes(struct vfs_handle_struct *handle,
                 return -1;
         }
 
-        if(null_timespec(ft->create_time)){
+        if (is_omit_timespec(&ft->create_time)){
                 DEBUG(10,("vfs_gpfs_ntimes:Create Time is NULL\n"));
                 return 0;
         }
diff --git a/source3/modules/vfs_io_uring.c b/source3/modules/vfs_io_uring.c
new file mode 100644
index 00000000000..378e48d112f
--- /dev/null
+++ b/source3/modules/vfs_io_uring.c
@@ -0,0 +1,543 @@
+/*
+ * Use the io_uring of Linux (>= 5.1)
+ *
+ * Copyright (C) Volker Lendecke 2008
+ * Copyright (C) Jeremy Allison 2010
+ * Copyright (C) Stefan Metzmacher 2019
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "includes.h"
+#include "system/filesys.h"
+#include "smbd/smbd.h"
+#include "smbd/globals.h"
+#include "lib/util/tevent_unix.h"
+#include "smbprofile.h"
+#include <liburing.h>
+
+struct vfs_io_uring_request;
+
+struct vfs_io_uring_config {
+	struct io_uring uring;
+	struct tevent_fd *fde;
+	struct vfs_io_uring_request *queue;
+	struct vfs_io_uring_request *pending;
+};
+
+struct vfs_io_uring_request {
+	struct vfs_io_uring_request *prev, *next;
+	struct vfs_io_uring_request **list_head;
+	struct vfs_io_uring_config *config;
+	struct tevent_req *req;
+	void *state;
+	struct io_uring_sqe sqe;
+	struct io_uring_cqe cqe;
+	struct timespec start_time;
+	struct timespec end_time;
+	SMBPROFILE_BYTES_ASYNC_STATE(profile_bytes);
+};
+
+static void vfs_io_uring_finish_req(struct vfs_io_uring_request *cur,
+				    const struct io_uring_cqe *cqe,
+				    struct timespec end_time,
+				    const char *location)
+{
+	struct tevent_req *req =
+		talloc_get_type_abort(cur->req,
+		struct tevent_req);
+
+	talloc_set_destructor(cur->state, NULL);
+	if (cur->list_head != NULL) {
+		DLIST_REMOVE((*cur->list_head), cur);
+		cur->list_head = NULL;
+	}
+	cur->cqe = *cqe;
+
+	SMBPROFILE_BYTES_ASYNC_SET_IDLE(cur->profile_bytes);
+	cur->end_time = end_time;
+
+	/*
+	 * We rely on being inside the _send() function
+	 * or tevent_req_defer_callback() being called
+	 * already.
+	 */
+	_tevent_req_done(req, location);
+}
+
+static void vfs_io_uring_config_destroy(struct vfs_io_uring_config *config,
+				        int ret,
+				        const char *location)
+{
+	struct vfs_io_uring_request *cur = NULL, *next = NULL;
+	struct timespec start_time;
+	struct timespec end_time;
+	struct io_uring_cqe err_cqe = {
+		.res = ret,
+	};
+
+	PROFILE_TIMESTAMP(&start_time);
+
+	if (config->uring.ring_fd != -1) {
+		/* TODO: cancel queued and pending requests */
+		TALLOC_FREE(config->fde);
+		io_uring_queue_exit(&config->uring);
+		config->uring.ring_fd = -1;
+	}
+
+	PROFILE_TIMESTAMP(&end_time);
+
+	for (cur = config->pending; cur != NULL; cur = next) {
+		next = cur->next;
+		err_cqe.user_data = (uintptr_t)(void *)cur;
+		vfs_io_uring_finish_req(cur, &err_cqe, end_time, location);
+	}
+
+	for (cur = config->queue; cur != NULL; cur = next) {
+		next = cur->next;
+		err_cqe.user_data = (uintptr_t)(void *)cur;
+		cur->start_time = start_time;
+		vfs_io_uring_finish_req(cur, &err_cqe, end_time, location);
+	}
+}
+
+static int vfs_io_uring_config_destructor(struct vfs_io_uring_config *config)
+{
+	vfs_io_uring_config_destroy(config, -EUCLEAN, __location__);
+	return 0;
+}
+
+static int vfs_io_uring_request_state_deny_destructor(void *_state)
+{
+	struct __vfs_io_uring_generic_state {
+		struct vfs_io_uring_request ur;
+	} *state = (struct __vfs_io_uring_generic_state *)_state;
+	struct vfs_io_uring_request *cur = &state->ur;
+
+	/* our parent is gone */
+	cur->req = NULL;
+
+	/* remove ourself from any list */
+	DLIST_REMOVE((*cur->list_head), cur);
+	cur->list_head = NULL;
+
+	/*
+	 * Our state is about to go away,
+	 * all we can do is shutting down the whole uring.
+	 * But that's ok as we're most likely called from exit_server()
+	 */
+	vfs_io_uring_config_destroy(cur->config, -ESHUTDOWN, __location__);
+	return 0;
+}
+
+static void vfs_io_uring_fd_handler(struct tevent_context *ev,
+				    struct tevent_fd *fde,
+				    uint16_t flags,
+				    void *private_data);
+
+static int vfs_io_uring_connect(vfs_handle_struct *handle, const char *service,
+			    const char *user)
+{
+	int ret;
+	struct vfs_io_uring_config *config;
+	unsigned num_entries;
+	bool sqpoll;
+	unsigned flags = 0;
+
+	config = talloc_zero(handle->conn, struct vfs_io_uring_config);
+	if (config == NULL) {
+		DEBUG(0, ("talloc_zero() failed\n"));
+		return -1;
+	}
+
+	SMB_VFS_HANDLE_SET_DATA(handle, config,
+				NULL, struct vfs_io_uring_config,
+				return -1);
+
+	ret = SMB_VFS_NEXT_CONNECT(handle, service, user);
+	if (ret < 0) {
+		return ret;
+	}
+
+	num_entries = lp_parm_ulong(SNUM(handle->conn),
+				    "vfs_io_uring",
+				    "num_entries",
+				    128);
+	num_entries = MAX(num_entries, 1);
+
+	sqpoll = lp_parm_bool(SNUM(handle->conn),
+			     "vfs_io_uring",
+			     "sqpoll",
+			     false);
+	if (sqpoll) {
+		flags |= IORING_SETUP_SQPOLL;
+	}
+
+	ret = io_uring_queue_init(num_entries, &config->uring, flags);
+	if (ret < 0) {
+		SMB_VFS_NEXT_DISCONNECT(handle);
+		errno = -ret;
+		return -1;
+	}
+
+	talloc_set_destructor(config, vfs_io_uring_config_destructor);
+
+#ifdef HAVE_IO_URING_RING_DONTFORK
+	ret = io_uring_ring_dontfork(&config->uring);
+	if (ret < 0) {
+		SMB_VFS_NEXT_DISCONNECT(handle);
+		errno = -ret;
+		return -1;
+	}
+#endif /* HAVE_IO_URING_RING_DONTFORK */
+
+	config->fde = tevent_add_fd(handle->conn->sconn->ev_ctx,
+				    config,
+				    config->uring.ring_fd,
+				    TEVENT_FD_READ,
+				    vfs_io_uring_fd_handler,
+				    handle);
+	if (config->fde == NULL) {
+		ret = errno;
+		SMB_VFS_NEXT_DISCONNECT(handle);
+		errno = ret;
+		return -1;
+	}
+
+	return 0;
+}
+
+static void vfs_io_uring_queue_run(struct vfs_io_uring_config *config)
+{
+	struct vfs_io_uring_request *cur = NULL, *next = NULL;
+	struct io_uring_cqe *cqe = NULL;
+	unsigned cqhead;
+	unsigned nr = 0;
+	struct timespec start_time;
+	struct timespec end_time;
+	int ret;
+
+	PROFILE_TIMESTAMP(&start_time);
+
+	if (config->uring.ring_fd == -1) {
+		vfs_io_uring_config_destroy(config, -ESTALE, __location__);
+		return;
+	}
+
+	for (cur = config->queue; cur != NULL; cur = next) {
+		struct io_uring_sqe *sqe = NULL;
+
+		next = cur->next;
+
+		sqe = io_uring_get_sqe(&config->uring);
+		if (sqe == NULL) {
+			break;
+		}
+
+		talloc_set_destructor(cur->state,
+			vfs_io_uring_request_state_deny_destructor);
+		DLIST_REMOVE(config->queue, cur);
+		*sqe = cur->sqe;
+		DLIST_ADD_END(config->pending, cur);
+		cur->list_head = &config->pending;
+		SMBPROFILE_BYTES_ASYNC_SET_BUSY(cur->profile_bytes);
+
+		cur->start_time = start_time;
+	}
+
+	ret = io_uring_submit(&config->uring);
+	if (ret == -EAGAIN || ret == -EBUSY) {
+		/* We just retry later */
+	} else if (ret < 0) {
+		vfs_io_uring_config_destroy(config, ret, __location__);
+		return;
+	}
+
+	PROFILE_TIMESTAMP(&end_time);
+
+	io_uring_for_each_cqe(&config->uring, cqhead, cqe) {
+		cur = (struct vfs_io_uring_request *)io_uring_cqe_get_data(cqe);
+		vfs_io_uring_finish_req(cur, cqe, end_time, __location__);
+		nr++;
+	}
+
+	io_uring_cq_advance(&config->uring, nr);
+}
+
+static void vfs_io_uring_fd_handler(struct tevent_context *ev,
+				    struct tevent_fd *fde,
+				    uint16_t flags,
+				    void *private_data)
+{
+	vfs_handle_struct *handle = (vfs_handle_struct *)private_data;
+	struct vfs_io_uring_config *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct vfs_io_uring_config,
+				smb_panic(__location__));
+
+	vfs_io_uring_queue_run(config);
+}
+
+struct vfs_io_uring_pread_state {
+	struct vfs_io_uring_request ur;
+	struct iovec iov;
+};
+
+static struct tevent_req *vfs_io_uring_pread_send(struct vfs_handle_struct *handle,
+					     TALLOC_CTX *mem_ctx,
+					     struct tevent_context *ev,
+					     struct files_struct *fsp,
+					     void *data,
+					     size_t n, off_t offset)
+{
+	struct tevent_req *req = NULL;
+	struct vfs_io_uring_pread_state *state = NULL;
+	struct vfs_io_uring_config *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct vfs_io_uring_config,
+				smb_panic(__location__));
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct vfs_io_uring_pread_state);
+	if (req == NULL) {
+		return NULL;
+	}
+	state->ur.config = config;
+	state->ur.req = req;
+	state->ur.state = state;
+
+	SMBPROFILE_BYTES_ASYNC_START(syscall_asys_pread, profile_p,
+				     state->ur.profile_bytes, n);
+	SMBPROFILE_BYTES_ASYNC_SET_IDLE(state->ur.profile_bytes);
+
+	state->iov.iov_base = (void *)data;
+	state->iov.iov_len = n;
+	io_uring_prep_readv(&state->ur.sqe,
+			    fsp->fh->fd,
+			    &state->iov, 1,
+			    offset);
+	io_uring_sqe_set_data(&state->ur.sqe, &state->ur);
+	DLIST_ADD_END(config->queue, &state->ur);
+	state->ur.list_head = &config->queue;
+
+	vfs_io_uring_queue_run(config);
+
+	if (!tevent_req_is_in_progress(req)) {
+		return tevent_req_post(req, ev);
+	}
+
+	tevent_req_defer_callback(req, ev);
+	return req;
+}
+
+static ssize_t vfs_io_uring_pread_recv(struct tevent_req *req,
+				  struct vfs_aio_state *vfs_aio_state)
+{
+	struct vfs_io_uring_pread_state *state = tevent_req_data(
+		req, struct vfs_io_uring_pread_state);
+	int ret;
+
+	SMBPROFILE_BYTES_ASYNC_END(state->ur.profile_bytes);
+	vfs_aio_state->duration = nsec_time_diff(&state->ur.end_time,
+						 &state->ur.start_time);
+
+	if (tevent_req_is_unix_error(req, &vfs_aio_state->error)) {
+		return -1;
+	}
+
+	if (state->ur.cqe.res < 0) {
+		vfs_aio_state->error = -state->ur.cqe.res;
+		ret = -1;
+	} else {
+		vfs_aio_state->error = 0;
+		ret = state->ur.cqe.res;
+	}
+
+	tevent_req_received(req);
+	return ret;
+}
+
+struct vfs_io_uring_pwrite_state {
+	struct vfs_io_uring_request ur;
+	struct iovec iov;
+};
+
+static struct tevent_req *vfs_io_uring_pwrite_send(struct vfs_handle_struct *handle,
+					      TALLOC_CTX *mem_ctx,
+					      struct tevent_context *ev,
+					      struct files_struct *fsp,
+					      const void *data,
+					      size_t n, off_t offset)
+{
+	struct tevent_req *req = NULL;
+	struct vfs_io_uring_pwrite_state *state = NULL;
+	struct vfs_io_uring_config *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct vfs_io_uring_config,
+				smb_panic(__location__));
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct vfs_io_uring_pwrite_state);
+	if (req == NULL) {
+		return NULL;
+	}
+	state->ur.config = config;
+	state->ur.req = req;
+	state->ur.state = state;
+
+	SMBPROFILE_BYTES_ASYNC_START(syscall_asys_pwrite, profile_p,
+				     state->ur.profile_bytes, n);
+	SMBPROFILE_BYTES_ASYNC_SET_IDLE(state->ur.profile_bytes);
+
+	state->iov.iov_base = discard_const(data);
+	state->iov.iov_len = n;
+	io_uring_prep_writev(&state->ur.sqe,
+			     fsp->fh->fd,
+			     &state->iov, 1,
+			     offset);
+	io_uring_sqe_set_data(&state->ur.sqe, &state->ur);
+	DLIST_ADD_END(config->queue, &state->ur);
+	state->ur.list_head = &config->queue;
+
+	vfs_io_uring_queue_run(config);
+
+	if (!tevent_req_is_in_progress(req)) {
+		return tevent_req_post(req, ev);
+	}
+
+	tevent_req_defer_callback(req, ev);
+	return req;
+}
+
+static ssize_t vfs_io_uring_pwrite_recv(struct tevent_req *req,
+				   struct vfs_aio_state *vfs_aio_state)
+{
+	struct vfs_io_uring_pwrite_state *state = tevent_req_data(
+		req, struct vfs_io_uring_pwrite_state);
+	int ret;
+
+	SMBPROFILE_BYTES_ASYNC_END(state->ur.profile_bytes);
+	vfs_aio_state->duration = nsec_time_diff(&state->ur.end_time,
+						 &state->ur.start_time);
+
+	if (tevent_req_is_unix_error(req, &vfs_aio_state->error)) {
+		return -1;
+	}
+
+	if (state->ur.cqe.res < 0) {
+		vfs_aio_state->error = -state->ur.cqe.res;
+		ret = -1;
+	} else {
+		vfs_aio_state->error = 0;
+		ret = state->ur.cqe.res;
+	}
+
+	tevent_req_received(req);
+	return ret;
+}
+
+struct vfs_io_uring_fsync_state {
+	struct vfs_io_uring_request ur;
+};
+
+static struct tevent_req *vfs_io_uring_fsync_send(struct vfs_handle_struct *handle,
+					     TALLOC_CTX *mem_ctx,
+					     struct tevent_context *ev,
+					     struct files_struct *fsp)
+{
+	struct tevent_req *req = NULL;
+	struct vfs_io_uring_fsync_state *state = NULL;
+	struct vfs_io_uring_config *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct vfs_io_uring_config,
+				smb_panic(__location__));
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct vfs_io_uring_fsync_state);
+	if (req == NULL) {
+		return NULL;
+	}
+	state->ur.config = config;
+	state->ur.req = req;
+	state->ur.state = state;
+
+	SMBPROFILE_BYTES_ASYNC_START(syscall_asys_fsync, profile_p,
+				     state->ur.profile_bytes, 0);
+	SMBPROFILE_BYTES_ASYNC_SET_IDLE(state->ur.profile_bytes);
+
+	io_uring_prep_fsync(&state->ur.sqe,
+			    fsp->fh->fd,
+			    0); /* fsync_flags */
+	io_uring_sqe_set_data(&state->ur.sqe, &state->ur);
+	DLIST_ADD_END(config->queue, &state->ur);
+	state->ur.list_head = &config->queue;
+
+	vfs_io_uring_queue_run(config);
+
+	if (!tevent_req_is_in_progress(req)) {
+		return tevent_req_post(req, ev);
+	}
+
+	tevent_req_defer_callback(req, ev);
+	return req;
+}
+
+static int vfs_io_uring_fsync_recv(struct tevent_req *req,
+			      struct vfs_aio_state *vfs_aio_state)
+{
+	struct vfs_io_uring_fsync_state *state = tevent_req_data(
+		req, struct vfs_io_uring_fsync_state);
+	int ret;
+
+	SMBPROFILE_BYTES_ASYNC_END(state->ur.profile_bytes);
+	vfs_aio_state->duration = nsec_time_diff(&state->ur.end_time,
+						 &state->ur.start_time);
+
+	if (tevent_req_is_unix_error(req, &vfs_aio_state->error)) {
+		return -1;
+	}
+
+	if (state->ur.cqe.res < 0) {
+		vfs_aio_state->error = -state->ur.cqe.res;
+		ret = -1;
+	} else {
+		vfs_aio_state->error = 0;
+		ret = state->ur.cqe.res;
+	}
+
+	tevent_req_received(req);
+	return ret;
+}
+
+static struct vfs_fn_pointers vfs_io_uring_fns = {
+	.connect_fn = vfs_io_uring_connect,
+	.pread_send_fn = vfs_io_uring_pread_send,
+	.pread_recv_fn = vfs_io_uring_pread_recv,
+	.pwrite_send_fn = vfs_io_uring_pwrite_send,
+	.pwrite_recv_fn = vfs_io_uring_pwrite_recv,
+	.fsync_send_fn = vfs_io_uring_fsync_send,
+	.fsync_recv_fn = vfs_io_uring_fsync_recv,
+};
+
+static_decl_vfs;
+NTSTATUS vfs_io_uring_init(TALLOC_CTX *ctx)
+{
+	return smb_register_vfs(SMB_VFS_INTERFACE_VERSION,
+				"io_uring", &vfs_io_uring_fns);
+}
diff --git a/source3/modules/vfs_nfs4acl_xattr.c b/source3/modules/vfs_nfs4acl_xattr.c
index d03079be831..f8cbe7964d1 100644
--- a/source3/modules/vfs_nfs4acl_xattr.c
+++ b/source3/modules/vfs_nfs4acl_xattr.c
@@ -476,6 +476,8 @@ static int nfs4acl_connect(struct vfs_handle_struct *handle,
 			   const char *service,
 			   const char *user)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct nfs4acl_config *config = NULL;
 	const struct enum_list *default_acl_style_list = NULL;
 	const char *default_xattr_name = NULL;
@@ -551,7 +553,7 @@ static int nfs4acl_connect(struct vfs_handle_struct *handle,
 						 default_acl_style_list,
 						 DEFAULT_ACL_EVERYONE);
 
-	config->xattr_name = lp_parm_talloc_string(config,
+	config->xattr_name = lp_parm_substituted_string(config, lp_sub,
 						   SNUM(handle->conn),
 						   "nfs4acl_xattr",
 						   "xattr_name",
diff --git a/source3/modules/vfs_not_implemented.c b/source3/modules/vfs_not_implemented.c
index b68b9e2e8b9..5861e20d88d 100644
--- a/source3/modules/vfs_not_implemented.c
+++ b/source3/modules/vfs_not_implemented.c
@@ -97,6 +97,25 @@ NTSTATUS vfs_not_implemented_get_dfs_referrals(struct vfs_handle_struct *handle,
 	return NT_STATUS_NOT_IMPLEMENTED;
 }
 
+NTSTATUS vfs_not_implemented_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	return NT_STATUS_NOT_IMPLEMENTED;
+}
+
+NTSTATUS vfs_not_implemented_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count)
+{
+	return NT_STATUS_NOT_IMPLEMENTED;
+}
+
 DIR *vfs_not_implemented_opendir(vfs_handle_struct *handle,
 			const struct smb_filename *smb_fname,
 			const char *mask,
@@ -420,7 +439,7 @@ bool vfs_not_implemented_lock(vfs_handle_struct *handle, files_struct *fsp, int
 
 int vfs_not_implemented_kernel_flock(struct vfs_handle_struct *handle,
 				     struct files_struct *fsp,
-				     uint32_t share_mode, uint32_t access_mask)
+				     uint32_t share_access, uint32_t access_mask)
 {
 	errno = ENOSYS;
 	return -1;
@@ -1037,6 +1056,8 @@ static struct vfs_fn_pointers vfs_not_implemented_fns = {
 	.statvfs_fn = vfs_not_implemented_statvfs,
 	.fs_capabilities_fn = vfs_not_implemented_fs_capabilities,
 	.get_dfs_referrals_fn = vfs_not_implemented_get_dfs_referrals,
+	.create_dfs_pathat_fn = vfs_not_implemented_create_dfs_pathat,
+	.read_dfs_pathat_fn = vfs_not_implemented_read_dfs_pathat,
 	.snap_check_path_fn = vfs_not_implemented_snap_check_path,
 	.snap_create_fn = vfs_not_implemented_snap_create,
 	.snap_delete_fn = vfs_not_implemented_snap_delete,
diff --git a/source3/modules/vfs_recycle.c b/source3/modules/vfs_recycle.c
index 46a4fcb16bf..a1d32bf10cb 100644
--- a/source3/modules/vfs_recycle.c
+++ b/source3/modules/vfs_recycle.c
@@ -417,7 +417,7 @@ static void recycle_do_touch(vfs_handle_struct *handle,
 	struct smb_file_time ft;
 	int ret, err;
 
-	ZERO_STRUCT(ft);
+	init_smb_file_time(&ft);
 
 	smb_fname_tmp = cp_smb_filename(talloc_tos(), smb_fname);
 	if (smb_fname_tmp == NULL) {
@@ -454,6 +454,8 @@ static int recycle_unlink_internal(vfs_handle_struct *handle,
 				const struct smb_filename *smb_fname,
 				int flags)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	connection_struct *conn = handle->conn;
 	char *path_name = NULL;
        	char *temp_name = NULL;
@@ -467,7 +469,7 @@ static int recycle_unlink_internal(vfs_handle_struct *handle,
 	bool exist;
 	int rc = -1;
 
-	repository = talloc_sub_full(NULL, lp_servicename(talloc_tos(), SNUM(conn)),
+	repository = talloc_sub_full(NULL, lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 					conn->session_info->unix_info->unix_name,
 					conn->connectpath,
 					conn->session_info->unix_token->gid,
diff --git a/source3/modules/vfs_shadow_copy2.c b/source3/modules/vfs_shadow_copy2.c
index b4086757683..c9b8d80e7f4 100644
--- a/source3/modules/vfs_shadow_copy2.c
+++ b/source3/modules/vfs_shadow_copy2.c
@@ -1558,7 +1558,7 @@ static void store_cwd_data(vfs_handle_struct *handle,
 	}
 	TALLOC_FREE(priv->shadow_connectpath);
 	if (connectpath) {
-		DBG_DEBUG("shadow conectpath = %s\n", connectpath);
+		DBG_DEBUG("shadow connectpath = %s\n", connectpath);
 		priv->shadow_connectpath = talloc_strdup(priv, connectpath);
 		if (priv->shadow_connectpath == NULL) {
 			smb_panic("talloc failed\n");
@@ -2442,6 +2442,85 @@ static int shadow_copy2_setxattr(struct vfs_handle_struct *handle,
 				aname, value, size, flags);
 }
 
+static NTSTATUS shadow_copy2_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	time_t timestamp = 0;
+
+	if (!shadow_copy2_strip_snapshot(talloc_tos(),
+					handle,
+					smb_fname->base_name,
+					&timestamp,
+					NULL)) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	if (timestamp != 0) {
+		return NT_STATUS_MEDIA_WRITE_PROTECTED;
+	}
+	return SMB_VFS_NEXT_CREATE_DFS_PATHAT(handle,
+			dirfsp,
+			smb_fname,
+			reflist,
+			referral_count);
+}
+
+static NTSTATUS shadow_copy2_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count)
+{
+	time_t timestamp = 0;
+	char *stripped = NULL;
+	struct smb_filename *conv = NULL;
+	NTSTATUS status;
+
+	if (!shadow_copy2_strip_snapshot(mem_ctx,
+					handle,
+					smb_fname->base_name,
+					&timestamp,
+					&stripped)) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	if (timestamp == 0) {
+		return SMB_VFS_NEXT_READ_DFS_PATHAT(handle,
+					mem_ctx,
+					dirfsp,
+					smb_fname,
+					ppreflist,
+					preferral_count);
+	}
+
+	conv = cp_smb_filename(mem_ctx, smb_fname);
+	if (conv == NULL) {
+		TALLOC_FREE(stripped);
+		return NT_STATUS_NO_MEMORY;
+	}
+	conv->base_name = shadow_copy2_convert(conv,
+					handle,
+					stripped,
+					timestamp);
+	TALLOC_FREE(stripped);
+	if (conv->base_name == NULL) {
+		TALLOC_FREE(conv);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	status = SMB_VFS_NEXT_READ_DFS_PATHAT(handle,
+				mem_ctx,
+				dirfsp,
+				conv,
+				ppreflist,
+				preferral_count);
+
+	TALLOC_FREE(conv);
+	return status;
+}
+
 static int shadow_copy2_get_real_filename(struct vfs_handle_struct *handle,
 					  const char *path,
 					  const char *name,
@@ -3123,6 +3202,8 @@ static struct vfs_fn_pointers vfs_shadow_copy2_fns = {
 	.opendir_fn = shadow_copy2_opendir,
 	.disk_free_fn = shadow_copy2_disk_free,
 	.get_quota_fn = shadow_copy2_get_quota,
+	.create_dfs_pathat_fn = shadow_copy2_create_dfs_pathat,
+	.read_dfs_pathat_fn = shadow_copy2_read_dfs_pathat,
 	.renameat_fn = shadow_copy2_renameat,
 	.linkat_fn = shadow_copy2_linkat,
 	.symlinkat_fn = shadow_copy2_symlinkat,
diff --git a/source3/modules/vfs_snapper.c b/source3/modules/vfs_snapper.c
index 9ef04d91e76..91729f2abd6 100644
--- a/source3/modules/vfs_snapper.c
+++ b/source3/modules/vfs_snapper.c
@@ -2849,12 +2849,37 @@ static int snapper_gmt_get_quota(vfs_handle_struct *handle,
 	return ret;
 }
 
+static NTSTATUS snapper_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	time_t timestamp = 0;
+
+	if (!snapper_gmt_strip_snapshot(talloc_tos(),
+					handle,
+					smb_fname->base_name,
+					&timestamp,
+					NULL)) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	if (timestamp != 0) {
+		return NT_STATUS_MEDIA_WRITE_PROTECTED;
+	}
+	return SMB_VFS_NEXT_CREATE_DFS_PATHAT(handle,
+			dirfsp,
+			smb_fname,
+			reflist,
+			referral_count);
+}
 
 static struct vfs_fn_pointers snapper_fns = {
 	.snap_check_path_fn = snapper_snap_check_path,
 	.snap_create_fn = snapper_snap_create,
 	.snap_delete_fn = snapper_snap_delete,
 	.get_shadow_copy_data_fn = snapper_get_shadow_copy_data,
+	.create_dfs_pathat_fn = snapper_create_dfs_pathat,
 	.opendir_fn = snapper_gmt_opendir,
 	.disk_free_fn = snapper_gmt_disk_free,
 	.get_quota_fn = snapper_gmt_get_quota,
diff --git a/source3/modules/vfs_streams_depot.c b/source3/modules/vfs_streams_depot.c
index 9f3b79992bc..9b0e73b25b7 100644
--- a/source3/modules/vfs_streams_depot.c
+++ b/source3/modules/vfs_streams_depot.c
@@ -115,6 +115,8 @@ static char *stream_dir(vfs_handle_struct *handle,
 			const struct smb_filename *smb_fname,
 			const SMB_STRUCT_STAT *base_sbuf, bool create_it)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint32_t hash;
 	struct smb_filename *smb_fname_hash = NULL;
 	char *result = NULL;
@@ -141,7 +143,7 @@ static char *stream_dir(vfs_handle_struct *handle,
 		goto fail;
 	}
 
-	rootdir = lp_parm_talloc_string(talloc_tos(),
+	rootdir = lp_parm_substituted_string(talloc_tos(), lp_sub,
 		SNUM(handle->conn), "streams_depot", "directory",
 		tmp);
 	if (rootdir == NULL) {
diff --git a/source3/modules/vfs_streams_xattr.c b/source3/modules/vfs_streams_xattr.c
index fa54fe26435..85efe2bcc37 100644
--- a/source3/modules/vfs_streams_xattr.c
+++ b/source3/modules/vfs_streams_xattr.c
@@ -1585,7 +1585,7 @@ static bool streams_xattr_getlock(vfs_handle_struct *handle,
 
 static int streams_xattr_kernel_flock(vfs_handle_struct *handle,
 				      files_struct *fsp,
-				      uint32_t share_mode,
+				      uint32_t share_access,
 				      uint32_t access_mask)
 {
 	struct stream_io *sio =
@@ -1593,7 +1593,7 @@ static int streams_xattr_kernel_flock(vfs_handle_struct *handle,
 
 	if (sio == NULL) {
 		return SMB_VFS_NEXT_KERNEL_FLOCK(handle, fsp,
-						 share_mode, access_mask);
+						 share_access, access_mask);
 	}
 
 	return 0;
diff --git a/source3/modules/vfs_time_audit.c b/source3/modules/vfs_time_audit.c
index 70efa30b914..5548f771fa5 100644
--- a/source3/modules/vfs_time_audit.c
+++ b/source3/modules/vfs_time_audit.c
@@ -323,6 +323,60 @@ static NTSTATUS smb_time_audit_get_dfs_referrals(
 	return result;
 }
 
+static NTSTATUS smb_time_audit_create_dfs_pathat(struct vfs_handle_struct *handle,
+			struct files_struct *dirfsp,
+			const struct smb_filename *smb_fname,
+			const struct referral *reflist,
+			size_t referral_count)
+{
+	NTSTATUS result;
+	struct timespec ts1,ts2;
+	double timediff;
+
+	clock_gettime_mono(&ts1);
+	result = SMB_VFS_NEXT_CREATE_DFS_PATHAT(handle,
+			dirfsp,
+			smb_fname,
+			reflist,
+			referral_count);
+	clock_gettime_mono(&ts2);
+	timediff = nsec_time_diff(&ts2,&ts1)*1.0e-9;
+
+	if (timediff > audit_timeout) {
+		smb_time_audit_log("get_dfs_referrals", timediff);
+	}
+
+	return result;
+}
+
+static NTSTATUS smb_time_audit_read_dfs_pathat(struct vfs_handle_struct *handle,
+			TALLOC_CTX *mem_ctx,
+			struct files_struct *dirfsp,
+			const struct smb_filename *smb_fname,
+			struct referral **ppreflist,
+			size_t *preferral_count)
+{
+	NTSTATUS result;
+	struct timespec ts1,ts2;
+	double timediff;
+
+	clock_gettime_mono(&ts1);
+	result = SMB_VFS_NEXT_READ_DFS_PATHAT(handle,
+			mem_ctx,
+			dirfsp,
+			smb_fname,
+			ppreflist,
+			preferral_count);
+	clock_gettime_mono(&ts2);
+	timediff = nsec_time_diff(&ts2,&ts1)*1.0e-9;
+
+	if (timediff > audit_timeout) {
+		smb_time_audit_log("read_dfs_pathat", timediff);
+	}
+
+	return result;
+}
+
 static NTSTATUS smb_time_audit_snap_check_path(struct vfs_handle_struct *handle,
 					       TALLOC_CTX *mem_ctx,
 					       const char *service_path,
@@ -1281,14 +1335,15 @@ static bool smb_time_audit_lock(vfs_handle_struct *handle, files_struct *fsp,
 
 static int smb_time_audit_kernel_flock(struct vfs_handle_struct *handle,
 				       struct files_struct *fsp,
-				       uint32_t share_mode, uint32_t access_mask)
+				       uint32_t share_access,
+				       uint32_t access_mask)
 {
 	int result;
 	struct timespec ts1,ts2;
 	double timediff;
 
 	clock_gettime_mono(&ts1);
-	result = SMB_VFS_NEXT_KERNEL_FLOCK(handle, fsp, share_mode,
+	result = SMB_VFS_NEXT_KERNEL_FLOCK(handle, fsp, share_access,
 					   access_mask);
 	clock_gettime_mono(&ts2);
 	timediff = nsec_time_diff(&ts2,&ts1)*1.0e-9;
@@ -2806,6 +2861,8 @@ static struct vfs_fn_pointers vfs_time_audit_fns = {
 	.statvfs_fn = smb_time_audit_statvfs,
 	.fs_capabilities_fn = smb_time_audit_fs_capabilities,
 	.get_dfs_referrals_fn = smb_time_audit_get_dfs_referrals,
+	.create_dfs_pathat_fn = smb_time_audit_create_dfs_pathat,
+	.read_dfs_pathat_fn = smb_time_audit_read_dfs_pathat,
 	.opendir_fn = smb_time_audit_opendir,
 	.fdopendir_fn = smb_time_audit_fdopendir,
 	.readdir_fn = smb_time_audit_readdir,
diff --git a/source3/modules/vfs_tsmsm.c b/source3/modules/vfs_tsmsm.c
index 85a9bfdfa9c..27b21369673 100644
--- a/source3/modules/vfs_tsmsm.c
+++ b/source3/modules/vfs_tsmsm.c
@@ -89,6 +89,8 @@ static void tsmsm_free_data(void **pptr) {
 static int tsmsm_connect(struct vfs_handle_struct *handle,
 			 const char *service,
 			 const char *user) {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct tsmsm_struct *tsmd;
 	const char *fres;
 	const char *tsmname;
@@ -115,18 +117,18 @@ static int tsmsm_connect(struct vfs_handle_struct *handle,
 	tsmname = (handle->param ? handle->param : "tsmsm");
 	
 	/* Get 'hsm script' and 'dmapi attribute' parameters to tsmd context */
-	tsmd->hsmscript = lp_parm_talloc_string(
-		tsmd, SNUM(handle->conn), tsmname,
+	tsmd->hsmscript = lp_parm_substituted_string(
+		tsmd, lp_sub, SNUM(handle->conn), tsmname,
 		"hsm script", NULL);
 	talloc_steal(tsmd, tsmd->hsmscript);
 	
-	tsmd->attrib_name = lp_parm_talloc_string(
-		tsmd, SNUM(handle->conn), tsmname,
+	tsmd->attrib_name = lp_parm_substituted_string(
+		tsmd, lp_sub, SNUM(handle->conn), tsmname,
 		"dmapi attribute", DM_ATTRIB_OBJECT);
 	talloc_steal(tsmd, tsmd->attrib_name);
 	
-	tsmd->attrib_value = lp_parm_talloc_string(
-		tsmd, SNUM(handle->conn), tsmname,
+	tsmd->attrib_value = lp_parm_substituted_string(
+		tsmd, lp_sub, SNUM(handle->conn), tsmname,
 		"dmapi value", NULL);
 	talloc_steal(tsmd, tsmd->attrib_value);
 	
diff --git a/source3/modules/vfs_virusfilter_utils.c b/source3/modules/vfs_virusfilter_utils.c
index 480279f90d6..0ee17ef7479 100644
--- a/source3/modules/vfs_virusfilter_utils.c
+++ b/source3/modules/vfs_virusfilter_utils.c
@@ -35,8 +35,11 @@ char *virusfilter_string_sub(
 	connection_struct *conn,
 	const char *str)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
 	return talloc_sub_full(mem_ctx,
-		lp_servicename(mem_ctx, SNUM(conn)),
+		lp_servicename(mem_ctx, lp_sub, SNUM(conn)),
 		conn->session_info->unix_info->unix_name,
 		conn->connectpath,
 		conn->session_info->unix_token->gid,
diff --git a/source3/modules/vfs_zfsacl.c b/source3/modules/vfs_zfsacl.c
index 2c5d82ae207..524881ab4af 100644
--- a/source3/modules/vfs_zfsacl.c
+++ b/source3/modules/vfs_zfsacl.c
@@ -36,6 +36,12 @@
 
 #define ZFSACL_MODULE_NAME "zfsacl"
 
+struct zfsacl_config_data {
+	struct smbacl4_vfs_params nfs4_params;
+	bool zfsacl_map_dacl_protected;
+	bool zfsacl_denymissingspecial;
+};
+
 /* zfs_get_nt_acl()
  * read the local file's acls and return it in NT form
  * using the NFSv4 format conversion
@@ -43,7 +49,8 @@
 static NTSTATUS zfs_get_nt_acl_common(struct connection_struct *conn,
 				      TALLOC_CTX *mem_ctx,
 				      const struct smb_filename *smb_fname,
-				      struct SMB4ACL_T **ppacl)
+				      struct SMB4ACL_T **ppacl,
+				      struct zfsacl_config_data *config)
 {
 	int naces, i;
 	ace_t *acebuf;
@@ -51,6 +58,7 @@ static NTSTATUS zfs_get_nt_acl_common(struct connection_struct *conn,
 	SMB_STRUCT_STAT sbuf;
 	const SMB_STRUCT_STAT *psbuf = NULL;
 	int ret;
+	bool inherited_is_present = false;
 	bool is_dir;
 
 	if (VALID_STAT(smb_fname->st)) {
@@ -117,6 +125,11 @@ static NTSTATUS zfs_get_nt_acl_common(struct connection_struct *conn,
 			aceprop.aceMask |= SMB_ACE4_DELETE_CHILD;
 		}
 
+#ifdef ACE_INHERITED_ACE
+		if (aceprop.aceFlags & ACE_INHERITED_ACE) {
+			inherited_is_present = true;
+		}
+#endif
 		if(aceprop.aceFlags & ACE_OWNER) {
 			aceprop.flags = SMB_ACE4_ID_SPECIAL;
 			aceprop.who.special_id = SMB_ACE4_WHO_OWNER;
@@ -133,6 +146,15 @@ static NTSTATUS zfs_get_nt_acl_common(struct connection_struct *conn,
 			return NT_STATUS_NO_MEMORY;
 	}
 
+#ifdef ACE_INHERITED_ACE
+	if (!inherited_is_present && config->zfsacl_map_dacl_protected) {
+		DBG_DEBUG("Setting SEC_DESC_DACL_PROTECTED on [%s]\n",
+			  smb_fname_str_dbg(smb_fname));
+		smbacl4_set_controlflags(pacl,
+					 SEC_DESC_DACL_PROTECTED |
+					 SEC_DESC_SELF_RELATIVE);
+	}
+#endif
 	*ppacl = pacl;
 	return NT_STATUS_OK;
 }
@@ -146,6 +168,11 @@ static bool zfs_process_smbacl(vfs_handle_struct *handle, files_struct *fsp,
 	struct SMB4ACE_T *smbace;
 	TALLOC_CTX	*mem_ctx;
 	bool have_special_id = false;
+	struct zfsacl_config_data *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct zfsacl_config_data,
+				return False);
 
 	/* allocate the field of ZFS aces */
 	mem_ctx = talloc_tos();
@@ -187,9 +214,7 @@ static bool zfs_process_smbacl(vfs_handle_struct *handle, files_struct *fsp,
 		}
 	}
 
-	if (!have_special_id
-	    && lp_parm_bool(fsp->conn->params->service, "zfsacl",
-			    "denymissingspecial", false)) {
+	if (!have_special_id && config->zfsacl_denymissingspecial) {
 		errno = EACCES;
 		return false;
 	}
@@ -220,8 +245,18 @@ static NTSTATUS zfs_set_nt_acl(vfs_handle_struct *handle, files_struct *fsp,
 			   uint32_t security_info_sent,
 			   const struct security_descriptor *psd)
 {
-        return smb_set_nt_acl_nfs4(handle, fsp, NULL, security_info_sent, psd,
-				   zfs_process_smbacl);
+	struct zfsacl_config_data *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct zfsacl_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	return smb_set_nt_acl_nfs4(handle,
+				fsp,
+				&config->nfs4_params,
+				security_info_sent,
+				psd,
+				zfs_process_smbacl);
 }
 
 static NTSTATUS zfsacl_fget_nt_acl(struct vfs_handle_struct *handle,
@@ -232,10 +267,16 @@ static NTSTATUS zfsacl_fget_nt_acl(struct vfs_handle_struct *handle,
 {
 	struct SMB4ACL_T *pacl;
 	NTSTATUS status;
+	struct zfsacl_config_data *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct zfsacl_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
 	TALLOC_CTX *frame = talloc_stackframe();
 
 	status = zfs_get_nt_acl_common(handle->conn, frame,
-				       fsp->fsp_name, &pacl);
+				       fsp->fsp_name, &pacl, config);
 	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(frame);
 		if (!NT_STATUS_EQUAL(status, NT_STATUS_NOT_SUPPORTED)) {
@@ -268,9 +309,14 @@ static NTSTATUS zfsacl_get_nt_acl(struct vfs_handle_struct *handle,
 {
 	struct SMB4ACL_T *pacl;
 	NTSTATUS status;
+	struct zfsacl_config_data *config = NULL;
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct zfsacl_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
 	TALLOC_CTX *frame = talloc_stackframe();
 
-	status = zfs_get_nt_acl_common(handle->conn, frame, smb_fname, &pacl);
+	status = zfs_get_nt_acl_common(handle->conn, frame, smb_fname, &pacl, config);
 	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(frame);
 		if (!NT_STATUS_EQUAL(status, NT_STATUS_NOT_SUPPORTED)) {
@@ -395,9 +441,47 @@ static int zfsacl_fail__sys_acl_blob_get_fd(vfs_handle_struct *handle, files_str
 	return -1;
 }
 
+static int zfsacl_connect(struct vfs_handle_struct *handle,
+			    const char *service, const char *user)
+{
+	struct zfsacl_config_data *config = NULL;
+	int ret;
+
+	ret = SMB_VFS_NEXT_CONNECT(handle, service, user);
+	if (ret < 0) {
+		return ret;
+	}
+
+	config = talloc_zero(handle->conn, struct zfsacl_config_data);
+	if (!config) {
+		DBG_ERR("talloc_zero() failed\n");
+		errno = ENOMEM;
+		return -1;
+	}
+
+	config->zfsacl_map_dacl_protected = lp_parm_bool(SNUM(handle->conn),
+				"zfsacl", "map_dacl_protected", false);
+
+	config->zfsacl_denymissingspecial = lp_parm_bool(SNUM(handle->conn),
+				"zfsacl", "denymissingspecial", false);
+
+	ret = smbacl4_get_vfs_params(handle->conn, &config->nfs4_params);
+	if (ret < 0) {
+		TALLOC_FREE(config);
+		return ret;
+	}
+
+	SMB_VFS_HANDLE_SET_DATA(handle, config,
+				NULL, struct zfsacl_config_data,
+				return -1);
+
+	return 0;
+}
+
 /* VFS operations structure */
 
 static struct vfs_fn_pointers zfsacl_fns = {
+	.connect_fn = zfsacl_connect,
 	.sys_acl_get_file_fn = zfsacl_fail__sys_acl_get_file,
 	.sys_acl_get_fd_fn = zfsacl_fail__sys_acl_get_fd,
 	.sys_acl_blob_get_file_fn = zfsacl_fail__sys_acl_blob_get_file,
diff --git a/source3/modules/wscript_build b/source3/modules/wscript_build
index e4f92fac150..41d8568e43a 100644
--- a/source3/modules/wscript_build
+++ b/source3/modules/wscript_build
@@ -7,7 +7,7 @@ bld.SAMBA3_SUBSYSTEM('NFS4_ACLS',
 bld.SAMBA3_BINARY('test_nfs4_acls',
                   source='test_nfs4_acls.c',
                   deps='smbd_base cmocka',
-                  install=False)
+                  for_selftest=True)
 
 bld.SAMBA3_SUBSYSTEM('vfs_acl_common',
                      source='vfs_acl_common.c',
@@ -396,6 +396,14 @@ bld.SAMBA3_MODULE('vfs_aio_pthread',
                  internal_module=bld.SAMBA3_IS_STATIC_MODULE('vfs_aio_pthread'),
                  enabled=bld.SAMBA3_IS_ENABLED_MODULE('vfs_aio_pthread'))
 
+bld.SAMBA3_MODULE('vfs_io_uring',
+                 subsystem='vfs',
+                 source='vfs_io_uring.c',
+                 deps='samba-util tevent uring',
+                 init_function='',
+                 internal_module=bld.SAMBA3_IS_STATIC_MODULE('vfs_io_uring'),
+                 enabled=bld.SAMBA3_IS_ENABLED_MODULE('vfs_io_uring'))
+
 bld.SAMBA3_MODULE('vfs_preopen',
                  subsystem='vfs',
                  source='vfs_preopen.c',
diff --git a/source3/nmbd/nmbd.c b/source3/nmbd/nmbd.c
index 66cd65ca208..0b881d13f7b 100644
--- a/source3/nmbd/nmbd.c
+++ b/source3/nmbd/nmbd.c
@@ -389,12 +389,14 @@ static void reload_interfaces(time_t t)
 
 static bool reload_nmbd_services(bool test)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	bool ret;
 
 	set_remote_machine_name("nmbd", False);
 
 	if ( lp_loaded() ) {
-		char *fname = lp_next_configfile(talloc_tos());
+		char *fname = lp_next_configfile(talloc_tos(), lp_sub);
 		if (file_exist(fname) && !strcsequal(fname,get_dyn_CONFIGFILE())) {
 			set_dyn_CONFIGFILE(fname);
 			test = False;
@@ -849,6 +851,8 @@ static bool open_sockets(bool isdaemon, int port)
 		POPT_COMMON_SAMBA
 		POPT_TABLEEND
 	};
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	TALLOC_CTX *frame;
 	NTSTATUS status;
 	bool ok;
@@ -914,7 +918,7 @@ static bool open_sockets(bool isdaemon, int port)
 	}
 
 	fault_setup();
-	dump_core_setup("nmbd", lp_logfile(talloc_tos()));
+	dump_core_setup("nmbd", lp_logfile(talloc_tos(), lp_sub));
 
 	/* POSIX demands that signals are inherited. If the invoking process has
 	 * these signals masked, we will have problems, as we won't receive them. */
diff --git a/source3/nmbd/nmbd_sendannounce.c b/source3/nmbd/nmbd_sendannounce.c
index a9cdf1c5a58..f4c852ba0b8 100644
--- a/source3/nmbd/nmbd_sendannounce.c
+++ b/source3/nmbd/nmbd_sendannounce.c
@@ -461,7 +461,7 @@ void announce_my_servers_removed(void)
 
 void announce_remote(time_t t)
 {
-	char *s;
+	char *s = NULL;
 	const char *ptr;
 	static time_t last_time = 0;
 	char *s2;
@@ -469,17 +469,19 @@ void announce_remote(time_t t)
 	char *comment;
 	int stype = lp_default_server_announce();
 	TALLOC_CTX *frame = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	if (last_time && (t < (last_time + REMOTE_ANNOUNCE_INTERVAL)))
 		return;
 
 	last_time = t;
 
-	s = lp_remote_announce(talloc_tos());
+	s = lp_remote_announce(talloc_tos(), lp_sub);
 	if (!*s)
 		return;
 
-	comment = string_truncate(lp_server_string(talloc_tos()),
+	comment = string_truncate(lp_server_string(talloc_tos(), lp_sub),
 				  MAX_SERVER_STRING_LENGTH);
 
 	frame = talloc_stackframe();
@@ -540,13 +542,15 @@ void browse_sync_remote(time_t t)
 	char *p;
 	unstring myname;
 	TALLOC_CTX *frame = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	if (last_time && (t < (last_time + REMOTE_ANNOUNCE_INTERVAL)))
 		return;
 
 	last_time = t;
 
-	s = lp_remote_browse_sync(talloc_tos());
+	s = lp_remote_browse_sync(talloc_tos(), lp_sub);
 	if (!*s)
 		return;
 
diff --git a/source3/nmbd/nmbd_serverlistdb.c b/source3/nmbd/nmbd_serverlistdb.c
index ad251833ed5..e7cb36a2de2 100644
--- a/source3/nmbd/nmbd_serverlistdb.c
+++ b/source3/nmbd/nmbd_serverlistdb.c
@@ -275,6 +275,8 @@ void write_browse_list(time_t t, bool force_write)
 	bool list_changed = force_write;
 	static time_t lasttime = 0;
 	TALLOC_CTX *ctx = talloc_tos();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	/* Always dump if we're being told to by a signal. */
 	if(force_write == False) {
@@ -369,7 +371,7 @@ void write_browse_list(time_t t, bool force_write)
 
 		/* Output server details, plus what workgroup they're in. */
 		write_browse_list_entry(fp, my_netbios_names(i), stype,
-			string_truncate(lp_server_string(talloc_tos()), MAX_SERVER_STRING_LENGTH), lp_workgroup());
+			string_truncate(lp_server_string(talloc_tos(), lp_sub), MAX_SERVER_STRING_LENGTH), lp_workgroup());
 	}
 
 	for (subrec = FIRST_SUBNET; subrec ; subrec = NEXT_SUBNET_INCLUDING_UNICAST(subrec)) { 
diff --git a/source3/nmbd/nmbd_winsserver.c b/source3/nmbd/nmbd_winsserver.c
index c34bfaea3be..f68d6eebc0b 100644
--- a/source3/nmbd/nmbd_winsserver.c
+++ b/source3/nmbd/nmbd_winsserver.c
@@ -454,8 +454,10 @@ static void get_global_id_and_update(uint64_t *current_id, bool update)
 
 static void wins_hook(const char *operation, struct name_record *namerec, int ttl)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *command = NULL;
-	char *cmd = lp_wins_hook(talloc_tos());
+	char *cmd = lp_wins_hook(talloc_tos(), lp_sub);
 	char *p, *namestr;
 	int i;
 	TALLOC_CTX *ctx = talloc_tos();
diff --git a/source3/nmbd/nmbd_workgroupdb.c b/source3/nmbd/nmbd_workgroupdb.c
index 5f52a74106e..14bc941b872 100644
--- a/source3/nmbd/nmbd_workgroupdb.c
+++ b/source3/nmbd/nmbd_workgroupdb.c
@@ -226,6 +226,8 @@ static void fail_register(struct subnet_record *subrec, struct response_record *
 
 void initiate_myworkgroup_startup(struct subnet_record *subrec, struct work_record *work)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int i;
 
 	if(!strequal(lp_workgroup(), work->work_group))
@@ -254,7 +256,7 @@ workgroup %s on subnet %s\n", work->work_group, subrec->subnet_name));
 			stype &= ~(SV_TYPE_MASTER_BROWSER|SV_TYPE_POTENTIAL_BROWSER|SV_TYPE_DOMAIN_MASTER|SV_TYPE_DOMAIN_MEMBER);
    
 		create_server_on_workgroup(work,name,stype|SV_TYPE_LOCAL_LIST_ONLY, PERMANENT_TTL, 
-				string_truncate(lp_server_string(talloc_tos()), MAX_SERVER_STRING_LENGTH));
+				string_truncate(lp_server_string(talloc_tos(), lp_sub), MAX_SERVER_STRING_LENGTH));
 		DEBUG(3,("initiate_myworkgroup_startup: Added server name entry %s \
 on subnet %s\n", name, subrec->subnet_name));
 	}
diff --git a/source3/param/loadparm.c b/source3/param/loadparm.c
index 31fa229d5ff..ce41477097a 100644
--- a/source3/param/loadparm.c
+++ b/source3/param/loadparm.c
@@ -53,6 +53,7 @@
  *
  */
 
+#define LOADPARM_SUBSTITUTION_INTERNALS 1
 #include "includes.h"
 #include "system/filesys.h"
 #include "util_tdb.h"
@@ -991,7 +992,11 @@ static struct loadparm_context *setup_lp_context(TALLOC_CTX *mem_ctx)
  callers without affecting the source string.
 ********************************************************************/
 
-char *lp_string(TALLOC_CTX *ctx, const char *s)
+static char *loadparm_s3_global_substitution_fn(
+			TALLOC_CTX *mem_ctx,
+			const struct loadparm_substitution *lp_sub,
+			const char *s,
+			void *private_data)
 {
 	char *ret;
 
@@ -1007,14 +1012,14 @@ char *lp_string(TALLOC_CTX *ctx, const char *s)
 		return NULL;
 	}
 
-	ret = talloc_sub_basic(ctx,
+	ret = talloc_sub_basic(mem_ctx,
 			get_current_username(),
 			current_user_info.domain,
 			s);
 	if (trim_char(ret, '\"', '\"')) {
 		if (strchr(ret,'\"') != NULL) {
 			TALLOC_FREE(ret);
-			ret = talloc_sub_basic(ctx,
+			ret = talloc_sub_basic(mem_ctx,
 					get_current_username(),
 					current_user_info.domain,
 					s);
@@ -1023,13 +1028,23 @@ char *lp_string(TALLOC_CTX *ctx, const char *s)
 	return ret;
 }
 
+static const struct loadparm_substitution s3_global_substitution = {
+	.substituted_string_fn = loadparm_s3_global_substitution_fn,
+};
+
+const struct loadparm_substitution *loadparm_s3_global_substitution(void)
+{
+	return &s3_global_substitution;
+}
+
 /*
    In this section all the functions that are used to access the
    parameters from the rest of the program are defined
 */
 
-#define FN_GLOBAL_STRING(fn_name,ptr) \
-char *lp_ ## fn_name(TALLOC_CTX *ctx) {return(lp_string((ctx), *(char **)(&Globals.ptr) ? *(char **)(&Globals.ptr) : ""));}
+#define FN_GLOBAL_SUBSTITUTED_STRING(fn_name,ptr) \
+char *lp_ ## fn_name(TALLOC_CTX *ctx, const struct loadparm_substitution *lp_sub) \
+ {return lpcfg_substituted_string(ctx, lp_sub, *(char **)(&Globals.ptr) ? *(char **)(&Globals.ptr) : "");}
 #define FN_GLOBAL_CONST_STRING(fn_name,ptr) \
  const char *lp_ ## fn_name(void) {return(*(const char * const *)(&Globals.ptr) ? *(const char * const *)(&Globals.ptr) : "");}
 #define FN_GLOBAL_LIST(fn_name,ptr) \
@@ -1041,8 +1056,9 @@ char *lp_ ## fn_name(TALLOC_CTX *ctx) {return(lp_string((ctx), *(char **)(&Globa
 #define FN_GLOBAL_INTEGER(fn_name,ptr) \
  int lp_ ## fn_name(void) {return(*(int *)(&Globals.ptr));}
 
-#define FN_LOCAL_STRING(fn_name,val) \
-char *lp_ ## fn_name(TALLOC_CTX *ctx,int i) {return(lp_string((ctx), (LP_SNUM_OK(i) && ServicePtrs[(i)]->val) ? ServicePtrs[(i)]->val : sDefault.val));}
+#define FN_LOCAL_SUBSTITUTED_STRING(fn_name,val) \
+char *lp_ ## fn_name(TALLOC_CTX *ctx, const struct loadparm_substitution *lp_sub, int i) \
+ {return lpcfg_substituted_string((ctx), lp_sub, (LP_SNUM_OK(i) && ServicePtrs[(i)]->val) ? ServicePtrs[(i)]->val : sDefault.val);}
 #define FN_LOCAL_CONST_STRING(fn_name,val) \
  const char *lp_ ## fn_name(int i) {return (const char *)((LP_SNUM_OK(i) && ServicePtrs[(i)]->val) ? ServicePtrs[(i)]->val : sDefault.val);}
 #define FN_LOCAL_LIST(fn_name,val) \
@@ -1074,7 +1090,7 @@ int lp_winbind_max_domain_connections(void)
 
 #include "lib/param/param_functions.c"
 
-FN_LOCAL_STRING(servicename, szService)
+FN_LOCAL_SUBSTITUTED_STRING(servicename, szService)
 FN_LOCAL_CONST_STRING(const_servicename, szService)
 
 /* These functions cannot be auto-generated */
@@ -1213,19 +1229,26 @@ static int lp_enum(const char *s,const struct enum_list *_enum)
 
 /* Return parametric option from a given service. Type is a part of option before ':' */
 /* Parametric option has following syntax: 'Type: option = value' */
-char *lp_parm_talloc_string(TALLOC_CTX *ctx, int snum, const char *type, const char *option, const char *def)
+char *lp_parm_substituted_string(TALLOC_CTX *mem_ctx,
+				 const struct loadparm_substitution *lp_sub,
+				 int snum,
+				 const char *type,
+				 const char *option,
+				 const char *def)
 {
 	struct parmlist_entry *data = get_parametrics(snum, type, option);
 
+	SMB_ASSERT(lp_sub != NULL);
+
 	if (data == NULL||data->value==NULL) {
 		if (def) {
-			return lp_string(ctx, def);
+			return lpcfg_substituted_string(mem_ctx, lp_sub, def);
 		} else {
 			return NULL;
 		}
 	}
 
-	return lp_string(ctx, data->value);
+	return lpcfg_substituted_string(mem_ctx, lp_sub, data->value);
 }
 
 /* Return parametric option from a given service. Type is a part of option before ':' */
@@ -1525,6 +1548,8 @@ static bool hash_a_service(const char *name, int idx)
 bool lp_add_home(const char *pszHomename, int iDefaultService,
 		 const char *user, const char *pszHomedir)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int i;
 	char *global_path;
 
@@ -1538,7 +1563,7 @@ bool lp_add_home(const char *pszHomename, int iDefaultService,
 	if (i < 0)
 		return false;
 
-	global_path = lp_path(talloc_tos(), GLOBAL_SECTION_SNUM);
+	global_path = lp_path(talloc_tos(), lp_sub, GLOBAL_SECTION_SNUM);
 	if (!(*(ServicePtrs[iDefaultService]->path))
 	    || strequal(ServicePtrs[iDefaultService]->path, global_path)) {
 		lpcfg_string_set(ServicePtrs[i], &ServicePtrs[i]->path,
@@ -2562,7 +2587,7 @@ const char *lp_ldap_machine_suffix(TALLOC_CTX *ctx)
 	if (Globals._ldap_machine_suffix[0])
 		return append_ldap_suffix(ctx, Globals._ldap_machine_suffix);
 
-	return lp_string(ctx, Globals.ldap_suffix);
+	return talloc_strdup(ctx, Globals.ldap_suffix);
 }
 
 const char *lp_ldap_user_suffix(TALLOC_CTX *ctx)
@@ -2570,7 +2595,7 @@ const char *lp_ldap_user_suffix(TALLOC_CTX *ctx)
 	if (Globals._ldap_user_suffix[0])
 		return append_ldap_suffix(ctx, Globals._ldap_user_suffix);
 
-	return lp_string(ctx, Globals.ldap_suffix);
+	return talloc_strdup(ctx, Globals.ldap_suffix);
 }
 
 const char *lp_ldap_group_suffix(TALLOC_CTX *ctx)
@@ -2578,7 +2603,7 @@ const char *lp_ldap_group_suffix(TALLOC_CTX *ctx)
 	if (Globals._ldap_group_suffix[0])
 		return append_ldap_suffix(ctx, Globals._ldap_group_suffix);
 
-	return lp_string(ctx, Globals.ldap_suffix);
+	return talloc_strdup(ctx, Globals.ldap_suffix);
 }
 
 const char *lp_ldap_idmap_suffix(TALLOC_CTX *ctx)
@@ -2586,7 +2611,7 @@ const char *lp_ldap_idmap_suffix(TALLOC_CTX *ctx)
 	if (Globals._ldap_idmap_suffix[0])
 		return append_ldap_suffix(ctx, Globals._ldap_idmap_suffix);
 
-	return lp_string(ctx, Globals.ldap_suffix);
+	return talloc_strdup(ctx, Globals.ldap_suffix);
 }
 
 /**
@@ -2715,6 +2740,38 @@ static bool do_parameter(const char *pszParmName, const char *pszParmValue,
 	}
 }
 
+
+static const char *ad_dc_req_vfs_mods[] = {"dfs_samba4", "acl_xattr", NULL};
+
+/*
+ * check that @vfs_objects includes all vfs modules required by an AD DC.
+ */
+static bool check_ad_dc_required_mods(const char **vfs_objects)
+{
+	int i;
+	int j;
+	int got_req;
+
+	for (i = 0; ad_dc_req_vfs_mods[i] != NULL; i++) {
+		got_req = false;
+		for (j = 0; vfs_objects[j] != NULL; j++) {
+			if (!strwicmp(ad_dc_req_vfs_mods[i], vfs_objects[j])) {
+				got_req = true;
+				break;
+			}
+		}
+		if (!got_req) {
+			DEBUG(0, ("vfs objects specified without required AD "
+				  "DC module: %s\n", ad_dc_req_vfs_mods[i]));
+			return false;
+		}
+	}
+
+	DEBUG(6, ("vfs objects specified with all required AD DC modules\n"));
+	return true;
+}
+
+
 /***************************************************************************
  Initialize any local variables in the sDefault table, after parsing a
  [globals] section.
@@ -2734,7 +2791,10 @@ static void init_locals(void)
 	 */
 	if (lp_server_role() == ROLE_ACTIVE_DIRECTORY_DC) {
 		const char **vfs_objects = lp_vfs_objects(-1);
-		if (!vfs_objects || !vfs_objects[0]) {
+		if (vfs_objects != NULL) {
+			/* ignore return, only warn if modules are missing */
+			check_ad_dc_required_mods(vfs_objects);
+		} else {
 			if (lp_parm_const_string(-1, "xattr_tdb", "file", NULL)) {
 				lp_do_parameter(-1, "vfs objects", "dfs_samba4 acl_xattr xattr_tdb");
 			} else if (lp_parm_const_string(-1, "posix", "eadb", NULL)) {
@@ -2867,7 +2927,7 @@ bool lp_snum_ok(int iService)
  Auto-load some home services.
 ***************************************************************************/
 
-static void lp_add_auto_services(char *str)
+static void lp_add_auto_services(const char *str)
 {
 	char *s;
 	char *p;
@@ -3329,6 +3389,7 @@ static int process_usershare_file(const char *dir_name, const char *file_name, i
 	char *canon_name = NULL;
 	bool added_service = false;
 	int ret = -1;
+	NTSTATUS status;
 
 	/* Ensure share name doesn't contain invalid characters. */
 	if (!validate_net_name(file_name, INVALID_SHARENAME_CHARS, strlen(file_name))) {
@@ -3365,7 +3426,6 @@ static int process_usershare_file(const char *dir_name, const char *file_name, i
 
 	{
 		TDB_DATA data;
-		NTSTATUS status;
 
 		status = dbwrap_fetch_bystring(ServiceHash, canon_name,
 					       canon_name, &data);
@@ -3462,7 +3522,8 @@ static int process_usershare_file(const char *dir_name, const char *file_name, i
 	}
 
 	/* Write the ACL of the new/modified share. */
-	if (!set_share_security(canon_name, psd)) {
+	status = set_share_security(canon_name, psd);
+	if (!NT_STATUS_IS_OK(status)) {
 		 DEBUG(0, ("process_usershare_file: Failed to set share "
 			"security for user share %s\n",
 			canon_name ));
@@ -3762,13 +3823,15 @@ int load_usershare_shares(struct smbd_server_connection *sconn,
 	tmp_ctx = talloc_stackframe();
 	for (iService = iNumServices - 1; iService >= 0; iService--) {
 		if (VALID(iService) && (ServicePtrs[iService]->usershare == USERSHARE_PENDING_DELETE)) {
+			const struct loadparm_substitution *lp_sub =
+				loadparm_s3_global_substitution();
 			char *servname;
 
 			if (snumused && snumused(sconn, iService)) {
 				continue;
 			}
 
-			servname = lp_servicename(tmp_ctx, iService);
+			servname = lp_servicename(tmp_ctx, lp_sub, iService);
 
 			/* Remove from the share ACL db. */
 			DEBUG(10,("load_usershare_shares: Removing deleted usershare %s\n",
@@ -3954,7 +4017,9 @@ static bool lp_load_ex(const char *pszFname,
 	}
 
 	{
-		char *serv = lp_auto_services(talloc_tos());
+		const struct loadparm_substitution *lp_sub =
+			loadparm_s3_global_substitution();
+		char *serv = lp_auto_services(talloc_tos(), lp_sub);
 		lp_add_auto_services(serv);
 		TALLOC_FREE(serv);
 	}
@@ -4250,12 +4315,14 @@ int lp_servicenumber(const char *pszServiceName)
 
 const char *volume_label(TALLOC_CTX *ctx, int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *ret;
-	const char *label = lp_volume(ctx, snum);
+	const char *label = lp_volume(ctx, lp_sub, snum);
 	size_t end = 32;
 
 	if (!*label) {
-		label = lp_servicename(ctx, snum);
+		label = lp_servicename(ctx, lp_sub, snum);
 	}
 
 	/*
@@ -4386,9 +4453,12 @@ void lp_remove_service(int snum)
 	ServicePtrs[snum]->valid = false;
 }
 
-const char *lp_printername(TALLOC_CTX *ctx, int snum)
+const char *lp_printername(TALLOC_CTX *ctx,
+			   const struct loadparm_substitution *lp_sub,
+			   int snum)
 {
-	const char *ret = lp__printername(ctx, snum);
+	const char *ret = lp__printername(ctx, lp_sub, snum);
+
 	if (ret == NULL || *ret == '\0') {
 		ret = lp_const_servicename(snum);
 	}
@@ -4461,26 +4531,6 @@ uint32_t lp_get_spoolss_state( void )
 	return lp_disable_spoolss() ? SVCCTL_STOPPED : SVCCTL_RUNNING;
 }
 
-/*******************************************************************
- Ensure we don't use sendfile if server smb signing is active.
-********************************************************************/
-
-bool lp_use_sendfile(int snum, struct smb_signing_state *signing_state)
-{
-	bool sign_active = false;
-
-	/* Using sendfile blows the brains out of any DOS or Win9x TCP stack... JRA. */
-	if (get_Protocol() < PROTOCOL_NT1) {
-		return false;
-	}
-	if (signing_state) {
-		sign_active = smb_signing_is_active(signing_state);
-	}
-	return (lp__use_sendfile(snum) &&
-			(get_remote_arch() != RA_WIN95) &&
-			!sign_active);
-}
-
 /*******************************************************************
  Turn off sendfile if we find the underlying OS doesn't support it.
 ********************************************************************/
diff --git a/source3/param/loadparm_ctx.c b/source3/param/loadparm_ctx.c
index 645b787acb9..0a8f957b787 100644
--- a/source3/param/loadparm_ctx.c
+++ b/source3/param/loadparm_ctx.c
@@ -66,7 +66,6 @@ static struct loadparm_s3_helpers s3_fns =
 	.load = lp_load_for_s4_ctx,
 	.store_cmdline = store_lp_set_cmdline,
 	.dump = lp_dump,
-	.lp_string = lp_string,
 	.lp_include = lp_include,
 	.init_ldap_debugging = init_ldap_debugging,
 	.set_netbios_aliases = set_netbios_aliases,
diff --git a/source3/param/service.c b/source3/param/service.c
index 22f46f08894..09b8228daad 100644
--- a/source3/param/service.c
+++ b/source3/param/service.c
@@ -111,6 +111,8 @@ int add_home_service(const char *service, const char *username, const char *home
 
 int find_service(TALLOC_CTX *ctx, const char *service_in, char **p_service_out)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int iService;
 
 	if (!service_in) {
@@ -189,7 +191,7 @@ int find_service(TALLOC_CTX *ctx, const char *service_in, char **p_service_out)
 	}
 
 	/* Is it a usershare service ? */
-	if (iService < 0 && *lp_usershare_path(talloc_tos())) {
+	if (iService < 0 && *lp_usershare_path(talloc_tos(), lp_sub)) {
 		/* Ensure the name is canonicalized. */
 		if (!strlower_m(*p_service_out)) {
 			goto fail;
@@ -199,7 +201,7 @@ int find_service(TALLOC_CTX *ctx, const char *service_in, char **p_service_out)
 
 	/* just possibly it's a default service? */
 	if (iService < 0) {
-		char *pdefservice = lp_defaultservice(talloc_tos());
+		char *pdefservice = lp_defaultservice(talloc_tos(), lp_sub);
 		if (pdefservice &&
 				*pdefservice &&
 				!strequal(pdefservice, *p_service_out)
diff --git a/source3/passdb/pdb_interface.c b/source3/passdb/pdb_interface.c
index 556839ae9d1..03aa4ff8472 100644
--- a/source3/passdb/pdb_interface.c
+++ b/source3/passdb/pdb_interface.c
@@ -447,6 +447,8 @@ static NTSTATUS pdb_default_create_user(struct pdb_methods *methods,
 					TALLOC_CTX *tmp_ctx, const char *name,
 					uint32_t acb_info, uint32_t *rid)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct samu *sam_pass;
 	NTSTATUS status;
 	struct passwd *pwd;
@@ -461,9 +463,9 @@ static NTSTATUS pdb_default_create_user(struct pdb_methods *methods,
 		fstring name2;
 
 		if ((acb_info & ACB_NORMAL) && name[strlen(name)-1] != '$') {
-			add_script = lp_add_user_script(tmp_ctx);
+			add_script = lp_add_user_script(tmp_ctx, lp_sub);
 		} else {
-			add_script = lp_add_machine_script(tmp_ctx);
+			add_script = lp_add_machine_script(tmp_ctx, lp_sub);
 		}
 
 		if (!add_script || add_script[0] == '\0') {
@@ -549,6 +551,8 @@ NTSTATUS pdb_create_user(TALLOC_CTX *mem_ctx, const char *name, uint32_t flags,
 
 static int smb_delete_user(const char *unix_user)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *del_script = NULL;
 	int ret;
 
@@ -559,7 +563,7 @@ static int smb_delete_user(const char *unix_user)
 		return -1;
 	}
 
-	del_script = lp_delete_user_script(talloc_tos());
+	del_script = lp_delete_user_script(talloc_tos(), lp_sub);
 	if (!del_script || !*del_script) {
 		return -1;
 	}
diff --git a/source3/passdb/pdb_ldap.c b/source3/passdb/pdb_ldap.c
index 22050fa828c..36b4aa61fd4 100644
--- a/source3/passdb/pdb_ldap.c
+++ b/source3/passdb/pdb_ldap.c
@@ -193,9 +193,9 @@ static NTSTATUS ldapsam_get_seq_num(struct pdb_methods *my_methods, time_t *seq_
 
 	if (!smbldap_has_naming_context(
 		    smbldap_get_ldap(ldap_state->smbldap_state),
-		    lp_ldap_suffix(talloc_tos()))) {
+		    lp_ldap_suffix())) {
 		DEBUG(3,("ldapsam_get_seq_num: DIT not configured to hold %s "
-			 "as top-level namingContext\n", lp_ldap_suffix(talloc_tos())));
+			 "as top-level namingContext\n", lp_ldap_suffix()));
 		return ntstatus;
 	}
 
@@ -218,7 +218,7 @@ static NTSTATUS ldapsam_get_seq_num(struct pdb_methods *my_methods, time_t *seq_
 		attrs[0] = talloc_strdup(mem_ctx, "syncreplCookie");
 		attrs[1] = NULL;
 		suffix = talloc_asprintf(mem_ctx,
-				"cn=syncrepl%d,%s", rid, lp_ldap_suffix(talloc_tos()));
+				"cn=syncrepl%d,%s", rid, lp_ldap_suffix());
 		if (!suffix) {
 			ntstatus = NT_STATUS_NO_MEMORY;
 			goto done;
@@ -230,7 +230,7 @@ static NTSTATUS ldapsam_get_seq_num(struct pdb_methods *my_methods, time_t *seq_
 		attrs[0] = talloc_strdup(mem_ctx, "contextCSN");
 		attrs[1] = NULL;
 		suffix = talloc_asprintf(mem_ctx,
-				"cn=ldapsync,%s", lp_ldap_suffix(talloc_tos()));
+				"cn=ldapsync,%s", lp_ldap_suffix());
 
 		if (!suffix) {
 			ntstatus = NT_STATUS_NO_MEMORY;
@@ -2040,6 +2040,8 @@ static NTSTATUS ldapsam_rename_sam_account(struct pdb_methods *my_methods,
 					   struct samu *old_acct,
 					   const char *newname)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char *oldname;
 	int rc;
 	char *rename_script = NULL;
@@ -2057,7 +2059,7 @@ static NTSTATUS ldapsam_rename_sam_account(struct pdb_methods *my_methods,
 	oldname = pdb_get_username(old_acct);
 
 	/* rename the posix user */
-	rename_script = lp_rename_user_script(talloc_tos());
+	rename_script = lp_rename_user_script(talloc_tos(), lp_sub);
 	if (rename_script == NULL) {
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -2372,7 +2374,7 @@ static int ldapsam_search_one_group (struct ldapsam_privates *ldap_state,
 
 	attr_list = get_attr_list(NULL, groupmap_attr_list);
 	rc = smbldap_search(ldap_state->smbldap_state,
-			    lp_ldap_suffix (talloc_tos()), scope,
+			    lp_ldap_suffix(), scope,
 			    filter, attr_list, 0, result);
 	TALLOC_FREE(attr_list);
 
@@ -2707,7 +2709,7 @@ static NTSTATUS ldapsam_enum_group_members(struct pdb_methods *methods,
 		goto done;
 	}
 
-	rc = smbldap_search(conn, lp_ldap_suffix(talloc_tos()),
+	rc = smbldap_search(conn, lp_ldap_suffix(),
 			    LDAP_SCOPE_SUBTREE, filter, id_attrs, 0,
 			    &result);
 
@@ -2775,7 +2777,7 @@ static NTSTATUS ldapsam_enum_group_members(struct pdb_methods *methods,
 			goto done;
 		}
 
-		rc = smbldap_search(conn, lp_ldap_suffix(talloc_tos()),
+		rc = smbldap_search(conn, lp_ldap_suffix(),
 				    LDAP_SCOPE_SUBTREE, filter, sid_attrs, 0,
 				    &result);
 
@@ -2831,7 +2833,7 @@ static NTSTATUS ldapsam_enum_group_members(struct pdb_methods *methods,
 				 LDAP_OBJ_SAMBASAMACCOUNT,
 				 gidstr);
 
-	rc = smbldap_search(conn, lp_ldap_suffix(talloc_tos()),
+	rc = smbldap_search(conn, lp_ldap_suffix(),
 			    LDAP_SCOPE_SUBTREE, filter, sid_attrs, 0,
 			    &result);
 
@@ -2919,7 +2921,7 @@ static NTSTATUS ldapsam_enum_group_memberships(struct pdb_methods *methods,
 			goto done;
 		}
 
-		rc = smbldap_search(conn, lp_ldap_suffix(talloc_tos()),
+		rc = smbldap_search(conn, lp_ldap_suffix(),
 				    LDAP_SCOPE_SUBTREE, filter, attrs, 0, &result);
 
 		if (rc != LDAP_SUCCESS)
@@ -2968,7 +2970,7 @@ static NTSTATUS ldapsam_enum_group_memberships(struct pdb_methods *methods,
 		goto done;
 	}
 
-	rc = smbldap_search(conn, lp_ldap_suffix(talloc_tos()),
+	rc = smbldap_search(conn, lp_ldap_suffix(),
 			    LDAP_SCOPE_SUBTREE, filter, attrs, 0, &result);
 
 	if (rc != LDAP_SUCCESS)
@@ -3157,7 +3159,7 @@ static NTSTATUS ldapsam_add_group_mapping_entry(struct pdb_methods *methods,
 		goto done;
 	}
 
-	rc = smbldap_search(ldap_state->smbldap_state, lp_ldap_suffix(talloc_tos()),
+	rc = smbldap_search(ldap_state->smbldap_state, lp_ldap_suffix(),
 			    LDAP_SCOPE_SUBTREE, filter, attrs, True, &msg);
 	smbldap_talloc_autofree_ldapmsg(mem_ctx, msg);
 
@@ -3458,7 +3460,7 @@ static NTSTATUS ldapsam_setsamgrent(struct pdb_methods *my_methods,
 		return NT_STATUS_NO_MEMORY;
 	}
 	attr_list = get_attr_list( NULL, groupmap_attr_list );
-	rc = smbldap_search(ldap_state->smbldap_state, lp_ldap_suffix(talloc_tos()),
+	rc = smbldap_search(ldap_state->smbldap_state, lp_ldap_suffix(),
 			    LDAP_SCOPE_SUBTREE, filter,
 			    attr_list, 0, &ldap_state->result);
 	TALLOC_FREE(attr_list);
@@ -3467,7 +3469,7 @@ static NTSTATUS ldapsam_setsamgrent(struct pdb_methods *my_methods,
 		DEBUG(0, ("ldapsam_setsamgrent: LDAP search failed: %s\n",
 			  ldap_err2string(rc)));
 		DEBUG(3, ("ldapsam_setsamgrent: Query was: %s, %s\n",
-			  lp_ldap_suffix(talloc_tos()), filter));
+			  lp_ldap_suffix(), filter));
 		ldap_msgfree(ldap_state->result);
 		ldap_state->result = NULL;
 		TALLOC_FREE(filter);
@@ -3896,7 +3898,7 @@ static NTSTATUS ldapsam_alias_memberships(struct pdb_methods *methods,
 		result = ldap_state->search_cache.result;
 		ldap_state->search_cache.result = NULL;
 	} else {
-		rc = smbldap_search(ldap_state->smbldap_state, lp_ldap_suffix(talloc_tos()),
+		rc = smbldap_search(ldap_state->smbldap_state, lp_ldap_suffix(),
 				    LDAP_SCOPE_SUBTREE, filter, attrs, 0, &result);
 		if (rc != LDAP_SUCCESS) {
 			return NT_STATUS_UNSUCCESSFUL;
@@ -4279,7 +4281,7 @@ static NTSTATUS ldapsam_lookup_rids(struct pdb_methods *methods,
 		}
 
 		rc = smbldap_search(ldap_state->smbldap_state,
-				    lp_ldap_suffix(talloc_tos()),
+				    lp_ldap_suffix(),
 				    LDAP_SCOPE_SUBTREE, filter, ldap_attrs, 0,
 				    &msg);
 		smbldap_talloc_autofree_ldapmsg(mem_ctx, msg);
@@ -4718,7 +4720,7 @@ static bool ldapsam_search_users(struct pdb_methods *methods,
 		 ((acct_flags & (ACB_WSTRUST|ACB_SVRTRUST|ACB_DOMTRUST)) != 0))
 		state->base = lp_ldap_machine_suffix(talloc_tos());
 	else
-		state->base = lp_ldap_suffix(talloc_tos());
+		state->base = lp_ldap_suffix();
 
 	state->acct_flags = acct_flags;
 	state->base = talloc_strdup(search, state->base);
@@ -4887,7 +4889,7 @@ static bool ldapsam_search_grouptype(struct pdb_methods *methods,
 
 	state->connection = ldap_state->smbldap_state;
 
-	state->base = lp_ldap_suffix(search);
+	state->base = lp_ldap_suffix();
 	state->connection = ldap_state->smbldap_state;
 	state->scope = LDAP_SCOPE_SUBTREE;
 	state->filter =	talloc_asprintf(search, "(&(objectclass=%s)"
diff --git a/source3/passdb/pdb_ldap_util.c b/source3/passdb/pdb_ldap_util.c
index f9e6cbbc3a9..6fac6e209c3 100644
--- a/source3/passdb/pdb_ldap_util.c
+++ b/source3/passdb/pdb_ldap_util.c
@@ -54,7 +54,7 @@ static NTSTATUS add_new_domain_account_policies(struct smbldap_state *ldap_state
 
 	if (asprintf(&dn, "%s=%s,%s",
 		get_attr_key2string(dominfo_attr_list, LDAP_ATTR_DOMAIN),
-		escape_domain_name, lp_ldap_suffix(talloc_tos())) < 0) {
+		escape_domain_name, lp_ldap_suffix()) < 0) {
 		SAFE_FREE(escape_domain_name);
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -176,7 +176,7 @@ static NTSTATUS add_new_domain_info(struct smbldap_state *ldap_state,
 
 	if (asprintf(&dn, "%s=%s,%s",
 		     get_attr_key2string(dominfo_attr_list, LDAP_ATTR_DOMAIN),
-		     escape_domain_name, lp_ldap_suffix(talloc_tos())) < 0) {
+		     escape_domain_name, lp_ldap_suffix()) < 0) {
 		SAFE_FREE(escape_domain_name);
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -286,7 +286,7 @@ NTSTATUS smbldap_search_domain_info(struct smbldap_state *ldap_state,
 
 	if (rc != LDAP_SUCCESS) {
 		DEBUG(2,("smbldap_search_domain_info: Problem during LDAPsearch: %s\n", ldap_err2string (rc)));
-		DEBUG(2,("smbldap_search_domain_info: Query was: %s, %s\n", lp_ldap_suffix(talloc_tos()), filter));
+		DEBUG(2,("smbldap_search_domain_info: Query was: %s, %s\n", lp_ldap_suffix(), filter));
 		goto failed;
 	}
 
diff --git a/source3/passdb/pdb_smbpasswd.c b/source3/passdb/pdb_smbpasswd.c
index bed3cea744c..76cfddfb195 100644
--- a/source3/passdb/pdb_smbpasswd.c
+++ b/source3/passdb/pdb_smbpasswd.c
@@ -1444,13 +1444,15 @@ static NTSTATUS smbpasswd_rename_sam_account (struct pdb_methods *my_methods,
 					      struct samu *old_acct,
 					      const char *newname)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *rename_script = NULL;
 	struct samu *new_acct = NULL;
 	bool interim_account = False;
 	TALLOC_CTX *ctx = talloc_tos();
 	NTSTATUS ret = NT_STATUS_UNSUCCESSFUL;
 
-	if (!*(lp_rename_user_script(talloc_tos())))
+	if (!*(lp_rename_user_script(talloc_tos(), lp_sub)))
 		goto done;
 
 	if ( !(new_acct = samu_new( NULL )) ) {
@@ -1470,7 +1472,7 @@ static NTSTATUS smbpasswd_rename_sam_account (struct pdb_methods *my_methods,
 	interim_account = True;
 
 	/* rename the posix user */
-	rename_script = lp_rename_user_script(ctx);
+	rename_script = lp_rename_user_script(ctx, lp_sub);
 	if (!rename_script) {
 		ret = NT_STATUS_NO_MEMORY;
 		goto done;
diff --git a/source3/passdb/pdb_tdb.c b/source3/passdb/pdb_tdb.c
index 7488d99a94e..8b4d84b3704 100644
--- a/source3/passdb/pdb_tdb.c
+++ b/source3/passdb/pdb_tdb.c
@@ -1001,6 +1001,8 @@ static NTSTATUS tdbsam_rename_sam_account(struct pdb_methods *my_methods,
 					  struct samu *old_acct,
 					  const char *newname)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct samu      *new_acct = NULL;
 	char *rename_script = NULL;
 	int              rename_ret;
@@ -1013,7 +1015,7 @@ static NTSTATUS tdbsam_rename_sam_account(struct pdb_methods *my_methods,
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	rename_script = lp_rename_user_script(new_acct);
+	rename_script = lp_rename_user_script(new_acct, lp_sub);
 	if (!rename_script) {
 		TALLOC_FREE(new_acct);
 		return NT_STATUS_NO_MEMORY;
diff --git a/source3/passdb/secrets.c b/source3/passdb/secrets.c
index ce215b1f2b2..2b2206070e2 100644
--- a/source3/passdb/secrets.c
+++ b/source3/passdb/secrets.c
@@ -324,7 +324,7 @@ bool fetch_ldap_pw(char **dn, char** pw)
 	char *key = NULL;
 	size_t size = 0;
 
-	*dn = smb_xstrdup(lp_ldap_admin_dn(talloc_tos()));
+	*dn = smb_xstrdup(lp_ldap_admin_dn());
 
 	if (asprintf(&key, "%s/%s", SECRETS_LDAP_BIND_PW, *dn) < 0) {
 		SAFE_FREE(*dn);
diff --git a/source3/passdb/wscript_build b/source3/passdb/wscript_build
index faa0cc4b495..7facc1fed79 100644
--- a/source3/passdb/wscript_build
+++ b/source3/passdb/wscript_build
@@ -10,7 +10,7 @@ bld.SAMBA3_MODULE('pdb_tdbsam',
 
 bld.SAMBA3_MODULE('pdb_ldapsam',
                  subsystem='pdb',
-                 deps='smbldap smbldaphelper',
+                 deps='smbldap smbldaphelper LIBCLI_AUTH',
                  source='pdb_ldap.c pdb_nds.c',
                  init_function='',
                  internal_module=bld.SAMBA3_IS_STATIC_MODULE('pdb_ldapsam'),
diff --git a/source3/printing/load.c b/source3/printing/load.c
index 7e25d5a91c7..6a5d4ed97c2 100644
--- a/source3/printing/load.c
+++ b/source3/printing/load.c
@@ -27,6 +27,8 @@ auto-load some homes and printer services
 ***************************************************************************/
 static void add_auto_printers(void)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char *p;
 	int pnum = lp_servicenumber(PRINTERS_NAME);
 	char *str;
@@ -40,7 +42,7 @@ static void add_auto_printers(void)
 	if (pnum < 0)
 		return;
 
-	auto_serv = lp_auto_services(talloc_tos());
+	auto_serv = lp_auto_services(talloc_tos(), lp_sub);
 	str = SMB_STRDUP(auto_serv);
 	TALLOC_FREE(auto_serv);
 	if (str == NULL) {
diff --git a/source3/printing/notify.c b/source3/printing/notify.c
index 56747272394..d09c12ade77 100644
--- a/source3/printing/notify.c
+++ b/source3/printing/notify.c
@@ -423,7 +423,9 @@ void notify_printer_status(struct tevent_context *ev,
 			   struct messaging_context *msg_ctx,
 			   int snum, uint32_t status)
 {
-	const char *sharename = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *sharename = lp_servicename(talloc_tos(), lp_sub, snum);
 
 	if (sharename)
 		notify_printer_status_byname(ev, msg_ctx, sharename, status);
@@ -511,7 +513,9 @@ void notify_printer_driver(struct tevent_context *ev,
 			   struct messaging_context *msg_ctx,
 			   int snum, const char *driver_name)
 {
-	const char *sharename = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *sharename = lp_servicename(talloc_tos(), lp_sub, snum);
 
 	send_notify_field_buffer(
 		ev, msg_ctx,
@@ -523,7 +527,9 @@ void notify_printer_comment(struct tevent_context *ev,
 			    struct messaging_context *msg_ctx,
 			    int snum, const char *comment)
 {
-	const char *sharename = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *sharename = lp_servicename(talloc_tos(), lp_sub, snum);
 
 	send_notify_field_buffer(
 		ev, msg_ctx,
@@ -535,7 +541,9 @@ void notify_printer_sharename(struct tevent_context *ev,
 			      struct messaging_context *msg_ctx,
 			      int snum, const char *share_name)
 {
-	const char *sharename = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *sharename = lp_servicename(talloc_tos(), lp_sub, snum);
 
 	send_notify_field_buffer(
 		ev, msg_ctx,
@@ -547,7 +555,9 @@ void notify_printer_printername(struct tevent_context *ev,
 				struct messaging_context *msg_ctx,
 				int snum, const char *printername)
 {
-	const char *sharename = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *sharename = lp_servicename(talloc_tos(), lp_sub, snum);
 
 	send_notify_field_buffer(
 		ev, msg_ctx,
@@ -559,7 +569,9 @@ void notify_printer_port(struct tevent_context *ev,
 			 struct messaging_context *msg_ctx,
 			 int snum, const char *port_name)
 {
-	const char *sharename = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *sharename = lp_servicename(talloc_tos(), lp_sub, snum);
 
 	send_notify_field_buffer(
 		ev, msg_ctx,
@@ -571,7 +583,9 @@ void notify_printer_location(struct tevent_context *ev,
 			     struct messaging_context *msg_ctx,
 			     int snum, const char *location)
 {
-	const char *sharename = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *sharename = lp_servicename(talloc_tos(), lp_sub, snum);
 
 	send_notify_field_buffer(
 		ev, msg_ctx,
@@ -583,7 +597,9 @@ void notify_printer_sepfile(struct tevent_context *ev,
 			    struct messaging_context *msg_ctx,
 			    int snum, const char *sepfile)
 {
-	const char *sharename = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *sharename = lp_servicename(talloc_tos(), lp_sub, snum);
 
 	send_notify_field_buffer(
 		ev, msg_ctx,
diff --git a/source3/printing/nt_printing.c b/source3/printing/nt_printing.c
index 89405f1c8ee..98536017b5b 100644
--- a/source3/printing/nt_printing.c
+++ b/source3/printing/nt_printing.c
@@ -80,6 +80,9 @@ static bool print_driver_directories_init(void)
 	char *driver_path;
 	bool ok;
 	TALLOC_CTX *mem_ctx = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
 	const char *dir_list[] = {
 		"W32X86/PCC",
 		"x64/PCC",
@@ -94,7 +97,7 @@ static bool print_driver_directories_init(void)
 		return true;
 	}
 
-	driver_path = lp_path(mem_ctx, service);
+	driver_path = lp_path(mem_ctx, lp_sub, service);
 	if (driver_path == NULL) {
 		talloc_free(mem_ctx);
 		return false;
@@ -987,6 +990,8 @@ static uint32_t get_correct_cversion(const struct auth_session_info *session_inf
 				   WERROR *perr)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int cversion = -1;
 	NTSTATUS          nt_status;
 	struct smb_filename *smb_fname = NULL;
@@ -1028,7 +1033,7 @@ static uint32_t get_correct_cversion(const struct auth_session_info *session_inf
 		return -1;
 	}
 
-	printdollar_path = lp_path(frame, printdollar_snum);
+	printdollar_path = lp_path(frame, lp_sub, printdollar_snum);
 	if (printdollar_path == NULL) {
 		*perr = WERR_NOT_ENOUGH_MEMORY;
 		TALLOC_FREE(frame);
@@ -1477,6 +1482,8 @@ WERROR move_driver_to_download_area(const struct auth_session_info *session_info
 				    const char *driver_directory)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct spoolss_AddDriverInfo3 *driver;
 	struct spoolss_AddDriverInfo3 converted_driver;
 	const char *short_architecture;
@@ -1527,7 +1534,7 @@ WERROR move_driver_to_download_area(const struct auth_session_info *session_info
 
 	nt_status = create_conn_struct_tos_cwd(global_messaging_context(),
 					       printdollar_snum,
-					       lp_path(frame, printdollar_snum),
+					       lp_path(frame, lp_sub, printdollar_snum),
 					       session_info,
 					       &c);
 	if (!NT_STATUS_IS_OK(nt_status)) {
@@ -1706,6 +1713,8 @@ bool printer_driver_in_use(TALLOC_CTX *mem_ctx,
 			   struct dcerpc_binding_handle *b,
 			   const struct spoolss_DriverInfo8 *r)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int snum;
 	int n_services = lp_numservices();
 	bool in_use = false;
@@ -1726,7 +1735,7 @@ bool printer_driver_in_use(TALLOC_CTX *mem_ctx,
 		}
 
 		result = winreg_get_printer(mem_ctx, b,
-					    lp_servicename(talloc_tos(), snum),
+					    lp_servicename(talloc_tos(), lp_sub, snum),
 					    &pinfo2);
 		if (!W_ERROR_IS_OK(result)) {
 			continue; /* skip */
@@ -2041,6 +2050,8 @@ bool delete_driver_files(const struct auth_session_info *session_info,
 			 const struct spoolss_DriverInfo8 *r)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char *short_arch;
 	struct conn_struct_tos *c = NULL;
 	connection_struct *conn = NULL;
@@ -2069,7 +2080,7 @@ bool delete_driver_files(const struct auth_session_info *session_info,
 
 	nt_status = create_conn_struct_tos_cwd(global_messaging_context(),
 					       printdollar_snum,
-					       lp_path(frame, printdollar_snum),
+					       lp_path(frame, lp_sub, printdollar_snum),
 					       session_info,
 					       &c);
 	if (!NT_STATUS_IS_OK(nt_status)) {
@@ -2234,6 +2245,8 @@ WERROR print_access_check(const struct auth_session_info *session_info,
 			  int access_type)
 {
 	struct spoolss_security_descriptor *secdesc = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint32_t access_granted;
 	size_t sd_size;
 	NTSTATUS status;
@@ -2253,7 +2266,7 @@ WERROR print_access_check(const struct auth_session_info *session_info,
 
 	/* Get printer name */
 
-	pname = lp_printername(talloc_tos(), snum);
+	pname = lp_printername(talloc_tos(), lp_sub, snum);
 
 	if (!pname || !*pname) {
 		return WERR_ACCESS_DENIED;
diff --git a/source3/printing/nt_printing_ads.c b/source3/printing/nt_printing_ads.c
index a82f1361fc8..478d1231b00 100644
--- a/source3/printing/nt_printing_ads.c
+++ b/source3/printing/nt_printing_ads.c
@@ -619,6 +619,8 @@ done:
 
 WERROR check_published_printers(struct messaging_context *msg_ctx)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	ADS_STATUS ads_rc;
 	ADS_STRUCT *ads = NULL;
 	int snum;
@@ -666,7 +668,7 @@ WERROR check_published_printers(struct messaging_context *msg_ctx)
 		}
 
 		result = winreg_get_printer_internal(tmp_ctx, session_info, msg_ctx,
-					    lp_servicename(talloc_tos(), snum),
+					    lp_servicename(talloc_tos(), lp_sub, snum),
 					    &pinfo2);
 		if (!W_ERROR_IS_OK(result)) {
 			continue;
diff --git a/source3/printing/nt_printing_os2.c b/source3/printing/nt_printing_os2.c
index 5ed577100e1..82b82482031 100644
--- a/source3/printing/nt_printing_os2.c
+++ b/source3/printing/nt_printing_os2.c
@@ -73,7 +73,9 @@ static bool set_driver_mapping(const char *from, const char *to)
  */
 WERROR spoolss_map_to_os2_driver(TALLOC_CTX *mem_ctx, const char **pdrivername)
 {
-	const char *mapfile = lp_os2_driver_map(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *mapfile = lp_os2_driver_map(talloc_tos(), lp_sub);
 	char **lines = NULL;
 	const char *drivername;
 	int numlines = 0;
diff --git a/source3/printing/print_cups.c b/source3/printing/print_cups.c
index 738307f47b4..b52f7e25da5 100644
--- a/source3/printing/print_cups.c
+++ b/source3/printing/print_cups.c
@@ -108,14 +108,16 @@ cups_passwd_cb(const char *prompt)	/* I - Prompt */
 
 static http_t *cups_connect(TALLOC_CTX *frame)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	http_t *http = NULL;
 	char *server = NULL, *p = NULL;
 	int port;
 	int timeout = lp_cups_connection_timeout();
 	size_t size;
 
-	if (lp_cups_server(talloc_tos()) != NULL && strlen(lp_cups_server(talloc_tos())) > 0) {
-		if (!push_utf8_talloc(frame, &server, lp_cups_server(talloc_tos()), &size)) {
+	if (lp_cups_server(talloc_tos(), lp_sub) != NULL && strlen(lp_cups_server(talloc_tos(), lp_sub)) > 0) {
+		if (!push_utf8_talloc(frame, &server, lp_cups_server(talloc_tos(), lp_sub), &size)) {
 			return NULL;
 		}
 	} else {
@@ -143,7 +145,18 @@ static http_t *cups_connect(TALLOC_CTX *frame)
                 alarm(timeout);
         }
 
-#ifdef HAVE_HTTPCONNECTENCRYPT
+#if defined(HAVE_HTTPCONNECT2)
+	http = httpConnect2(server,
+			    port,
+			    NULL,
+			    AF_UNSPEC,
+			    lp_cups_encrypt() ?
+				HTTP_ENCRYPTION_ALWAYS :
+				HTTP_ENCRYPTION_IF_REQUESTED,
+			    1, /* blocking */
+			    30 * 1000, /* timeout */
+			    NULL);
+#elif defined(HAVE_HTTPCONNECTENCRYPT)
 	http = httpConnectEncrypt(server, port, lp_cups_encrypt());
 #else
 	http = httpConnect(server, port);
@@ -514,7 +527,7 @@ static void cups_async_callback(struct tevent_context *event_ctx,
 	struct pcap_data pcap_data;
 	DATA_BLOB pcap_blob;
 	enum ndr_err_code ndr_ret;
-	int i;
+	uint32_t i;
 
 	DEBUG(5,("cups_async_callback: callback received for printer data. "
 		"fd = %d\n", cb_args->pipe_fd));
@@ -560,9 +573,9 @@ static void cups_async_callback(struct tevent_context *event_ctx,
 err_out:
 	pcap_cache_destroy_specific(&tmp_pcap_cache);
 	TALLOC_FREE(frame);
+	TALLOC_FREE(cache_fd_event);
 	close(cb_args->pipe_fd);
 	TALLOC_FREE(cb_args);
-	TALLOC_FREE(cache_fd_event);
 }
 
 bool cups_cache_reload(struct tevent_context *ev,
@@ -942,6 +955,8 @@ static int cups_job_submit(int snum, struct printjob *pjob,
 			   char *lpq_cmd)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int		ret = 1;		/* Return value */
 	http_t		*http = NULL;		/* HTTP connection to server */
 	ipp_t		*request = NULL,	/* IPP Request */
@@ -1001,7 +1016,7 @@ static int cups_job_submit(int snum, struct printjob *pjob,
         	     "attributes-natural-language", NULL, language->language);
 
 	if (!push_utf8_talloc(frame, &printername,
-			      lp_printername(talloc_tos(), snum),
+			      lp_printername(talloc_tos(), lp_sub, snum),
 			      &size)) {
 		goto out;
 	}
@@ -1049,7 +1064,7 @@ static int cups_job_submit(int snum, struct printjob *pjob,
 	 */
 
 	if (!push_utf8_talloc(frame, &cupsoptions,
-			      lp_cups_options(talloc_tos(), snum), &size)) {
+			      lp_cups_options(talloc_tos(), lp_sub, snum), &size)) {
 		goto out;
 	}
 	num_options = 0;
@@ -1082,7 +1097,7 @@ static int cups_job_submit(int snum, struct printjob *pjob,
 	if ((response = cupsDoFileRequest(http, request, uri, pjob->filename)) != NULL) {
 		if (ippGetStatusCode(response) >= IPP_OK_CONFLICT) {
 			DEBUG(0,("Unable to print file to %s - %s\n",
-				 lp_printername(talloc_tos(), snum),
+				 lp_printername(talloc_tos(), lp_sub, snum),
 			         ippErrorString(cupsLastError())));
 		} else {
 			ret = 0;
@@ -1096,7 +1111,7 @@ static int cups_job_submit(int snum, struct printjob *pjob,
 		}
 	} else {
 		DEBUG(0,("Unable to print file to `%s' - %s\n",
-			 lp_printername(talloc_tos(), snum),
+			 lp_printername(talloc_tos(), lp_sub, snum),
 			 ippErrorString(cupsLastError())));
 	}
 
@@ -1484,6 +1499,8 @@ static int cups_queue_get(const char *sharename,
 static int cups_queue_pause(int snum)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int		ret = 1;		/* Return value */
 	http_t		*http = NULL;		/* HTTP connection to server */
 	ipp_t		*request = NULL,	/* IPP Request */
@@ -1535,7 +1552,7 @@ static int cups_queue_pause(int snum)
         	     "attributes-natural-language", NULL, language->language);
 
 	if (!push_utf8_talloc(frame, &printername,
-			      lp_printername(talloc_tos(), snum), &size)) {
+			      lp_printername(talloc_tos(), lp_sub, snum), &size)) {
 		goto out;
 	}
 	ustatus = httpAssembleURIf(HTTP_URI_CODING_ALL,
@@ -1566,14 +1583,14 @@ static int cups_queue_pause(int snum)
 	if ((response = cupsDoRequest(http, request, "/admin/")) != NULL) {
 		if (ippGetStatusCode(response) >= IPP_OK_CONFLICT) {
 			DEBUG(0,("Unable to pause printer %s - %s\n",
-				 lp_printername(talloc_tos(), snum),
+				 lp_printername(talloc_tos(), lp_sub, snum),
 				ippErrorString(cupsLastError())));
 		} else {
 			ret = 0;
 		}
 	} else {
 		DEBUG(0,("Unable to pause printer %s - %s\n",
-			 lp_printername(talloc_tos(), snum),
+			 lp_printername(talloc_tos(), lp_sub, snum),
 			ippErrorString(cupsLastError())));
 	}
 
@@ -1599,6 +1616,8 @@ static int cups_queue_pause(int snum)
 static int cups_queue_resume(int snum)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int		ret = 1;		/* Return value */
 	http_t		*http = NULL;		/* HTTP connection to server */
 	ipp_t		*request = NULL,	/* IPP Request */
@@ -1649,7 +1668,7 @@ static int cups_queue_resume(int snum)
 	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
         	     "attributes-natural-language", NULL, language->language);
 
-	if (!push_utf8_talloc(frame, &printername, lp_printername(talloc_tos(), snum),
+	if (!push_utf8_talloc(frame, &printername, lp_printername(talloc_tos(), lp_sub, snum),
 			      &size)) {
 		goto out;
 	}
@@ -1681,14 +1700,14 @@ static int cups_queue_resume(int snum)
 	if ((response = cupsDoRequest(http, request, "/admin/")) != NULL) {
 		if (ippGetStatusCode(response) >= IPP_OK_CONFLICT) {
 			DEBUG(0,("Unable to resume printer %s - %s\n",
-				 lp_printername(talloc_tos(), snum),
+				 lp_printername(talloc_tos(), lp_sub, snum),
 				ippErrorString(cupsLastError())));
 		} else {
 			ret = 0;
 		}
 	} else {
 		DEBUG(0,("Unable to resume printer %s - %s\n",
-			 lp_printername(talloc_tos(), snum),
+			 lp_printername(talloc_tos(), lp_sub, snum),
 			ippErrorString(cupsLastError())));
 	}
 
diff --git a/source3/printing/print_generic.c b/source3/printing/print_generic.c
index 574f357c76c..0059fad23c5 100644
--- a/source3/printing/print_generic.c
+++ b/source3/printing/print_generic.c
@@ -31,6 +31,8 @@ extern userdom_struct current_user_info;
 static int print_run_command(int snum, const char* printername, bool do_sub,
 			     const char *command, int *outfd, ...)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *syscmd;
 	char *arg;
 	int ret;
@@ -73,14 +75,14 @@ static int print_run_command(int snum, const char* printername, bool do_sub,
 		return -1;
 	}
 
-	syscmd = lp_string(ctx, syscmd);
+	syscmd = lpcfg_substituted_string(ctx, lp_sub, syscmd);
 	if (syscmd == NULL) {
 		return -1;
 	}
 
 	if (do_sub && snum != -1) {
 		syscmd = talloc_sub_advanced(ctx,
-				lp_servicename(talloc_tos(), snum),
+				lp_servicename(talloc_tos(), lp_sub, snum),
 				current_user_info.unix_name,
 				"",
 				get_current_gid(NULL),
@@ -118,11 +120,13 @@ pause a job
 ****************************************************************************/
 static int generic_job_pause(int snum, struct printjob *pjob)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	fstring jobstr;
 	
 	/* need to pause the spooled entry */
 	slprintf(jobstr, sizeof(jobstr)-1, "%d", pjob->sysjob);
-	return print_run_command(snum, lp_printername(talloc_tos(), snum), True,
+	return print_run_command(snum, lp_printername(talloc_tos(), lp_sub, snum), True,
 				 lp_lppause_command(snum), NULL,
 				 "%j", jobstr,
 				 NULL);
@@ -133,11 +137,13 @@ resume a job
 ****************************************************************************/
 static int generic_job_resume(int snum, struct printjob *pjob)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	fstring jobstr;
 
 	/* need to pause the spooled entry */
 	slprintf(jobstr, sizeof(jobstr)-1, "%d", pjob->sysjob);
-	return print_run_command(snum, lp_printername(talloc_tos(), snum), True,
+	return print_run_command(snum, lp_printername(talloc_tos(), lp_sub, snum), True,
 				 lp_lpresume_command(snum), NULL,
 				 "%j", jobstr,
 				 NULL);
@@ -208,6 +214,8 @@ static int generic_job_submit(int snum, struct printjob *pjob,
 			      char *lpq_cmd)
 {
 	int ret = -1;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *current_directory = NULL;
 	char *print_directory = NULL;
 	char *wd = NULL;
@@ -259,7 +267,7 @@ static int generic_job_submit(int snum, struct printjob *pjob,
 	slprintf(job_size, sizeof(job_size)-1, "%lu", (unsigned long)pjob->size);
 
 	/* send it to the system spooler */
-	ret = print_run_command(snum, lp_printername(talloc_tos(), snum), True,
+	ret = print_run_command(snum, lp_printername(talloc_tos(), lp_sub, snum), True,
 			lp_print_command(snum), NULL,
 			"%s", p,
 			"%J", jobname,
@@ -277,7 +285,7 @@ static int generic_job_submit(int snum, struct printjob *pjob,
 	 * determine the backend job identifier (sysjob).
 	 */
 	pjob->sysjob = -1;
-	ret = generic_queue_get(lp_printername(talloc_tos(), snum),
+	ret = generic_queue_get(lp_printername(talloc_tos(), lp_sub, snum),
 				printing_type, lpq_cmd, &q, &status);
 	if (ret > 0) {
 		int i;
@@ -312,7 +320,10 @@ static int generic_job_submit(int snum, struct printjob *pjob,
 ****************************************************************************/
 static int generic_queue_pause(int snum)
 {
-	return print_run_command(snum, lp_printername(talloc_tos(), snum), True,
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
+	return print_run_command(snum, lp_printername(talloc_tos(), lp_sub, snum), True,
 				 lp_queuepause_command(snum), NULL, NULL);
 }
 
@@ -321,7 +332,10 @@ static int generic_queue_pause(int snum)
 ****************************************************************************/
 static int generic_queue_resume(int snum)
 {
-	return print_run_command(snum, lp_printername(talloc_tos(), snum), True,
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
+	return print_run_command(snum, lp_printername(talloc_tos(), lp_sub, snum), True,
 				 lp_queueresume_command(snum), NULL, NULL);
 }
 
diff --git a/source3/printing/print_iprint.c b/source3/printing/print_iprint.c
index 1c9e5a25922..f75aa0a12ac 100644
--- a/source3/printing/print_iprint.c
+++ b/source3/printing/print_iprint.c
@@ -93,7 +93,9 @@ iprint_passwd_cb(const char *prompt)	/* I - Prompt */
 
 static const char *iprint_server(void)
 {
-	const char *server = lp_iprint_server(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *server = lp_iprint_server(talloc_tos(), lp_sub);
 
 	if ((server != NULL) && (strlen(server) > 0)) {
 		DEBUG(10, ("iprint server explicitly set to %s\n",
@@ -375,7 +377,19 @@ bool iprint_cache_reload(struct pcap_cache **_pcache)
 	* Try to connect to the server...
 	*/
 
-	if ((http = httpConnect(iprint_server(), ippPort())) == NULL) {
+#ifdef HAVE_HTTPCONNECT2
+	http = httpConnect2(iprint_server(),
+			    ippPort(),
+			    NULL,
+			    AF_UNSPEC,
+			    HTTP_ENCRYPTION_NEVER,
+			    1, /* blocking */
+			    30 * 1000, /* timeout */
+			    NULL);
+#else
+	http = httpConnect(iprint_server(), ippPort());
+#endif
+	if (http == NULL) {
 		DEBUG(0,("Unable to connect to iPrint server %s - %s\n", 
 			 iprint_server(), strerror(errno)));
 		goto out;
@@ -495,7 +509,19 @@ static int iprint_job_delete(const char *sharename, const char *lprm_command, st
 	* Try to connect to the server...
 	*/
 
-	if ((http = httpConnect(iprint_server(), ippPort())) == NULL) {
+#ifdef HAVE_HTTPCONNECT2
+	http = httpConnect2(iprint_server(),
+			    ippPort(),
+			    NULL,
+			    AF_UNSPEC,
+			    HTTP_ENCRYPTION_NEVER,
+			    1, /* blocking */
+			    30 * 1000, /* timeout */
+			    NULL);
+#else
+	http = httpConnect(iprint_server(), ippPort());
+#endif
+	if (http == NULL) {
 		DEBUG(0,("Unable to connect to iPrint server %s - %s\n", 
 			 iprint_server(), strerror(errno)));
 		goto out;
@@ -579,6 +605,8 @@ static int iprint_job_pause(int snum, struct printjob *pjob)
 	cups_lang_t	*language = NULL;	/* Default language */
 	char		uri[HTTP_MAX_URI];	/* printer-uri attribute */
 	char		httpPath[HTTP_MAX_URI];	/* path portion of the printer-uri */
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 
 	DEBUG(5,("iprint_job_pause(%d, %p (%d))\n", snum, pjob, pjob->sysjob));
@@ -593,7 +621,19 @@ static int iprint_job_pause(int snum, struct printjob *pjob)
 	* Try to connect to the server...
 	*/
 
-	if ((http = httpConnect(iprint_server(), ippPort())) == NULL) {
+#ifdef HAVE_HTTPCONNECT2
+	http = httpConnect2(iprint_server(),
+			    ippPort(),
+			    NULL,
+			    AF_UNSPEC,
+			    HTTP_ENCRYPTION_NEVER,
+			    1, /* blocking */
+			    30 * 1000, /* timeout */
+			    NULL);
+#else
+	http = httpConnect(iprint_server(), ippPort());
+#endif
+	if (http == NULL) {
 		DEBUG(0,("Unable to connect to iPrint server %s - %s\n", 
 			 iprint_server(), strerror(errno)));
 		goto out;
@@ -624,7 +664,7 @@ static int iprint_job_pause(int snum, struct printjob *pjob)
 	             "attributes-natural-language", NULL, language->language);
 
 	slprintf(uri, sizeof(uri) - 1, "ipp://%s/ipp/%s", iprint_server(),
-		 lp_printername(talloc_tos(), snum));
+		 lp_printername(talloc_tos(), lp_sub, snum));
 
 	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri", NULL, uri);
 
@@ -638,7 +678,7 @@ static int iprint_job_pause(int snum, struct printjob *pjob)
 	*/
 
 	slprintf(httpPath, sizeof(httpPath) - 1, "/ipp/%s",
-		 lp_printername(talloc_tos(), snum));
+		 lp_printername(talloc_tos(), lp_sub, snum));
 
 	if ((response = cupsDoRequest(http, request, httpPath)) != NULL) {
 		if (ippGetStatusCode(response) >= IPP_OK_CONFLICT) {
@@ -679,6 +719,8 @@ static int iprint_job_resume(int snum, struct printjob *pjob)
 	cups_lang_t	*language = NULL;	/* Default language */
 	char		uri[HTTP_MAX_URI];	/* printer-uri attribute */
 	char		httpPath[HTTP_MAX_URI];	/* path portion of the printer-uri */
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 
 	DEBUG(5,("iprint_job_resume(%d, %p (%d))\n", snum, pjob, pjob->sysjob));
@@ -693,7 +735,19 @@ static int iprint_job_resume(int snum, struct printjob *pjob)
 	* Try to connect to the server...
 	*/
 
-	if ((http = httpConnect(iprint_server(), ippPort())) == NULL) {
+#ifdef HAVE_HTTPCONNECT2
+	http = httpConnect2(iprint_server(),
+			    ippPort(),
+			    NULL,
+			    AF_UNSPEC,
+			    HTTP_ENCRYPTION_NEVER,
+			    1, /* blocking */
+			    30 * 1000, /* timeout */
+			    NULL);
+#else
+	http = httpConnect(iprint_server(), ippPort());
+#endif
+	if (http == NULL) {
 		DEBUG(0,("Unable to connect to iPrint server %s - %s\n", 
 			 iprint_server(), strerror(errno)));
 		goto out;
@@ -724,7 +778,7 @@ static int iprint_job_resume(int snum, struct printjob *pjob)
 	             "attributes-natural-language", NULL, language->language);
 
 	slprintf(uri, sizeof(uri) - 1, "ipp://%s/ipp/%s", iprint_server(),
-		 lp_printername(talloc_tos(), snum));
+		 lp_printername(talloc_tos(), lp_sub, snum));
 
 	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri", NULL, uri);
 
@@ -738,7 +792,7 @@ static int iprint_job_resume(int snum, struct printjob *pjob)
 	*/
 
 	slprintf(httpPath, sizeof(httpPath) - 1, "/ipp/%s",
-		 lp_printername(talloc_tos(), snum));
+		 lp_printername(talloc_tos(), lp_sub, snum));
 
 	if ((response = cupsDoRequest(http, request, httpPath)) != NULL) {
 		if (ippGetStatusCode(response) >= IPP_OK_CONFLICT) {
@@ -781,6 +835,8 @@ static int iprint_job_submit(int snum, struct printjob *pjob,
 	ipp_attribute_t	*attr;		/* Current attribute */
 	cups_lang_t	*language = NULL;	/* Default language */
 	char		uri[HTTP_MAX_URI]; /* printer-uri attribute */
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	DEBUG(5,("iprint_job_submit(%d, %p (%d))\n", snum, pjob, pjob->sysjob));
 
@@ -794,7 +850,19 @@ static int iprint_job_submit(int snum, struct printjob *pjob,
 	* Try to connect to the server...
 	*/
 
-	if ((http = httpConnect(iprint_server(), ippPort())) == NULL) {
+#ifdef HAVE_HTTPCONNECT2
+	http = httpConnect2(iprint_server(),
+			    ippPort(),
+			    NULL,
+			    AF_UNSPEC,
+			    HTTP_ENCRYPTION_NEVER,
+			    1, /* blocking */
+			    30 * 1000, /* timeout */
+			    NULL);
+#else
+	http = httpConnect(iprint_server(), ippPort());
+#endif
+	if (http == NULL) {
 		DEBUG(0,("Unable to connect to iPrint server %s - %s\n", 
 			 iprint_server(), strerror(errno)));
 		goto out;
@@ -825,7 +893,7 @@ static int iprint_job_submit(int snum, struct printjob *pjob,
 	             "attributes-natural-language", NULL, language->language);
 
 	slprintf(uri, sizeof(uri) - 1, "ipp://%s/ipp/%s", iprint_server(),
-		 lp_printername(talloc_tos(), snum));
+		 lp_printername(talloc_tos(), lp_sub, snum));
 
 	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
 	             "printer-uri", NULL, uri);
@@ -844,19 +912,19 @@ static int iprint_job_submit(int snum, struct printjob *pjob,
 	* Do the request and get back a response...
 	*/
 
-	slprintf(uri, sizeof(uri) - 1, "/ipp/%s", lp_printername(talloc_tos(), snum));
+	slprintf(uri, sizeof(uri) - 1, "/ipp/%s", lp_printername(talloc_tos(), lp_sub, snum));
 
 	if ((response = cupsDoFileRequest(http, request, uri, pjob->filename)) != NULL) {
 		if (ippGetStatusCode(response) >= IPP_OK_CONFLICT) {
 			DEBUG(0,("Unable to print file to %s - %s\n",
-				 lp_printername(talloc_tos(), snum),
+				 lp_printername(talloc_tos(), lp_sub, snum),
 			         ippErrorString(cupsLastError())));
 		} else {
 			ret = 0;
 		}
 	} else {
 		DEBUG(0,("Unable to print file to `%s' - %s\n",
-			 lp_printername(talloc_tos(), snum),
+			 lp_printername(talloc_tos(), lp_sub, snum),
 			 ippErrorString(cupsLastError())));
 	}
 
@@ -959,7 +1027,19 @@ static int iprint_queue_get(const char *sharename,
 	* Try to connect to the server...
 	*/
 
-	if ((http = httpConnect(iprint_server(), ippPort())) == NULL) {
+#ifdef HAVE_HTTPCONNECT2
+	http = httpConnect2(iprint_server(),
+			    ippPort(),
+			    NULL,
+			    AF_UNSPEC,
+			    HTTP_ENCRYPTION_NEVER,
+			    1, /* blocking */
+			    30 * 1000, /* timeout */
+			    NULL);
+#else
+	http = httpConnect(iprint_server(), ippPort());
+#endif
+	if (http == NULL) {
 		DEBUG(0,("Unable to connect to iPrint server %s - %s\n", 
 			 iprint_server(), strerror(errno)));
 		goto out;
diff --git a/source3/printing/printing.c b/source3/printing/printing.c
index 0f4db52e011..3c74efb9657 100644
--- a/source3/printing/printing.c
+++ b/source3/printing/printing.c
@@ -1711,6 +1711,8 @@ static void print_queue_update(struct messaging_context *msg_ctx,
 	int type;
 	struct printif *current_printif;
 	TALLOC_CTX *ctx = talloc_tos();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	fstrcpy( sharename, lp_const_servicename(snum));
 
@@ -1719,13 +1721,13 @@ static void print_queue_update(struct messaging_context *msg_ctx,
 	lpqcommand = talloc_string_sub2(ctx,
 			lp_lpq_command(snum),
 			"%p",
-			lp_printername(talloc_tos(), snum),
+			lp_printername(talloc_tos(), lp_sub, snum),
 			false, false, false);
 	if (!lpqcommand) {
 		return;
 	}
 	lpqcommand = talloc_sub_full(ctx,
-			lp_servicename(talloc_tos(), snum),
+			lp_servicename(talloc_tos(), lp_sub, snum),
 			current_user_info.unix_name,
 			"",
 			get_current_gid(NULL),
@@ -1739,13 +1741,13 @@ static void print_queue_update(struct messaging_context *msg_ctx,
 	lprmcommand = talloc_string_sub2(ctx,
 			lp_lprm_command(snum),
 			"%p",
-			lp_printername(talloc_tos(), snum),
+			lp_printername(talloc_tos(), lp_sub, snum),
 			false, false, false);
 	if (!lprmcommand) {
 		return;
 	}
 	lprmcommand = talloc_sub_full(ctx,
-			lp_servicename(talloc_tos(), snum),
+			lp_servicename(talloc_tos(), lp_sub, snum),
 			current_user_info.unix_name,
 			"",
 			get_current_gid(NULL),
@@ -2157,6 +2159,8 @@ static bool print_job_delete1(struct tevent_context *ev,
 			      int snum, uint32_t jobid)
 {
 	const char* sharename = lp_const_servicename(snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct printjob *pjob;
 	int result = 0;
 	struct printif *current_printif = get_printer_fns( snum );
@@ -2198,7 +2202,7 @@ static bool print_job_delete1(struct tevent_context *ev,
 	if (pjob->spooled && pjob->sysjob != -1)
 	{
 		result = (*(current_printif->job_delete))(
-			lp_printername(talloc_tos(), snum),
+			lp_printername(talloc_tos(), lp_sub, snum),
 			lp_lprm_command(snum),
 			pjob);
 
@@ -2264,6 +2268,8 @@ WERROR print_job_delete(const struct auth_session_info *server_info,
 			int snum, uint32_t jobid)
 {
 	const char* sharename = lp_const_servicename(snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct printjob *pjob;
 	bool 	owner;
 	WERROR werr;
@@ -2283,7 +2289,7 @@ WERROR print_job_delete(const struct auth_session_info *server_info,
 		DEBUG(0, ("print job delete denied."
 			  "User name: %s, Printer name: %s.",
 			  uidtoname(server_info->unix_token->uid),
-			  lp_printername(tmp_ctx, snum)));
+			  lp_printername(tmp_ctx, lp_sub, snum)));
 
 		werr = WERR_ACCESS_DENIED;
 		goto err_out;
@@ -2338,6 +2344,8 @@ WERROR print_job_pause(const struct auth_session_info *server_info,
 		     int snum, uint32_t jobid)
 {
 	const char* sharename = lp_const_servicename(snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct printjob *pjob;
 	int ret = -1;
 	struct printif *current_printif = get_printer_fns( snum );
@@ -2368,7 +2376,7 @@ WERROR print_job_pause(const struct auth_session_info *server_info,
 		DEBUG(0, ("print job pause denied."
 			  "User name: %s, Printer name: %s.",
 			  uidtoname(server_info->unix_token->uid),
-			  lp_printername(tmp_ctx, snum)));
+			  lp_printername(tmp_ctx, lp_sub, snum)));
 
 		werr = WERR_ACCESS_DENIED;
 		goto err_out;
@@ -2406,6 +2414,8 @@ WERROR print_job_resume(const struct auth_session_info *server_info,
 		      int snum, uint32_t jobid)
 {
 	const char *sharename = lp_const_servicename(snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct printjob *pjob;
 	int ret;
 	struct printif *current_printif = get_printer_fns( snum );
@@ -2435,7 +2445,7 @@ WERROR print_job_resume(const struct auth_session_info *server_info,
 		DEBUG(0, ("print job resume denied."
 			  "User name: %s, Printer name: %s.",
 			  uidtoname(server_info->unix_token->uid),
-			  lp_printername(tmp_ctx, snum)));
+			  lp_printername(tmp_ctx, lp_sub, snum)));
 
 		werr = WERR_ACCESS_DENIED;
 		goto err_out;
@@ -2688,6 +2698,8 @@ static WERROR print_job_checks(const struct auth_session_info *server_info,
 			       int snum, int *njobs)
 {
 	const char *sharename = lp_const_servicename(snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint64_t dspace, dsize;
 	uint64_t minspace;
 	int ret;
@@ -2708,7 +2720,7 @@ static WERROR print_job_checks(const struct auth_session_info *server_info,
 	/* see if we have sufficient disk space */
 	if (lp_min_print_space(snum)) {
 		minspace = lp_min_print_space(snum);
-		ret = sys_fsusage(lp_path(talloc_tos(), snum), &dspace, &dsize);
+		ret = sys_fsusage(lp_path(talloc_tos(), lp_sub, snum), &dspace, &dsize);
 		if (ret == 0 && dspace < 2*minspace) {
 			DEBUG(3, ("print_job_checks: "
 				  "disk space check failed.\n"));
@@ -2743,6 +2755,8 @@ static WERROR print_job_spool_file(int snum, uint32_t jobid,
 				   const char *output_file,
 				   struct printjob *pjob)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	WERROR werr;
 	SMB_STRUCT_STAT st;
 	const char *path;
@@ -2754,7 +2768,7 @@ static WERROR print_job_spool_file(int snum, uint32_t jobid,
 	 * Verify that the file name is ok, within path, and it is
 	 * already already there */
 	if (output_file) {
-		path = lp_path(talloc_tos(), snum);
+		path = lp_path(talloc_tos(), lp_sub, snum);
 		len = strlen(path);
 		if (strncmp(output_file, path, len) == 0 &&
 		    (output_file[len - 1] == '/' || output_file[len] == '/')) {
@@ -2783,7 +2797,7 @@ static WERROR print_job_spool_file(int snum, uint32_t jobid,
 	}
 
 	slprintf(pjob->filename, sizeof(pjob->filename)-1,
-		 "%s/%sXXXXXX", lp_path(talloc_tos(), snum),
+		 "%s/%sXXXXXX", lp_path(talloc_tos(), lp_sub, snum),
 		 PRINT_SPOOL_PREFIX);
 	mask = umask(S_IRWXO | S_IRWXG);
 	pjob->fd = mkstemp(pjob->filename);
@@ -2823,6 +2837,8 @@ WERROR print_job_start(const struct auth_session_info *server_info,
 	struct printjob pjob;
 	const char *sharename = lp_const_servicename(snum);
 	struct tdb_print_db *pdb = get_print_db_byname(sharename);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int njobs;
 	WERROR werr;
 
@@ -2830,7 +2846,7 @@ WERROR print_job_start(const struct auth_session_info *server_info,
 		return WERR_INTERNAL_DB_CORRUPTION;
 	}
 
-	path = lp_path(talloc_tos(), snum);
+	path = lp_path(talloc_tos(), lp_sub, snum);
 
 	werr = print_job_checks(server_info, msg_ctx, snum, &njobs);
 	if (!W_ERROR_IS_OK(werr)) {
@@ -2952,6 +2968,8 @@ NTSTATUS print_job_end(struct messaging_context *msg_ctx, int snum,
 		       uint32_t jobid, enum file_close_type close_type)
 {
 	const char* sharename = lp_const_servicename(snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct printjob *pjob;
 	int ret;
 	SMB_STRUCT_STAT sbuf;
@@ -3029,14 +3047,14 @@ NTSTATUS print_job_end(struct messaging_context *msg_ctx, int snum,
 	lpq_cmd = talloc_string_sub2(tmp_ctx,
 				     lp_lpq_command(snum),
 				     "%p",
-				     lp_printername(talloc_tos(), snum),
+				     lp_printername(talloc_tos(), lp_sub, snum),
 				     false, false, false);
 	if (lpq_cmd == NULL) {
 		status = NT_STATUS_PRINT_CANCELLED;
 		goto fail;
 	}
 	lpq_cmd = talloc_sub_full(tmp_ctx,
-				      lp_servicename(talloc_tos(), snum),
+				      lp_servicename(talloc_tos(), lp_sub, snum),
 				      current_user_info.unix_name,
 				      "",
 				      get_current_gid(NULL),
@@ -3087,6 +3105,8 @@ static bool get_stored_queue_info(struct messaging_context *msg_ctx,
 				  struct tdb_print_db *pdb, int snum,
 				  int *pcount, print_queue_struct **ppqueue)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	TDB_DATA data, cgdata, jcdata;
 	print_queue_struct *queue = NULL;
 	uint32_t qcount = 0;
@@ -3097,7 +3117,7 @@ static bool get_stored_queue_info(struct messaging_context *msg_ctx,
 	uint32_t i;
 	int max_reported_jobs = lp_max_reported_print_jobs(snum);
 	bool ret = false;
-	const char* sharename = lp_servicename(talloc_tos(), snum);
+	const char* sharename = lp_servicename(talloc_tos(), lp_sub, snum);
 	TALLOC_CTX *tmp_ctx = talloc_new(msg_ctx);
 	if (tmp_ctx == NULL) {
 		return false;
diff --git a/source3/printing/printspoolss.c b/source3/printing/printspoolss.c
index 9d565de120a..523e429b205 100644
--- a/source3/printing/printspoolss.c
+++ b/source3/printing/printspoolss.c
@@ -57,6 +57,8 @@ NTSTATUS print_spool_open(files_struct *fsp,
 			  const char *fname,
 			  uint64_t current_vuid)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	NTSTATUS status;
 	TALLOC_CTX *tmp_ctx;
 	struct print_file_data *pf;
@@ -78,7 +80,7 @@ NTSTATUS print_spool_open(files_struct *fsp,
 		status = NT_STATUS_NO_MEMORY;
 		goto done;
 	}
-	pf->svcname = lp_servicename(pf, SNUM(fsp->conn));
+	pf->svcname = lp_servicename(pf, lp_sub, SNUM(fsp->conn));
 
 	/* the document name is derived from the file name.
 	 * "Remote Downlevel Document" is added in front to
@@ -119,6 +121,7 @@ NTSTATUS print_spool_open(files_struct *fsp,
 
 	pf->filename = talloc_asprintf(pf, "%s/%sXXXXXX",
 					lp_path(talloc_tos(),
+						lp_sub,
 						SNUM(fsp->conn)),
 					PRINT_SPOOL_PREFIX);
 	if (!pf->filename) {
diff --git a/source3/printing/queue_process.c b/source3/printing/queue_process.c
index 905fd63970b..0b6dc9fca9f 100644
--- a/source3/printing/queue_process.c
+++ b/source3/printing/queue_process.c
@@ -56,6 +56,8 @@ static void delete_and_reload_printers_full(struct tevent_context *ev,
 {
 	struct auth_session_info *session_info = NULL;
 	struct spoolss_PrinterInfo2 *pinfo2 = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int n_services;
 	int pnum;
 	int snum;
@@ -91,7 +93,7 @@ static void delete_and_reload_printers_full(struct tevent_context *ev,
 		}
 
 		sname = lp_const_servicename(snum);
-		pname = lp_printername(session_info, snum);
+		pname = lp_printername(session_info, lp_sub, snum);
 
 		/* check printer, but avoid removing non-autoloaded printers */
 		if (lp_autoloaded(snum) && !pcap_printername_ok(pname)) {
@@ -101,6 +103,7 @@ static void delete_and_reload_printers_full(struct tevent_context *ev,
 						 msg_ctx,
 						 NULL,
 						 lp_servicename(session_info,
+								lp_sub,
 								snum),
 						 &pinfo2)) {
 				nt_printer_publish(session_info,
diff --git a/source3/printing/spoolssd.c b/source3/printing/spoolssd.c
index 427e31e0122..ebfeea4f76d 100644
--- a/source3/printing/spoolssd.c
+++ b/source3/printing/spoolssd.c
@@ -59,7 +59,9 @@ static struct pf_daemon_config pf_spoolss_cfg = { 0 };
 
 static void spoolss_reopen_logs(int child_id)
 {
-	char *lfile = lp_logfile(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *lfile = lp_logfile(talloc_tos(), lp_sub);
 	char *ext;
 	int rc;
 
@@ -81,11 +83,11 @@ static void spoolss_reopen_logs(int child_id)
 		if (strstr(lfile, ext) == NULL) {
 			if (child_id) {
 				rc = asprintf(&lfile, "%s.%d",
-					      lp_logfile(talloc_tos()),
+					      lp_logfile(talloc_tos(), lp_sub),
 					      child_id);
 			} else {
 				rc = asprintf(&lfile, "%s.%s",
-					      lp_logfile(talloc_tos()),
+					      lp_logfile(talloc_tos(), lp_sub),
 					      ext);
 			}
 		}
@@ -580,14 +582,16 @@ static void print_queue_forward(struct messaging_context *msg,
 
 static char *get_bq_logfile(void)
 {
-	char *lfile = lp_logfile(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *lfile = lp_logfile(talloc_tos(), lp_sub);
 	int rc;
 
 	if (lfile == NULL || lfile[0] == '\0') {
 		rc = asprintf(&lfile, "%s/log.%s.bq",
 					get_dyn_LOGFILEBASE(), DAEMON_NAME);
 	} else {
-		rc = asprintf(&lfile, "%s.bq", lp_logfile(talloc_tos()));
+		rc = asprintf(&lfile, "%s.bq", lp_logfile(talloc_tos(), lp_sub));
 	}
 	if (rc == -1) {
 		lfile = NULL;
diff --git a/source3/rpc_client/cli_netlogon.c b/source3/rpc_client/cli_netlogon.c
index ea9cb757048..175f83d6750 100644
--- a/source3/rpc_client/cli_netlogon.c
+++ b/source3/rpc_client/cli_netlogon.c
@@ -37,6 +37,7 @@
 #include "dbwrap/dbwrap.h"
 #include "dbwrap/dbwrap_open.h"
 #include "util_tdb.h"
+#include "lib/crypto/gnutls_helpers.h"
 
 
 NTSTATUS rpccli_pre_open_netlogon_creds(void)
@@ -528,6 +529,7 @@ NTSTATUS rpccli_netlogon_password_logon(
 	case NetlogonNetworkTransitiveInformation: {
 		struct netr_NetworkInfo *network_info;
 		uint8_t chal[8];
+		int rc;
 
 		ZERO_STRUCT(lm);
 		ZERO_STRUCT(nt);
@@ -541,7 +543,11 @@ NTSTATUS rpccli_netlogon_password_logon(
 		generate_random_buffer(chal, 8);
 
 		SMBencrypt(password, chal, local_lm_response);
-		SMBNTencrypt(password, chal, local_nt_response);
+		rc = SMBNTencrypt(password, chal, local_nt_response);
+		if (rc != 0) {
+			TALLOC_FREE(frame);
+			return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 
 		lm.length = 24;
 		lm.data = local_lm_response;
diff --git a/source3/rpc_client/cli_samr.c b/source3/rpc_client/cli_samr.c
index a3b24e7b164..acd96480a20 100644
--- a/source3/rpc_client/cli_samr.c
+++ b/source3/rpc_client/cli_samr.c
@@ -39,6 +39,7 @@ NTSTATUS dcerpc_samr_chgpasswd_user(struct dcerpc_binding_handle *h,
 				    NTSTATUS *presult)
 {
 	NTSTATUS status;
+	int rc;
 	struct samr_Password hash1, hash2, hash3, hash4, hash5, hash6;
 
 	uint8_t old_nt_hash[16] = {0};
@@ -54,12 +55,36 @@ NTSTATUS dcerpc_samr_chgpasswd_user(struct dcerpc_binding_handle *h,
 	E_deshash(oldpassword, old_lm_hash);
 	E_deshash(newpassword, new_lm_hash);
 
-	E_old_pw_hash(new_lm_hash, old_lm_hash, hash1.hash);
-	E_old_pw_hash(old_lm_hash, new_lm_hash, hash2.hash);
-	E_old_pw_hash(new_nt_hash, old_nt_hash, hash3.hash);
-	E_old_pw_hash(old_nt_hash, new_nt_hash, hash4.hash);
-	E_old_pw_hash(old_lm_hash, new_nt_hash, hash5.hash);
-	E_old_pw_hash(old_nt_hash, new_lm_hash, hash6.hash);
+	rc = E_old_pw_hash(new_lm_hash, old_lm_hash, hash1.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto done;
+	}
+	rc = E_old_pw_hash(old_lm_hash, new_lm_hash, hash2.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto done;
+	}
+	rc = E_old_pw_hash(new_nt_hash, old_nt_hash, hash3.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto done;
+	}
+	rc = E_old_pw_hash(old_nt_hash, new_nt_hash, hash4.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto done;
+	}
+	rc = E_old_pw_hash(old_lm_hash, new_nt_hash, hash5.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto done;
+	}
+	rc = E_old_pw_hash(old_nt_hash, new_lm_hash, hash6.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto done;
+	}
 
 	status = dcerpc_samr_ChangePasswordUser(h,
 						mem_ctx,
@@ -76,6 +101,7 @@ NTSTATUS dcerpc_samr_chgpasswd_user(struct dcerpc_binding_handle *h,
 						&hash6,
 						presult);
 
+done:
 	ZERO_ARRAY(old_nt_hash);
 	ZERO_ARRAY(old_lm_hash);
 	ZERO_ARRAY(new_nt_hash);
@@ -117,6 +143,7 @@ NTSTATUS dcerpc_samr_chgpasswd_user2(struct dcerpc_binding_handle *h,
 				     NTSTATUS *presult)
 {
 	NTSTATUS status;
+	int rc;
 	struct samr_CryptPassword new_nt_password;
 	struct samr_CryptPassword new_lm_password;
 	struct samr_Password old_nt_hash_enc;
@@ -153,7 +180,11 @@ NTSTATUS dcerpc_samr_chgpasswd_user2(struct dcerpc_binding_handle *h,
 			return status;
 		}
 
-		E_old_pw_hash(new_nt_hash, old_lanman_hash, old_lanman_hash_enc.hash);
+		rc = E_old_pw_hash(new_nt_hash, old_lanman_hash, old_lanman_hash_enc.hash);
+		if (rc != 0) {
+			status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			goto done;
+		}
 	} else {
 		ZERO_STRUCT(new_lm_password);
 		ZERO_STRUCT(old_lanman_hash_enc);
@@ -165,7 +196,11 @@ NTSTATUS dcerpc_samr_chgpasswd_user2(struct dcerpc_binding_handle *h,
 	if (!NT_STATUS_IS_OK(status)) {
 		return status;
 	}
-	E_old_pw_hash(new_nt_hash, old_nt_hash, old_nt_hash_enc.hash);
+	rc = E_old_pw_hash(new_nt_hash, old_nt_hash, old_nt_hash_enc.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto done;
+	}
 
 	status = dcerpc_samr_ChangePasswordUser2(h,
 						 mem_ctx,
@@ -178,6 +213,7 @@ NTSTATUS dcerpc_samr_chgpasswd_user2(struct dcerpc_binding_handle *h,
 						 &old_lanman_hash_enc,
 						 presult);
 
+done:
 	ZERO_STRUCT(new_nt_password);
 	ZERO_STRUCT(new_lm_password);
 	ZERO_STRUCT(old_nt_hash_enc);
@@ -312,6 +348,7 @@ NTSTATUS dcerpc_samr_chgpasswd_user3(struct dcerpc_binding_handle *h,
 				     NTSTATUS *presult)
 {
 	NTSTATUS status;
+	int rc;
 
 	struct samr_CryptPassword new_nt_password;
 	struct samr_CryptPassword new_lm_password;
@@ -350,7 +387,11 @@ NTSTATUS dcerpc_samr_chgpasswd_user3(struct dcerpc_binding_handle *h,
 			return status;
 		}
 
-		E_old_pw_hash(new_nt_hash, old_lanman_hash, old_lanman_hash_enc.hash);
+		rc = E_old_pw_hash(new_nt_hash, old_lanman_hash, old_lanman_hash_enc.hash);
+		if (rc != 0) {
+			status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			goto done;
+		}
 	} else {
 		ZERO_STRUCT(new_lm_password);
 		ZERO_STRUCT(old_lanman_hash_enc);
@@ -363,7 +404,11 @@ NTSTATUS dcerpc_samr_chgpasswd_user3(struct dcerpc_binding_handle *h,
 		return status;
 	}
 
-	E_old_pw_hash(new_nt_hash, old_nt_hash, old_nt_hash_enc.hash);
+	rc = E_old_pw_hash(new_nt_hash, old_nt_hash, old_nt_hash_enc.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto done;
+	}
 
 	status = dcerpc_samr_ChangePasswordUser3(h,
 						 mem_ctx,
@@ -379,6 +424,7 @@ NTSTATUS dcerpc_samr_chgpasswd_user3(struct dcerpc_binding_handle *h,
 						 reject,
 						 presult);
 
+done:
 	ZERO_STRUCT(new_nt_password);
 	ZERO_STRUCT(new_lm_password);
 	ZERO_STRUCT(old_nt_hash_enc);
diff --git a/source3/rpc_server/dfs/srv_dfs_nt.c b/source3/rpc_server/dfs/srv_dfs_nt.c
index 0a4d6d31b7c..49f2b359283 100644
--- a/source3/rpc_server/dfs/srv_dfs_nt.c
+++ b/source3/rpc_server/dfs/srv_dfs_nt.c
@@ -75,7 +75,9 @@ WERROR _dfs_Add(struct pipes_struct *p, struct dfs_Add *r)
 	}
 
 	/* The following call can change the cwd. */
-	status = get_referred_path(ctx, r->in.path,
+	status = get_referred_path(ctx,
+				   p->session_info,
+				   r->in.path,
 				   p->remote_address,
 				   p->local_address,
 				   true, /*allow_broken_path */
@@ -106,7 +108,7 @@ WERROR _dfs_Add(struct pipes_struct *p, struct dfs_Add *r)
 	jn->referral_list[jn->referral_count-1].ttl = REFERRAL_TTL;
 	jn->referral_list[jn->referral_count-1].alternate_path = altpath;
 
-	if(!create_msdfs_link(jn)) {
+	if(!create_msdfs_link(jn, p->session_info)) {
 		return WERR_NERR_DFSCANTCREATEJUNCTIONPOINT;
 	}
 
@@ -147,7 +149,9 @@ WERROR _dfs_Remove(struct pipes_struct *p, struct dfs_Remove *r)
 			r->in.dfs_entry_path, r->in.servername, r->in.sharename));
 	}
 
-	status = get_referred_path(ctx, r->in.dfs_entry_path,
+	status = get_referred_path(ctx,
+				   p->session_info,
+				   r->in.dfs_entry_path,
 				   p->remote_address,
 				   p->local_address,
 				   true, /*allow_broken_path */
@@ -158,13 +162,15 @@ WERROR _dfs_Remove(struct pipes_struct *p, struct dfs_Remove *r)
 
 	/* if no server-share pair given, remove the msdfs link completely */
 	if(!r->in.servername && !r->in.sharename) {
-		if(!remove_msdfs_link(jn)) {
+		if(!remove_msdfs_link(jn, p->session_info)) {
 			return WERR_NERR_DFSNOSUCHVOLUME;
 		}
 	} else {
-		int i=0;
+		size_t i = 0;
 		/* compare each referral in the list with the one to remove */
-		DEBUG(10,("altpath: .%s. refcnt: %d\n", altpath, jn->referral_count));
+		DBG_DEBUG("altpath: .%s. refcnt: %zu\n",
+				altpath,
+				jn->referral_count);
 		for(i=0;i<jn->referral_count;i++) {
 			char *refpath = talloc_strdup(ctx,
 					jn->referral_list[i].alternate_path);
@@ -187,11 +193,11 @@ WERROR _dfs_Remove(struct pipes_struct *p, struct dfs_Remove *r)
 
 		/* Only one referral, remove it */
 		if(jn->referral_count == 1) {
-			if(!remove_msdfs_link(jn)) {
+			if(!remove_msdfs_link(jn, p->session_info)) {
 				return WERR_NERR_DFSNOSUCHVOLUME;
 			}
 		} else {
-			if(!create_msdfs_link(jn)) {
+			if(!create_msdfs_link(jn, p->session_info)) {
 				return WERR_NERR_DFSCANTCREATEJUNCTIONPOINT;
 			}
 		}
@@ -226,7 +232,7 @@ static bool init_reply_dfs_info_2(TALLOC_CTX *mem_ctx, struct junction_map* j, s
 
 static bool init_reply_dfs_info_3(TALLOC_CTX *mem_ctx, struct junction_map* j, struct dfs_Info3* dfs3)
 {
-	int ii;
+	size_t ii;
 	if (j->volume_name[0] == '\0')
 		dfs3->path = talloc_asprintf(mem_ctx, "\\\\%s\\%s",
 			lp_netbios_name(), j->service_name);
@@ -268,7 +274,7 @@ static bool init_reply_dfs_info_3(TALLOC_CTX *mem_ctx, struct junction_map* j, s
 			continue;
 		}
 		*p = '\0';
-		DEBUG(5,("storage %d: %s.%s\n",ii,path,p+1));
+		DBG_INFO("storage %zu: %s.%s\n",ii,path,p+1);
 		stor->state = 2; /* set all stores as ONLINE */
 		stor->server = talloc_strdup(mem_ctx, path);
 		stor->share = talloc_strdup(mem_ctx, p+1);
@@ -289,7 +295,7 @@ WERROR _dfs_Enum(struct pipes_struct *p, struct dfs_Enum *r)
 	size_t i;
 	TALLOC_CTX *ctx = talloc_tos();
 
-	jn = enum_msdfs_links(ctx, &num_jn);
+	jn = enum_msdfs_links(ctx, p->session_info, &num_jn);
 	if (!jn || num_jn == 0) {
 		num_jn = 0;
 		jn = NULL;
@@ -377,7 +383,9 @@ WERROR _dfs_GetInfo(struct pipes_struct *p, struct dfs_GetInfo *r)
 	}
 
 	/* The following call can change the cwd. */
-	status = get_referred_path(ctx, r->in.dfs_entry_path,
+	status = get_referred_path(ctx,
+				   p->session_info,
+				   r->in.dfs_entry_path,
 				   p->remote_address,
 				   p->local_address,
 				   true, /*allow_broken_path */
diff --git a/source3/rpc_server/epmd.c b/source3/rpc_server/epmd.c
index 2f41d22c97b..3e3bc6b4049 100644
--- a/source3/rpc_server/epmd.c
+++ b/source3/rpc_server/epmd.c
@@ -38,7 +38,9 @@
 
 static void epmd_reopen_logs(void)
 {
-	char *lfile = lp_logfile(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *lfile = lp_logfile(talloc_tos(), lp_sub);
 	int rc;
 
 	if (lfile == NULL || lfile[0] == '\0') {
@@ -50,7 +52,7 @@ static void epmd_reopen_logs(void)
 	} else {
 		if (strstr(lfile, DAEMON_NAME) == NULL) {
 			rc = asprintf(&lfile, "%s.%s",
-				      lp_logfile(talloc_tos()), DAEMON_NAME);
+				      lp_logfile(talloc_tos(), lp_sub), DAEMON_NAME);
 			if (rc > 0) {
 				lp_set_logfile(lfile);
 				SAFE_FREE(lfile);
diff --git a/source3/rpc_server/eventlog/srv_eventlog_nt.c b/source3/rpc_server/eventlog/srv_eventlog_nt.c
index 5093125a6f6..9d8322adf34 100644
--- a/source3/rpc_server/eventlog/srv_eventlog_nt.c
+++ b/source3/rpc_server/eventlog/srv_eventlog_nt.c
@@ -79,8 +79,10 @@ static EVENTLOG_INFO *find_eventlog_info_by_hnd( struct pipes_struct * p,
 /********************************************************************
 ********************************************************************/
 
-static bool elog_check_access( EVENTLOG_INFO *info, const struct security_token *token )
+static bool elog_check_access(EVENTLOG_INFO *info,
+			      struct auth_session_info *session_info)
 {
+	const struct security_token *token = session_info->security_token;
 	char *tdbname = elog_tdbname(talloc_tos(), info->logname );
 	struct security_descriptor *sec_desc;
 	struct security_ace *ace;
@@ -92,6 +94,7 @@ static bool elog_check_access( EVENTLOG_INFO *info, const struct security_token
 	/* get the security descriptor for the file */
 
 	status = get_nt_acl_no_snum( info,
+			session_info,
 			tdbname,
 			SECINFO_OWNER | SECINFO_GROUP | SECINFO_DACL,
 			&sec_desc);
@@ -242,7 +245,7 @@ static NTSTATUS elog_open( struct pipes_struct * p, const char *logname, struct
 			elog->logname = talloc_strdup( elog, ELOG_APPL );
 
 			/* do the access check */
-			if ( !elog_check_access( elog, p->session_info->security_token ) ) {
+			if ( !elog_check_access( elog, p->session_info) ) {
 				TALLOC_FREE( elog );
 				return NT_STATUS_ACCESS_DENIED;
 			}
@@ -260,7 +263,7 @@ static NTSTATUS elog_open( struct pipes_struct * p, const char *logname, struct
 
 	/* now do the access check.  Close the tdb if we fail here */
 
-	if ( !elog_check_access( elog, p->session_info->security_token ) ) {
+	if ( !elog_check_access( elog, p->session_info) ) {
 		TALLOC_FREE( elog );
 		return NT_STATUS_ACCESS_DENIED;
 	}
diff --git a/source3/rpc_server/fss/srv_fss_agent.c b/source3/rpc_server/fss/srv_fss_agent.c
index 13b4806e6a2..aebd9c0c753 100644
--- a/source3/rpc_server/fss/srv_fss_agent.c
+++ b/source3/rpc_server/fss/srv_fss_agent.c
@@ -286,12 +286,14 @@ static NTSTATUS fss_conn_create_tos(struct messaging_context *msg_ctx,
 				    int snum,
 				    struct connection_struct **conn_out)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct conn_struct_tos *c = NULL;
 	NTSTATUS status;
 
 	status = create_conn_struct_tos(msg_ctx,
 					snum,
-					lp_path(talloc_tos(), snum),
+					lp_path(talloc_tos(), lp_sub, snum),
 					session_info,
 					&c);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -730,6 +732,8 @@ uint32_t _fss_AddToShadowCopySet(struct pipes_struct *p,
 	struct connection_struct *conn;
 	NTSTATUS status;
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	if (!fss_permitted(p)) {
 		ret = HRES_ERROR_V(HRES_E_ACCESSDENIED);
@@ -755,7 +759,7 @@ uint32_t _fss_AddToShadowCopySet(struct pipes_struct *p,
 		goto err_tmp_free;
 	}
 
-	path_name = lp_path(frame, snum);
+	path_name = lp_path(frame, lp_sub, snum);
 	if (path_name == NULL) {
 		ret = HRES_ERROR_V(HRES_E_OUTOFMEMORY);
 		goto err_tmp_free;
@@ -1099,10 +1103,10 @@ static uint32_t fss_sc_expose(struct smbconf_ctx *fconf_ctx,
 			DEBUG(2, ("no share SD to clone for %s snapshot\n",
 				  sc_smap->share_name));
 		} else {
-			bool ok;
-			ok = set_share_security(sc_smap->sc_share_name, sd);
+			NTSTATUS status;
+			status = set_share_security(sc_smap->sc_share_name, sd);
 			TALLOC_FREE(sd);
-			if (!ok) {
+			if (!NT_STATUS_IS_OK(status)) {
 				DEBUG(0, ("failed to set %s share SD\n",
 					  sc_smap->sc_share_name));
 				err = HRES_ERROR_V(HRES_E_FAIL);
@@ -1325,6 +1329,8 @@ uint32_t _fss_IsPathSupported(struct pipes_struct *p,
 	struct connection_struct *conn;
 	char *share;
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	if (!fss_permitted(p)) {
 		TALLOC_FREE(frame);
@@ -1355,7 +1361,7 @@ uint32_t _fss_IsPathSupported(struct pipes_struct *p,
 		return HRES_ERROR_V(HRES_E_ACCESSDENIED);
 	}
 	status = SMB_VFS_SNAP_CHECK_PATH(conn, frame,
-					 lp_path(frame, snum),
+					 lp_path(frame, lp_sub, snum),
 					 &base_vol);
 	unbecome_user_without_service();
 	if (!NT_STATUS_IS_OK(status)) {
diff --git a/source3/rpc_server/fssd.c b/source3/rpc_server/fssd.c
index 9e5a6110ebc..8dc8b0e8e64 100644
--- a/source3/rpc_server/fssd.c
+++ b/source3/rpc_server/fssd.c
@@ -42,7 +42,9 @@ void start_fssd(struct tevent_context *ev_ctx,
 
 static void fssd_reopen_logs(void)
 {
-	char *lfile = lp_logfile(NULL);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *lfile = lp_logfile(NULL, lp_sub);
 	int rc;
 
 	if (lfile == NULL || lfile[0] == '\0') {
@@ -53,7 +55,7 @@ static void fssd_reopen_logs(void)
 		}
 	} else {
 		if (strstr(lfile, DAEMON_NAME) == NULL) {
-			rc = asprintf(&lfile, "%s.%s", lp_logfile(NULL), DAEMON_NAME);
+			rc = asprintf(&lfile, "%s.%s", lp_logfile(NULL, lp_sub), DAEMON_NAME);
 			if (rc > 0) {
 				lp_set_logfile(lfile);
 				SAFE_FREE(lfile);
diff --git a/source3/rpc_server/lsasd.c b/source3/rpc_server/lsasd.c
index 850ee26036f..556a8299072 100644
--- a/source3/rpc_server/lsasd.c
+++ b/source3/rpc_server/lsasd.c
@@ -62,7 +62,9 @@ static struct pf_daemon_config pf_lsasd_cfg = { 0 };
 
 static void lsasd_reopen_logs(int child_id)
 {
-	char *lfile = lp_logfile(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *lfile = lp_logfile(talloc_tos(), lp_sub);
 	char *extension;
 	int rc;
 
@@ -83,11 +85,11 @@ static void lsasd_reopen_logs(int child_id)
 		if (strstr(lfile, extension) == NULL) {
 			if (child_id) {
 				rc = asprintf(&lfile, "%s.%d",
-						lp_logfile(talloc_tos()),
+						lp_logfile(talloc_tos(), lp_sub),
 						child_id);
 			} else {
 				rc = asprintf(&lfile, "%s.%s",
-						lp_logfile(talloc_tos()),
+						lp_logfile(talloc_tos(), lp_sub),
 						extension);
 			}
 		}
@@ -595,7 +597,7 @@ static bool lsasd_create_sockets(struct tevent_context *ev_ctx,
 	struct dcerpc_binding_vector *v, *v_orig;
 	TALLOC_CTX *tmp_ctx;
 	NTSTATUS status;
-	uint32_t i;
+	int i;
 	int fd = -1;
 	int rc;
 	bool ok = false;
diff --git a/source3/rpc_server/mdssvc/es_parser_test.c b/source3/rpc_server/mdssvc/es_parser_test.c
index 5751606fa1e..7d88c67abff 100644
--- a/source3/rpc_server/mdssvc/es_parser_test.c
+++ b/source3/rpc_server/mdssvc/es_parser_test.c
@@ -39,7 +39,7 @@ int main(int argc, char **argv)
 	json_t *mappings = NULL;
 	json_error_t json_error;
 	char *default_path = NULL;
-	char *path = NULL;
+	const char *path = NULL;
 	const char *query_string = NULL;
 	const char *path_scope = NULL;
 	char *es_query = NULL;
@@ -67,12 +67,10 @@ int main(int argc, char **argv)
 		return 1;
 	}
 
-	path = lp_parm_talloc_string(mem_ctx,
-				     GLOBAL_SECTION_SNUM,
-				     "elasticsearch",
-				     "mappings",
-				     default_path);
-	TALLOC_FREE(default_path);
+	path = lp_parm_const_string(GLOBAL_SECTION_SNUM,
+				    "elasticsearch",
+				    "mappings",
+				    default_path);
 	if (path == NULL) {
 		TALLOC_FREE(mem_ctx);
 		return 1;
diff --git a/source3/rpc_server/mdssvc/mdssvc_es.c b/source3/rpc_server/mdssvc/mdssvc_es.c
index 3c54abf01fd..aa169a80e1f 100644
--- a/source3/rpc_server/mdssvc/mdssvc_es.c
+++ b/source3/rpc_server/mdssvc/mdssvc_es.c
@@ -55,7 +55,7 @@ static bool mdssvc_es_init(struct mdssvc_ctx *mdssvc_ctx)
 	struct mdssvc_es_ctx *mdssvc_es_ctx = NULL;
 	json_error_t json_error;
 	char *default_path = NULL;
-	char *path = NULL;
+	const char *path = NULL;
 
 	mdssvc_es_ctx = talloc_zero(mdssvc_ctx, struct mdssvc_es_ctx);
 	if (mdssvc_es_ctx == NULL) {
@@ -78,12 +78,10 @@ static bool mdssvc_es_init(struct mdssvc_ctx *mdssvc_ctx)
 		return false;
 	}
 
-	path = lp_parm_talloc_string(mdssvc_es_ctx,
-				     GLOBAL_SECTION_SNUM,
-				     "elasticsearch",
-				     "mappings",
-				     default_path);
-	TALLOC_FREE(default_path);
+	path = lp_parm_const_string(GLOBAL_SECTION_SNUM,
+				    "elasticsearch",
+				    "mappings",
+				    default_path);
 	if (path == NULL) {
 		TALLOC_FREE(mdssvc_es_ctx);
 		return false;
@@ -93,11 +91,10 @@ static bool mdssvc_es_init(struct mdssvc_ctx *mdssvc_ctx)
 	if (mdssvc_es_ctx->mappings == NULL) {
 		DBG_ERR("Opening mapping file [%s] failed: %s\n",
 			path, json_error.text);
-		TALLOC_FREE(path);
 		TALLOC_FREE(mdssvc_es_ctx);
 		return false;
 	}
-	TALLOC_FREE(path);
+	TALLOC_FREE(default_path);
 
 	mdssvc_ctx->backend_private = mdssvc_es_ctx;
 	return true;
@@ -187,6 +184,7 @@ static struct tevent_req *mds_es_connect_send(
 	struct tevent_req *req = NULL;
 	struct tevent_req *subreq = NULL;
 	struct mds_es_connect_state *state = NULL;
+	const char *server_addr = NULL;
 	bool use_tls;
 	NTSTATUS status;
 
@@ -199,12 +197,16 @@ static struct tevent_req *mds_es_connect_send(
 		.mds_es_ctx = mds_es_ctx,
 	};
 
-	state->server_addr = lp_parm_talloc_string(
-		state,
+	server_addr = lp_parm_const_string(
 		mds_es_ctx->mds_ctx->snum,
 		"elasticsearch",
 		"address",
 		"localhost");
+	state->server_addr = talloc_strdup(state, server_addr);
+	if (tevent_req_nomem(state->server_addr, req)) {
+		return tevent_req_post(req, ev);
+	}
+
 	state->server_port = lp_parm_int(
 		mds_es_ctx->mds_ctx->snum,
 		"elasticsearch",
diff --git a/source3/rpc_server/mdssvc/srv_mdssvc_nt.c b/source3/rpc_server/mdssvc/srv_mdssvc_nt.c
index 81114ce6513..04287008a5c 100644
--- a/source3/rpc_server/mdssvc/srv_mdssvc_nt.c
+++ b/source3/rpc_server/mdssvc/srv_mdssvc_nt.c
@@ -151,6 +151,8 @@ static NTSTATUS create_mdssvc_policy_handle(TALLOC_CTX *mem_ctx,
 
 void _mdssvc_open(struct pipes_struct *p, struct mdssvc_open *r)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int snum;
 	char *outpath = discard_const_p(char, r->out.share_path);
 	char *path;
@@ -168,7 +170,7 @@ void _mdssvc_open(struct pipes_struct *p, struct mdssvc_open *r)
 		return;
 	}
 
-	path = lp_path(talloc_tos(), snum);
+	path = lp_path(talloc_tos(), lp_sub, snum);
 	if (path == NULL) {
 		DBG_ERR("Couldn't create policy handle for %s\n",
 			r->in.share_name);
diff --git a/source3/rpc_server/netlogon/srv_netlog_nt.c b/source3/rpc_server/netlogon/srv_netlog_nt.c
index 671300676ff..52b17c10e61 100644
--- a/source3/rpc_server/netlogon/srv_netlog_nt.c
+++ b/source3/rpc_server/netlogon/srv_netlog_nt.c
@@ -1220,7 +1220,12 @@ static NTSTATUS netr_set_machine_account_password(TALLOC_CTX *mem_ctx,
 				status = NT_STATUS_NO_MEMORY;
 				goto out;
 			}
-			sess_crypt_blob(&out, &in, &session_key, true);
+			rc = sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
+			if (rc != 0) {
+				status = gnutls_error_to_ntstatus(rc,
+								  NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+				goto out;
+			}
 			memcpy(info18.nt_pwd.hash, out.data, out.length);
 
 			info18.nt_pwd_active = true;
@@ -1311,7 +1316,10 @@ NTSTATUS _netr_ServerPasswordSet(struct pipes_struct *p,
 	DEBUG(3,("_netr_ServerPasswordSet: Server Password Set by remote machine:[%s] on account [%s]\n",
 			r->in.computer_name, creds->computer_name));
 
-	netlogon_creds_des_decrypt(creds, r->in.new_password);
+	status = netlogon_creds_des_decrypt(creds, r->in.new_password);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
 
 	DEBUG(100,("_netr_ServerPasswordSet: new given value was :\n"));
 	for(i = 0; i < sizeof(r->in.new_password->hash); i++)
@@ -2443,10 +2451,10 @@ WERROR _netr_DsRGetForestTrustInformation(struct pipes_struct *p,
 {
 	NTSTATUS status;
 	struct lsa_ForestTrustInformation *info, **info_ptr;
+	enum security_user_level security_level;
 
-	if (!(p->pipe_bound && (p->auth.auth_type != DCERPC_AUTH_TYPE_NONE)
-		       && (p->auth.auth_level != DCERPC_AUTH_LEVEL_NONE))) {
-		p->fault_state = DCERPC_FAULT_ACCESS_DENIED;
+	security_level = security_session_user_level(p->session_info, NULL);
+	if (security_level < SECURITY_USER) {
 		return WERR_ACCESS_DENIED;
 	}
 
@@ -2560,6 +2568,7 @@ static NTSTATUS get_password_from_trustAuth(TALLOC_CTX *mem_ctx,
 {
 	enum ndr_err_code ndr_err;
 	struct trustAuthInOutBlob trustAuth;
+	NTSTATUS status;
 
 	ndr_err = ndr_pull_struct_blob_all(trustAuth_blob, mem_ctx, &trustAuth,
 					   (ndr_pull_flags_fn_t)ndr_pull_trustAuthInOutBlob);
@@ -2572,7 +2581,10 @@ static NTSTATUS get_password_from_trustAuth(TALLOC_CTX *mem_ctx,
 		mdfour(current_pw_enc->hash,
 		       trustAuth.current.array[0].AuthInfo.clear.password,
 		       trustAuth.current.array[0].AuthInfo.clear.size);
-		netlogon_creds_des_encrypt(creds, current_pw_enc);
+		status = netlogon_creds_des_encrypt(creds, current_pw_enc);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
 	} else {
 		return NT_STATUS_UNSUCCESSFUL;
 	}
@@ -2583,7 +2595,10 @@ static NTSTATUS get_password_from_trustAuth(TALLOC_CTX *mem_ctx,
 		mdfour(previous_pw_enc->hash,
 		       trustAuth.previous.array[0].AuthInfo.clear.password,
 		       trustAuth.previous.array[0].AuthInfo.clear.size);
-		netlogon_creds_des_encrypt(creds, previous_pw_enc);
+		status = netlogon_creds_des_encrypt(creds, previous_pw_enc);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
 	} else {
 		ZERO_STRUCTP(previous_pw_enc);
 	}
diff --git a/source3/rpc_server/rpc_server.c b/source3/rpc_server/rpc_server.c
index c0c0f9a22a4..5550121cf09 100644
--- a/source3/rpc_server/rpc_server.c
+++ b/source3/rpc_server/rpc_server.c
@@ -33,6 +33,7 @@
 #include "rpc_server/rpc_ncacn_np.h"
 #include "rpc_server/srv_pipe_hnd.h"
 #include "rpc_server/srv_pipe.h"
+#include "librpc/gen_ndr/ndr_dcerpc.h"
 
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_RPC_SRV
@@ -971,6 +972,9 @@ void dcerpc_ncacn_packet_process(struct tevent_req *subreq)
 	}
 	DEBUG(10, ("PDU is in %s Endian format!\n",
 		   ncacn_conn->p->endian ? "Big" : "Little"));
+	if (DEBUGLEVEL >= 10) {
+		NDR_PRINT_DEBUG(ncacn_packet, pkt);
+	}
 	process_complete_pdu(ncacn_conn->p, pkt);
 
 	/* reset pipe state and free PDU */
diff --git a/source3/rpc_server/samr/srv_samr_chgpasswd.c b/source3/rpc_server/samr/srv_samr_chgpasswd.c
index 8c9cf73bdd8..8bc7af09ee9 100644
--- a/source3/rpc_server/samr/srv_samr_chgpasswd.c
+++ b/source3/rpc_server/samr/srv_samr_chgpasswd.c
@@ -510,6 +510,8 @@ while we were waiting\n", WTERMSIG(wstat)));
 bool chgpasswd(const char *name, const char *rhost, const struct passwd *pass,
 	       const char *oldpass, const char *newpass, bool as_root)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *passwordprogram = NULL;
 	char *chatsequence = NULL;
 	size_t i;
@@ -592,12 +594,12 @@ bool chgpasswd(const char *name, const char *rhost, const struct passwd *pass,
 		return false;
 	}
 
-	passwordprogram = lp_passwd_program(ctx);
+	passwordprogram = lp_passwd_program(ctx, lp_sub);
 	if (!passwordprogram || !*passwordprogram) {
 		DEBUG(2, ("chgpasswd: Null password program - no password changing\n"));
 		return false;
 	}
-	chatsequence = lp_passwd_chat(ctx);
+	chatsequence = lp_passwd_chat(ctx, lp_sub);
 	if (!chatsequence || !*chatsequence) {
 		DEBUG(2, ("chgpasswd: Null chat sequence - no password changing\n"));
 		return false;
@@ -804,7 +806,11 @@ static NTSTATUS check_oem_password(const char *user,
 			/*
 			 * check the NT verifier
 			 */
-			E_old_pw_hash(new_nt_hash, nt_pw, verifier);
+			rc = E_old_pw_hash(new_nt_hash, nt_pw, verifier);
+			if (rc != 0) {
+				NTSTATUS status = NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER;
+				return gnutls_error_to_ntstatus(rc, status);
+			}
 			if (memcmp(verifier, old_nt_hash_encrypted, 16)) {
 				DEBUG(0, ("check_oem_password: old nt "
 					  "password doesn't match.\n"));
@@ -831,7 +837,11 @@ static NTSTATUS check_oem_password(const char *user,
 			/*
 			 * check the lm verifier
 			 */
-			E_old_pw_hash(new_nt_hash, lanman_pw, verifier);
+			rc = E_old_pw_hash(new_nt_hash, lanman_pw, verifier);
+			if (rc != 0) {
+				NTSTATUS status = NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER;
+				return gnutls_error_to_ntstatus(rc, status);
+			}
 			if (memcmp(verifier, old_lm_hash_encrypted, 16)) {
 				DEBUG(0,("check_oem_password: old lm password doesn't match.\n"));
 				return NT_STATUS_WRONG_PASSWORD;
@@ -851,7 +861,11 @@ static NTSTATUS check_oem_password(const char *user,
 		/*
 		 * check the lm verifier
 		 */
-		E_old_pw_hash(new_lm_hash, lanman_pw, verifier);
+		rc = E_old_pw_hash(new_lm_hash, lanman_pw, verifier);
+		if (rc != 0) {
+			NTSTATUS status = NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER;
+			return gnutls_error_to_ntstatus(rc, status);
+		}
 		if (memcmp(verifier, old_lm_hash_encrypted, 16)) {
 			DEBUG(0,("check_oem_password: old lm password doesn't match.\n"));
 			return NT_STATUS_WRONG_PASSWORD;
@@ -990,16 +1004,18 @@ NTSTATUS check_password_complexity(const char *username,
 				   enum samPwdChangeReason *samr_reject_reason)
 {
 	TALLOC_CTX *tosctx = talloc_tos();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int check_ret;
 	char *cmd;
 
 	/* Use external script to check password complexity */
-	if ((lp_check_password_script(tosctx) == NULL)
-	    || (*(lp_check_password_script(tosctx)) == '\0')) {
+	if ((lp_check_password_script(tosctx, lp_sub) == NULL)
+	    || (*(lp_check_password_script(tosctx, lp_sub)) == '\0')){
 		return NT_STATUS_OK;
 	}
 
-	cmd = talloc_string_sub(tosctx, lp_check_password_script(tosctx), "%u",
+	cmd = talloc_string_sub(tosctx, lp_check_password_script(tosctx, lp_sub), "%u",
 				username);
 	if (!cmd) {
 		return NT_STATUS_PASSWORD_RESTRICTION;
diff --git a/source3/rpc_server/samr/srv_samr_nt.c b/source3/rpc_server/samr/srv_samr_nt.c
index 87214b2899e..ee3a5660358 100644
--- a/source3/rpc_server/samr/srv_samr_nt.c
+++ b/source3/rpc_server/samr/srv_samr_nt.c
@@ -518,6 +518,8 @@ NTSTATUS _samr_OpenDomain(struct pipes_struct *p,
 NTSTATUS _samr_GetUserPwInfo(struct pipes_struct *p,
 			     struct samr_GetUserPwInfo *r)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct samr_user_info *uinfo;
 	enum lsa_SidType sid_type;
 	uint32_t min_password_length = 0;
@@ -554,8 +556,8 @@ NTSTATUS _samr_GetUserPwInfo(struct pipes_struct *p,
 					       &password_properties);
 			unbecome_root();
 
-			if (lp_check_password_script(talloc_tos())
-			    && *lp_check_password_script(talloc_tos())) {
+			if (lp_check_password_script(talloc_tos(), lp_sub)
+			    && *lp_check_password_script(talloc_tos(), lp_sub)) {
 				password_properties |= DOMAIN_PASSWORD_COMPLEX;
 			}
 
@@ -1883,6 +1885,8 @@ NTSTATUS _samr_ChangePasswordUser3(struct pipes_struct *p,
 	enum samPwdChangeReason reject_reason;
 	struct samr_DomInfo1 *dominfo = NULL;
 	struct userPwdChangeFailureInformation *reject = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint32_t tmp;
 	char *rhost;
 
@@ -1972,8 +1976,8 @@ NTSTATUS _samr_ChangePasswordUser3(struct pipes_struct *p,
 		unix_to_nt_time_abs((NTTIME *)&dominfo->max_password_age, u_expire);
 		unix_to_nt_time_abs((NTTIME *)&dominfo->min_password_age, u_min_age);
 
-		if (lp_check_password_script(talloc_tos())
-			&& *lp_check_password_script(talloc_tos())) {
+		if (lp_check_password_script(talloc_tos(), lp_sub)
+			&& *lp_check_password_script(talloc_tos(), lp_sub)) {
 			dominfo->password_properties |= DOMAIN_PASSWORD_COMPLEX;
 		}
 
@@ -3217,6 +3221,8 @@ static uint32_t samr_get_server_role(void)
 static NTSTATUS query_dom_info_1(TALLOC_CTX *mem_ctx,
 				 struct samr_DomInfo1 *r)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint32_t account_policy_temp;
 	time_t u_expire, u_min_age;
 
@@ -3246,7 +3252,7 @@ static NTSTATUS query_dom_info_1(TALLOC_CTX *mem_ctx,
 	unix_to_nt_time_abs((NTTIME *)&r->max_password_age, u_expire);
 	unix_to_nt_time_abs((NTTIME *)&r->min_password_age, u_min_age);
 
-	if (lp_check_password_script(talloc_tos()) && *lp_check_password_script(talloc_tos())) {
+	if (lp_check_password_script(talloc_tos(), lp_sub) && *lp_check_password_script(talloc_tos(), lp_sub)){
 		r->password_properties |= DOMAIN_PASSWORD_COMPLEX;
 	}
 
@@ -3260,6 +3266,8 @@ static NTSTATUS query_dom_info_2(TALLOC_CTX *mem_ctx,
 				 struct samr_DomGeneralInformation *r,
 				 struct samr_domain_info *dinfo)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint32_t u_logout;
 	time_t seq_num;
 
@@ -3283,7 +3291,7 @@ static NTSTATUS query_dom_info_2(TALLOC_CTX *mem_ctx,
 
 	unbecome_root();
 
-	r->oem_information.string	= lp_server_string(r);
+	r->oem_information.string	= lp_server_string(r, lp_sub);
 	r->domain_name.string		= lp_workgroup();
 	r->primary.string		= lp_netbios_name();
 	r->sequence_num			= seq_num;
@@ -3327,7 +3335,10 @@ static NTSTATUS query_dom_info_3(TALLOC_CTX *mem_ctx,
 static NTSTATUS query_dom_info_4(TALLOC_CTX *mem_ctx,
 				 struct samr_DomOEMInformation *r)
 {
-	r->oem_information.string = lp_server_string(r);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
+	r->oem_information.string = lp_server_string(r, lp_sub);
 
 	return NT_STATUS_OK;
 }
@@ -4411,6 +4422,8 @@ static NTSTATUS set_user_info_18(struct samr_UserInfo18 *id18,
 				 DATA_BLOB *session_key,
 				 struct samu *pwd)
 {
+	int rc;
+
 	if (id18 == NULL) {
 		DEBUG(2, ("set_user_info_18: id18 is NULL\n"));
 		return NT_STATUS_INVALID_PARAMETER;
@@ -4429,7 +4442,11 @@ static NTSTATUS set_user_info_18(struct samr_UserInfo18 *id18,
 		in = data_blob_const(id18->nt_pwd.hash, 16);
 		out = data_blob_talloc_zero(mem_ctx, 16);
 
-		sess_crypt_blob(&out, &in, session_key, false);
+		rc = sess_crypt_blob(&out, &in, session_key, SAMBA_GNUTLS_DECRYPT);
+		if (rc != 0) {
+			return gnutls_error_to_ntstatus(rc,
+							NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 
 		if (!pdb_set_nt_passwd(pwd, out.data, PDB_CHANGED)) {
 			return NT_STATUS_ACCESS_DENIED;
@@ -4445,7 +4462,11 @@ static NTSTATUS set_user_info_18(struct samr_UserInfo18 *id18,
 		in = data_blob_const(id18->lm_pwd.hash, 16);
 		out = data_blob_talloc_zero(mem_ctx, 16);
 
-		sess_crypt_blob(&out, &in, session_key, false);
+		rc = sess_crypt_blob(&out, &in, session_key, SAMBA_GNUTLS_DECRYPT);
+		if (rc != 0) {
+			return gnutls_error_to_ntstatus(rc,
+							NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 
 		if (!pdb_set_lanman_passwd(pwd, out.data, PDB_CHANGED)) {
 			return NT_STATUS_ACCESS_DENIED;
@@ -4487,6 +4508,7 @@ static NTSTATUS set_user_info_21(struct samr_UserInfo21 *id21,
 				 struct samu *pwd)
 {
 	NTSTATUS status;
+	int rc;
 
 	if (id21 == NULL) {
 		DEBUG(5, ("set_user_info_21: NULL id21\n"));
@@ -4517,7 +4539,11 @@ static NTSTATUS set_user_info_21(struct samr_UserInfo21 *id21,
 			in = data_blob_const(id21->nt_owf_password.array, 16);
 			out = data_blob_talloc_zero(mem_ctx, 16);
 
-			sess_crypt_blob(&out, &in, session_key, false);
+			rc = sess_crypt_blob(&out, &in, session_key, SAMBA_GNUTLS_DECRYPT);
+			if (rc != 0) {
+				return gnutls_error_to_ntstatus(rc,
+								NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			}
 
 			pdb_set_nt_passwd(pwd, out.data, PDB_CHANGED);
 			pdb_set_pass_last_set_time(pwd, time(NULL), PDB_CHANGED);
@@ -4540,7 +4566,11 @@ static NTSTATUS set_user_info_21(struct samr_UserInfo21 *id21,
 			in = data_blob_const(id21->lm_owf_password.array, 16);
 			out = data_blob_talloc_zero(mem_ctx, 16);
 
-			sess_crypt_blob(&out, &in, session_key, false);
+			rc = sess_crypt_blob(&out, &in, session_key, SAMBA_GNUTLS_DECRYPT);
+			if (rc != 0) {
+				return gnutls_error_to_ntstatus(rc,
+								NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			}
 
 			pdb_set_lanman_passwd(pwd, out.data, PDB_CHANGED);
 			pdb_set_pass_last_set_time(pwd, time(NULL), PDB_CHANGED);
@@ -6258,6 +6288,8 @@ NTSTATUS _samr_SetAliasInfo(struct pipes_struct *p,
 NTSTATUS _samr_GetDomPwInfo(struct pipes_struct *p,
 			    struct samr_GetDomPwInfo *r)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint32_t min_password_length = 0;
 	uint32_t password_properties = 0;
 
@@ -6277,7 +6309,7 @@ NTSTATUS _samr_GetDomPwInfo(struct pipes_struct *p,
 			       &password_properties);
 	unbecome_root();
 
-	if (lp_check_password_script(talloc_tos()) && *lp_check_password_script(talloc_tos())) {
+	if (lp_check_password_script(talloc_tos(), lp_sub) && *lp_check_password_script(talloc_tos(), lp_sub)) {
 		password_properties |= DOMAIN_PASSWORD_COMPLEX;
 	}
 
diff --git a/source3/rpc_server/spoolss/srv_spoolss_nt.c b/source3/rpc_server/spoolss/srv_spoolss_nt.c
index f32b465afb6..d92963ec32a 100644
--- a/source3/rpc_server/spoolss/srv_spoolss_nt.c
+++ b/source3/rpc_server/spoolss/srv_spoolss_nt.c
@@ -346,7 +346,9 @@ static WERROR delete_printer_hook(TALLOC_CTX *ctx, struct security_token *token,
 				  const char *sharename,
 				  struct messaging_context *msg_ctx)
 {
-	char *cmd = lp_deleteprinter_command(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *cmd = lp_deleteprinter_command(talloc_tos(), lp_sub);
 	char *command = NULL;
 	int ret;
 	bool is_print_op = false;
@@ -2762,7 +2764,10 @@ static void spoolss_notify_share_name(struct messaging_context *msg_ctx,
 				      struct spoolss_PrinterInfo2 *pinfo2,
 				      TALLOC_CTX *mem_ctx)
 {
-	SETUP_SPOOLSS_NOTIFY_DATA_STRING(data, lp_servicename(talloc_tos(), snum));
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
+	SETUP_SPOOLSS_NOTIFY_DATA_STRING(data, lp_servicename(talloc_tos(), lp_sub, snum));
 }
 
 /*******************************************************************
@@ -2805,10 +2810,12 @@ static void spoolss_notify_comment(struct messaging_context *msg_ctx,
 				   struct spoolss_PrinterInfo2 *pinfo2,
 				   TALLOC_CTX *mem_ctx)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char *p;
 
 	if (*pinfo2->comment == '\0') {
-		p = lp_comment(talloc_tos(), snum);
+		p = lp_comment(talloc_tos(), lp_sub, snum);
 	} else {
 		p = pinfo2->comment;
 	}
@@ -3372,6 +3379,8 @@ static bool construct_notify_printer_info(struct messaging_context *msg_ctx,
 					  uint32_t id,
 					  TALLOC_CTX *mem_ctx)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int field_num,j;
 	enum spoolss_NotifyType type;
 	uint16_t field;
@@ -3382,7 +3391,7 @@ static bool construct_notify_printer_info(struct messaging_context *msg_ctx,
 
 	DEBUG(4,("construct_notify_printer_info: Notify type: [%s], number of notify info: [%d] on printer: [%s]\n",
 		(type == PRINTER_NOTIFY_TYPE ? "PRINTER_NOTIFY_TYPE" : "JOB_NOTIFY_TYPE"),
-		option_type->count, lp_servicename(talloc_tos(), snum)));
+		option_type->count, lp_servicename(talloc_tos(), lp_sub, snum)));
 
 	for(field_num=0; field_num < option_type->count; field_num++) {
 		field = option_type->fields[field_num].field;
@@ -3506,6 +3515,8 @@ static WERROR printserver_notify_info(struct pipes_struct *p,
 				      struct spoolss_NotifyInfo *info,
 				      TALLOC_CTX *mem_ctx)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int snum;
 	struct printer_handle *Printer = find_printer_index_by_hnd(p, hnd);
 	int n_services=lp_numservices();
@@ -3549,12 +3560,12 @@ static WERROR printserver_notify_info(struct pipes_struct *p,
 			result = winreg_get_printer_internal(mem_ctx,
 						    get_session_info_system(),
 						    p->msg_ctx,
-						    lp_servicename(talloc_tos(), snum),
+						    lp_servicename(talloc_tos(), lp_sub, snum),
 						    &pinfo2);
 			if (!W_ERROR_IS_OK(result)) {
 				DEBUG(4, ("printserver_notify_info: "
 					  "Failed to get printer [%s]\n",
-					  lp_servicename(talloc_tos(), snum)));
+					  lp_servicename(talloc_tos(), lp_sub, snum)));
 				continue;
 			}
 
@@ -3599,6 +3610,8 @@ static WERROR printer_notify_info(struct pipes_struct *p,
 				  struct spoolss_NotifyInfo *info,
 				  TALLOC_CTX *mem_ctx)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int snum;
 	struct printer_handle *Printer = find_printer_index_by_hnd(p, hnd);
 	int i;
@@ -3643,7 +3656,7 @@ static WERROR printer_notify_info(struct pipes_struct *p,
 	result = winreg_get_printer_internal(mem_ctx,
 				    get_session_info_system(),
 				    p->msg_ctx,
-				    lp_servicename(talloc_tos(), snum), &pinfo2);
+				    lp_servicename(talloc_tos(), lp_sub, snum), &pinfo2);
 	if (!W_ERROR_IS_OK(result)) {
 		result = WERR_INVALID_HANDLE;
 		goto err_pdb_drop;
@@ -3970,12 +3983,14 @@ static WERROR construct_printer_info1(TALLOC_CTX *mem_ctx,
 				      struct spoolss_PrinterInfo1 *r,
 				      int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	WERROR result;
 
 	r->flags		= flags;
 
 	if (info2->comment == NULL || info2->comment[0] == '\0') {
-		r->comment	= lp_comment(mem_ctx, snum);
+		r->comment	= lp_comment(mem_ctx, lp_sub, snum);
 	} else {
 		r->comment	= talloc_strdup(mem_ctx, info2->comment); /* saved comment */
 	}
@@ -4007,6 +4022,8 @@ static WERROR construct_printer_info2(TALLOC_CTX *mem_ctx,
 				      struct spoolss_PrinterInfo2 *r,
 				      int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int count;
 	print_status_struct status;
 	WERROR result;
@@ -4025,7 +4042,7 @@ static WERROR construct_printer_info2(TALLOC_CTX *mem_ctx,
 		return result;
 	}
 
-	r->sharename		= lp_servicename(mem_ctx, snum);
+	r->sharename		= lp_servicename(mem_ctx, lp_sub, snum);
 	W_ERROR_HAVE_NO_MEMORY(r->sharename);
 	r->portname		= talloc_strdup(mem_ctx, info2->portname);
 	W_ERROR_HAVE_NO_MEMORY(r->portname);
@@ -4033,7 +4050,7 @@ static WERROR construct_printer_info2(TALLOC_CTX *mem_ctx,
 	W_ERROR_HAVE_NO_MEMORY(r->drivername);
 
 	if (info2->comment[0] == '\0') {
-		r->comment	= lp_comment(mem_ctx, snum);
+		r->comment	= lp_comment(mem_ctx, lp_sub, snum);
 	} else {
 		r->comment	= talloc_strdup(mem_ctx, info2->comment);
 	}
@@ -4233,6 +4250,8 @@ static WERROR construct_printer_info7(TALLOC_CTX *mem_ctx,
 				      struct spoolss_PrinterInfo7 *r,
 				      int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const struct auth_session_info *session_info;
 	struct spoolss_PrinterInfo2 *pinfo2 = NULL;
 	char *printer;
@@ -4245,7 +4264,7 @@ static WERROR construct_printer_info7(TALLOC_CTX *mem_ctx,
 	session_info = get_session_info_system();
 	SMB_ASSERT(session_info != NULL);
 
-	printer = lp_servicename(tmp_ctx, snum);
+	printer = lp_servicename(tmp_ctx, lp_sub, snum);
 	if (printer == NULL) {
 		DEBUG(0, ("invalid printer snum %d\n", snum));
 		werr = WERR_INVALID_PARAMETER;
@@ -6357,7 +6376,9 @@ static bool check_printer_ok(TALLOC_CTX *mem_ctx,
 
 static WERROR add_port_hook(TALLOC_CTX *ctx, struct security_token *token, const char *portname, const char *uri)
 {
-	char *cmd = lp_addport_command(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *cmd = lp_addport_command(talloc_tos(), lp_sub);
 	char *command = NULL;
 	int ret;
 	bool is_print_op = false;
@@ -6418,7 +6439,9 @@ static bool add_printer_hook(TALLOC_CTX *ctx, struct security_token *token,
 			     const char *remote_machine,
 			     struct messaging_context *msg_ctx)
 {
-	char *cmd = lp_addprinter_command(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *cmd = lp_addprinter_command(talloc_tos(), lp_sub);
 	char **qlines;
 	char *command = NULL;
 	int numlines;
@@ -6923,6 +6946,8 @@ static WERROR update_printer(struct pipes_struct *p,
 	struct spoolss_SetPrinterInfo2 *printer = info_ctr->info.info2;
 	struct spoolss_PrinterInfo2 *old_printer;
 	struct printer_handle *Printer = find_printer_index_by_hnd(p, handle);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int snum;
 	WERROR result = WERR_OK;
 	TALLOC_CTX *tmp_ctx;
@@ -6980,7 +7005,7 @@ static WERROR update_printer(struct pipes_struct *p,
 	/* Call addprinter hook */
 	/* Check changes to see if this is really needed */
 
-	if (*lp_addprinter_command(talloc_tos()) &&
+	if (*lp_addprinter_command(talloc_tos(), lp_sub) &&
 			(!strequal(printer->drivername, old_printer->drivername) ||
 			 !strequal(printer->comment, old_printer->comment) ||
 			 !strequal(printer->portname, old_printer->portname) ||
@@ -7038,6 +7063,8 @@ static WERROR publish_or_unpublish_printer(struct pipes_struct *p,
 					   struct spoolss_SetPrinterInfo7 *info7)
 {
 #ifdef HAVE_ADS
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct spoolss_PrinterInfo2 *pinfo2 = NULL;
 	WERROR result;
 	int snum;
@@ -7060,7 +7087,7 @@ static WERROR publish_or_unpublish_printer(struct pipes_struct *p,
 	result = winreg_get_printer_internal(p->mem_ctx,
 				    get_session_info_system(),
 				    p->msg_ctx,
-				    lp_servicename(talloc_tos(), snum),
+				    lp_servicename(talloc_tos(), lp_sub, snum),
 				    &pinfo2);
 	if (!W_ERROR_IS_OK(result)) {
 		return WERR_INVALID_HANDLE;
@@ -7314,13 +7341,15 @@ static WERROR fill_job_info1(TALLOC_CTX *mem_ctx,
 			     int position, int snum,
 			     struct spoolss_PrinterInfo2 *pinfo2)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct tm *t;
 
 	t = gmtime(&queue->time);
 
 	r->job_id		= jobid;
 
-	r->printer_name		= lp_servicename(mem_ctx, snum);
+	r->printer_name		= lp_servicename(mem_ctx, lp_sub, snum);
 	W_ERROR_HAVE_NO_MEMORY(r->printer_name);
 	r->server_name		= talloc_strdup(mem_ctx, pinfo2->servername);
 	W_ERROR_HAVE_NO_MEMORY(r->server_name);
@@ -7356,13 +7385,15 @@ static WERROR fill_job_info2(TALLOC_CTX *mem_ctx,
 			     struct spoolss_PrinterInfo2 *pinfo2,
 			     struct spoolss_DeviceMode *devmode)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct tm *t;
 
 	t = gmtime(&queue->time);
 
 	r->job_id		= jobid;
 
-	r->printer_name		= lp_servicename(mem_ctx, snum);
+	r->printer_name		= lp_servicename(mem_ctx, lp_sub, snum);
 	W_ERROR_HAVE_NO_MEMORY(r->printer_name);
 	r->server_name		= talloc_strdup(mem_ctx, pinfo2->servername);
 	W_ERROR_HAVE_NO_MEMORY(r->server_name);
@@ -8176,7 +8207,9 @@ static WERROR fill_port_2(TALLOC_CTX *mem_ctx,
 
 static WERROR enumports_hook(TALLOC_CTX *ctx, int *count, char ***lines)
 {
-	char *cmd = lp_enumports_command(talloc_tos());
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *cmd = lp_enumports_command(talloc_tos(), lp_sub);
 	char **qlines = NULL;
 	char *command = NULL;
 	int numlines;
@@ -8395,6 +8428,8 @@ static WERROR spoolss_addprinterex_level_2(struct pipes_struct *p,
 {
 	struct spoolss_SetPrinterInfo2 *info2 = info_ctr->info.info2;
 	uint32_t info2_mask = SPOOLSS_PRINTER_INFO_ALL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int	snum;
 	WERROR err = WERR_OK;
 
@@ -8440,7 +8475,7 @@ static WERROR spoolss_addprinterex_level_2(struct pipes_struct *p,
 	/* FIXME!!!  smbd should check to see if the driver is installed before
 	   trying to add a printer like this  --jerry */
 
-	if (*lp_addprinter_command(talloc_tos()) ) {
+	if (*lp_addprinter_command(talloc_tos(), lp_sub) ) {
 		char *raddr;
 
 		raddr = tsocket_address_inet_addr_string(p->remote_address,
@@ -9980,6 +10015,8 @@ done:
 WERROR _spoolss_SetPrinterDataEx(struct pipes_struct *p,
 				 struct spoolss_SetPrinterDataEx *r)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct spoolss_PrinterInfo2 *pinfo2 = NULL;
 	int 			snum = 0;
 	WERROR 			result = WERR_OK;
@@ -10037,7 +10074,7 @@ WERROR _spoolss_SetPrinterDataEx(struct pipes_struct *p,
 	}
 
 	result = winreg_get_printer(tmp_ctx, b,
-				    lp_servicename(talloc_tos(), snum),
+				    lp_servicename(talloc_tos(), lp_sub, snum),
 				    &pinfo2);
 	if (!W_ERROR_IS_OK(result)) {
 		goto done;
diff --git a/source3/rpc_server/srv_pipe.c b/source3/rpc_server/srv_pipe.c
index fa5043e8c1f..3bc291fb0c9 100644
--- a/source3/rpc_server/srv_pipe.c
+++ b/source3/rpc_server/srv_pipe.c
@@ -1401,6 +1401,7 @@ static bool api_pipe_request(struct pipes_struct *p,
 	bool ret = False;
 	struct pipe_rpc_fns *pipe_fns;
 	const char *interface_name = NULL;
+	const char *dump_dir = NULL;
 
 	if (!p->pipe_bound) {
 		DEBUG(1, ("Pipe not bound!\n"));
@@ -1465,6 +1466,16 @@ static bool api_pipe_request(struct pipes_struct *p,
 		break;
 	}
 
+	dump_dir = lp_parm_const_string(0, "dcesrv", "fuzz directory", NULL);
+
+	dcerpc_save_ndr_fuzz_seed(p,
+				  p->in_data.data,
+				  dump_dir,
+				  interface_name,
+				  NDR_IN,
+				  pkt->u.request.opnum,
+				  false);
+
 	if (!srv_pipe_check_verification_trailer(p, pkt, pipe_fns)) {
 		DEBUG(1, ("srv_pipe_check_verification_trailer: failed\n"));
 		set_incoming_fault(p);
@@ -1487,6 +1498,14 @@ static bool api_pipe_request(struct pipes_struct *p,
 			 &pipe_fns->syntax);
 	unbecome_authenticated_pipe_user();
 
+	dcerpc_save_ndr_fuzz_seed(p,
+				  p->out_data.rdata,
+				  dump_dir,
+				  interface_name,
+				  NDR_OUT,
+				  pkt->u.request.opnum,
+				  false);
+
 	TALLOC_FREE(frame);
 	return ret;
 }
diff --git a/source3/rpc_server/srvsvc/srv_srvsvc_nt.c b/source3/rpc_server/srvsvc/srv_srvsvc_nt.c
index 34a227c76e9..79744344537 100644
--- a/source3/rpc_server/srvsvc/srv_srvsvc_nt.c
+++ b/source3/rpc_server/srvsvc/srv_srvsvc_nt.c
@@ -210,7 +210,10 @@ static enum srvsvc_ShareType get_share_type(int snum)
 static void init_srv_share_info_0(struct pipes_struct *p,
 				  struct srvsvc_NetShareInfo0 *r, int snum)
 {
-	r->name		= lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
+	r->name		= lp_servicename(talloc_tos(), lp_sub, snum);
 }
 
 /*******************************************************************
@@ -221,13 +224,15 @@ static void init_srv_share_info_1(struct pipes_struct *p,
 				  struct srvsvc_NetShareInfo1 *r,
 				  int snum)
 {
-	char *net_name = lp_servicename(talloc_tos(), snum);
-	char *remark = lp_comment(p->mem_ctx, snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *net_name = lp_servicename(talloc_tos(), lp_sub, snum);
+	char *remark = lp_comment(p->mem_ctx, lp_sub, snum);
 
 	if (remark) {
 		remark = talloc_sub_full(
-			p->mem_ctx, lp_servicename(talloc_tos(), snum),
-			get_current_username(), lp_path(talloc_tos(), snum),
+			p->mem_ctx, lp_servicename(talloc_tos(), lp_sub, snum),
+			get_current_username(), lp_path(talloc_tos(), lp_sub, snum),
 			p->session_info->unix_token->uid, get_current_username(),
 			"", remark);
 	}
@@ -245,22 +250,24 @@ static void init_srv_share_info_2(struct pipes_struct *p,
 				  struct srvsvc_NetShareInfo2 *r,
 				  int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *remark = NULL;
 	char *path = NULL;
 	int max_connections = lp_max_connections(snum);
 	uint32_t max_uses = max_connections!=0 ? max_connections : (uint32_t)-1;
-	char *net_name = lp_servicename(talloc_tos(), snum);
+	char *net_name = lp_servicename(talloc_tos(), lp_sub, snum);
 
-	remark = lp_comment(p->mem_ctx, snum);
+	remark = lp_comment(p->mem_ctx, lp_sub, snum);
 	if (remark) {
 		remark = talloc_sub_full(
-			p->mem_ctx, lp_servicename(talloc_tos(), snum),
-			get_current_username(), lp_path(talloc_tos(), snum),
+			p->mem_ctx, lp_servicename(talloc_tos(), lp_sub, snum),
+			get_current_username(), lp_path(talloc_tos(), lp_sub, snum),
 			p->session_info->unix_token->uid, get_current_username(),
 			"", remark);
 	}
 	path = talloc_asprintf(p->mem_ctx,
-			"C:%s", lp_path(talloc_tos(), snum));
+			"C:%s", lp_path(talloc_tos(), lp_sub, snum));
 
 	if (path) {
 		/*
@@ -314,13 +321,15 @@ static void map_generic_share_sd_bits(struct security_descriptor *psd)
 static void init_srv_share_info_501(struct pipes_struct *p,
 				    struct srvsvc_NetShareInfo501 *r, int snum)
 {
-	const char *net_name = lp_servicename(talloc_tos(), snum);
-	char *remark = lp_comment(p->mem_ctx, snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *net_name = lp_servicename(talloc_tos(), lp_sub, snum);
+	char *remark = lp_comment(p->mem_ctx, lp_sub, snum);
 
 	if (remark) {
 		remark = talloc_sub_full(
-			p->mem_ctx, lp_servicename(talloc_tos(), snum),
-			get_current_username(), lp_path(talloc_tos(), snum),
+			p->mem_ctx, lp_servicename(talloc_tos(), lp_sub, snum),
+			get_current_username(), lp_path(talloc_tos(), lp_sub, snum),
 			p->session_info->unix_token->uid, get_current_username(),
 			"", remark);
 	}
@@ -343,22 +352,24 @@ static void init_srv_share_info_501(struct pipes_struct *p,
 static void init_srv_share_info_502(struct pipes_struct *p,
 				    struct srvsvc_NetShareInfo502 *r, int snum)
 {
-	const char *net_name = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *net_name = lp_servicename(talloc_tos(), lp_sub, snum);
 	char *path = NULL;
 	struct security_descriptor *sd = NULL;
 	struct sec_desc_buf *sd_buf = NULL;
 	size_t sd_size = 0;
 	TALLOC_CTX *ctx = p->mem_ctx;
-	char *remark = lp_comment(ctx, snum);
+	char *remark = lp_comment(ctx, lp_sub, snum);
 
 	if (remark) {
 		remark = talloc_sub_full(
-			p->mem_ctx, lp_servicename(talloc_tos(), snum),
-			get_current_username(), lp_path(talloc_tos(), snum),
+			p->mem_ctx, lp_servicename(talloc_tos(), lp_sub, snum),
+			get_current_username(), lp_path(talloc_tos(), lp_sub, snum),
 			p->session_info->unix_token->uid, get_current_username(),
 			"", remark);
 	}
-	path = talloc_asprintf(ctx, "C:%s", lp_path(talloc_tos(), snum));
+	path = talloc_asprintf(ctx, "C:%s", lp_path(talloc_tos(), lp_sub, snum));
 	if (path) {
 		/*
 		 * Change / to \\ so that win2k will see it as a valid path.  This was added to
@@ -367,7 +378,7 @@ static void init_srv_share_info_502(struct pipes_struct *p,
 		string_replace(path, '/', '\\');
 	}
 
-	sd = get_share_security(ctx, lp_servicename(talloc_tos(), snum), &sd_size);
+	sd = get_share_security(ctx, lp_servicename(talloc_tos(), lp_sub, snum), &sd_size);
 
 	sd_buf = make_sec_desc_buf(p->mem_ctx, sd_size, sd);
 
@@ -390,12 +401,14 @@ static void init_srv_share_info_1004(struct pipes_struct *p,
 				     struct srvsvc_NetShareInfo1004 *r,
 				     int snum)
 {
-	char *remark = lp_comment(p->mem_ctx, snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *remark = lp_comment(p->mem_ctx, lp_sub, snum);
 
 	if (remark) {
 		remark = talloc_sub_full(
-			p->mem_ctx, lp_servicename(talloc_tos(), snum),
-			get_current_username(), lp_path(talloc_tos(), snum),
+			p->mem_ctx, lp_servicename(talloc_tos(), lp_sub, snum),
+			get_current_username(), lp_path(talloc_tos(), lp_sub, snum),
 			p->session_info->unix_token->uid, get_current_username(),
 			"", remark);
 	}
@@ -453,12 +466,14 @@ static void init_srv_share_info_1501(struct pipes_struct *p,
 				     struct sec_desc_buf **r,
 				     int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct security_descriptor *sd;
 	struct sec_desc_buf *sd_buf = NULL;
 	size_t sd_size;
 	TALLOC_CTX *ctx = p->mem_ctx;
 
-	sd = get_share_security(ctx, lp_servicename(talloc_tos(), snum), &sd_size);
+	sd = get_share_security(ctx, lp_servicename(talloc_tos(), lp_sub, snum), &sd_size);
 	if (sd) {
 		sd_buf = make_sec_desc_buf(p->mem_ctx, sd_size, sd);
 	}
@@ -472,7 +487,9 @@ static void init_srv_share_info_1501(struct pipes_struct *p,
 
 static bool is_hidden_share(int snum)
 {
-	const char *net_name = lp_servicename(talloc_tos(), snum);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	const char *net_name = lp_servicename(talloc_tos(), lp_sub, snum);
 
 	return (net_name[strlen(net_name) - 1] == '$') ? True : False;
 }
@@ -483,6 +500,9 @@ static bool is_hidden_share(int snum)
 static bool is_enumeration_allowed(struct pipes_struct *p,
                                    int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
 	if (!lp_access_based_share_enum(snum)) {
 		return true;
 	}
@@ -494,7 +514,7 @@ static bool is_enumeration_allowed(struct pipes_struct *p,
 	}
 
 	return share_access_check(p->session_info->security_token,
-				  lp_servicename(talloc_tos(), snum),
+				  lp_servicename(talloc_tos(), lp_sub, snum),
 				  FILE_READ_DATA, NULL);
 }
 
@@ -551,6 +571,8 @@ static WERROR init_srv_share_info_ctr(struct pipes_struct *p,
 				      uint32_t *total_entries,
 				      bool all_shares)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint32_t num_entries = 0;
 	uint32_t alloc_entries = 0;
 	int num_services = 0;
@@ -581,12 +603,12 @@ static WERROR init_srv_share_info_ctr(struct pipes_struct *p,
                     is_enumeration_allowed(p, snum) &&
                     (all_shares || !is_hidden_share(snum)) ) {
                         DEBUG(10, ("counting service %s\n",
-				lp_servicename(talloc_tos(), snum) ? lp_servicename(talloc_tos(), snum) : "(null)"));
+				lp_servicename(talloc_tos(), lp_sub, snum) ? lp_servicename(talloc_tos(), lp_sub, snum) : "(null)"));
                         allowed[snum] = true;
                         num_entries++;
                 } else {
                         DEBUG(10, ("NOT counting service %s\n",
-				lp_servicename(talloc_tos(), snum) ? lp_servicename(talloc_tos(), snum) : "(null)"));
+				lp_servicename(talloc_tos(), lp_sub, snum) ? lp_servicename(talloc_tos(), lp_sub, snum) : "(null)"));
                 }
         }
 
@@ -1130,6 +1152,8 @@ static WERROR init_srv_conn_info_1(const char *name,
 				   uint32_t *resume_handle_p,
 				   uint32_t *total_entries)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint32_t num_entries = 0;
 	int snum = 0;
 	uint32_t resume_handle = resume_handle_p ? *resume_handle_p : 0;
@@ -1238,7 +1262,7 @@ static WERROR init_srv_conn_info_1(const char *name,
 		 */
 
 		count_share_opens(ctr1->array, svrid_arr,
-				  lp_path(talloc_tos(), snum),
+				  lp_path(talloc_tos(), lp_sub, snum),
 				  num_entries, *total_entries);
 
 	}
@@ -1312,6 +1336,8 @@ WERROR _srvsvc_NetFileEnum(struct pipes_struct *p,
 WERROR _srvsvc_NetSrvGetInfo(struct pipes_struct *p,
 			     struct srvsvc_NetSrvGetInfo *r)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	WERROR status = WERR_OK;
 
 	DEBUG(5,("_srvsvc_NetSrvGetInfo: %d\n", __LINE__));
@@ -1340,7 +1366,7 @@ WERROR _srvsvc_NetSrvGetInfo(struct pipes_struct *p,
 		info102->version_major	= SAMBA_MAJOR_NBT_ANNOUNCE_VERSION;
 		info102->version_minor	= SAMBA_MINOR_NBT_ANNOUNCE_VERSION;
 		info102->server_type	= lp_default_server_announce();
-		info102->comment	= string_truncate(lp_server_string(talloc_tos()),
+		info102->comment	= string_truncate(lp_server_string(talloc_tos(), lp_sub),
 						MAX_SERVER_STRING_LENGTH);
 		info102->users		= 0xffffffff;
 		info102->disc		= 0xf;
@@ -1366,7 +1392,7 @@ WERROR _srvsvc_NetSrvGetInfo(struct pipes_struct *p,
 		info101->version_major	= SAMBA_MAJOR_NBT_ANNOUNCE_VERSION;
 		info101->version_minor	= SAMBA_MINOR_NBT_ANNOUNCE_VERSION;
 		info101->server_type	= lp_default_server_announce();
-		info101->comment	= string_truncate(lp_server_string(talloc_tos()),
+		info101->comment	= string_truncate(lp_server_string(talloc_tos(), lp_sub),
 						MAX_SERVER_STRING_LENGTH);
 
 		r->out.info->info101 = info101;
@@ -1711,6 +1737,8 @@ WERROR _srvsvc_NetShareGetInfo(struct pipes_struct *p,
 WERROR _srvsvc_NetShareSetInfo(struct pipes_struct *p,
 			       struct srvsvc_NetShareSetInfo *r)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *command = NULL;
 	char *share_name = NULL;
 	char *comment = NULL;
@@ -1781,7 +1809,7 @@ WERROR _srvsvc_NetShareSetInfo(struct pipes_struct *p,
 
 	switch (r->in.level) {
 	case 1:
-		pathname = lp_path(ctx, snum);
+		pathname = lp_path(ctx, lp_sub, snum);
 		comment = talloc_strdup(ctx, info->info1->comment);
 		type = info->info1->type;
 		psd = NULL;
@@ -1810,7 +1838,7 @@ WERROR _srvsvc_NetShareSetInfo(struct pipes_struct *p,
 		map_generic_share_sd_bits(psd);
 		break;
 	case 1004:
-		pathname = lp_path(ctx, snum);
+		pathname = lp_path(ctx, lp_sub, snum);
 		comment = talloc_strdup(ctx, info->info1004->comment);
 		type = STYPE_DISKTREE;
 		break;
@@ -1830,16 +1858,16 @@ WERROR _srvsvc_NetShareSetInfo(struct pipes_struct *p,
 			csc_policy_changed = true;
 		}
 
-		pathname = lp_path(ctx, snum);
-		comment = lp_comment(ctx, snum);
+		pathname = lp_path(ctx, lp_sub, snum);
+		comment = lp_comment(ctx, lp_sub, snum);
 		type = STYPE_DISKTREE;
 		break;
 	case 1006:
 	case 1007:
 		return WERR_ACCESS_DENIED;
 	case 1501:
-		pathname = lp_path(ctx, snum);
-		comment = lp_comment(ctx, snum);
+		pathname = lp_path(ctx, lp_sub, snum);
+		comment = lp_comment(ctx, lp_sub, snum);
 		psd = info->info1501->sd;
 		map_generic_share_sd_bits(psd);
 		type = STYPE_DISKTREE;
@@ -1875,22 +1903,23 @@ WERROR _srvsvc_NetShareSetInfo(struct pipes_struct *p,
 	string_replace(comment, '"', ' ');
 
 	DEBUG(10,("_srvsvc_NetShareSetInfo: change share command = %s\n",
-		lp_change_share_command(talloc_tos()) ? lp_change_share_command(talloc_tos()) : "NULL" ));
+		lp_change_share_command(talloc_tos(), lp_sub) ? lp_change_share_command(talloc_tos(), lp_sub) : "NULL" ));
 
 	/* Only call modify function if something changed. */
 
-	if (strcmp(path, lp_path(talloc_tos(), snum)) || strcmp(comment, lp_comment(talloc_tos(), snum))
+	if (strcmp(path, lp_path(talloc_tos(), lp_sub, snum))
+			|| strcmp(comment, lp_comment(talloc_tos(), lp_sub, snum))
 			|| (lp_max_connections(snum) != max_connections)
 			|| csc_policy_changed) {
 
-		if (!lp_change_share_command(talloc_tos()) || !*lp_change_share_command(talloc_tos())) {
+		if (!lp_change_share_command(talloc_tos(), lp_sub) || !*lp_change_share_command(talloc_tos(), lp_sub)) {
 			DEBUG(10,("_srvsvc_NetShareSetInfo: No change share command\n"));
 			return WERR_ACCESS_DENIED;
 		}
 
 		command = talloc_asprintf(p->mem_ctx,
 				"%s \"%s\" \"%s\" \"%s\" \"%s\" %d \"%s\"",
-				lp_change_share_command(talloc_tos()),
+				lp_change_share_command(talloc_tos(), lp_sub),
 				get_dyn_CONFIGFILE(),
 				share_name,
 				path,
@@ -1936,13 +1965,16 @@ WERROR _srvsvc_NetShareSetInfo(struct pipes_struct *p,
 	if (psd) {
 		struct security_descriptor *old_sd;
 		size_t sd_size;
+		NTSTATUS status;
 
-		old_sd = get_share_security(p->mem_ctx, lp_servicename(talloc_tos(), snum), &sd_size);
+		old_sd = get_share_security(p->mem_ctx, lp_servicename(talloc_tos(), lp_sub, snum), &sd_size);
 
 		if (old_sd && !security_descriptor_equal(old_sd, psd)) {
-			if (!set_share_security(share_name, psd))
+			status = set_share_security(share_name, psd);
+			if (!NT_STATUS_IS_OK(status)) {
 				DEBUG(0,("_srvsvc_NetShareSetInfo: Failed to change security info in share %s.\n",
 					share_name ));
+			}
 		}
 	}
 
@@ -1974,6 +2006,8 @@ WERROR _srvsvc_NetShareAdd(struct pipes_struct *p,
 	int max_connections = 0;
 	SMB_STRUCT_STAT st;
 	TALLOC_CTX *ctx = p->mem_ctx;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	DEBUG(5,("_srvsvc_NetShareAdd: %d\n", __LINE__));
 
@@ -1986,7 +2020,7 @@ WERROR _srvsvc_NetShareAdd(struct pipes_struct *p,
 	if (p->session_info->unix_token->uid != sec_initial_uid()  && !is_disk_op )
 		return WERR_ACCESS_DENIED;
 
-	if (!lp_add_share_command(talloc_tos()) || !*lp_add_share_command(talloc_tos())) {
+	if (!lp_add_share_command(talloc_tos(), lp_sub) || !*lp_add_share_command(talloc_tos(), lp_sub)) {
 		DBG_WARNING("_srvsvc_NetShareAdd: No \"add share command\" parameter set in smb.conf.\n");
 		return WERR_ACCESS_DENIED;
 	}
@@ -2092,7 +2126,7 @@ WERROR _srvsvc_NetShareAdd(struct pipes_struct *p,
 
 	command = talloc_asprintf(ctx,
 			"%s \"%s\" \"%s\" \"%s\" \"%s\" %d",
-			lp_add_share_command(talloc_tos()),
+			lp_add_share_command(talloc_tos(), lp_sub),
 			get_dyn_CONFIGFILE(),
 			share_name_in,
 			path,
@@ -2131,9 +2165,11 @@ WERROR _srvsvc_NetShareAdd(struct pipes_struct *p,
 		return WERR_ACCESS_DENIED;
 
 	if (psd) {
+		NTSTATUS status;
 		/* Note we use share_name here, not share_name_in as
 		   we need a canonicalized name for setting security. */
-		if (!set_share_security(share_name, psd)) {
+		status = set_share_security(share_name, psd);
+		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(0,("_srvsvc_NetShareAdd: Failed to add security info to share %s.\n",
 				share_name ));
 		}
@@ -2165,6 +2201,8 @@ WERROR _srvsvc_NetShareDel(struct pipes_struct *p,
 	int snum;
 	bool is_disk_op;
 	TALLOC_CTX *ctx = p->mem_ctx;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	DEBUG(5,("_srvsvc_NetShareDel: %d\n", __LINE__));
 
@@ -2197,14 +2235,14 @@ WERROR _srvsvc_NetShareDel(struct pipes_struct *p,
 	if (p->session_info->unix_token->uid != sec_initial_uid()  && !is_disk_op )
 		return WERR_ACCESS_DENIED;
 
-	if (!lp_delete_share_command(talloc_tos()) || !*lp_delete_share_command(talloc_tos())) {
+	if (!lp_delete_share_command(talloc_tos(), lp_sub) || !*lp_delete_share_command(talloc_tos(), lp_sub)) {
 		DBG_WARNING("_srvsvc_NetShareDel: No \"delete share command\" parameter set in smb.conf.\n");
 		return WERR_ACCESS_DENIED;
 	}
 
 	command = talloc_asprintf(ctx,
 			"%s \"%s\" \"%s\"",
-			lp_delete_share_command(talloc_tos()),
+			lp_delete_share_command(talloc_tos(), lp_sub),
 			get_dyn_CONFIGFILE(),
 			share_name);
 	if (!command) {
@@ -2315,6 +2353,8 @@ WERROR _srvsvc_NetGetFileSecurity(struct pipes_struct *p,
 				  struct srvsvc_NetGetFileSecurity *r)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smb_filename *smb_fname = NULL;
 	size_t sd_size;
 	char *servicename = NULL;
@@ -2347,7 +2387,7 @@ WERROR _srvsvc_NetGetFileSecurity(struct pipes_struct *p,
 
 	nt_status = create_conn_struct_tos_cwd(global_messaging_context(),
 					       snum,
-					       lp_path(frame, snum),
+					       lp_path(frame, lp_sub, snum),
 					       p->session_info,
 					       &c);
 	if (!NT_STATUS_IS_OK(nt_status)) {
@@ -2447,6 +2487,8 @@ WERROR _srvsvc_NetSetFileSecurity(struct pipes_struct *p,
 				  struct srvsvc_NetSetFileSecurity *r)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smb_filename *smb_fname = NULL;
 	char *servicename = NULL;
 	files_struct *fsp = NULL;
@@ -2481,7 +2523,7 @@ WERROR _srvsvc_NetSetFileSecurity(struct pipes_struct *p,
 
 	nt_status = create_conn_struct_tos_cwd(global_messaging_context(),
 					       snum,
-					       lp_path(frame, snum),
+					       lp_path(frame, lp_sub, snum),
 					       p->session_info,
 					       &c);
 	if (!NT_STATUS_IS_OK(nt_status)) {
diff --git a/source3/rpc_server/winreg/srv_winreg_nt.c b/source3/rpc_server/winreg/srv_winreg_nt.c
index e42f0ba203e..6c3270d886a 100644
--- a/source3/rpc_server/winreg/srv_winreg_nt.c
+++ b/source3/rpc_server/winreg/srv_winreg_nt.c
@@ -519,6 +519,8 @@ WERROR _winreg_InitiateSystemShutdown(struct pipes_struct *p,
 WERROR _winreg_InitiateSystemShutdownEx(struct pipes_struct *p,
 					struct winreg_InitiateSystemShutdownEx *r)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *shutdown_script = NULL;
 	char *msg = NULL;
 	char *chkmsg = NULL;
@@ -529,7 +531,7 @@ WERROR _winreg_InitiateSystemShutdownEx(struct pipes_struct *p,
 	int ret = -1;
 	bool can_shutdown = false;
 
-	shutdown_script = lp_shutdown_script(p->mem_ctx);
+	shutdown_script = lp_shutdown_script(p->mem_ctx, lp_sub);
 	if (!shutdown_script) {
 		return WERR_NOT_ENOUGH_MEMORY;
 	}
@@ -611,10 +613,13 @@ WERROR _winreg_InitiateSystemShutdownEx(struct pipes_struct *p,
 WERROR _winreg_AbortSystemShutdown(struct pipes_struct *p,
 				   struct winreg_AbortSystemShutdown *r)
 {
-	const char *abort_shutdown_script = lp_abort_shutdown_script(talloc_tos());
+	const char *abort_shutdown_script = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int ret = -1;
 	bool can_shutdown = false;
 
+	abort_shutdown_script = lp_abort_shutdown_script(talloc_tos(), lp_sub);
 	if (!*abort_shutdown_script)
 		return WERR_ACCESS_DENIED;
 
diff --git a/source3/rpc_server/wkssvc/srv_wkssvc_nt.c b/source3/rpc_server/wkssvc/srv_wkssvc_nt.c
index f661833abe2..6ec3f30c138 100644
--- a/source3/rpc_server/wkssvc/srv_wkssvc_nt.c
+++ b/source3/rpc_server/wkssvc/srv_wkssvc_nt.c
@@ -79,7 +79,8 @@ static char **get_logged_on_userlist(TALLOC_CTX *mem_ctx)
 		for (i = 0; i < num_users; i++) {
 			/* getutxent can return multiple user entries for the
 			 * same user, so ignore any dups */
-			if (strcmp(u->ut_user, usr_infos[i].name) == 0) {
+			int cmp = strncmp(u->ut_user, usr_infos[i].name, sizeof(u->ut_user));
+			if (cmp == 0) {
 				break;
 			}
 		}
diff --git a/source3/rpc_server/wscript_build b/source3/rpc_server/wscript_build
index 870eb3d39d6..8077a9c1a1b 100644
--- a/source3/rpc_server/wscript_build
+++ b/source3/rpc_server/wscript_build
@@ -86,7 +86,8 @@ bld.SAMBA3_SUBSYSTEM('RPC_NETDFS',
 
 bld.SAMBA3_SUBSYSTEM('RPC_NETLOGON',
                      source='''netlogon/srv_netlog_nt.c
-                     ../../librpc/gen_ndr/srv_netlogon.c''')
+                     ../../librpc/gen_ndr/srv_netlogon.c''',
+                    deps='LIBCLI_AUTH')
 
 bld.SAMBA3_SUBSYSTEM('RPC_NTSVCS',
                     source='''ntsvcs/srv_ntsvcs_nt.c
diff --git a/source3/rpcclient/cmd_clusapi.c b/source3/rpcclient/cmd_clusapi.c
index 33d3a1c016e..7f208a1ca1a 100644
--- a/source3/rpcclient/cmd_clusapi.c
+++ b/source3/rpcclient/cmd_clusapi.c
@@ -501,6 +501,116 @@ static WERROR cmd_clusapi_get_cluster_version2(struct rpc_pipe_client *cli,
 	return WERR_OK;
 }
 
+static WERROR cmd_clusapi_pause_node(struct rpc_pipe_client *cli,
+				     TALLOC_CTX *mem_ctx,
+				     int argc,
+				     const char **argv)
+{
+	struct dcerpc_binding_handle *b = cli->binding_handle;
+	NTSTATUS status;
+	const char *lpszNodeName = "CTDB_NODE_0";
+	WERROR Status;
+	struct policy_handle hNode;
+	WERROR rpc_status;
+	WERROR result, ignore;
+
+	if (argc >= 2) {
+		lpszNodeName = argv[1];
+	}
+
+	status = dcerpc_clusapi_OpenNode(b, mem_ctx,
+					 lpszNodeName,
+					 &Status,
+					 &rpc_status,
+					 &hNode);
+	if (!NT_STATUS_IS_OK(status)) {
+		return ntstatus_to_werror(status);
+	}
+
+	if (!W_ERROR_IS_OK(Status)) {
+		printf("Failed to open node %s\n", lpszNodeName);
+		printf("Status: %s\n", win_errstr(Status));
+		return Status;
+	}
+
+	status = dcerpc_clusapi_PauseNode(b, mem_ctx,
+					  hNode,
+					  &rpc_status,
+					  &result);
+	if (!NT_STATUS_IS_OK(status)) {
+		return ntstatus_to_werror(status);
+	}
+	if (!W_ERROR_IS_OK(result)) {
+		printf("Failed to pause node %s\n", lpszNodeName);
+		printf("Status: %s\n", win_errstr(result));
+		return result;
+	}
+
+	dcerpc_clusapi_CloseNode(b, mem_ctx,
+				 &hNode,
+				 &ignore);
+
+	printf("Cluster node %s has been paused\n", lpszNodeName);
+	printf("rpc_status: %s\n", win_errstr(rpc_status));
+
+	return WERR_OK;
+}
+
+static WERROR cmd_clusapi_resume_node(struct rpc_pipe_client *cli,
+				      TALLOC_CTX *mem_ctx,
+				      int argc,
+				      const char **argv)
+{
+	struct dcerpc_binding_handle *b = cli->binding_handle;
+	NTSTATUS status;
+	const char *lpszNodeName = "CTDB_NODE_0";
+	WERROR Status;
+	struct policy_handle hNode;
+	WERROR rpc_status;
+	WERROR result, ignore;
+
+	if (argc >= 2) {
+		lpszNodeName = argv[1];
+	}
+
+	status = dcerpc_clusapi_OpenNode(b, mem_ctx,
+					 lpszNodeName,
+					 &Status,
+					 &rpc_status,
+					 &hNode);
+	if (!NT_STATUS_IS_OK(status)) {
+		return ntstatus_to_werror(status);
+	}
+
+	if (!W_ERROR_IS_OK(Status)) {
+		printf("Failed to open node %s\n", lpszNodeName);
+		printf("Status: %s\n", win_errstr(Status));
+		return Status;
+	}
+
+	status = dcerpc_clusapi_ResumeNode(b, mem_ctx,
+					   hNode,
+					   &rpc_status,
+					   &result);
+	if (!NT_STATUS_IS_OK(status)) {
+		return ntstatus_to_werror(status);
+	}
+	if (!W_ERROR_IS_OK(result)) {
+		printf("Failed to resume node %s\n", lpszNodeName);
+		printf("Status: %s\n", win_errstr(result));
+		return result;
+	}
+
+	dcerpc_clusapi_CloseNode(b, mem_ctx,
+				 &hNode,
+				 &ignore);
+
+	printf("Cluster node %s has been resumed\n", lpszNodeName);
+	printf("rpc_status: %s\n", win_errstr(rpc_status));
+
+	return WERR_OK;
+}
+
 
 struct cmd_set clusapi_commands[] = {
 
@@ -514,7 +624,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_open_cluster,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Open cluster",
 		.usage              = "",
 	},
 	{
@@ -524,7 +634,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_get_cluster_name,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Get cluster name",
 		.usage              = "",
 	},
 	{
@@ -534,7 +644,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_get_cluster_version,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Get cluster version",
 		.usage              = "",
 	},
 	{
@@ -544,7 +654,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_get_quorum_resource,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Get quorum resource",
 		.usage              = "",
 	},
 	{
@@ -554,7 +664,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_create_enum,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Create enum query",
 		.usage              = "",
 	},
 	{
@@ -564,7 +674,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_create_enumex,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Create enumex query",
 		.usage              = "",
 	},
 	{
@@ -574,7 +684,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_open_resource,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Open cluster resource",
 		.usage              = "",
 	},
 	{
@@ -584,7 +694,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_online_resource,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Set cluster resource online",
 		.usage              = "",
 	},
 	{
@@ -594,7 +704,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_offline_resource,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Set cluster resource offline",
 		.usage              = "",
 	},
 	{
@@ -604,7 +714,7 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_get_resource_state,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Get cluster resource state",
 		.usage              = "",
 	},
 	{
@@ -614,7 +724,27 @@ struct cmd_set clusapi_commands[] = {
 		.wfn                = cmd_clusapi_get_cluster_version2,
 		.table              = &ndr_table_clusapi,
 		.rpc_pipe           = NULL,
-		.description        = "bla",
+		.description        = "Get cluster version2",
+		.usage              = "",
+	},
+	{
+		.name               = "clusapi_pause_node",
+		.returntype         = RPC_RTYPE_WERROR,
+		.ntfn               = NULL,
+		.wfn                = cmd_clusapi_pause_node,
+		.table              = &ndr_table_clusapi,
+		.rpc_pipe           = NULL,
+		.description        = "Pause cluster node",
+		.usage              = "",
+	},
+	{
+		.name               = "clusapi_resume_node",
+		.returntype         = RPC_RTYPE_WERROR,
+		.ntfn               = NULL,
+		.wfn                = cmd_clusapi_resume_node,
+		.table              = &ndr_table_clusapi,
+		.rpc_pipe           = NULL,
+		.description        = "Resume cluster node",
 		.usage              = "",
 	},
 	{
diff --git a/source3/rpcclient/cmd_samr.c b/source3/rpcclient/cmd_samr.c
index 932688d7113..068f5dc4a63 100644
--- a/source3/rpcclient/cmd_samr.c
+++ b/source3/rpcclient/cmd_samr.c
@@ -3133,6 +3133,7 @@ static NTSTATUS cmd_samr_setuserinfo_int(struct rpc_pipe_client *cli,
 	uint8_t password_expired = 0;
 	struct dcerpc_binding_handle *b = cli->binding_handle;
 	TALLOC_CTX *frame = NULL;
+	int rc;
 
 	if (argc < 4) {
 		printf("Usage: %s username level password [password_expired]\n",
@@ -3175,7 +3176,11 @@ static NTSTATUS cmd_samr_setuserinfo_int(struct rpc_pipe_client *cli,
 				status = NT_STATUS_NO_MEMORY;
 				goto done;
 			}
-			sess_crypt_blob(&out, &in, &session_key, true);
+			rc = sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
+			if (rc != 0) {
+				status = gnutls_error_to_ntstatus(rc,
+								  NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			}
 			memcpy(nt_hash, out.data, out.length);
 		}
 		{
@@ -3186,7 +3191,11 @@ static NTSTATUS cmd_samr_setuserinfo_int(struct rpc_pipe_client *cli,
 				status = NT_STATUS_NO_MEMORY;
 				goto done;
 			}
-			sess_crypt_blob(&out, &in, &session_key, true);
+			rc = sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
+			if (rc != 0) {
+				status = gnutls_error_to_ntstatus(rc,
+								  NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			}
 			memcpy(lm_hash, out.data, out.length);
 		}
 
@@ -3223,7 +3232,11 @@ static NTSTATUS cmd_samr_setuserinfo_int(struct rpc_pipe_client *cli,
 				status = NT_STATUS_NO_MEMORY;
 				goto done;
 			}
-			sess_crypt_blob(&out, &in, &session_key, true);
+			rc = sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
+			if (rc != 0) {
+				status = gnutls_error_to_ntstatus(rc,
+								  NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			}
 			info.info21.nt_owf_password.array =
 				(uint16_t *)talloc_memdup(frame, out.data, 16);
 		}
@@ -3231,7 +3244,11 @@ static NTSTATUS cmd_samr_setuserinfo_int(struct rpc_pipe_client *cli,
 			DATA_BLOB in,out;
 			in = data_blob_const(lm_hash, 16);
 			out = data_blob_talloc_zero(frame, 16);
-			sess_crypt_blob(&out, &in, &session_key, true);
+			rc = sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
+			if (rc != 0) {
+				status = gnutls_error_to_ntstatus(rc,
+								  NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+			}
 			info.info21.lm_owf_password.array =
 				(uint16_t *)talloc_memdup(frame, out.data, 16);
 			if (out.data == NULL) {
diff --git a/source3/rpcclient/cmd_spoolss.c b/source3/rpcclient/cmd_spoolss.c
index 78c381b9a59..bc37393291a 100644
--- a/source3/rpcclient/cmd_spoolss.c
+++ b/source3/rpcclient/cmd_spoolss.c
@@ -1630,7 +1630,10 @@ static WERROR cmd_spoolss_getdriverpackagepath(struct rpc_pipe_client *cli,
 	}
 
 	offered = 1;
-	cab = talloc_array(mem_ctx, char, offered);
+	cab = talloc_zero_array(mem_ctx, char, offered);
+	if (cab == NULL) {
+		return WERR_NOT_ENOUGH_MEMORY;
+	}
 	status = dcerpc_spoolss_GetPrinterDriverPackagePath(b, mem_ctx,
 							    cli->srv_name_slash,
 							    env,
@@ -1647,7 +1650,9 @@ static WERROR cmd_spoolss_getdriverpackagepath(struct rpc_pipe_client *cli,
 	if (W_ERROR_EQUAL(W_ERROR(WIN32_FROM_HRESULT(hresult)), WERR_INSUFFICIENT_BUFFER)) {
 		offered = needed;
 		cab = talloc_zero_array(mem_ctx, char, offered);
-
+		if (cab == NULL) {
+			return WERR_NOT_ENOUGH_MEMORY;
+		}
 		status = dcerpc_spoolss_GetPrinterDriverPackagePath(b, mem_ctx,
 								    cli->srv_name_slash,
 								    env,
@@ -3926,6 +3931,209 @@ static WERROR cmd_spoolss_play_gdi_script_on_printer_ic(struct rpc_pipe_client *
 	return result;
 }
 
+static WERROR cmd_spoolss_get_core_printer_drivers(struct rpc_pipe_client *cli,
+						   TALLOC_CTX *mem_ctx, int argc,
+						   const char **argv)
+{
+	NTSTATUS status;
+	HRESULT result;
+	struct dcerpc_binding_handle *b = cli->binding_handle;
+	const char *architecture = SPOOLSS_ARCHITECTURE_x64;
+	struct spoolss_CorePrinterDriver core_printer_drivers;
+	DATA_BLOB blob;
+	bool ok;
+	int i;
+	uint32_t count;
+	const char **array;
+
+	if (argc == 1) {
+		count = 1;
+		array = talloc_zero_array(mem_ctx, const char *, count + 1);
+		if (array == NULL) {
+			return WERR_NOT_ENOUGH_MEMORY;
+		}
+		array[0] = talloc_strdup(array, SPOOLSS_CORE_PRINT_PACKAGE_FILES_XPSDRV);
+		if (array[0] == NULL) {
+			return WERR_NOT_ENOUGH_MEMORY;
+		}
+	} else {
+		count = argc -1;
+		array = talloc_zero_array(mem_ctx, const char *, count + 1);
+		if (array == NULL) {
+			return WERR_NOT_ENOUGH_MEMORY;
+		}
+		for (i = 0; i < argc - 1; i++) {
+			array[i] = talloc_strdup(array, argv[i + 1]);
+			if (array[i] == NULL) {
+				return WERR_NOT_ENOUGH_MEMORY;
+			}
+		}
+	}
+
+	ok = push_reg_multi_sz(mem_ctx, &blob, array);
+	if (!ok) {
+		return WERR_NOT_ENOUGH_MEMORY;
+	}
+
+	status = dcerpc_spoolss_GetCorePrinterDrivers(b, mem_ctx,
+						      cli->srv_name_slash,
+						      architecture,
+						      blob.length/2,
+						      (uint16_t *)blob.data,
+						      count,
+						      &core_printer_drivers,
+						      &result);
+	if (!NT_STATUS_IS_OK(status)) {
+		return ntstatus_to_werror(status);
+	}
+
+	if (!HRES_IS_OK(result)) {
+		return W_ERROR(WIN32_FROM_HRESULT(result));
+	}
+
+	return WERR_OK;
+}
+
+static WERROR cmd_spoolss_enum_permachineconnections(struct rpc_pipe_client *cli,
+						     TALLOC_CTX *mem_ctx, int argc,
+						     const char **argv)
+{
+	NTSTATUS status;
+	WERROR result;
+	struct dcerpc_binding_handle *b = cli->binding_handle;
+	const char *servername = cli->srv_name_slash;
+	DATA_BLOB in = data_blob_null;
+	struct spoolss_PrinterInfo4 *info;
+	uint32_t needed, count;
+
+	if (argc > 2) {
+		printf("usage: %s [servername]\n", argv[0]);
+		return WERR_OK;
+	}
+
+	if (argc > 1) {
+		servername = argv[1];
+	}
+
+	status = dcerpc_spoolss_EnumPerMachineConnections(b, mem_ctx,
+							  servername,
+							  &in,
+							  in.length,
+							  &count,
+							  &info,
+							  &needed,
+							  &result);
+	if (!NT_STATUS_IS_OK(status)) {
+		return ntstatus_to_werror(status);
+	}
+
+	if (W_ERROR_EQUAL(result, WERR_INSUFFICIENT_BUFFER)) {
+		in = data_blob_talloc_zero(mem_ctx, needed);
+		status = dcerpc_spoolss_EnumPerMachineConnections(b, mem_ctx,
+								  servername,
+								  &in,
+								  in.length,
+								  &count,
+								  &info,
+								  &needed,
+								  &result);
+		if (!NT_STATUS_IS_OK(status)) {
+			return ntstatus_to_werror(status);
+		}
+	}
+
+	return result;
+}
+
+static WERROR cmd_spoolss_add_permachineconnection(struct rpc_pipe_client *cli,
+						   TALLOC_CTX *mem_ctx, int argc,
+						   const char **argv)
+{
+	NTSTATUS status;
+	WERROR result;
+	struct dcerpc_binding_handle *b = cli->binding_handle;
+	const char *servername = cli->srv_name_slash;
+	const char *printername = "Microsoft Print to PDF";
+	const char *printserver = "samba.org";
+	const char *provider = ""; /* refers to Win32spl.dll then */
+	const char *composed_printername;
+
+	if (argc > 5) {
+		printf("usage: %s [servername] [printername] [printserver] [provider]\n", argv[0]);
+		return WERR_OK;
+	}
+
+	if (argc > 1) {
+		servername = argv[1];
+	}
+	if (argc > 2) {
+		printername = argv[2];
+	}
+	if (argc > 3) {
+		printserver = argv[3];
+	}
+	if (argc > 4) {
+		provider = argv[4];
+	}
+
+	composed_printername = talloc_asprintf(mem_ctx, "%s\\%s", servername,
+			printername);
+	if (composed_printername == NULL) {
+		return WERR_NOT_ENOUGH_MEMORY;
+	}
+	status = dcerpc_spoolss_AddPerMachineConnection(b, mem_ctx,
+							servername,
+							composed_printername,
+							printserver,
+							provider,
+							&result);
+	if (!NT_STATUS_IS_OK(status)) {
+		return ntstatus_to_werror(status);
+	}
+
+	return result;
+}
+
+static WERROR cmd_spoolss_del_permachineconnection(struct rpc_pipe_client *cli,
+						   TALLOC_CTX *mem_ctx, int argc,
+						   const char **argv)
+{
+	NTSTATUS status;
+	WERROR result;
+	struct dcerpc_binding_handle *b = cli->binding_handle;
+	const char *servername = cli->srv_name_slash;
+	const char *printername = "Microsoft Print to PDF";
+	const char *composed_printername;
+
+	if (argc > 3) {
+		printf("usage: %s [servername] [printername]\n", argv[0]);
+		return WERR_OK;
+	}
+
+	if (argc > 1) {
+		servername = argv[1];
+	}
+	if (argc > 2) {
+		printername = argv[2];
+	}
+
+	composed_printername = talloc_asprintf(mem_ctx, "%s\\%s", servername,
+			printername);
+	if (composed_printername == NULL) {
+		return WERR_NOT_ENOUGH_MEMORY;
+	}
+
+	status = dcerpc_spoolss_DeletePerMachineConnection(b, mem_ctx,
+							   servername,
+							   composed_printername,
+							   &result);
+	if (!NT_STATUS_IS_OK(status)) {
+		return ntstatus_to_werror(status);
+	}
+
+	return result;
+}
+
 /* List of commands exported by this module */
 struct cmd_set spoolss_commands[] = {
 
@@ -4314,7 +4522,46 @@ struct cmd_set spoolss_commands[] = {
 		.description        = "Create Printer IC",
 		.usage              = "",
 	},
-
+	{
+		.name               = "getcoreprinterdrivers",
+		.returntype         = RPC_RTYPE_WERROR,
+		.ntfn               = NULL,
+		.wfn                = cmd_spoolss_get_core_printer_drivers,
+		.table              = &ndr_table_spoolss,
+		.rpc_pipe           = NULL,
+		.description        = "Get CorePrinterDriver",
+		.usage              = "",
+	},
+	{
+		.name               = "enumpermachineconnections",
+		.returntype         = RPC_RTYPE_WERROR,
+		.ntfn               = NULL,
+		.wfn                = cmd_spoolss_enum_permachineconnections,
+		.table              = &ndr_table_spoolss,
+		.rpc_pipe           = NULL,
+		.description        = "Enumerate Per Machine Connections",
+		.usage              = "",
+	},
+	{
+		.name               = "addpermachineconnection",
+		.returntype         = RPC_RTYPE_WERROR,
+		.ntfn               = NULL,
+		.wfn                = cmd_spoolss_add_permachineconnection,
+		.table              = &ndr_table_spoolss,
+		.rpc_pipe           = NULL,
+		.description        = "Add Per Machine Connection",
+		.usage              = "",
+	},
+	{
+		.name               = "delpermachineconnection",
+		.returntype         = RPC_RTYPE_WERROR,
+		.ntfn               = NULL,
+		.wfn                = cmd_spoolss_del_permachineconnection,
+		.table              = &ndr_table_spoolss,
+		.rpc_pipe           = NULL,
+		.description        = "Delete Per Machine Connection",
+		.usage              = "",
+	},
 	{
 		.name = NULL,
 	},
diff --git a/source3/script/smbtar b/source3/script/smbtar
index 67a794553cf..e86448cbf6c 100644
--- a/source3/script/smbtar
+++ b/source3/script/smbtar
@@ -134,6 +134,7 @@ while getopts riavl:b:d:N:s:p:x:u:Xt: c; do
       ;;
    v) # be [v]erbose and display what's going on
       verbose=""
+      tarargs=${tarargs}v
       ;;
    '?') # any other switch
        Usage 2 "Invalid switch specified - abort."
diff --git a/source3/script/tests/printing/modprinter.pl b/source3/script/tests/printing/modprinter.pl
index fc71e665451..28817dbd284 100755
--- a/source3/script/tests/printing/modprinter.pl
+++ b/source3/script/tests/printing/modprinter.pl
@@ -131,7 +131,7 @@ if ($opt_delete && ($found_section == 0)) {
 	die "share $share_name not found";
 }
 
-delete @ENV{'BASH_ENV'};
+delete @ENV{"BASH_ENV"};
 
 $ENV{'PATH'} = '/bin:/usr/bin'; # untaint PATH
 system("cp", "$tmp", "$smb_conf_file");
diff --git a/source3/script/tests/test_close_denied_share.sh b/source3/script/tests/test_close_denied_share.sh
new file mode 100755
index 00000000000..6b7d78663fe
--- /dev/null
+++ b/source3/script/tests/test_close_denied_share.sh
@@ -0,0 +1,80 @@
+#!/bin/bash
+#
+# Test smbcontrol close-denied-share command.
+#
+# Verify that changing and querying the security descriptor works. Also
+# ensure that the output format for ACL entries does not change.
+#
+# The test uses well-known SIDs to not require looking up names and SIDs
+#
+# Copyright (C) 2015, 2019 Christof Schmitt
+
+if [ $# -lt 6 ]; then
+    echo Usage: test_close_denied_share.sh \
+	 SERVERCONFFILE SHARESEC SMBCLIENT SMBCONTROL IP SHARE
+exit 1
+fi
+
+CONF=$1
+SHARESEC=$2
+SMBCLIENT=$3
+SMBCONTROL=$4
+SERVER=$5
+SHARE=$6
+
+incdir=$(dirname $0)/../../../testprogs/blackbox
+. $incdir/subunit.sh
+
+failed=0
+
+rm -f smbclient-stdin smbclient-stdout
+mkfifo smbclient-stdin smbclient-stdout
+
+CLI_FORCE_INTERACTIVE=1; export CLI_FORCE_INTERACTIVE
+
+${SMBCLIENT} //${SERVER}/${SHARE} ${CONF} -U${USER}%${PASSWORD} \
+	     < smbclient-stdin > smbclient-stdout &
+CLIENT_PID=$!
+
+sleep 1
+
+exec 100>smbclient-stdin  101<smbclient-stdout
+
+# consume the smbclient startup message
+
+head -n 1 <&101
+
+testit "smbcontrol" ${SMBCONTROL} ${CONF} smbd close-denied-share ${SHARE} ||
+    failed=$(expr $failed + 1)
+sleep 1
+
+echo dir >&100
+
+COUNT=$(head -n 2 <&101 |
+	    grep NT_STATUS_NETWORK_NAME_DELETED |
+	    wc -l)
+testit "Verify close-denied-share did not kill valid client" \
+       test $COUNT -eq 0 || failed=$(expr $failed + 1)
+
+testit "Deny access" ${SHARESEC} ${CONF} --replace S-1-1-0:DENIED/0x0/FULL \
+       ${SHARE} || failed=$(expr $failed + 1)
+
+testit "smbcontrol" ${SMBCONTROL} ${CONF} smbd close-denied-share ${SHARE} ||
+    failed=$(expr $failed + 1)
+sleep 1
+
+echo dir >&100
+
+COUNT=$(head -n 2 <&101 |
+	    grep NT_STATUS_NETWORK_NAME_DELETED |
+	    wc -l)
+testit "Verify close-denied-share did kill now-invalid client" \
+       test $COUNT -eq 1 || failed=$(expr $failed + 1)
+
+kill ${CLIENT_PID}
+rm -f smbclient-stdin smbclient-stdout
+
+testit "Allow access" ${SHARESEC} ${CONF} --replace S-1-1-0:ALLOWED/0x0/FULL \
+       ${SHARE} || failed=$(expr $failed + 1)
+
+testok $0 $failed
diff --git a/source3/script/tests/test_dfree_command.sh b/source3/script/tests/test_dfree_command.sh
index a60a52de5c4..715496d47d7 100755
--- a/source3/script/tests/test_dfree_command.sh
+++ b/source3/script/tests/test_dfree_command.sh
@@ -17,7 +17,9 @@ USERNAME=$3
 PASSWORD=$4
 PREFIX=$5
 smbclient=$6
-shift 6
+protocol=$7
+
+shift 7
 failed=0
 
 incdir=`dirname $0`/../../../testprogs/blackbox
@@ -47,12 +49,18 @@ test_smbclient_dfree() {
 	return $status
 }
 
+if [ $protocol = "SMB3" ]; then
+	test_smbclient_dfree "Test dfree command share root SMB3" dfree "l" "2000 1024. 20" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB3 || failed=`expr $failed + 1`
+	test_smbclient_dfree "Test dfree command subdir1 SMB3" dfree "cd subdir1; l" "8000 1024. 80" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB3 || failed=`expr $failed + 1`
+	test_smbclient_dfree "Test dfree command subdir2 SMB3" dfree "cd subdir2; l" "32000 1024. 320" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB3 || failed=`expr $failed + 1`
 
-test_smbclient_dfree "Test dfree command share root SMB3" dfree "l" "2000 1024. 20" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB3 || failed=`expr $failed + 1`
-test_smbclient_dfree "Test dfree command share root NT1" dfree "l" "2000 1024. 20" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=NT1 || failed=`expr $failed + 1`
-test_smbclient_dfree "Test dfree command subdir1 SMB3" dfree "cd subdir1; l" "8000 1024. 80" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB3 || failed=`expr $failed + 1`
-test_smbclient_dfree "Test dfree command subdir2 SMB3" dfree "cd subdir2; l" "32000 1024. 320" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB3 || failed=`expr $failed + 1`
+elif [ $protocol = "NT1" ]; then
+	test_smbclient_dfree "Test dfree command share root NT1" dfree "l" "2000 1024. 20" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=NT1 || failed=`expr $failed + 1`
 #SMB1 queries disk usage stat on the share's root, regardless of working directory
-test_smbclient_dfree "Test dfree command subdir1 NT1" dfree "cd subdir1; l" "2000 1024. 20" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=NT1 || failed=`expr $failed + 1`
+	test_smbclient_dfree "Test dfree command subdir1 NT1" dfree "cd subdir1; l" "2000 1024. 20" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=NT1 || failed=`expr $failed + 1`
 
+else
+	echo "unsupported protocol $protocol" |  subunit_fail_test "Test dfree command"
+	$failed=`expr $failed + 1`
+fi
 exit $failed
diff --git a/source3/script/tests/test_dfree_quota.sh b/source3/script/tests/test_dfree_quota.sh
index cfba4a9173f..e86d431180a 100755
--- a/source3/script/tests/test_dfree_quota.sh
+++ b/source3/script/tests/test_dfree_quota.sh
@@ -19,7 +19,8 @@ WORKDIR=$5/dfree
 smbclient=$6
 smbcquotas=$7
 smbcacls=$8
-shift 8
+protocol=$9
+shift 9
 failed=0
 
 CONFFILE=$ENVDIR/lib/dfq.conf
@@ -196,13 +197,22 @@ test_smbcquotas() {
 	return $status
 }
 
+if [ $protocol != "SMB3" -a $protocol != "NT1"]; then
+	echo "unsupported protocol $protocol" | subunit_fail_test "Test dfree quota"
+	failed=`expr $failed + 1`
+fi
+
+if [ $protocol = "NT1" ]; then
+	setup_conf
+	#basic quota test (SMB1 only)
+	test_smbcquotas "Test user quota" confq1 $USERNAME "40960/4096000/3072000" "smb1" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=NT1 || failed=`expr $failed + 1`
+	exit $failed
+fi
+
 #basic disk-free tests
 test_smbclient_dfree "Test dfree share root SMB3 no quota" dfq "." "conf1 ." "10 1024. 5" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB3 || failed=`expr $failed + 1`
 test_smbclient_dfree "Test dfree subdir SMB3 no quota" dfq "subdir1" "conf1 . conf2 subdir1" "20 1024. 10" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB3 || failed=`expr $failed + 1`
-test_smbclient_dfree "Test dfree subdir NT1 no quota" dfq "subdir1" "conf1 . conf2 subdir1" "10 1024. 5" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=NT1 || failed=`expr $failed + 1`
 test_smbclient_dfree "Test large disk" dfq "." "conf3 ." "1125899906842624 1024. 3000" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB3 || failed=`expr $failed + 1`
-#basic quota test (SMB1 only)
-test_smbcquotas "Test user quota" confq1 $USERNAME "40960/4096000/3072000" "smb1" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=NT1 || failed=`expr $failed + 1`
 #basic quota test (SMB2 only)
 test_smbcquotas "Test user quota" confq1 $USERNAME "40960/4096000/3072000" "smb2" -U$USERNAME%$PASSWORD --option=clientmaxprotocol=SMB2 || failed=`expr $failed + 1`
 
diff --git a/source3/script/tests/test_durable_handle_reconnect.sh b/source3/script/tests/test_durable_handle_reconnect.sh
index bca8e2def96..77d82c1b403 100755
--- a/source3/script/tests/test_durable_handle_reconnect.sh
+++ b/source3/script/tests/test_durable_handle_reconnect.sh
@@ -11,9 +11,10 @@ delay_inject_conf=$(dirname $SMB_CONF_PATH)/delay_inject.conf
 
 echo 'delay_inject:ntimes = 5000' > $delay_inject_conf
 
-testit "durable_v2_delay" $VALGRIND \
+testit "durable_v2_delay.durable_v2_reconnect_delay" $VALGRIND \
        $BINDIR/smbtorture //$SERVER_IP/delay_inject \
-       -U$USERNAME%$PASSWORD  smb2.durable-v2-delay ||
+       -U$USERNAME%$PASSWORD \
+       smb2.durable-v2-delay.durable_v2_reconnect_delay ||
 	failed=$(expr $failed + 1)
 
 rm $delay_inject_conf
diff --git a/source3/script/tests/test_inherit_owner.sh b/source3/script/tests/test_inherit_owner.sh
index 9f22a2c1cba..7e1333787aa 100755
--- a/source3/script/tests/test_inherit_owner.sh
+++ b/source3/script/tests/test_inherit_owner.sh
@@ -37,7 +37,7 @@ create_file() {
     local bname=$(basename $fname)
     touch $PREFIX/$bname
     $SMBCLIENT //$SERVER/$share -U $USERNAME%$PASSWORD -c "cd $rem_dirname; rm $bname" 2>/dev/null
-    $SMBCLIENT //$SERVER/$share -U $USERNAME%$PASSWORD -c "cd $rem_dirname; ls" 2>/dev/null | grep "$bname" && exit 1
+    $SMBCLIENT //$SERVER/$share -U $USERNAME%$PASSWORD -c "cd $rem_dirname; allinfo $bname" 2>/dev/null | grep "NT_STATUS_OBJECT_NAME_NOT_FOUND" || exit 1
     $SMBCLIENT //$SERVER/$share -U $USERNAME%$PASSWORD -c "lcd $PREFIX; cd $rem_dirname; put $bname" 2>/dev/null || exit 1
 }
 
@@ -47,7 +47,7 @@ create_dir() {
     local rem_dirname=$(dirname $dname)
     local bname=$(basename $dname)
     $SMBCLIENT //$SERVER/$share -U $USERNAME%$PASSWORD -c "cd $rem_dirname; rmdir $bname" 2>/dev/null
-    $SMBCLIENT //$SERVER/$share -U $USERNAME%$PASSWORD -c "cd $rem_dirname; ls" 2>/dev/null | grep "$dname" && exit 1
+    $SMBCLIENT //$SERVER/$share -U $USERNAME%$PASSWORD -c "cd $rem_dirname; allinfo $bname" 2>/dev/null | grep "NT_STATUS_OBJECT_NAME_NOT_FOUND" || exit 1
     $SMBCLIENT //$SERVER/$share -U $USERNAME%$PASSWORD -c "cd $rem_dirname; mkdir $bname" 2>/dev/null || exit 1
 }
 
diff --git a/source3/script/tests/test_net_misc.sh b/source3/script/tests/test_net_misc.sh
index 566694be74b..cc8781c355b 100755
--- a/source3/script/tests/test_net_misc.sh
+++ b/source3/script/tests/test_net_misc.sh
@@ -14,10 +14,17 @@ SERVERCONFFILE="$2"
 NET="$3"
 CONFIGURATION="$4"
 
-NET="$VALGRIND ${NET:-$BINDIR/net} $CONFIGURATION"
+# optional protocl, default to NT1
+if [ $# -gt 4 ]; then
+	PROTOCOL="$5"
+else
+	PROTOCOL="NT1"
+fi
 
-NETTIME="${NET} time"
-NETLOOKUP="${NET} lookup"
+NET="$VALGRIND ${NET:-$BINDIR/net} $CONFIGURATION"
+NETTIME="${NET}   --option=clientmaxprotocol=${PROTOCOL} time"
+NETLOOKUP="${NET} --option=clientmaxprotocol=${PROTOCOL} lookup"
+NETSHARE="${NET} -U${USERNAME}%${PASSWORD} --option=clientmaxprotocol=${PROTOCOL} -S ${SERVER} share"
 
 incdir=`dirname $0`/../../../testprogs/blackbox
 . $incdir/subunit.sh
@@ -38,6 +45,13 @@ test_lookup()
 	${NETLOOKUP} ${PARAM}
 }
 
+test_share()
+{
+	PARAM="$1"
+
+	${NETSHARE} ${PARAM}
+}
+
 testit "get the time" \
 	test_time || \
 	failed=`expr $failed + 1`
@@ -58,5 +72,10 @@ testit "lookup the master browser" \
 	test_lookup master || \
 	failed=`expr $failed + 1`
 
+# This test attempts to lookup shares
+testit "lookup share list" \
+	test_share list || \
+	failed=`expr $failed + 1`
+
 testok $0 $failed
 
diff --git a/source3/script/tests/test_open_eintr.sh b/source3/script/tests/test_open_eintr.sh
new file mode 100755
index 00000000000..d08f7fcfc23
--- /dev/null
+++ b/source3/script/tests/test_open_eintr.sh
@@ -0,0 +1,66 @@
+#!/bin/bash
+#
+# Test smbd handling when open returns EINTR
+#
+# Copyright (C) 2020 Volker Lendecke
+
+if [ $# -lt 5 ]; then
+    echo Usage: test_open_eintr.sh \
+	 --configfile=SERVERCONFFILE SMBCLIENT SMBCONTROL SERVER SHARE
+exit 1
+fi
+
+CONF=$1; shift 1
+SMBCLIENT=$1; shift 1
+SMBCONTROL=$1; shift 1
+SERVER=$1; shift 1
+SHARE=$1; shift 1
+
+error_inject_conf=$(dirname ${SERVERCONFFILE})/error_inject.conf
+> ${error_inject_conf}
+
+incdir=$(dirname $0)/../../../testprogs/blackbox
+. $incdir/subunit.sh
+
+failed=0
+
+rm -f smbclient-stdin smbclient-stdout smbclient-stderr
+mkfifo smbclient-stdin smbclient-stdout smbclient-stderr
+
+CLI_FORCE_INTERACTIVE=1; export CLI_FORCE_INTERACTIVE
+
+${SMBCLIENT} //${SERVER}/${SHARE} ${CONF} -U${USER}%${PASSWORD} \
+	     < smbclient-stdin > smbclient-stdout 2>smbclient-stderr &
+CLIENT_PID=$!
+
+sleep 1
+
+exec 100>smbclient-stdin 101<smbclient-stdout 102<smbclient-stderr
+
+# consume the smbclient startup messages
+head -n 1 <&101
+head -n 1 <&102
+
+echo "error_inject:open = EINTR" > ${error_inject_conf}
+${SMBCONTROL} ${CONF} 0 reload-config
+
+sleep 1
+> ${error_inject_conf}
+
+echo 'get badnames/blank.txt -' >&100
+
+sleep 1
+
+> ${error_inject_conf}
+${SMBCONTROL} ${CONF} 0 reload-config
+
+head -n 1 <&102 | grep 'getting file' > /dev/null
+GREP_RET=$?
+
+kill ${CLIENT_PID}
+rm -f smbclient-stdin smbclient-stdout smbclient-stderr
+
+testit "Verify that we could get the file" \
+       test $GREP_RET -eq 0 || failed=$(expr $failed + 1)
+
+testok $0 $failed
diff --git a/source3/script/tests/test_preserve_case.sh b/source3/script/tests/test_preserve_case.sh
index 2e49b0c0c84..04885f12a1e 100755
--- a/source3/script/tests/test_preserve_case.sh
+++ b/source3/script/tests/test_preserve_case.sh
@@ -17,7 +17,13 @@ USERNAME=$3
 PASSWORD=$4
 PREFIX=$5
 smbclient=$6
-shift 6
+if [ $# -gt 6 ]; then
+	PROTOCOL_LIST=$7
+	shift 7
+else
+	PROTOCOL_LIST="NT1 SMB2 SMB3"
+	shift 6
+fi
 failed=0
 
 incdir=`dirname $0`/../../../testprogs/blackbox
@@ -40,7 +46,6 @@ test_smbclient() {
 	return $status
 }
 
-PROTOCOL_LIST="NT1 SMB2 SMB3"
 SHARE="lowercase"
 
 for PROTOCOL in $PROTOCOL_LIST; do
diff --git a/source3/script/tests/test_sharesec.sh b/source3/script/tests/test_sharesec.sh
index 8165a58ee68..ce1ada53e36 100755
--- a/source3/script/tests/test_sharesec.sh
+++ b/source3/script/tests/test_sharesec.sh
@@ -7,18 +7,20 @@
 #
 # The test uses well-known SIDs to not require looking up names and SIDs
 #
-# Copyright (C) 2015 Christof Schmitt
+# Copyright (C) 2015, 2019 Christof Schmitt
 
-if [ $# -lt 3 ]; then
-	echo Usage: test_sharesec.sh SERVERCONFFILE SHARESEC SHARE
+if [ $# -lt 4 ]; then
+	echo Usage: test_sharesec.sh SERVERCONFFILE SHARESEC NET SHARE
 exit 1
 fi
 
 CONF=$1
 SHARESEC=$2
-SHARE=$3
+NET=$3
+SHARE=$4
 
 CMD="$SHARESEC $CONF $SHARE"
+NET_CMD="$NET $CONF"
 
 incdir=$(dirname $0)/../../../testprogs/blackbox
 . $incdir/subunit.sh
@@ -122,4 +124,17 @@ ACL=$($CMD --view | grep ACL: | sed -e 's/^ACL://')
 testit "Verify standard ACL" test $ACL = S-1-1-0:ALLOWED/0x0/FULL || \
 	failed=$(expr $failed + 1)
 
+testit "Create new share" $NET_CMD conf addshare tmp_share /tmp || \
+	failed=$(expr $failed + 1)
+testit "Change ACL" $SHARESEC $CONF --replace S-1-1-0:DENIED/0x0/FULL tmp_share || \
+	failed=$(expr $failed + 1)
+testit "Delete share" $NET_CMD conf delshare tmp_share || \
+	failed=$(expr $failed + 1)
+testit "Create share again" $NET_CMD conf addshare tmp_share /tmp || \
+	failed=$(expr $failed + 1)
+ACL=$($SHARESEC $CONF --view tmp_share | grep 'ACL:')
+testit "Check for default ACL" \
+       test "$ACL" = "ACL:S-1-1-0:ALLOWED/0x0/FULL" || \
+	failed=$(expr $failed + 1)
+
 testok $0 $failed
diff --git a/source3/script/tests/test_smbclient_machine_auth.sh b/source3/script/tests/test_smbclient_machine_auth.sh
index a890d483149..8a2cc551728 100755
--- a/source3/script/tests/test_smbclient_machine_auth.sh
+++ b/source3/script/tests/test_smbclient_machine_auth.sh
@@ -18,8 +18,8 @@ ADDARGS="$*"
 incdir=`dirname $0`/../../../testprogs/blackbox
 . $incdir/subunit.sh
 
-testit "smbclient //$SERVER/tmp" $SMBCLIENT //$SERVER/tmp --machine-pass -I $SERVER_IP -p 139 -c quit $ADDARGS
+testit "smbclient //$SERVER/tmp" $SMBCLIENT //$SERVER/tmp --machine-pass -p 139 -c quit $ADDARGS
 
 # Testing these here helps because we know the machine account isn't already this user/group
-testit "smbclient //$SERVER/forceuser" $SMBCLIENT //$SERVER/tmp --machine-pass -I $SERVER_IP -p 139 -c quit $ADDARGS
-testit "smbclient //$SERVER/forcegroup" $SMBCLIENT //$SERVER/tmp --machine-pass -I $SERVER_IP -p 139 -c quit $ADDARGS
+testit "smbclient //$SERVER/forceuser" $SMBCLIENT //$SERVER/tmp --machine-pass -p 139 -c quit $ADDARGS
+testit "smbclient //$SERVER/forcegroup" $SMBCLIENT //$SERVER/tmp --machine-pass -p 139 -c quit $ADDARGS
diff --git a/source3/script/tests/test_smbclient_ntlm.sh b/source3/script/tests/test_smbclient_ntlm.sh
index 33a927fe4c2..ab556cd56a4 100755
--- a/source3/script/tests/test_smbclient_ntlm.sh
+++ b/source3/script/tests/test_smbclient_ntlm.sh
@@ -2,9 +2,9 @@
 
 # this runs a smbclient based authentication tests
 
-if [ $# -lt 5 ]; then
+if [ $# -lt 6 ]; then
 cat <<EOF
-Usage: test_smbclient_ntlm.sh SERVER USERNAME PASSWORD MAPTOGUEST SMBCLIENT <smbclient arguments>
+Usage: test_smbclient_ntlm.sh SERVER USERNAME PASSWORD MAPTOGUEST SMBCLIENT PROTOCOL <smbclient arguments>
 EOF
 exit 1;
 fi
@@ -14,31 +14,62 @@ USERNAME="$2"
 PASSWORD="$3"
 MAPTOGUEST="$4"
 SMBCLIENT="$5"
+PROTOCOL="$6"
 SMBCLIENT="$VALGRIND ${SMBCLIENT}"
-shift 5
+shift 6
 ADDARGS="$*"
 
 incdir=`dirname $0`/../../../testprogs/blackbox
 . $incdir/subunit.sh
 
-testit "smbclient username.password.NT1OLD" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U$USERNAME%$PASSWORD -mNT1 --option=clientusespnego=no --option=clientntlmv2auth=no -c quit $ADDARGS
-testit "smbclient username.password.NT1NEW" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U$USERNAME%$PASSWORD -mNT1 -c quit $ADDARGS
-testit "smbclient username.password.SMB3" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U$USERNAME%$PASSWORD -mSMB3 -c quit $ADDARGS
+if [ $PROTOCOL != "SMB3" -a $PROTOCOL != "NT1" ]; then
+cat <<EOF
+Uexpected protocol specified $PROTOCOL
+EOF
+	exit 1;
+fi
 
-testit "smbclient anonymous.nopassword.NT1OLD" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U% -mNT1 --option=clientusespnego=no --option=clientntlmv2auth=no -c quit $ADDARGS
-testit "smbclient anonymous.nopassword.NT1NEW" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U% -mNT1 -c quit $ADDARGS
-testit "smbclient anonymous.nopassword.SMB3" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U% -mSMB3 -c quit $ADDARGS
+if [ $PROTOCOL = "NT1" ]; then
+	testit "smbclient username.password.NT1OLD" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U$USERNAME%$PASSWORD -mNT1 --option=clientusespnego=no --option=clientntlmv2auth=no -c quit $ADDARGS
+	testit "smbclient username.password.NT1NEW" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U$USERNAME%$PASSWORD -mNT1 -c quit $ADDARGS
+fi
+if [ $PROTOCOL = "SMB3" ]; then
+	testit "smbclient username.password.SMB3" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U$USERNAME%$PASSWORD -mSMB3 -c quit $ADDARGS
+fi
+
+if [ $PROTOCOL = "NT1" ]; then
+	testit "smbclient anonymous.nopassword.NT1OLD" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U% -mNT1 --option=clientusespnego=no --option=clientntlmv2auth=no -c quit $ADDARGS
+	testit "smbclient anonymous.nopassword.NT1NEW" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U% -mNT1 -c quit $ADDARGS
+fi
+if [ $PROTOCOL = "SMB3" ]; then
+	testit "smbclient anonymous.nopassword.SMB3" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U% -mSMB3 -c quit $ADDARGS
+fi
 if test x"${MAPTOGUEST}" = x"never" ; then
-	testit_expect_failure "smbclient anonymous.badpassword.NT1NEW.fail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U%badpassword -mNT1 -c quit $ADDARGS
-	testit_expect_failure "smbclient anonymous.badpassword.SMB3.fail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U%badpassword -mSMB3 -c quit $ADDARGS
+	if [ $PROTOCOL = "NT1" ]; then
+		testit_expect_failure "smbclient anonymous.badpassword.NT1NEW.fail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U%badpassword -mNT1 -c quit $ADDARGS
+	fi
+	if [ $PROTOCOL = "SMB3" ]; then
+		testit_expect_failure "smbclient anonymous.badpassword.SMB3.fail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U%badpassword -mSMB3 -c quit $ADDARGS
+	fi
 else
-	testit "smbclient anonymous.badpassword.NT1NEW.guest" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U%badpassword -mNT1 -c quit $ADDARGS
-	testit "smbclient anonymous.badpassword.SMB3.guest" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U%badpassword -mSMB3 -c quit $ADDARGS
-
-	testit "smbclient baduser.badpassword.NT1NEW.guest" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mNT1 -c quit $ADDARGS
-	testit "smbclient baduser.badpassword.SMB3.guest" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mSMB3 -c quit $ADDARGS
+	if [ $PROTOCOL = "NT1" ]; then
+		testit "smbclient anonymous.badpassword.NT1NEW.guest" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U%badpassword -mNT1 -c quit $ADDARGS
+	fi
+	if [ $PROTOCOL = "SMB3" ]; then
+		testit "smbclient anonymous.badpassword.SMB3.guest" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -U%badpassword -mSMB3 -c quit $ADDARGS
+	fi
 
-	testit_expect_failure "smbclient baduser.badpassword.NT1OLD.signfail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mNT1 --option=clientusespnego=no --option=clientntlmv2auth=no --signing=required -c quit $ADDARGS
-	testit_expect_failure "smbclient baduser.badpassword.NT1NEW.signfail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mNT1 --signing=required -c quit $ADDARGS
-	testit_expect_failure "smbclient baduser.badpassword.SMB3.signfail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mSMB3 --signing=required -c quit $ADDARGS
+	if [ $PROTOCOL = "NT1" ]; then
+		testit "smbclient baduser.badpassword.NT1NEW.guest" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mNT1 -c quit $ADDARGS
+	fi
+	if [ $PROTOCOL = "SMB3" ]; then
+		testit "smbclient baduser.badpassword.SMB3.guest" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mSMB3 -c quit $ADDARGS
+	fi
+	if [ $PROTOCOL = "NT1" ]; then
+		testit_expect_failure "smbclient baduser.badpassword.NT1OLD.signfail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mNT1 --option=clientusespnego=no --option=clientntlmv2auth=no --signing=required -c quit $ADDARGS
+		testit_expect_failure "smbclient baduser.badpassword.NT1NEW.signfail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mNT1 --signing=required -c quit $ADDARGS
+	fi
+	if [ $PROTOCOL = "SMB3" ]; then
+		testit_expect_failure "smbclient baduser.badpassword.SMB3.signfail" $SMBCLIENT //$SERVER/IPC\$ $CONFIGURATION -Ubaduser%badpassword -mSMB3 --signing=required -c quit $ADDARGS
+	fi
 fi
diff --git a/source3/script/tests/test_smbclient_s3.sh b/source3/script/tests/test_smbclient_s3.sh
index 0bae1d78fac..5df8a7cb550 100755
--- a/source3/script/tests/test_smbclient_s3.sh
+++ b/source3/script/tests/test_smbclient_s3.sh
@@ -331,7 +331,7 @@ test_msdfs_link()
     tmpfile=$PREFIX/smbclient.in.$$
     prompt="  msdfs-target  "
 
-    cmd='$SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/msdfs-share -I $SERVER_IP $ADDARGS -m nt1 -c dir 2>&1'
+    cmd='$SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/msdfs-share -I $SERVER_IP $ADDARGS -m $PROTOCOL -c dir 2>&1'
     out=`eval $cmd`
     ret=$?
 
@@ -694,7 +694,9 @@ EOF
 test_bad_names()
 {
     # First with SMB1
-    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/badname-tmp -I $SERVER_IP $ADDARGS -mNT1 -c ls 2>&1'
+
+if [ $PROTOCOL = "NT1" ]; then
+    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/badname-tmp -I $SERVER_IP $ADDARGS -m$PROTOCOL -c ls 2>&1'
     eval echo "$cmd"
     out=`eval $cmd`
     ret=$?
@@ -752,9 +754,12 @@ test_bad_names()
 	echo "failed listing \\badname-tmp - grep (5) failed with $ret"
 	return 1
     fi
+fi
+
+if [ $PROTOCOL = "SMB3" ]; then
 
     # Now check again with -mSMB3
-    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/badname-tmp -I $SERVER_IP $ADDARGS -mSMB3 -c ls 2>&1'
+    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/badname-tmp -I $SERVER_IP $ADDARGS -m$PROTOCOL -c ls 2>&1'
     eval echo "$cmd"
     out=`eval $cmd`
     ret=$?
@@ -812,6 +817,7 @@ test_bad_names()
 	echo "failed listing \\badname-tmp - SMB3 grep (5) failed with $ret"
 	return 1
     fi
+fi
 }
 
 # Test accessing an share with a name that must be mangled - with acl_xattrs.
@@ -862,8 +868,9 @@ del smbclient
 del scopy_file
 quit
 EOF
+if [ $PROTOCOL = "SMB3" ]; then
     # First SMB3
-    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/tmp -I $SERVER_IP $ADDARGS -mSMB3 < $tmpfile 2>&1'
+    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/tmp -I $SERVER_IP $ADDARGS -m$PROTOOCL < $tmpfile 2>&1'
     eval echo "$cmd"
     out=`eval $cmd`
     ret=$?
@@ -883,12 +890,13 @@ EOF
 	echo "failed md5sum (1)"
 	return 1
     fi
-
+fi
 #
 # Now do again using SMB1
 # to force client-side fallback.
 #
 
+if [ $PROTOCOL = "NT1" ]; then
     cat > $tmpfile <<EOF
 put ${SMBCLIENT}
 scopy smbclient scopy_file
@@ -898,7 +906,7 @@ del smbclient
 del scopy_file
 quit
 EOF
-    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/tmp -I $SERVER_IP $ADDARGS -mNT1 < $tmpfile 2>&1'
+    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/tmp -I $SERVER_IP $ADDARGS -m$PROTOCOL < $tmpfile 2>&1'
     eval echo "$cmd"
     out=`eval $cmd`
     ret=$?
@@ -918,6 +926,7 @@ EOF
 	echo "failed md5sum (2)"
 	return 1
     fi
+fi
 }
 
 # Test creating a stream on the root of the share directory filname - :foobar
diff --git a/source3/script/tests/test_smbspool.sh b/source3/script/tests/test_smbspool.sh
index 7ba03f01fc7..ae4ac989e55 100755
--- a/source3/script/tests/test_smbspool.sh
+++ b/source3/script/tests/test_smbspool.sh
@@ -48,7 +48,7 @@ test_smbspool_noargs()
 
 test_smbspool_authinforequired_none()
 {
-	cmd='$samba_smbspool_krb5 smb://$SERVER_IP/print1 200 $USERNAME "Testprint" 1 "options" $SRCDIR/testdata/printing/example.ps 2>&1'
+	cmd='$samba_smbspool_krb5 smb://$SERVER_IP/print4 200 $USERNAME "Testprint" 1 "options" $SRCDIR/testdata/printing/example.ps 2>&1'
 
 	AUTH_INFO_REQUIRED="none"
 	export AUTH_INFO_REQUIRED
@@ -60,14 +60,35 @@ test_smbspool_authinforequired_none()
 	if [ $ret != 0 ]; then
 		echo "$out"
 		echo "failed to execute $smbspool_krb5"
+		return 1
 	fi
 
-	echo "$out" | grep 'ATTR: auth-info-required=negotiate'
+	return 0
+}
+
+test_smbspool_authinforequired_unknown()
+{
+	cmd='$samba_smbspool_krb5 smb://$SERVER_IP/print4 200 $USERNAME "Testprint" 1 "options" $SRCDIR/testdata/printing/example.ps 2>&1'
+
+	# smbspool_krb5_wrapper must ignore AUTH_INFO_REQUIRED unknown to him and pass the task to smbspool
+	# smbspool must fail with NT_STATUS_ACCESS_DENIED (22)
+	# "jjf4wgmsbc0" is just a random string
+	AUTH_INFO_REQUIRED="jjf4wgmsbc0"
+	export AUTH_INFO_REQUIRED
+	eval echo "$cmd"
+	out=$(eval $cmd)
 	ret=$?
-	if [ $ret != 0 ] ; then
-		echo "$out"
-		return 1
-	fi
+	unset AUTH_INFO_REQUIRED
+
+	case "$ret" in
+		2 ) return 0 ;;
+		* )
+			echo "ret=$ret"
+			echo "$out"
+			echo "failed to test $smbspool_krb5 against unknown value of AUTH_INFO_REQUIRED"
+			return 1
+		;;
+	esac
 }
 
 #
@@ -191,6 +212,10 @@ testit "smbspool_krb5_wrapper AuthInfoRequired=none" \
 	test_smbspool_authinforequired_none || \
 	failed=$(expr $failed + 1)
 
+testit "smbspool_krb5_wrapper AuthInfoRequired=(sth unknown)" \
+	test_smbspool_authinforequired_unknown || \
+	failed=$(expr $failed + 1)
+
 testit "smbspool print example.ps" \
 	$samba_smbspool smb://$USERNAME:$PASSWORD@$SERVER_IP/print1 200 $USERNAME "Testprint" 1 "options" $SRCDIR/testdata/printing/example.ps || \
 	failed=$(expr $failed + 1)
diff --git a/source3/script/tests/test_timestamps.sh b/source3/script/tests/test_timestamps.sh
new file mode 100755
index 00000000000..be8410bd641
--- /dev/null
+++ b/source3/script/tests/test_timestamps.sh
@@ -0,0 +1,69 @@
+#!/bin/sh
+#
+# This verifies getting and setting timestamps with non-trivial values like 0
+# and < 0 works.
+#
+
+if [ $# -lt 5 ]; then
+    echo "Usage: $0 SERVER_IP USERNAME PASSWORD PREFIX SMBCLIENT"
+    exit 1
+fi
+
+SERVER_IP="$1"
+USERNAME="$2"
+PASSWORD="$3"
+PREFIX="$4"
+SMBCLIENT="$5"
+
+SMBCLIENT="$VALGRIND ${SMBCLIENT}"
+failed=0
+
+incdir=`dirname $0`/../../../testprogs/blackbox
+. $incdir/subunit.sh
+
+export TZ=GMT
+
+setup_testfiles() {
+    touch -d "$(date --date=@0)" $PREFIX/time_0
+    touch -d "$(date --date=@-1)" $PREFIX/time_-1
+    touch -d "$(date --date=@-2)" $PREFIX/time_-2
+    touch -t 196801010000 $PREFIX/time_1968
+}
+
+remove_testfiles() {
+    rm $PREFIX/time_0
+    rm $PREFIX/time_-1
+    rm $PREFIX/time_-2
+    rm $PREFIX/time_1968
+}
+
+test_time() {
+    local file="$1"
+    local expected="$2"
+
+    $SMBCLIENT //$SERVER/tmp -U $USERNAME%$PASSWORD -c "allinfo $file"
+    out=$($SMBCLIENT //$SERVER/tmp -U $USERNAME%$PASSWORD -c "allinfo $file" 2>&1) || return 1
+    echo "smbclient allinfo on $fname returned: \"$out\""
+
+    # Ignore create_time as that is synthesized
+    for time in access_time write_time change_time ; do
+	echo "$out" | grep "$time" | grep "$expected" || {
+            echo "Expected \"$expected\", got: \"$(echo $out | grep $time)\""
+	    return 1
+	}
+    done
+}
+
+#Setup
+testit "create testfiles" setup_testfiles || failed=`expr $failed + 1`
+
+# Tests
+testit "time=0" test_time time_0 "Thu Jan  1 12:00:00 AM 1970 GMT" || failed=`expr $failed + 1`
+testit "time=-1" test_time time_-1 "Wed Dec 31 11:59:59 PM 1969 GMT" || failed=`expr $failed + 1`
+testit "time=-2" test_time time_-2 "Wed Dec 31 11:59:58 PM 1969 GMT" || failed=`expr $failed + 1`
+testit "time=1968" test_time time_1968 "Mon Jan  1 12:00:00 AM 1968 GMT" || failed=`expr $failed + 1`
+
+# Cleanup
+testit "delete testfile" remove_testfiles || failed=`expr $failed + 1`
+
+exit $failed
diff --git a/source3/selftest/tests.py b/source3/selftest/tests.py
index a744e22fe88..dddcb03230c 100755
--- a/source3/selftest/tests.py
+++ b/source3/selftest/tests.py
@@ -214,13 +214,16 @@ local_tests = [
     "LOCAL-DBWRAP-WATCH1",
     "LOCAL-DBWRAP-WATCH2",
     "LOCAL-DBWRAP-WATCH3",
+    "LOCAL-DBWRAP-WATCH4",
     "LOCAL-DBWRAP-DO-LOCKED1",
     "LOCAL-G-LOCK1",
     "LOCAL-G-LOCK2",
     "LOCAL-G-LOCK3",
     "LOCAL-G-LOCK4",
+    "LOCAL-G-LOCK4A",
     "LOCAL-G-LOCK5",
     "LOCAL-G-LOCK6",
+    "LOCAL-G-LOCK7",
     "LOCAL-NAMEMAP-CACHE1",
     "LOCAL-IDMAP-CACHE1",
     "LOCAL-hex_encode_buf",
@@ -243,16 +246,25 @@ plantestsuite("samba3.blackbox.smbclient_basic.SMB3_11", "nt4_dc_schannel", [os.
 plantestsuite("samba3.blackbox.smbclient_basic", "ad_member", [os.path.join(samba3srcdir, "script/tests/test_smbclient_basic.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME', '$DC_PASSWORD', smbclient3, configuration])
 for options in ["", "--option=clientntlmv2auth=no", "--option=clientusespnego=no", "--option=clientusespnego=no --option=clientntlmv2auth=no", "--option=clientntlmv2auth=no --option=clientlanmanauth=yes --max-protocol=LANMAN2", "--option=clientntlmv2auth=no --option=clientlanmanauth=yes --option=clientmaxprotocol=NT1"]:
     env = "nt4_dc"
-    plantestsuite("samba3.blackbox.smbclient_auth.plain (%s) %s" % (env, options), env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME', '$DC_PASSWORD', smbclient3, configuration, options])
+    plantestsuite("samba3.blackbox.smbclient_auth.plain.%s" % (options), env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME', '$DC_PASSWORD', smbclient3, configuration, options])
 
 for env in ["nt4_dc", "nt4_member", "ad_member", "ad_dc", "ad_dc_ntvfs", "s4member", "fl2000dc"]:
-    plantestsuite("samba3.blackbox.smbclient_machine_auth.plain (%s:local)" % env, "%s:local" % env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_machine_auth.sh"), '$SERVER', smbclient3, configuration])
-    plantestsuite("samba3.blackbox.smbclient_ntlm.plain (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_ntlm.sh"), '$SERVER', '$DC_USERNAME', '$DC_PASSWORD', "never", smbclient3, configuration])
+    plantestsuite("samba3.blackbox.smbclient_machine_auth.plain", "%s:local" % env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_machine_auth.sh"), '$SERVER', smbclient3, configuration])
+    plantestsuite("samba3.blackbox.smbclient_ntlm.plain NT1", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_ntlm.sh"), '$SERVER', '$DC_USERNAME', '$DC_PASSWORD', "never", smbclient3, "NT1", configuration])
+    plantestsuite("samba3.blackbox.smbclient_ntlm.plain SMB3", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_ntlm.sh"), '$SERVER', '$DC_USERNAME', '$DC_PASSWORD', "never", smbclient3, "SMB3", configuration])
 
 for options in ["--option=clientntlmv2auth=no", "--option=clientusespnego=no --option=clientntlmv2auth=no", "--option=clientusespnego=no --option=clientntlmv2auth=no -mNT1", ""]:
     for env in ["nt4_member", "ad_member"]:
-        plantestsuite("samba3.blackbox.smbclient_auth.plain (%s) %s" % (env, options), env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME', '$DC_PASSWORD', smbclient3, configuration, options])
-        plantestsuite("samba3.blackbox.smbclient_auth.plain (%s) %s member creds" % (env, options), env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$SERVER/$USERNAME', '$PASSWORD', smbclient3, configuration, options])
+        plantestsuite("samba3.blackbox.smbclient_auth.plain.%s" % (options), env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME', '$DC_PASSWORD', smbclient3, configuration, options])
+        plantestsuite("samba3.blackbox.smbclient_auth.plain.%s.member_creds" % (options), env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$SERVER/$USERNAME', '$PASSWORD', smbclient3, configuration, options])
+
+for env in ["nt4_member", "ad_member"]:
+    plantestsuite("samba3.blackbox.smbclient_auth.empty_domain.domain_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '/$DC_USERNAME', '$DC_PASSWORD', smbclient3, configuration, options])
+    plantestsuite("samba3.blackbox.smbclient_auth.empty_domain.member_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '/$USERNAME', '$PASSWORD', smbclient3, configuration, options])
+    plantestsuite("samba3.blackbox.smbclient_auth.dot_domain.domain_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', './$DC_USERNAME', '$DC_PASSWORD', smbclient3, configuration, options])
+    plantestsuite("samba3.blackbox.smbclient_auth.dot_domain.member_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', './$USERNAME', '$PASSWORD', smbclient3, configuration, options])
+    plantestsuite("samba3.blackbox.smbclient_auth.upn.domain_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME@$REALM', '$DC_PASSWORD', smbclient3, configuration, options])
+    plantestsuite("samba3.blackbox.smbclient_auth.upn.member_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$USERNAME@$SERVER', '$PASSWORD', smbclient3, configuration, options])
 
 env = "ad_dc"
 plantestsuite("samba3.blackbox.smbspool", env, [os.path.join(samba3srcdir, "script/tests/test_smbspool.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME', '$DC_PASSWORD', env])
@@ -261,14 +273,14 @@ for env in ["ad_member:local", "nt4_dc:local"]:
     plantestsuite("samba3.blackbox.smbpasswd", env, [os.path.join(samba3srcdir, "script/tests/test_smbpasswd.sh"), '$SERVER', '$SERVER_IP', '$DC_USERNAME', '$DC_PASSWORD'])
 
 env = "nt4_dc"
-plantestsuite("samba3.blackbox.smbclient_auth.plain (%s) ipv6" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IPV6', '$SERVER/$USERNAME', '$PASSWORD', smbclient3, configuration])
+plantestsuite("samba3.blackbox.smbclient_auth.plain.ipv6", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IPV6', '$SERVER/$USERNAME', '$PASSWORD', smbclient3, configuration])
 
 for env in ["nt4_member", "ad_member"]:
-    plantestsuite("samba3.blackbox.net_cred_change.(%s:local)" % env, "%s:local" % env, [os.path.join(samba3srcdir, "script/tests/test_net_cred_change.sh"), configuration])
+    plantestsuite("samba3.blackbox.net_cred_change", "%s:local" % env, [os.path.join(samba3srcdir, "script/tests/test_net_cred_change.sh"), configuration])
 
 env = "ad_member"
 t = "--krb5auth=$DOMAIN/$DC_USERNAME%$DC_PASSWORD"
-plantestsuite("samba3.wbinfo_simple.(%s:local).%s" % (env, t), "%s:local" % env, [os.path.join(srcdir(), "nsswitch/tests/test_wbinfo_simple.sh"), t])
+plantestsuite("samba3.wbinfo_simple.%s" % t, "%s:local" % env, [os.path.join(srcdir(), "nsswitch/tests/test_wbinfo_simple.sh"), t])
 plantestsuite("samba3.wbinfo_name_lookup", env,
               [os.path.join(srcdir(),
                             "nsswitch/tests/test_wbinfo_name_lookup.sh"),
@@ -297,50 +309,54 @@ plantestsuite("samba3.smbtorture_s3.%s" % t, env, [os.path.join(samba3srcdir, "s
 plantestsuite("samba3.substitutions", env, [os.path.join(samba3srcdir, "script/tests/test_substitutions.sh"), "$SERVER", "alice", "Secret007", "$PREFIX"])
 
 for env in ["maptoguest", "simpleserver"]:
-    plantestsuite("samba3.blackbox.smbclient_auth.plain (%s) local creds" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$USERNAME', '$PASSWORD', smbclient3, configuration + " --option=clientntlmv2auth=no --option=clientlanmanauth=yes"])
+    plantestsuite("samba3.blackbox.smbclient_auth.plain.local_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', '$USERNAME', '$PASSWORD', smbclient3, configuration + " --option=clientntlmv2auth=no --option=clientlanmanauth=yes"])
 
 env = "maptoguest"
-plantestsuite("samba3.blackbox.smbclient_auth.plain (%s) bad username" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', 'notmy$USERNAME', '$PASSWORD', smbclient3, configuration + " --option=clientntlmv2auth=no --option=clientlanmanauth=yes"])
-plantestsuite("samba3.blackbox.smbclient_ntlm.plain (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_ntlm.sh"), '$SERVER', '$USERNAME', '$PASSWORD', "baduser", smbclient3, configuration])
+plantestsuite("samba3.blackbox.smbclient_auth.plain.bad_username", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_auth.sh"), '$SERVER', '$SERVER_IP', 'notmy$USERNAME', '$PASSWORD', smbclient3, configuration + " --option=clientntlmv2auth=no --option=clientlanmanauth=yes"])
+plantestsuite("samba3.blackbox.smbclient_ntlm.plain.NT1", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_ntlm.sh"), '$SERVER', '$USERNAME', '$PASSWORD', "baduser", smbclient3, "NT1", configuration])
+plantestsuite("samba3.blackbox.smbclient_ntlm.plain.SMB3", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_ntlm.sh"), '$SERVER', '$USERNAME', '$PASSWORD', "baduser", smbclient3, "NT1", configuration])
 
 # plain
 for env in ["nt4_dc"]:
-    plantestsuite("samba3.blackbox.smbclient_s3.NT1.plain (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$DC_USERNAME', '$DC_PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1"])
-    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.plain (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$DC_USERNAME', '$DC_PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3"])
+    plantestsuite("samba3.blackbox.smbclient_s3.NT1.plain", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$DC_USERNAME', '$DC_PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1"])
+    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.plain", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$DC_USERNAME', '$DC_PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3"])
 
 for env in ["nt4_member", "ad_member"]:
-    plantestsuite("samba3.blackbox.smbclient_s3.NT1.plain (%s) member creds" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$SERVER', '$SERVER/$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1"])
-    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.plain (%s) member creds" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$SERVER', '$SERVER/$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3"])
+    plantestsuite("samba3.blackbox.smbclient_s3.NT1.plain.member_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$SERVER', '$SERVER/$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1"])
+    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.plain.member_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$SERVER', '$SERVER/$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3"])
 
 for env in ["nt4_dc"]:
-    plantestsuite("samba3.blackbox.smbclient_s3.NT1.sign (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$DC_USERNAME', '$DC_PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1", "--signing=required"])
-    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.sign (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$DC_USERNAME', '$DC_PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3", "--signing=required"])
+    plantestsuite("samba3.blackbox.smbclient_s3.NT1.sign", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$DC_USERNAME', '$DC_PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1", "--signing=required"])
+    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.sign", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$DC_USERNAME', '$DC_PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3", "--signing=required"])
 
 for env in ["nt4_member", "ad_member"]:
-    plantestsuite("samba3.blackbox.smbclient_s3.NT1.sign (%s) member creds" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$SERVER', '$SERVER/$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1", "--signing=required"])
-    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.sign (%s) member creds" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$SERVER', '$SERVER/$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3", "--signing=required"])
+    plantestsuite("samba3.blackbox.smbclient_s3.NT1.sign.member_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$SERVER', '$SERVER/$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1", "--signing=required"])
+    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.sign.member_creds", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$SERVER', '$SERVER/$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3", "--signing=required"])
 
 for env in ["nt4_dc"]:
     # encrypted
-    plantestsuite("samba3.blackbox.smbclient_s3.NT1.crypt (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1", "-e"])
-    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.crypt (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3", "-e"])
+    plantestsuite("samba3.blackbox.smbclient_s3.NT1.crypt", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "NT1", "-e"])
+    plantestsuite("samba3.blackbox.smbclient_s3.SMB3.crypt", env, [os.path.join(samba3srcdir, "script/tests/test_smbclient_s3.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$USERID', '$LOCAL_PATH', '$PREFIX', smbclient3, wbinfo, net, configuration, "SMB3", "-e"])
 
 for env in ["fileserver"]:
-    plantestsuite("samba3.blackbox.preserve_case (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_preserve_case.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3])
-    plantestsuite("samba3.blackbox.dfree_command (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_dfree_command.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3])
-    plantestsuite("samba3.blackbox.dfree_quota (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_dfree_quota.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbclient3, smbcquotas, smbcacls])
-    plantestsuite("samba3.blackbox.smbcquotas (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbcquota.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbcquotas])
-    plantestsuite("samba3.blackbox.valid_users (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_valid_users.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3])
-    plantestsuite("samba3.blackbox.offline (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_offline.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH/offline', smbclient3])
-    plantestsuite("samba3.blackbox.shadow_copy2 NT1 (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_shadow_copy.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH/shadow', smbclient3, '-m', 'NT1'])
-    plantestsuite("samba3.blackbox.shadow_copy2 SMB3 (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_shadow_copy.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH/shadow', smbclient3, '-m', 'SMB3'])
+    plantestsuite("samba3.blackbox.preserve_case.NT1", env, [os.path.join(samba3srcdir, "script/tests/test_preserve_case.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3, "NT1"])
+    plantestsuite("samba3.blackbox.preserve_case.SMB2+", env, [os.path.join(samba3srcdir, "script/tests/test_preserve_case.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3, '"SMB2 SMB3"'])
+    plantestsuite("samba3.blackbox.dfree_command.NT1", env, [os.path.join(samba3srcdir, "script/tests/test_dfree_command.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3, "NT1"])
+    plantestsuite("samba3.blackbox.dfree_command.SMB3", env, [os.path.join(samba3srcdir, "script/tests/test_dfree_command.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3, "SMB3"])
+    plantestsuite("samba3.blackbox.dfree_quota.NT1", env, [os.path.join(samba3srcdir, "script/tests/test_dfree_quota.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbclient3, smbcquotas, smbcacls, "NT1"])
+    plantestsuite("samba3.blackbox.dfree_quota.SMB3", env, [os.path.join(samba3srcdir, "script/tests/test_dfree_quota.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbclient3, smbcquotas, smbcacls, "SMB3"])
+    plantestsuite("samba3.blackbox.smbcquotas", env, [os.path.join(samba3srcdir, "script/tests/test_smbcquota.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbcquotas])
+    plantestsuite("samba3.blackbox.valid_users", env, [os.path.join(samba3srcdir, "script/tests/test_valid_users.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3])
+    plantestsuite("samba3.blackbox.offline", env, [os.path.join(samba3srcdir, "script/tests/test_offline.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH/offline', smbclient3])
+    plantestsuite("samba3.blackbox.shadow_copy2.NT1", env, [os.path.join(samba3srcdir, "script/tests/test_shadow_copy.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH/shadow', smbclient3, '-m', 'NT1'])
+    plantestsuite("samba3.blackbox.shadow_copy2.SMB3", env, [os.path.join(samba3srcdir, "script/tests/test_shadow_copy.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH/shadow', smbclient3, '-m', 'SMB3'])
     plantestsuite("samba3.blackbox.shadow_copy_torture", env, [os.path.join(samba3srcdir, "script/tests/test_shadow_copy_torture.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH/shadow', smbtorture4])
-    plantestsuite("samba3.blackbox.smbclient.forceuser_validusers (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_forceuser_validusers.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbclient3])
-    plantestsuite("samba3.blackbox.smbget (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smbget.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', 'smbget_user', '$PASSWORD', '$LOCAL_PATH/smbget', smbget])
-    plantestsuite("samba3.blackbox.netshareenum (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_shareenum.sh"), '$SERVER', '$USERNAME', '$PASSWORD', rpcclient])
+    plantestsuite("samba3.blackbox.smbclient.forceuser_validusers", env, [os.path.join(samba3srcdir, "script/tests/test_forceuser_validusers.sh"), '$SERVER', '$DOMAIN', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbclient3])
+    plantestsuite("samba3.blackbox.smbget", env, [os.path.join(samba3srcdir, "script/tests/test_smbget.sh"), '$SERVER', '$SERVER_IP', '$DOMAIN', 'smbget_user', '$PASSWORD', '$LOCAL_PATH/smbget', smbget])
+    plantestsuite("samba3.blackbox.netshareenum", env, [os.path.join(samba3srcdir, "script/tests/test_shareenum.sh"), '$SERVER', '$USERNAME', '$PASSWORD', rpcclient])
     plantestsuite("samba3.blackbox.acl_xattr.NT1", env, [os.path.join(samba3srcdir, "script/tests/test_acl_xattr.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3, smbcacls, '-mNT1'])
     plantestsuite("samba3.blackbox.acl_xattr.SMB3", env, [os.path.join(samba3srcdir, "script/tests/test_acl_xattr.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3, smbcacls, '-mSMB3'])
-    plantestsuite("samba3.blackbox.smb2.not_casesensitive (%s)" % env, env, [os.path.join(samba3srcdir, "script/tests/test_smb2_not_casesensitive.sh"), '//$SERVER/tmp', '$SERVER_IP', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbclient3])
+    plantestsuite("samba3.blackbox.smb2.not_casesensitive", env, [os.path.join(samba3srcdir, "script/tests/test_smb2_not_casesensitive.sh"), '//$SERVER/tmp', '$SERVER_IP', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbclient3])
     plantestsuite("samba3.blackbox.inherit_owner.default.NT1", env, [os.path.join(samba3srcdir, "script/tests/test_inherit_owner.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3, smbcacls, net, 'tmp', '0', '0', '-m', 'NT1'])
     plantestsuite("samba3.blackbox.inherit_owner.default.SMB3", env, [os.path.join(samba3srcdir, "script/tests/test_inherit_owner.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3, smbcacls, net, 'tmp', '0', '0', '-m', 'SMB3'])
     plantestsuite("samba3.blackbox.inherit_owner.full.NT1", env, [os.path.join(samba3srcdir, "script/tests/test_inherit_owner.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$PREFIX', smbclient3, smbcacls, net, 'inherit_owner', '1', '1', '-m', 'NT1'])
@@ -357,6 +373,9 @@ for env in ["fileserver"]:
     plantestsuite("samba3.blackbox.zero-data", env,
                   [os.path.join(samba3srcdir, "script/tests/test_zero_data.sh"),
                    '$SERVER_IP', '$USERNAME', '$PASSWORD', '$LOCAL_PATH'])
+    plantestsuite("samba3.blackbox.timestamps", env,
+                  [os.path.join(samba3srcdir, "script/tests/test_timestamps.sh"),
+                   '$SERVER_IP', '$USERNAME', '$PASSWORD', '$LOCAL_PATH', smbclient3])
 
     #
     # tar command tests
@@ -395,7 +414,10 @@ for env in ["fileserver:local"]:
 # TODO encrypted against member, with member creds, and with DC creds
 plantestsuite("samba3.blackbox.net.misc", "nt4_dc:local",
               [os.path.join(samba3srcdir, "script/tests/test_net_misc.sh"),
-               scriptdir, "$SMB_CONF_PATH", net, configuration])
+               scriptdir, "$SMB_CONF_PATH", net, configuration, "NT1"])
+plantestsuite("samba3.blackbox.net.misc", "nt4_dc:local",
+              [os.path.join(samba3srcdir, "script/tests/test_net_misc.sh"),
+               scriptdir, "$SMB_CONF_PATH", net, configuration, "SMB3"])
 plantestsuite("samba3.blackbox.net.local.registry", "nt4_dc:local",
               [os.path.join(samba3srcdir, "script/tests/test_net_registry.sh"),
                scriptdir, "$SMB_CONF_PATH", net, configuration])
@@ -767,7 +789,27 @@ plantestsuite("samba3.blackbox.rpcclient_samlogon", "ad_member:local", [os.path.
                                                                         "$DC_USERNAME", "$DC_PASSWORD", "ncacn_np:$DC_SERVER", configuration])
 plantestsuite("samba3.blackbox.sharesec", "simpleserver:local",
               [os.path.join(samba3srcdir, "script/tests/test_sharesec.sh"),
-               configuration, os.path.join(bindir(), "sharesec"), "tmp"])
+               configuration, os.path.join(bindir(), "sharesec"),
+               os.path.join(bindir(), "net"), "tmp"])
+
+plantestsuite("samba3.blackbox.close-denied-share", "simpleserver:local",
+              [os.path.join(samba3srcdir,
+                            "script/tests/test_close_denied_share.sh"),
+               configuration,
+               os.path.join(bindir(), "sharesec"),
+               os.path.join(bindir(), "smbclient"),
+               os.path.join(bindir(), "smbcontrol"),
+               '$SERVER_IP',
+               "tmp"])
+
+plantestsuite("samba3.blackbox.open-eintr", "simpleserver:local",
+              [os.path.join(samba3srcdir,
+                            "script/tests/test_open_eintr.sh"),
+               configuration,
+               os.path.join(bindir(), "smbclient"),
+               os.path.join(bindir(), "smbcontrol"),
+               '$SERVER_IP',
+               "error_inject"])
 
 plantestsuite("samba3.blackbox.net_tdb", "simpleserver:local",
               [os.path.join(samba3srcdir, "script/tests/test_net_tdb.sh"),
@@ -871,10 +913,10 @@ for e in endianness_options:
             plansmbtorture4testsuite(test, "nt4_dc", options, 'over ncacn_ip_tcp with [%s%s%s] ' % (a, s, e))
 
 plansmbtorture4testsuite('rpc.epmapper', 'nt4_dc:local', 'ncalrpc: -U$USERNAME%$PASSWORD', 'over ncalrpc')
-plansmbtorture4testsuite('rpc.fsrvp', 'nt4_dc:local', 'ncacn_np:$SERVER_IP[/pipe/FssagentRpc] -U$USERNAME%$PASSWORD', 'over ncacn_np')
+plansmbtorture4testsuite('rpc.fsrvp', 'nt4_dc:local', 'ncacn_np:$SERVER_IP -U$USERNAME%$PASSWORD', 'over ncacn_np')
 
 for env in ["ad_member_idmap_rid:local", "maptoguest:local"]:
-    plantestsuite("samba3.blackbox.guest (%s)" % env , env,
+    plantestsuite("samba3.blackbox.guest", env,
                   [os.path.join(samba3srcdir, "script/tests/test_guest_auth.sh"),
                    '$SERVER', smbclient3, smbcontrol, net, configuration])
 
diff --git a/source3/smbd/blocking.c b/source3/smbd/blocking.c
index 131c74b69da..fbedcea05aa 100644
--- a/source3/smbd/blocking.c
+++ b/source3/smbd/blocking.c
@@ -585,8 +585,8 @@ static void smbd_smb1_do_locks_try(struct tevent_req *req)
 	}
 
 setup_retry:
-	subreq = dbwrap_watched_watch_send(
-		state, state->ev, lck->data->record, blocking_pid);
+	subreq = share_mode_watch_send(
+		state, state->ev, lck->data->id, blocking_pid);
 	if (tevent_req_nomem(subreq, req)) {
 		goto done;
 	}
@@ -626,10 +626,10 @@ static void smbd_smb1_do_locks_retry(struct tevent_req *subreq)
 		return;
 	}
 
-	status = dbwrap_watched_watch_recv(subreq, NULL, NULL);
+	status = share_mode_watch_recv(subreq, NULL, NULL);
 	TALLOC_FREE(subreq);
 
-	DBG_DEBUG("dbwrap_watched_watch_recv returned %s\n",
+	DBG_DEBUG("share_mode_watch_recv returned %s\n",
 		  nt_errstr(status));
 
 	/*
diff --git a/source3/smbd/close.c b/source3/smbd/close.c
index 180a5da735b..f45371e656c 100644
--- a/source3/smbd/close.c
+++ b/source3/smbd/close.c
@@ -39,6 +39,8 @@
 static NTSTATUS check_magic(struct files_struct *fsp)
 {
 	int ret;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char *magic_output = NULL;
 	SMB_STRUCT_STAT st;
 	int tmp_fd, outfd;
@@ -48,7 +50,7 @@ static NTSTATUS check_magic(struct files_struct *fsp)
 	char *fname = NULL;
 	NTSTATUS status;
 
-	if (!*lp_magic_script(talloc_tos(), SNUM(conn))) {
+	if (!*lp_magic_script(talloc_tos(), lp_sub, SNUM(conn))) {
 		return NT_STATUS_OK;
 	}
 
@@ -64,13 +66,13 @@ static NTSTATUS check_magic(struct files_struct *fsp)
 		p++;
 	}
 
-	if (!strequal(lp_magic_script(talloc_tos(), SNUM(conn)),p)) {
+	if (!strequal(lp_magic_script(talloc_tos(), lp_sub, SNUM(conn)),p)) {
 		status = NT_STATUS_OK;
 		goto out;
 	}
 
-	if (*lp_magic_output(talloc_tos(), SNUM(conn))) {
-		magic_output = lp_magic_output(talloc_tos(), SNUM(conn));
+	if (*lp_magic_output(talloc_tos(), lp_sub, SNUM(conn))) {
+		magic_output = lp_magic_output(talloc_tos(), lp_sub, SNUM(conn));
 	} else {
 		magic_output = talloc_asprintf(ctx,
 				"%s.out",
@@ -311,13 +313,16 @@ static NTSTATUS close_remove_share_mode(files_struct *fsp,
 	}
 
 	if (fsp->write_time_forced) {
+		struct timespec ts;
+
 		DEBUG(10,("close_remove_share_mode: write time forced "
 			"for file %s\n",
 			fsp_str_dbg(fsp)));
-		set_close_write_time(fsp, lck->data->changed_write_time);
+		ts = nt_time_to_full_timespec(lck->data->changed_write_time);
+		set_close_write_time(fsp, ts);
 	} else if (fsp->update_write_time_on_close) {
 		/* Someone had a pending write. */
-		if (null_timespec(fsp->close_write_time)) {
+		if (is_omit_timespec(&fsp->close_write_time)) {
 			DEBUG(10,("close_remove_share_mode: update to current time "
 				"for file %s\n",
 				fsp_str_dbg(fsp)));
@@ -546,7 +551,7 @@ void set_close_write_time(struct files_struct *fsp, struct timespec ts)
 {
 	DEBUG(6,("close_write_time: %s" , time_to_asc(convert_timespec_to_time_t(ts))));
 
-	if (null_timespec(ts)) {
+	if (is_omit_timespec(&ts)) {
 		return;
 	}
 	fsp->write_time_forced = false;
@@ -560,13 +565,13 @@ static NTSTATUS update_write_time_on_close(struct files_struct *fsp)
 	NTSTATUS status;
 	struct share_mode_lock *lck = NULL;
 
-	ZERO_STRUCT(ft);
+	init_smb_file_time(&ft);
 
 	if (!fsp->update_write_time_on_close) {
 		return NT_STATUS_OK;
 	}
 
-	if (null_timespec(fsp->close_write_time)) {
+	if (is_omit_timespec(&fsp->close_write_time)) {
 		fsp->close_write_time = timespec_current();
 	}
 
@@ -601,7 +606,7 @@ static NTSTATUS update_write_time_on_close(struct files_struct *fsp)
 
 		/* Close write times overwrite sticky write times
 		   so we must replace any sticky write time here. */
-		if (!null_timespec(lck->data->changed_write_time)) {
+		if (!null_nttime(lck->data->changed_write_time)) {
 			(void)set_sticky_write_time(fsp->file_id, fsp->close_write_time);
 		}
 		TALLOC_FREE(lck);
@@ -925,6 +930,8 @@ static NTSTATUS rmdir_internals(TALLOC_CTX *ctx, files_struct *fsp)
 {
 	connection_struct *conn = fsp->conn;
 	struct smb_filename *smb_dname = fsp->fsp_name;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int ret;
 
 	SMB_ASSERT(!is_ntfs_stream_smb_fname(smb_dname));
@@ -959,7 +966,7 @@ static NTSTATUS rmdir_internals(TALLOC_CTX *ctx, files_struct *fsp)
 		return NT_STATUS_OK;
 	}
 
-	if(((errno == ENOTEMPTY)||(errno == EEXIST)) && *lp_veto_files(talloc_tos(), SNUM(conn))) {
+	if(((errno == ENOTEMPTY)||(errno == EEXIST)) && *lp_veto_files(talloc_tos(), lp_sub, SNUM(conn))) {
 		/*
 		 * Check to see if the only thing in this directory are
 		 * vetoed files/directories. If so then delete them and
diff --git a/source3/smbd/conn_idle.c b/source3/smbd/conn_idle.c
index 1934e9cc130..cd12e3f1266 100644
--- a/source3/smbd/conn_idle.c
+++ b/source3/smbd/conn_idle.c
@@ -81,15 +81,13 @@ bool conn_idle_all(struct smbd_server_connection *sconn, time_t t)
  The special sharename '*' forces unmount of all shares.
 ****************************************************************************/
 
-void conn_force_tdis(struct smbd_server_connection *sconn, const char *sharename)
+void conn_force_tdis(
+	struct smbd_server_connection *sconn,
+	bool (*check_fn)(struct connection_struct *conn,
+			 void *private_data),
+	void *private_data)
 {
 	connection_struct *conn, *next;
-	bool close_all = false;
-
-	if (strcmp(sharename, "*") == 0) {
-		close_all = true;
-		DEBUG(1, ("conn_force_tdis: Forcing close of all shares\n"));
-	}
 
 	/* SMB1 and SMB 2*/
 	for (conn = sconn->connections; conn; conn = next) {
@@ -105,21 +103,16 @@ void conn_force_tdis(struct smbd_server_connection *sconn, const char *sharename
 		}
 		tcon = conn->tcon;
 
-		if (close_all) {
-			do_close = true;
-		} else if (strequal(lp_servicename(talloc_tos(), SNUM(conn)),
-				    sharename)) {
-			DEBUG(1, ("conn_force_tdis: Forcing close of "
-				  "share '%s' (wire_id=0x%08x)\n",
-				  tcon->global->share_name,
-				  tcon->global->tcon_wire_id));
-			do_close = true;
-		}
-
+		do_close = check_fn(conn, private_data);
 		if (!do_close) {
 			continue;
 		}
 
+		DBG_WARNING("Forcing close of "
+			    "share '%s' (wire_id=0x%08x)\n",
+			    tcon->global->share_name,
+			    tcon->global->tcon_wire_id);
+
 		if (sconn->using_smb2) {
 			vuid = conn->vuid;
 		}
diff --git a/source3/smbd/conn_msg.c b/source3/smbd/conn_msg.c
index 46161cca4cb..9435d388508 100644
--- a/source3/smbd/conn_msg.c
+++ b/source3/smbd/conn_msg.c
@@ -30,16 +30,119 @@
  The special sharename '*' forces unmount of all shares.
 ****************************************************************************/
 
+struct force_tdis_state {
+	const char *sharename;
+};
+
+static bool force_tdis_check(
+	struct connection_struct *conn,
+	void *private_data)
+{
+	struct force_tdis_state *state = private_data;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *servicename = NULL;
+	bool do_close;
+
+	if (strcmp(state->sharename, "*") == 0) {
+		DBG_WARNING("Forcing close of all shares\n");
+		return true;
+	}
+
+	servicename = lp_servicename(talloc_tos(), lp_sub, SNUM(conn));
+	do_close = strequal(servicename, state->sharename);
+
+	TALLOC_FREE(servicename);
+
+	return do_close;
+}
+
 void msg_force_tdis(struct messaging_context *msg,
 		    void *private_data,
 		    uint32_t msg_type,
 		    struct server_id server_id,
 		    DATA_BLOB *data)
 {
-	const char *sharename = (const char *)data->data;
+	struct force_tdis_state state = {
+		.sharename = (const char *)data->data,
+	};
+	struct smbd_server_connection *sconn =
+		talloc_get_type_abort(private_data,
+		struct smbd_server_connection);
+
+	if ((data->length == 0) || (data->data[data->length-1] != 0)) {
+		DBG_WARNING("Ignoring invalid sharename\n");
+		return;
+	}
+
+	conn_force_tdis(sconn, force_tdis_check, &state);
+}
+
+static bool force_tdis_denied_check(
+	struct connection_struct *conn,
+	void *private_data)
+{
+	bool do_close;
+	uint32_t share_access;
+	bool read_only;
+	NTSTATUS status;
+
+	do_close = force_tdis_check(conn, private_data);
+	if (!do_close) {
+		return false;
+	}
+
+	status = check_user_share_access(
+		conn,
+		conn->session_info,
+		&share_access,
+		&read_only);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("check_user_share_access returned %s\n",
+			  nt_errstr(status));
+		return true;	/* close the share */
+	}
+
+	if (conn->share_access != share_access) {
+		DBG_DEBUG("share_access changed from %"PRIx32" to %"PRIx32"\n",
+			  conn->share_access, share_access);
+		return true;	/* close the share */
+	}
+
+	if (conn->read_only != read_only) {
+		DBG_DEBUG("read_only changed from %s to %s\n",
+			  conn->read_only ? "true" : "false",
+			  read_only ? "true" : "false");
+		return true;	/* close the share */
+	}
+
+	/*
+	 * all still ok, keep the connection open
+	 */
+	return false;
+}
+
+void msg_force_tdis_denied(
+	struct messaging_context *msg,
+	void *private_data,
+	uint32_t msg_type,
+	struct server_id server_id,
+	DATA_BLOB *data)
+{
+	struct force_tdis_state state = {
+		.sharename = (const char *)data->data,
+	};
 	struct smbd_server_connection *sconn =
 		talloc_get_type_abort(private_data,
 		struct smbd_server_connection);
 
-	conn_force_tdis(sconn, sharename);
+	if ((data->length == 0) || (data->data[data->length-1] != 0)) {
+		DBG_WARNING("Ignoring invalid sharename\n");
+		return;
+	}
+
+	change_to_root_user();
+	reload_services(sconn, conn_snum_used, false);
+
+	conn_force_tdis(sconn, force_tdis_denied_check, &state);
 }
diff --git a/source3/smbd/connection.c b/source3/smbd/connection.c
index c2dae6c73c4..8dea205e4c7 100644
--- a/source3/smbd/connection.c
+++ b/source3/smbd/connection.c
@@ -83,9 +83,11 @@ int count_current_connections(const char *sharename, bool verify)
 
 bool connections_snum_used(struct smbd_server_connection *unused, int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int active;
 
-	active = count_current_connections(lp_servicename(talloc_tos(), snum),
+	active = count_current_connections(lp_servicename(talloc_tos(), lp_sub, snum),
 					   true);
 	if (active > 0) {
 		return true;
diff --git a/source3/smbd/dfree.c b/source3/smbd/dfree.c
index 31900c847f1..d083ce22797 100644
--- a/source3/smbd/dfree.c
+++ b/source3/smbd/dfree.c
@@ -57,6 +57,8 @@ static uint64_t sys_disk_free(connection_struct *conn,
 			      uint64_t *dfree,
 			      uint64_t *dsize)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint64_t dfree_retval;
 	uint64_t dfree_q = 0;
 	uint64_t bsize_q = 0;
@@ -72,7 +74,7 @@ static uint64_t sys_disk_free(connection_struct *conn,
 	 * If external disk calculation specified, use it.
 	 */
 
-	dfree_command = lp_dfree_command(talloc_tos(), SNUM(conn));
+	dfree_command = lp_dfree_command(talloc_tos(), lp_sub, SNUM(conn));
 	if (dfree_command && *dfree_command) {
 		const char *p;
 		char **lines = NULL;
diff --git a/source3/smbd/dir.c b/source3/smbd/dir.c
index 49e8dd17451..8314f4084c0 100644
--- a/source3/smbd/dir.c
+++ b/source3/smbd/dir.c
@@ -899,7 +899,7 @@ bool smbd_dirptr_get_entry(TALLOC_CTX *ctx,
 			fileid = vfs_file_id_from_sbuf(conn,
 						       &smb_fname.st);
 			get_file_infos(fileid, 0, NULL, &write_time_ts);
-			if (!null_timespec(write_time_ts)) {
+			if (!is_omit_timespec(&write_time_ts)) {
 				update_stat_ex_mtime(&smb_fname.st,
 						     write_time_ts);
 			}
diff --git a/source3/smbd/dosmode.c b/source3/smbd/dosmode.c
index 38d34623336..322bf4476d6 100644
--- a/source3/smbd/dosmode.c
+++ b/source3/smbd/dosmode.c
@@ -313,7 +313,7 @@ NTSTATUS parse_dos_attribute_blob(struct smb_filename *smb_fname,
 		if ((dosattrib.info.info3.valid_flags & XATTR_DOSINFO_CREATE_TIME) &&
 		    !null_nttime(dosattrib.info.info3.create_time)) {
 			struct timespec create_time =
-				nt_time_to_unix_timespec(
+				nt_time_to_full_timespec(
 					dosattrib.info.info3.create_time);
 
 			update_stat_ex_create_time(&smb_fname->st,
@@ -336,7 +336,7 @@ NTSTATUS parse_dos_attribute_blob(struct smb_filename *smb_fname,
 		{
 			struct timespec creat_time;
 
-			creat_time = nt_time_to_unix_timespec(info->create_time);
+			creat_time = nt_time_to_full_timespec(info->create_time);
 			update_stat_ex_create_time(&smb_fname->st, creat_time);
 
 			DBG_DEBUG("file [%s] creation time [%s]\n",
@@ -492,13 +492,13 @@ NTSTATUS set_ea_dos_attribute(connection_struct *conn,
 	dosattrib.info.info4.valid_flags = XATTR_DOSINFO_ATTRIB |
 					XATTR_DOSINFO_CREATE_TIME;
 	dosattrib.info.info4.attrib = dosmode;
-	dosattrib.info.info4.create_time = unix_timespec_to_nt_time(
-				smb_fname->st.st_ex_btime);
+	dosattrib.info.info4.create_time = full_timespec_to_nt_time(
+		&smb_fname->st.st_ex_btime);
 
 	if (!(smb_fname->st.st_ex_iflags & ST_EX_IFLAG_CALCULATED_ITIME)) {
 		dosattrib.info.info4.valid_flags |= XATTR_DOSINFO_ITIME;
-		dosattrib.info.info4.itime = unix_timespec_to_nt_time(
-			smb_fname->st.st_ex_itime);
+		dosattrib.info.info4.itime = full_timespec_to_nt_time(
+			&smb_fname->st.st_ex_itime);
 	}
 
 	DEBUG(10,("set_ea_dos_attributes: set attribute 0x%x, btime = %s on file %s\n",
@@ -1122,6 +1122,8 @@ NTSTATUS file_set_sparse(connection_struct *conn,
 			 files_struct *fsp,
 			 bool sparse)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uint32_t old_dosmode;
 	uint32_t new_dosmode;
 	NTSTATUS status;
@@ -1131,7 +1133,7 @@ NTSTATUS file_set_sparse(connection_struct *conn,
 			"on readonly share[%s]\n",
 			smb_fname_str_dbg(fsp->fsp_name),
 			sparse,
-			lp_servicename(talloc_tos(), SNUM(conn))));
+			lp_servicename(talloc_tos(), lp_sub, SNUM(conn))));
 		return NT_STATUS_MEDIA_WRITE_PROTECTED;
 	}
 
@@ -1268,7 +1270,7 @@ int file_ntimes(connection_struct *conn, const struct smb_filename *smb_fname,
 
 bool set_sticky_write_time_path(struct file_id fileid, struct timespec mtime)
 {
-	if (null_timespec(mtime)) {
+	if (is_omit_timespec(&mtime)) {
 		return true;
 	}
 
@@ -1286,7 +1288,7 @@ bool set_sticky_write_time_path(struct file_id fileid, struct timespec mtime)
 
 bool set_sticky_write_time_fsp(struct files_struct *fsp, struct timespec mtime)
 {
-	if (null_timespec(mtime)) {
+	if (is_omit_timespec(&mtime)) {
 		return true;
 	}
 
diff --git a/source3/smbd/durable.c b/source3/smbd/durable.c
index c71a948191a..9a4ebfb12d2 100644
--- a/source3/smbd/durable.c
+++ b/source3/smbd/durable.c
@@ -104,7 +104,8 @@ NTSTATUS vfs_default_durable_cookie(struct files_struct *fsp,
 	cookie.update_write_time_triggered = fsp->update_write_time_triggered;
 	cookie.update_write_time_on_close = fsp->update_write_time_on_close;
 	cookie.write_time_forced = fsp->write_time_forced;
-	cookie.close_write_time = fsp->close_write_time;
+	cookie.close_write_time = full_timespec_to_nt_time(
+		&fsp->close_write_time);
 
 	cookie.stat_info.st_ex_dev = fsp->fsp_name->st.st_ex_dev;
 	cookie.stat_info.st_ex_ino = fsp->fsp_name->st.st_ex_ino;
@@ -205,19 +206,20 @@ NTSTATUS vfs_default_durable_disconnect(struct files_struct *fsp,
 	if (lck != NULL) {
 		struct smb_file_time ft;
 
-		ZERO_STRUCT(ft);
+		init_smb_file_time(&ft);
 
 		if (fsp->write_time_forced) {
-			ft.mtime = lck->data->changed_write_time;
+			ft.mtime = nt_time_to_full_timespec(
+				lck->data->changed_write_time);
 		} else if (fsp->update_write_time_on_close) {
-			if (null_timespec(fsp->close_write_time)) {
+			if (is_omit_timespec(&fsp->close_write_time)) {
 				ft.mtime = timespec_current();
 			} else {
 				ft.mtime = fsp->close_write_time;
 			}
 		}
 
-		if (!null_timespec(ft.mtime)) {
+		if (!is_omit_timespec(&ft.mtime)) {
 			round_timespec(conn->ts_res, &ft.mtime);
 			file_ntimes(conn, fsp->fsp_name, &ft);
 		}
@@ -253,7 +255,8 @@ NTSTATUS vfs_default_durable_disconnect(struct files_struct *fsp,
 	cookie.update_write_time_triggered = fsp->update_write_time_triggered;
 	cookie.update_write_time_on_close = fsp->update_write_time_on_close;
 	cookie.write_time_forced = fsp->write_time_forced;
-	cookie.close_write_time = fsp->close_write_time;
+	cookie.close_write_time = full_timespec_to_nt_time(
+		&fsp->close_write_time);
 
 	cookie.stat_info.st_ex_dev = fsp->fsp_name->st.st_ex_dev;
 	cookie.stat_info.st_ex_ino = fsp->fsp_name->st.st_ex_ino;
@@ -520,6 +523,8 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 				       files_struct **result,
 				       DATA_BLOB *new_cookie)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct share_mode_lock *lck;
 	struct share_mode_entry e;
 	struct files_struct *fsp = NULL;
@@ -650,7 +655,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 	{
 		DEBUG(5, ("vfs_default_durable_reconnect: denying durable "
 			  "share[%s] is not writeable anymore\n",
-			  lp_servicename(talloc_tos(), SNUM(conn))));
+			  lp_servicename(talloc_tos(), lp_sub, SNUM(conn))));
 		TALLOC_FREE(lck);
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
@@ -746,7 +751,8 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 	fsp->update_write_time_triggered = cookie.update_write_time_triggered;
 	fsp->update_write_time_on_close = cookie.update_write_time_on_close;
 	fsp->write_time_forced = cookie.write_time_forced;
-	fsp->close_write_time = cookie.close_write_time;
+	fsp->close_write_time = nt_time_to_full_timespec(
+		cookie.close_write_time);
 
 	status = fsp_set_smb_fname(fsp, smb_fname);
 	if (!NT_STATUS_IS_OK(status)) {
diff --git a/source3/smbd/fake_file.c b/source3/smbd/fake_file.c
index 83b66d6bd39..81ccbde6aab 100644
--- a/source3/smbd/fake_file.c
+++ b/source3/smbd/fake_file.c
@@ -126,6 +126,8 @@ NTSTATUS open_fake_file(struct smb_request *req, connection_struct *conn,
 				uint32_t access_mask,
 				files_struct **result)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	files_struct *fsp = NULL;
 	NTSTATUS status;
 
@@ -134,7 +136,7 @@ NTSTATUS open_fake_file(struct smb_request *req, connection_struct *conn,
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(10, ("open_fake_file: smbd_calculate_access_mask "
 			"on service[%s] file[%s] returned %s\n",
-			lp_servicename(talloc_tos(), SNUM(conn)),
+			lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 			smb_fname_str_dbg(smb_fname),
 			nt_errstr(status)));
 		return status;
@@ -144,7 +146,7 @@ NTSTATUS open_fake_file(struct smb_request *req, connection_struct *conn,
 	if (geteuid() != sec_initial_uid()) {
 		DEBUG(3, ("open_fake_file_shared: access_denied to "
 			  "service[%s] file[%s] user[%s]\n",
-			  lp_servicename(talloc_tos(), SNUM(conn)),
+			  lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 			  smb_fname_str_dbg(smb_fname),
 			  conn->session_info->unix_info->unix_name));
 		return NT_STATUS_ACCESS_DENIED;
diff --git a/source3/smbd/fileio.c b/source3/smbd/fileio.c
index b03f86d49d6..029965282f1 100644
--- a/source3/smbd/fileio.c
+++ b/source3/smbd/fileio.c
@@ -178,6 +178,8 @@ void trigger_write_time_update_immediate(struct files_struct *fsp)
 {
 	struct smb_file_time ft;
 
+	init_smb_file_time(&ft);
+
 	if (fsp->posix_flags & FSP_POSIX_FLAGS_OPEN) {
 		/* Don't use delayed writes on POSIX files. */
 		return;
@@ -199,7 +201,7 @@ void trigger_write_time_update_immediate(struct files_struct *fsp)
 	fsp->update_write_time_triggered = true;
         fsp->update_write_time_on_close = false;
 
-	ft = (struct smb_file_time) { .mtime = timespec_current() };
+	ft.mtime = timespec_current();
 
 	/* Update the time in the open file db. */
 	(void)set_write_time(fsp->file_id, ft.mtime);
diff --git a/source3/smbd/files.c b/source3/smbd/files.c
index 077610cad75..99b2f343685 100644
--- a/source3/smbd/files.c
+++ b/source3/smbd/files.c
@@ -65,6 +65,7 @@ NTSTATUS fsp_new(struct connection_struct *conn, TALLOC_CTX *mem_ctx,
 
 	fsp->fnum = FNUM_FIELD_INVALID;
 	fsp->conn = conn;
+	fsp->close_write_time = make_omit_timespec();
 
 	DLIST_ADD(sconn->files, fsp);
 	sconn->num_files += 1;
@@ -660,11 +661,7 @@ struct files_struct *file_fsp_get(struct smbd_smb2_request *smb2req,
 		return NULL;
 	}
 
-	if (smb2req->session->compat == NULL) {
-		return NULL;
-	}
-
-	if (smb2req->session->compat->vuid != fsp->vuid) {
+	if (smb2req->session->global->session_wire_id != fsp->vuid) {
 		return NULL;
 	}
 
diff --git a/source3/smbd/globals.h b/source3/smbd/globals.h
index c791eb0fa6f..7b26d04ed0f 100644
--- a/source3/smbd/globals.h
+++ b/source3/smbd/globals.h
@@ -232,9 +232,9 @@ bool smbd_smb2_is_compound(const struct smbd_smb2_request *req);
 NTSTATUS smbd_add_connection(struct smbXsrv_client *client, int sock_fd,
 			     struct smbXsrv_connection **_xconn);
 
-void reply_smb2002(struct smb_request *req, uint16_t choice);
-void reply_smb20ff(struct smb_request *req, uint16_t choice);
-void smbd_smb2_process_negprot(struct smbXsrv_connection *xconn,
+NTSTATUS reply_smb2002(struct smb_request *req, uint16_t choice);
+NTSTATUS reply_smb20ff(struct smb_request *req, uint16_t choice);
+NTSTATUS smbd_smb2_process_negprot(struct smbXsrv_connection *xconn,
 			       uint64_t expected_seq_low,
 			       const uint8_t *inpdu, size_t size);
 
@@ -573,6 +573,9 @@ NTSTATUS smb1srv_session_table_init(struct smbXsrv_connection *conn);
 NTSTATUS smb1srv_session_lookup(struct smbXsrv_connection *conn,
 				uint16_t vuid, NTTIME now,
 				struct smbXsrv_session **session);
+NTSTATUS smbXsrv_session_info_lookup(struct smbXsrv_client *client,
+				     uint64_t session_wire_id,
+				     struct auth_session_info **si);
 NTSTATUS smb2srv_session_table_init(struct smbXsrv_connection *conn);
 NTSTATUS smb2srv_session_lookup_conn(struct smbXsrv_connection *conn,
 				     uint64_t session_id, NTTIME now,
@@ -580,6 +583,14 @@ NTSTATUS smb2srv_session_lookup_conn(struct smbXsrv_connection *conn,
 NTSTATUS smb2srv_session_lookup_client(struct smbXsrv_client *client,
 				       uint64_t session_id, NTTIME now,
 				       struct smbXsrv_session **session);
+NTSTATUS get_valid_smbXsrv_session(struct smbXsrv_client *client,
+				   uint64_t session_wire_id,
+				   struct smbXsrv_session **session);
+NTSTATUS smbXsrv_session_local_traverse(
+	struct smbXsrv_client *client,
+	int (*caller_cb)(struct smbXsrv_session *session,
+			      void *caller_data),
+	void *caller_data);
 struct smbXsrv_session_global0;
 NTSTATUS smbXsrv_session_global_traverse(
 			int (*fn)(struct smbXsrv_session_global0 *, void *),
@@ -829,24 +840,10 @@ struct smbd_smb2_request {
 };
 
 struct smbd_server_connection;
-struct user_struct;
 
 struct pending_message_list;
 struct pending_auth_data;
 
-struct user_struct {
-	struct user_struct *next, *prev;
-	uint64_t vuid; /* Tag for this entry. */
-
-	char *session_keystr; /* used by utmp and pam session code.
-				 TDB key string */
-	int homes_snum;
-
-	struct auth_session_info *session_info;
-
-	struct smbXsrv_session *session;
-};
-
 struct pthreadpool_tevent;
 
 struct smbd_server_connection {
@@ -860,7 +857,6 @@ struct smbd_server_connection {
 	int trans_num;
 
 	size_t num_users;
-	struct user_struct *users;
 
 	size_t num_connections;
 	struct connection_struct *connections;
diff --git a/source3/smbd/lanman.c b/source3/smbd/lanman.c
index ee6e9a481e2..abbec164217 100644
--- a/source3/smbd/lanman.c
+++ b/source3/smbd/lanman.c
@@ -97,6 +97,8 @@ static int CopyExpanded(connection_struct *conn,
 			int snum, char **dst, char *src, int *p_space_remaining)
 {
 	TALLOC_CTX *ctx = talloc_tos();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *buf = NULL;
 	int l;
 
@@ -110,13 +112,13 @@ static int CopyExpanded(connection_struct *conn,
 		*p_space_remaining = 0;
 		return 0;
 	}
-	buf = talloc_string_sub(ctx, buf,"%S", lp_servicename(ctx, snum));
+	buf = talloc_string_sub(ctx, buf,"%S", lp_servicename(ctx, lp_sub, snum));
 	if (!buf) {
 		*p_space_remaining = 0;
 		return 0;
 	}
 	buf = talloc_sub_full(ctx,
-				  lp_servicename(ctx, SNUM(conn)),
+				  lp_servicename(ctx, lp_sub, SNUM(conn)),
 				conn->session_info->unix_info->unix_name,
 				conn->connectpath,
 				conn->session_info->unix_token->gid,
@@ -154,6 +156,8 @@ static int CopyAndAdvance(char **dst, char *src, int *n)
 static int StrlenExpanded(connection_struct *conn, int snum, char *s)
 {
 	TALLOC_CTX *ctx = talloc_tos();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *buf = NULL;
 	if (!s) {
 		return 0;
@@ -162,12 +166,12 @@ static int StrlenExpanded(connection_struct *conn, int snum, char *s)
 	if (!buf) {
 		return 0;
 	}
-	buf = talloc_string_sub(ctx,buf,"%S",lp_servicename(ctx, snum));
+	buf = talloc_string_sub(ctx,buf,"%S",lp_servicename(ctx, lp_sub, snum));
 	if (!buf) {
 		return 0;
 	}
 	buf = talloc_sub_full(ctx,
-				  lp_servicename(ctx, SNUM(conn)),
+				  lp_servicename(ctx, lp_sub, SNUM(conn)),
 				conn->session_info->unix_info->unix_name,
 				conn->connectpath,
 				conn->session_info->unix_token->gid,
@@ -1888,6 +1892,8 @@ static int fill_share_info(connection_struct *conn, int snum, int uLevel,
  			   char** buf, int* buflen,
  			   char** stringbuf, int* stringspace, char* baseaddr)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int struct_len;
 	char* p;
 	char* p2;
@@ -1915,10 +1921,10 @@ static int fill_share_info(connection_struct *conn, int snum, int uLevel,
 		len = 0;
 
 		if (uLevel > 0) {
-			len += StrlenExpanded(conn,snum,lp_comment(talloc_tos(), snum));
+			len += StrlenExpanded(conn,snum,lp_comment(talloc_tos(), lp_sub, snum));
 		}
 		if (uLevel > 1) {
-			len += strlen(lp_path(talloc_tos(), snum)) + 1;
+			len += strlen(lp_path(talloc_tos(), lp_sub, snum)) + 1;
 		}
 		if (buflen) {
 			*buflen = struct_len;
@@ -1947,7 +1953,7 @@ static int fill_share_info(connection_struct *conn, int snum, int uLevel,
 		baseaddr = p;
 	}
 
-	push_ascii(p,lp_servicename(talloc_tos(), snum),13, STR_TERMINATE);
+	push_ascii(p,lp_servicename(talloc_tos(), lp_sub, snum),13, STR_TERMINATE);
 
 	if (uLevel > 0) {
 		int type;
@@ -1962,7 +1968,7 @@ static int fill_share_info(connection_struct *conn, int snum, int uLevel,
 		}
 		SSVAL(p,14,type);		/* device type */
 		SIVAL(p,16,PTR_DIFF(p2,baseaddr));
-		len += CopyExpanded(conn,snum,&p2,lp_comment(talloc_tos(),snum),&l2);
+		len += CopyExpanded(conn,snum,&p2,lp_comment(talloc_tos(), lp_sub, snum),&l2);
 	}
 
 	if (uLevel > 1) {
@@ -1970,7 +1976,7 @@ static int fill_share_info(connection_struct *conn, int snum, int uLevel,
 		SSVALS(p,22,-1);		/* max uses */
 		SSVAL(p,24,1); /* current uses */
 		SIVAL(p,26,PTR_DIFF(p2,baseaddr)); /* local pathname */
-		len += CopyAndAdvance(&p2,lp_path(talloc_tos(),snum),&l2);
+		len += CopyAndAdvance(&p2,lp_path(talloc_tos(),lp_sub, snum),&l2);
 		memset(p+30,0,SHPWLEN+2); /* passwd (reserved), pad field */
 	}
 
@@ -2074,6 +2080,8 @@ static bool api_RNetShareEnum(struct smbd_server_connection *sconn,
 				int               *rdata_len,
 				int               *rparam_len )
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *str1 = get_safe_str_ptr(param,tpscnt,param,2);
 	char *str2 = skip_string(param,tpscnt,str1);
 	char *p = skip_string(param,tpscnt,str2);
@@ -2111,7 +2119,7 @@ static bool api_RNetShareEnum(struct smbd_server_connection *sconn,
 		if (!(lp_browseable(i) && lp_snum_ok(i))) {
 			continue;
 		}
-		push_ascii_fstring(servicename_dos, lp_servicename(talloc_tos(), i));
+		push_ascii_fstring(servicename_dos, lp_servicename(talloc_tos(), lp_sub, i));
 		/* Maximum name length = 13. */
 		if( lp_browseable( i ) && lp_snum_ok( i ) && (strlen(servicename_dos) < 13)) {
 			total++;
@@ -2144,7 +2152,7 @@ static bool api_RNetShareEnum(struct smbd_server_connection *sconn,
 		}
 
 		push_ascii_fstring(servicename_dos,
-				   lp_servicename(talloc_tos(), i));
+				   lp_servicename(talloc_tos(), lp_sub, i));
 		if (lp_browseable(i) && lp_snum_ok(i) && (strlen(servicename_dos) < 13)) {
 			if (fill_share_info( conn,i,uLevel,&p,&f_len,&p2,&s_len,*rdata ) < 0) {
 				break;
@@ -4407,19 +4415,23 @@ static bool api_WWkstaUserLogon(struct smbd_server_connection *sconn,
 	int uLevel;
 	struct pack_desc desc;
 	char* name;
-		/* With share level security vuid will always be zero.
-		   Don't depend on vuser being non-null !!. JRA */
-	struct user_struct *vuser = get_valid_user_struct(sconn, vuid);
+	struct auth_session_info *si = NULL;
+	NTSTATUS status;
+
+	status = smbXsrv_session_info_lookup(conn->sconn->client,
+					     vuid,
+					     &si);
+	if (!NT_STATUS_IS_OK(status)) {
+		return false;
+	}
 
 	if (!str1 || !str2 || !p) {
 		return False;
 	}
 
-	if(vuser != NULL) {
-		DEBUG(3,("  Username of UID %d is %s\n",
-			 (int)vuser->session_info->unix_token->uid,
-			 vuser->session_info->unix_info->unix_name));
-	}
+	DBG_INFO("Username of UID %ju is %s\n",
+		 (uintmax_t)si->unix_token->uid,
+		 si->unix_info->unix_name);
 
 	uLevel = get_safe_SVAL(param,tpscnt,p,0,-1);
 	name = get_safe_str_ptr(param,tpscnt,p,2);
@@ -4479,9 +4491,7 @@ static bool api_WWkstaUserLogon(struct smbd_server_connection *sconn,
 		}
 
 		PACKS(&desc,"z",lp_workgroup());/* domain */
-		PACKS(&desc,"z", vuser ?
-		      vuser->session_info->info->logon_script
-			: ""); /* script path */
+		PACKS(&desc,"z", si->info->logon_script); /* script path */
 		PACKI(&desc,"D",0x00000000);		/* reserved */
 	}
 
@@ -5782,9 +5792,18 @@ void api_reply(connection_struct *conn, uint64_t vuid,
 	/* Check whether this api call can be done anonymously */
 
 	if (api_commands[i].auth_user && lp_restrict_anonymous()) {
-		struct user_struct *user = get_valid_user_struct(req->sconn, vuid);
+		struct auth_session_info *si = NULL;
+		NTSTATUS status;
+
+		status = smbXsrv_session_info_lookup(conn->sconn->client,
+						     vuid,
+						     &si);
+		if (!NT_STATUS_IS_OK(status)) {
+			reply_nterror(req, NT_STATUS_ACCESS_DENIED);
+			return;
+		}
 
-		if (!user || security_session_user_level(user->session_info, NULL) < SECURITY_USER) {
+		if (security_session_user_level(si, NULL) < SECURITY_USER) {
 			reply_nterror(req, NT_STATUS_ACCESS_DENIED);
 			return;
 		}
diff --git a/source3/smbd/mangle.c b/source3/smbd/mangle.c
index 3649bf772fa..dbb187abb3b 100644
--- a/source3/smbd/mangle.c
+++ b/source3/smbd/mangle.c
@@ -45,7 +45,7 @@ static void mangle_init(void)
 	if (mangle_fns)
 		return;
 
-	method = lp_mangling_method(talloc_tos());
+	method = lp_mangling_method();
 
 	/* find the first mangling method that manages to initialise and
 	   matches the "mangling method" parameter */
diff --git a/source3/smbd/message.c b/source3/smbd/message.c
index a4ffad57b5c..b9728946889 100644
--- a/source3/smbd/message.c
+++ b/source3/smbd/message.c
@@ -43,6 +43,8 @@ struct msg_state {
 static void msg_deliver(struct msg_state *state)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *name = NULL;
 	int i;
 	int fd;
@@ -53,7 +55,7 @@ static void msg_deliver(struct msg_state *state)
 	char *s;
 	mode_t mask;
 
-	if (! (*lp_message_command(frame))) {
+	if (! (*lp_message_command(frame, lp_sub))) {
 		DEBUG(1,("no messaging command specified\n"));
 		goto done;
 	}
@@ -100,7 +102,7 @@ static void msg_deliver(struct msg_state *state)
 	close(fd);
 
 	/* run the command */
-	s = lp_message_command(frame);
+	s = lp_message_command(frame, lp_sub);
 	if (s == NULL) {
 		goto done;
 	}
@@ -143,6 +145,8 @@ static void msg_deliver(struct msg_state *state)
 
 void reply_sends(struct smb_request *req)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct msg_state *state;
 	int len;
 	const uint8_t *msg;
@@ -150,7 +154,7 @@ void reply_sends(struct smb_request *req)
 
 	START_PROFILE(SMBsends);
 
-	if (!(*lp_message_command(talloc_tos()))) {
+	if (!(*lp_message_command(talloc_tos(), lp_sub))) {
 		reply_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
 		END_PROFILE(SMBsends);
 		return;
@@ -194,12 +198,14 @@ void reply_sends(struct smb_request *req)
 
 void reply_sendstrt(struct smb_request *req)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smbXsrv_connection *xconn = req->xconn;
 	const uint8_t *p;
 
 	START_PROFILE(SMBsendstrt);
 
-	if (!(*lp_message_command(talloc_tos()))) {
+	if (!(*lp_message_command(talloc_tos(), lp_sub))) {
 		reply_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
 		END_PROFILE(SMBsendstrt);
 		return;
@@ -242,6 +248,8 @@ void reply_sendstrt(struct smb_request *req)
 
 void reply_sendtxt(struct smb_request *req)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smbXsrv_connection *xconn = req->xconn;
 	int len;
 	const char *msg;
@@ -250,7 +258,7 @@ void reply_sendtxt(struct smb_request *req)
 
 	START_PROFILE(SMBsendtxt);
 
-	if (! (*lp_message_command(talloc_tos()))) {
+	if (! (*lp_message_command(talloc_tos(), lp_sub))) {
 		reply_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
 		END_PROFILE(SMBsendtxt);
 		return;
@@ -297,10 +305,12 @@ void reply_sendtxt(struct smb_request *req)
 
 void reply_sendend(struct smb_request *req)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smbXsrv_connection *xconn = req->xconn;
 	START_PROFILE(SMBsendend);
 
-	if (! (*lp_message_command(talloc_tos()))) {
+	if (! (*lp_message_command(talloc_tos(), lp_sub))) {
 		reply_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
 		END_PROFILE(SMBsendend);
 		return;
diff --git a/source3/smbd/msdfs.c b/source3/smbd/msdfs.c
index fe8553215a4..cc32ebc9d29 100644
--- a/source3/smbd/msdfs.c
+++ b/source3/smbd/msdfs.c
@@ -61,6 +61,8 @@ static NTSTATUS parse_dfs_path(connection_struct *conn,
 				struct dfs_path *pdp, /* MUST BE TALLOCED */
 				bool *ppath_contains_wcard)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *pathname_local;
 	char *p,*temp;
 	char *servicename;
@@ -162,9 +164,9 @@ static NTSTATUS parse_dfs_path(connection_struct *conn,
 	}
 
 	/* Is this really our servicename ? */
-	if (conn && !( strequal(servicename, lp_servicename(talloc_tos(), SNUM(conn)))
+	if (conn && !( strequal(servicename, lp_servicename(talloc_tos(), lp_sub, SNUM(conn)))
 			|| (strequal(servicename, HOMES_NAME)
-			&& strequal(lp_servicename(talloc_tos(), SNUM(conn)),
+			&& strequal(lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 				get_current_username()) )) ) {
 		DEBUG(10,("parse_dfs_path: %s is not our servicename\n",
 			servicename));
@@ -299,21 +301,19 @@ static NTSTATUS create_conn_struct_as_root(TALLOC_CTX *ctx,
 	conn->params->service = snum;
 	conn->cnum = TID_FIELD_INVALID;
 
-	if (session_info != NULL) {
-		conn->session_info = copy_session_info(conn, session_info);
-		if (conn->session_info == NULL) {
-			DEBUG(0, ("copy_serverinfo failed\n"));
-			TALLOC_FREE(conn);
-			return NT_STATUS_NO_MEMORY;
-		}
-		/* unix_info could be NULL in session_info */
-		if (conn->session_info->unix_info != NULL) {
-			vfs_user = conn->session_info->unix_info->unix_name;
-		} else {
-			vfs_user = get_current_username();
-		}
+	SMB_ASSERT(session_info != NULL);
+
+	conn->session_info = copy_session_info(conn, session_info);
+	if (conn->session_info == NULL) {
+		DBG_ERR("copy_serverinfo failed\n");
+		TALLOC_FREE(conn);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	/* unix_info could be NULL in session_info */
+	if (conn->session_info->unix_info != NULL) {
+		vfs_user = conn->session_info->unix_info->unix_name;
 	} else {
-		/* use current authenticated user in absence of session_info */
 		vfs_user = get_current_username();
 	}
 
@@ -325,27 +325,21 @@ static NTSTATUS create_conn_struct_as_root(TALLOC_CTX *ctx,
 	 * smb.conf checks are done as we need a uid and token. JRA.
 	 *
 	 */
-	if (conn->session_info) {
-		share_access_check(conn->session_info->security_token,
-				   servicename,
-				   MAXIMUM_ALLOWED_ACCESS,
-				   &conn->share_access);
-
-		if ((conn->share_access & FILE_WRITE_DATA) == 0) {
-			if ((conn->share_access & FILE_READ_DATA) == 0) {
-				/* No access, read or write. */
-				DEBUG(3,("create_conn_struct: connection to %s "
-					 "denied due to security "
-					 "descriptor.\n",
-					 servicename));
-				conn_free(conn);
-				return NT_STATUS_ACCESS_DENIED;
-			} else {
-				conn->read_only = true;
-			}
+	share_access_check(conn->session_info->security_token,
+			   servicename,
+			   MAXIMUM_ALLOWED_ACCESS,
+			   &conn->share_access);
+
+	if ((conn->share_access & FILE_WRITE_DATA) == 0) {
+		if ((conn->share_access & FILE_READ_DATA) == 0) {
+			/* No access, read or write. */
+			DBG_WARNING("connection to %s "
+				    "denied due to security "
+				    "descriptor.\n",
+				    servicename);
+			conn_free(conn);
+			return NT_STATUS_ACCESS_DENIED;
 		}
-	} else {
-		conn->share_access = 0;
 		conn->read_only = true;
 	}
 
@@ -529,32 +523,34 @@ static void shuffle_strlist(char **list, int count)
  server we're referring to understands posix paths.
  **********************************************************************/
 
-static bool parse_msdfs_symlink(TALLOC_CTX *ctx,
-				int snum,
-				const char *target,
-				struct referral **preflist,
-				int *refcount)
+bool parse_msdfs_symlink(TALLOC_CTX *ctx,
+			bool shuffle_referrals,
+			const char *target,
+			struct referral **ppreflist,
+			size_t *prefcount)
 {
 	char *temp = NULL;
 	char *prot;
 	char **alt_path = NULL;
-	int count = 0, i;
-	struct referral *reflist;
+	size_t count = 0, i;
+	struct referral *reflist = NULL;
 	char *saveptr;
 
 	temp = talloc_strdup(ctx, target);
 	if (!temp) {
-		return False;
+		return false;
 	}
 	prot = strtok_r(temp, ":", &saveptr);
 	if (!prot) {
 		DEBUG(0,("parse_msdfs_symlink: invalid path !\n"));
-		return False;
+		TALLOC_FREE(temp);
+		return false;
 	}
 
 	alt_path = talloc_array(ctx, char *, MAX_REFERRAL_COUNT);
 	if (!alt_path) {
-		return False;
+		TALLOC_FREE(temp);
+		return false;
 	}
 
 	/* parse out the alternate paths */
@@ -564,21 +560,22 @@ static bool parse_msdfs_symlink(TALLOC_CTX *ctx,
 	}
 
 	/* shuffle alternate paths */
-	if (lp_msdfs_shuffle_referrals(snum)) {
+	if (shuffle_referrals) {
 		shuffle_strlist(alt_path, count);
 	}
 
-	DEBUG(10,("parse_msdfs_symlink: count=%d\n", count));
+	DBG_DEBUG("count=%zu\n", count);
 
 	if (count) {
-		reflist = *preflist = talloc_zero_array(ctx,
+		reflist = talloc_zero_array(ctx,
 				struct referral, count);
 		if(reflist == NULL) {
+			TALLOC_FREE(temp);
 			TALLOC_FREE(alt_path);
-			return False;
+			return false;
 		}
 	} else {
-		reflist = *preflist = NULL;
+		reflist = NULL;
 	}
 
 	for(i=0;i<count;i++) {
@@ -594,95 +591,33 @@ static bool parse_msdfs_symlink(TALLOC_CTX *ctx,
 			p++;
 		}
 
-		reflist[i].alternate_path = talloc_asprintf(ctx,
+		reflist[i].alternate_path = talloc_asprintf(reflist,
 				"\\%s",
 				p);
 		if (!reflist[i].alternate_path) {
-			return False;
+			TALLOC_FREE(temp);
+			TALLOC_FREE(alt_path);
+			TALLOC_FREE(reflist);
+			return false;
 		}
 
 		reflist[i].proximity = 0;
 		reflist[i].ttl = REFERRAL_TTL;
-		DEBUG(10, ("parse_msdfs_symlink: Created alt path: %s\n",
-					reflist[i].alternate_path));
+		DBG_DEBUG("Created alt path: %s\n",
+			reflist[i].alternate_path);
 	}
 
-	*refcount = count;
-
-	TALLOC_FREE(alt_path);
-	return True;
-}
-
-/**********************************************************************
- Returns true if the unix path is a valid msdfs symlink and also
- returns the target string from inside the link.
-**********************************************************************/
-
-static bool is_msdfs_link_internal(TALLOC_CTX *ctx,
-			connection_struct *conn,
-			struct smb_filename *smb_fname,
-			char **pp_link_target)
-{
-	int referral_len = 0;
-#if defined(HAVE_BROKEN_READLINK)
-	char link_target_buf[PATH_MAX];
-#else
-	char link_target_buf[7];
-#endif
-	size_t bufsize = 0;
-	char *link_target = NULL;
-
-	if (pp_link_target) {
-		bufsize = 1024;
-		link_target = talloc_array(ctx, char, bufsize);
-		if (!link_target) {
-			return False;
-		}
-		*pp_link_target = link_target;
+	if (ppreflist != NULL) {
+		*ppreflist = reflist;
 	} else {
-		bufsize = sizeof(link_target_buf);
-		link_target = link_target_buf;
+		TALLOC_FREE(reflist);
 	}
-
-	if (SMB_VFS_LSTAT(conn, smb_fname) != 0) {
-		DEBUG(5,("is_msdfs_link_read_target: %s does not exist.\n",
-			smb_fname->base_name));
-		goto err;
+	if (prefcount != NULL) {
+		*prefcount = count;
 	}
-	if (!S_ISLNK(smb_fname->st.st_ex_mode)) {
-		DEBUG(5,("is_msdfs_link_read_target: %s is not a link.\n",
-			smb_fname->base_name));
-		goto err;
-	}
-
-	referral_len = SMB_VFS_READLINKAT(conn,
-				conn->cwd_fsp,
-				smb_fname,
-				link_target,
-				bufsize - 1);
-
-	if (referral_len == -1) {
-		DEBUG(0,("is_msdfs_link_read_target: Error reading "
-			"msdfs link %s: %s\n",
-			smb_fname->base_name, strerror(errno)));
-		goto err;
-	}
-	link_target[referral_len] = '\0';
-
-	DEBUG(5,("is_msdfs_link_internal: %s -> %s\n", smb_fname->base_name,
-				link_target));
-
-	if (!strnequal(link_target, "msdfs:", 6)) {
-		goto err;
-	}
-	return True;
-
-  err:
-
-	if (link_target != link_target_buf) {
-		TALLOC_FREE(link_target);
-	}
-	return False;
+	TALLOC_FREE(temp);
+	TALLOC_FREE(alt_path);
+	return true;
 }
 
 /**********************************************************************
@@ -692,10 +627,13 @@ static bool is_msdfs_link_internal(TALLOC_CTX *ctx,
 bool is_msdfs_link(connection_struct *conn,
 		struct smb_filename *smb_fname)
 {
-	return is_msdfs_link_internal(talloc_tos(),
-					conn,
+	NTSTATUS status = SMB_VFS_READ_DFS_PATHAT(conn,
+					talloc_tos(),
+					conn->cwd_fsp,
 					smb_fname,
+					NULL,
 					NULL);
+	return (NT_STATUS_IS_OK(status));
 }
 
 /*****************************************************************
@@ -720,7 +658,8 @@ static NTSTATUS dfs_path_lookup(TALLOC_CTX *ctx,
 					       server+share+extrapath. */
 		uint32_t ucf_flags,
 		int *consumedcntp,
-		char **pp_targetpath)
+		struct referral **ppreflist,
+		size_t *preferral_count)
 {
 	char *p = NULL;
 	char *q = NULL;
@@ -754,7 +693,14 @@ static NTSTATUS dfs_path_lookup(TALLOC_CTX *ctx,
 
 	/* Optimization - check if we can redirect the whole path. */
 
-	if (is_msdfs_link_internal(ctx, conn, smb_fname, pp_targetpath)) {
+	status = SMB_VFS_READ_DFS_PATHAT(conn,
+					ctx,
+					conn->cwd_fsp,
+					smb_fname,
+					ppreflist,
+					preferral_count);
+
+	if (NT_STATUS_IS_OK(status)) {
 		/* XX_ALLOW_WCARD_XXX is called from search functions. */
 		if (ucf_flags &
 				(UCF_COND_ALLOW_WCARD_LCOMP|
@@ -765,9 +711,8 @@ static NTSTATUS dfs_path_lookup(TALLOC_CTX *ctx,
 			goto out;
 		}
 
-		DEBUG(6,("dfs_path_lookup: %s resolves to a "
-			"valid dfs link %s.\n", dfspath,
-			pp_targetpath ? *pp_targetpath : ""));
+		DBG_INFO("%s resolves to a valid dfs link\n",
+			dfspath);
 
 		if (consumedcntp) {
 			*consumedcntp = strlen(dfspath);
@@ -816,11 +761,18 @@ static NTSTATUS dfs_path_lookup(TALLOC_CTX *ctx,
 			*q = '\0';
 		}
 
-		if (is_msdfs_link_internal(ctx, conn,
-					   smb_fname, pp_targetpath)) {
-			DEBUG(4, ("dfs_path_lookup: Redirecting %s because "
-				  "parent %s is dfs link\n", dfspath,
-				  smb_fname_str_dbg(smb_fname)));
+		status = SMB_VFS_READ_DFS_PATHAT(conn,
+					ctx,
+					conn->cwd_fsp,
+					smb_fname,
+					ppreflist,
+					preferral_count);
+
+		if (NT_STATUS_IS_OK(status)) {
+			DBG_INFO("Redirecting %s because "
+				"parent %s is a dfs link\n",
+				dfspath,
+				smb_fname_str_dbg(smb_fname));
 
 			if (consumedcntp) {
 				*consumedcntp = strlen(canon_dfspath);
@@ -845,6 +797,7 @@ static NTSTATUS dfs_path_lookup(TALLOC_CTX *ctx,
 
 	status = NT_STATUS_OK;
  out:
+
 	TALLOC_FREE(smb_fname);
 	return status;
 }
@@ -872,6 +825,8 @@ static NTSTATUS dfs_redirect(TALLOC_CTX *ctx,
 			char **pp_path_out,
 			bool *ppath_contains_wcard)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	NTSTATUS status;
 	bool search_wcard_flag = (ucf_flags &
 		(UCF_COND_ALLOW_WCARD_LCOMP|UCF_ALWAYS_ALLOW_WCARD_LCOMP));
@@ -923,9 +878,9 @@ static NTSTATUS dfs_redirect(TALLOC_CTX *ctx,
 		return NT_STATUS_OK;
 	}
 
-	if (!( strequal(pdp->servicename, lp_servicename(talloc_tos(), SNUM(conn)))
+	if (!( strequal(pdp->servicename, lp_servicename(talloc_tos(), lp_sub, SNUM(conn)))
 			|| (strequal(pdp->servicename, HOMES_NAME)
-			&& strequal(lp_servicename(talloc_tos(), SNUM(conn)),
+			&& strequal(lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 				conn->session_info->unix_info->sanitized_username) )) ) {
 
 		/* The given sharename doesn't match this connection. */
@@ -934,8 +889,14 @@ static NTSTATUS dfs_redirect(TALLOC_CTX *ctx,
 		return NT_STATUS_OBJECT_PATH_NOT_FOUND;
 	}
 
-	status = dfs_path_lookup(ctx, conn, path_in, pdp,
-				 ucf_flags, NULL, NULL);
+	status = dfs_path_lookup(ctx,
+				conn,
+				path_in,
+				pdp,
+				ucf_flags,
+				NULL, /* int *consumedcntp */
+				NULL, /* struct referral **ppreflist */
+				NULL); /* size_t *preferral_count */
 	if (!NT_STATUS_IS_OK(status)) {
 		if (NT_STATUS_EQUAL(status, NT_STATUS_PATH_NOT_COVERED)) {
 			DEBUG(3,("dfs_redirect: Redirecting %s\n", path_in));
@@ -1000,6 +961,7 @@ static NTSTATUS self_ref(TALLOC_CTX *ctx,
 **********************************************************************/
 
 NTSTATUS get_referred_path(TALLOC_CTX *ctx,
+			   struct auth_session_info *session_info,
 			   const char *dfs_path,
 			   const struct tsocket_address *remote_address,
 			   const struct tsocket_address *local_address,
@@ -1009,9 +971,10 @@ NTSTATUS get_referred_path(TALLOC_CTX *ctx,
 			   bool *self_referralp)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct conn_struct_tos *c = NULL;
 	struct connection_struct *conn = NULL;
-	char *targetpath = NULL;
 	int snum;
 	NTSTATUS status = NT_STATUS_NOT_FOUND;
 	bool dummy;
@@ -1058,7 +1021,7 @@ NTSTATUS get_referred_path(TALLOC_CTX *ctx,
 		}
 	}
 
-	if (!lp_msdfs_root(snum) && (*lp_msdfs_proxy(talloc_tos(), snum) == '\0')) {
+	if (!lp_msdfs_root(snum) && (*lp_msdfs_proxy(talloc_tos(), lp_sub, snum) == '\0')) {
 		DEBUG(3,("get_referred_path: |%s| in dfs path %s is not "
 			"a dfs root.\n",
 			pdp->servicename, dfs_path));
@@ -1077,9 +1040,9 @@ NTSTATUS get_referred_path(TALLOC_CTX *ctx,
 	if (pdp->reqpath[0] == '\0') {
 		char *tmp;
 		struct referral *ref;
-		int refcount;
+		size_t refcount;
 
-		if (*lp_msdfs_proxy(talloc_tos(), snum) == '\0') {
+		if (*lp_msdfs_proxy(talloc_tos(), lp_sub, snum) == '\0') {
 			TALLOC_FREE(frame);
 			return self_ref(ctx,
 					dfs_path,
@@ -1094,13 +1057,17 @@ NTSTATUS get_referred_path(TALLOC_CTX *ctx,
  		 */
 
 		tmp = talloc_asprintf(frame, "msdfs:%s",
-				      lp_msdfs_proxy(frame, snum));
+				      lp_msdfs_proxy(frame, lp_sub, snum));
 		if (tmp == NULL) {
 			TALLOC_FREE(frame);
 			return NT_STATUS_NO_MEMORY;
 		}
 
-		if (!parse_msdfs_symlink(ctx, snum, tmp, &ref, &refcount)) {
+		if (!parse_msdfs_symlink(ctx,
+				lp_msdfs_shuffle_referrals(snum),
+				tmp,
+				&ref,
+				&refcount)) {
 			TALLOC_FREE(frame);
 			return NT_STATUS_INVALID_PARAMETER;
 		}
@@ -1113,8 +1080,8 @@ NTSTATUS get_referred_path(TALLOC_CTX *ctx,
 
 	status = create_conn_struct_tos_cwd(global_messaging_context(),
 					    snum,
-					    lp_path(frame, snum),
-					    NULL,
+					    lp_path(frame, lp_sub, snum),
+					    session_info,
 					    &c);
 	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(frame);
@@ -1148,8 +1115,14 @@ NTSTATUS get_referred_path(TALLOC_CTX *ctx,
 	/* If this is a DFS path dfs_lookup should return
 	 * NT_STATUS_PATH_NOT_COVERED. */
 
-	status = dfs_path_lookup(ctx, conn, dfs_path, pdp,
-				 0, consumedcntp, &targetpath);
+	status = dfs_path_lookup(ctx,
+				conn,
+				dfs_path,
+				pdp,
+				0, /* ucf_flags */
+				consumedcntp,
+				&jucn->referral_list,
+				&jucn->referral_count);
 
 	if (!NT_STATUS_EQUAL(status, NT_STATUS_PATH_NOT_COVERED)) {
 		DEBUG(3,("get_referred_path: No valid referrals for path %s\n",
@@ -1170,16 +1143,6 @@ NTSTATUS get_referred_path(TALLOC_CTX *ctx,
 		goto err_exit;
 	}
 
-	/* We know this is a valid dfs link. Parse the targetpath. */
-	if (!parse_msdfs_symlink(ctx, snum, targetpath,
-				&jucn->referral_list,
-				&jucn->referral_count)) {
-		DEBUG(3,("get_referred_path: failed to parse symlink "
-			"target %s\n", targetpath ));
-		status = NT_STATUS_NOT_FOUND;
-		goto err_exit;
-	}
-
 	status = NT_STATUS_OK;
  err_exit:
 	TALLOC_FREE(frame);
@@ -1264,6 +1227,8 @@ bool create_junction(TALLOC_CTX *ctx,
 		bool allow_broken_path,
 		struct junction_map *jucn)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int snum;
 	bool dummy;
 	struct dfs_path *pdp = talloc(ctx,struct dfs_path);
@@ -1299,7 +1264,7 @@ bool create_junction(TALLOC_CTX *ctx,
 
 	jucn->service_name = talloc_strdup(ctx, pdp->servicename);
 	jucn->volume_name = talloc_strdup(ctx, pdp->reqpath);
-	jucn->comment = lp_comment(ctx, snum);
+	jucn->comment = lp_comment(ctx, lp_sub, snum);
 
 	TALLOC_FREE(pdp);
 	if (!jucn->service_name || !jucn->volume_name || ! jucn->comment) {
@@ -1313,9 +1278,12 @@ bool create_junction(TALLOC_CTX *ctx,
  **********************************************************************/
 
 static bool junction_to_local_path_tos(const struct junction_map *jucn,
+				       struct auth_session_info *session_info,
 				       char **pp_path_out,
 				       connection_struct **conn_out)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct conn_struct_tos *c = NULL;
 	int snum;
 	char *path_out = NULL;
@@ -1327,8 +1295,8 @@ static bool junction_to_local_path_tos(const struct junction_map *jucn,
 	}
 	status = create_conn_struct_tos_cwd(global_messaging_context(),
 					    snum,
-					    lp_path(talloc_tos(), snum),
-					    NULL,
+					    lp_path(talloc_tos(), lp_sub, snum),
+					    session_info,
 					    &c);
 	if (!NT_STATUS_IS_OK(status)) {
 		return False;
@@ -1336,7 +1304,7 @@ static bool junction_to_local_path_tos(const struct junction_map *jucn,
 
 	path_out = talloc_asprintf(c,
 			"%s/%s",
-			lp_path(talloc_tos(), snum),
+			lp_path(talloc_tos(), lp_sub, snum),
 			jucn->volume_name);
 	if (path_out == NULL) {
 		TALLOC_FREE(c);
@@ -1347,38 +1315,38 @@ static bool junction_to_local_path_tos(const struct junction_map *jucn,
 	return True;
 }
 
-bool create_msdfs_link(const struct junction_map *jucn)
+/*
+ * Create a msdfs string in Samba format we can store
+ * in a filesystem object (currently a symlink).
+ */
+
+char *msdfs_link_string(TALLOC_CTX *ctx,
+			const struct referral *reflist,
+			size_t referral_count)
 {
-	TALLOC_CTX *frame = talloc_stackframe();
-	char *path = NULL;
+	char *refpath = NULL;
+	bool insert_comma = false;
 	char *msdfs_link = NULL;
-	connection_struct *conn;
-	int i=0;
-	bool insert_comma = False;
-	bool ret = False;
-	struct smb_filename *smb_fname = NULL;
-	bool ok;
-	int retval;
-
-	ok = junction_to_local_path_tos(jucn, &path, &conn);
-	if (!ok) {
-		TALLOC_FREE(frame);
-		return False;
-	}
+	size_t i;
 
 	/* Form the msdfs_link contents */
-	msdfs_link = talloc_strdup(conn, "msdfs:");
-	if (!msdfs_link) {
-		goto out;
+	msdfs_link = talloc_strdup(ctx, "msdfs:");
+	if (msdfs_link == NULL) {
+		goto err;
 	}
-	for(i=0; i<jucn->referral_count; i++) {
-		char *refpath = jucn->referral_list[i].alternate_path;
+
+	for( i= 0; i < referral_count; i++) {
+		refpath = talloc_strdup(ctx, reflist[i].alternate_path);
+
+		if (refpath == NULL) {
+			goto err;
+		}
 
 		/* Alternate paths always use Windows separators. */
 		trim_char(refpath, '\\', '\\');
-		if(*refpath == '\0') {
+		if (*refpath == '\0') {
 			if (i == 0) {
-				insert_comma = False;
+				insert_comma = false;
 			}
 			continue;
 		}
@@ -1392,16 +1360,51 @@ bool create_msdfs_link(const struct junction_map *jucn)
 					refpath);
 		}
 
-		if (!msdfs_link) {
-			goto out;
+		if (msdfs_link == NULL) {
+			goto err;
 		}
+
 		if (!insert_comma) {
-			insert_comma = True;
+			insert_comma = true;
 		}
+
+		TALLOC_FREE(refpath);
 	}
 
-	DEBUG(5,("create_msdfs_link: Creating new msdfs link: %s -> %s\n",
-		path, msdfs_link));
+	return msdfs_link;
+
+  err:
+
+	TALLOC_FREE(refpath);
+	TALLOC_FREE(msdfs_link);
+	return NULL;
+}
+
+bool create_msdfs_link(const struct junction_map *jucn,
+		       struct auth_session_info *session_info)
+{
+	TALLOC_CTX *frame = talloc_stackframe();
+	char *path = NULL;
+	connection_struct *conn;
+	struct smb_filename *smb_fname = NULL;
+	bool ok;
+	NTSTATUS status;
+	bool ret = false;
+
+	ok = junction_to_local_path_tos(jucn, session_info, &path, &conn);
+	if (!ok) {
+		goto out;
+	}
+
+	if (!CAN_WRITE(conn)) {
+		const struct loadparm_substitution *lp_sub =
+			loadparm_s3_global_substitution();
+		int snum = lp_servicenumber(jucn->service_name);
+
+		DBG_WARNING("Can't create DFS entry on read-only share %s\n",
+			lp_servicename(frame, lp_sub, snum));
+		goto out;
+	}
 
 	smb_fname = synthetic_smb_fname(frame,
 				path,
@@ -1409,45 +1412,47 @@ bool create_msdfs_link(const struct junction_map *jucn)
 				NULL,
 				0);
 	if (smb_fname == NULL) {
-		errno = ENOMEM;
 		goto out;
 	}
 
-	retval = SMB_VFS_SYMLINKAT(conn,
-			msdfs_link,
-			conn->cwd_fsp,
-			smb_fname);
-	if (retval < 0) {
-		if (errno == EEXIST) {
-			retval = SMB_VFS_UNLINKAT(conn,
+	status = SMB_VFS_CREATE_DFS_PATHAT(conn,
+				conn->cwd_fsp,
+				smb_fname,
+				jucn->referral_list,
+				jucn->referral_count);
+	if (!NT_STATUS_IS_OK(status)) {
+		if (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_COLLISION)) {
+			int retval = SMB_VFS_UNLINKAT(conn,
 						conn->cwd_fsp,
 						smb_fname,
 						0);
 			if (retval != 0) {
-				TALLOC_FREE(smb_fname);
 				goto out;
 			}
 		}
-		retval = SMB_VFS_SYMLINKAT(conn,
-				msdfs_link,
+		status = SMB_VFS_CREATE_DFS_PATHAT(conn,
 				conn->cwd_fsp,
-				smb_fname);
-		if (retval < 0) {
-			DEBUG(1,("create_msdfs_link: symlinkat failed "
-				 "%s -> %s\nError: %s\n",
-				 path, msdfs_link, strerror(errno)));
+				smb_fname,
+				jucn->referral_list,
+				jucn->referral_count);
+		if (!NT_STATUS_IS_OK(status)) {
+			DBG_WARNING("SMB_VFS_CREATE_DFS_PATHAT failed "
+				"%s - Error: %s\n",
+				path,
+				nt_errstr(status));
 			goto out;
 		}
 	}
 
-	ret = True;
+	ret = true;
 
 out:
 	TALLOC_FREE(frame);
 	return ret;
 }
 
-bool remove_msdfs_link(const struct junction_map *jucn)
+bool remove_msdfs_link(const struct junction_map *jucn,
+		       struct auth_session_info *session_info)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
 	char *path = NULL;
@@ -1457,12 +1462,23 @@ bool remove_msdfs_link(const struct junction_map *jucn)
 	bool ok;
 	int retval;
 
-	ok = junction_to_local_path_tos(jucn, &path, &conn);
+	ok = junction_to_local_path_tos(jucn, session_info, &path, &conn);
 	if (!ok) {
 		TALLOC_FREE(frame);
 		return false;
 	}
 
+	if (!CAN_WRITE(conn)) {
+		const struct loadparm_substitution *lp_sub =
+			loadparm_s3_global_substitution();
+		int snum = lp_servicenumber(jucn->service_name);
+
+		DBG_WARNING("Can't remove DFS entry on read-only share %s\n",
+			lp_servicename(frame, lp_sub, snum));
+		TALLOC_FREE(frame);
+		return false;
+	}
+
 	smb_fname = synthetic_smb_fname(frame,
 					path,
 					NULL,
@@ -1490,15 +1506,19 @@ bool remove_msdfs_link(const struct junction_map *jucn)
  Return the number of DFS links at the root of this share.
 *********************************************************************/
 
-static int count_dfs_links(TALLOC_CTX *ctx, int snum)
+static size_t count_dfs_links(TALLOC_CTX *ctx,
+			      struct auth_session_info *session_info,
+			      int snum)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	size_t cnt = 0;
 	DIR *dirp = NULL;
 	const char *dname = NULL;
 	char *talloced = NULL;
-	const char *connect_path = lp_path(frame, snum);
-	const char *msdfs_proxy = lp_msdfs_proxy(frame, snum);
+	const char *connect_path = lp_path(frame, lp_sub, snum);
+	const char *msdfs_proxy = lp_msdfs_proxy(frame, lp_sub, snum);
 	struct conn_struct_tos *c = NULL;
 	connection_struct *conn = NULL;
 	NTSTATUS status;
@@ -1516,7 +1536,7 @@ static int count_dfs_links(TALLOC_CTX *ctx, int snum)
 	status = create_conn_struct_tos_cwd(global_messaging_context(),
 					    snum,
 					    connect_path,
-					    NULL,
+					    session_info,
 					    &c);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(3, ("create_conn_struct failed: %s\n",
@@ -1561,6 +1581,10 @@ static int count_dfs_links(TALLOC_CTX *ctx, int snum)
 			goto out;
 		}
 		if (is_msdfs_link(conn, smb_dname)) {
+			if (cnt + 1 < cnt) {
+				cnt = 0;
+				goto out;
+			}
 			cnt++;
 		}
 		TALLOC_FREE(talloced);
@@ -1578,18 +1602,21 @@ out:
 *********************************************************************/
 
 static int form_junctions(TALLOC_CTX *ctx,
+			  struct auth_session_info *session_info,
 				int snum,
 				struct junction_map *jucn,
 				size_t jn_remain)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	size_t cnt = 0;
 	DIR *dirp = NULL;
 	const char *dname = NULL;
 	char *talloced = NULL;
-	const char *connect_path = lp_path(frame, snum);
-	char *service_name = lp_servicename(frame, snum);
-	const char *msdfs_proxy = lp_msdfs_proxy(frame, snum);
+	const char *connect_path = lp_path(frame, lp_sub, snum);
+	char *service_name = lp_servicename(frame, lp_sub, snum);
+	const char *msdfs_proxy = lp_msdfs_proxy(frame, lp_sub, snum);
 	struct conn_struct_tos *c = NULL;
 	connection_struct *conn = NULL;
 	struct referral *ref = NULL;
@@ -1613,7 +1640,7 @@ static int form_junctions(TALLOC_CTX *ctx,
 	status = create_conn_struct_tos_cwd(global_messaging_context(),
 					    snum,
 					    connect_path,
-					    NULL,
+					    session_info,
 					    &c);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(3, ("create_conn_struct failed: %s\n",
@@ -1679,7 +1706,6 @@ static int form_junctions(TALLOC_CTX *ctx,
 
 	while ((dname = vfs_readdirname(conn, dirp, NULL, &talloced))
 	       != NULL) {
-		char *link_target = NULL;
 		struct smb_filename *smb_dname = NULL;
 
 		if (cnt >= jn_remain) {
@@ -1697,27 +1723,24 @@ static int form_junctions(TALLOC_CTX *ctx,
 			TALLOC_FREE(talloced);
 			goto out;
 		}
-		if (is_msdfs_link_internal(ctx,
-					conn,
-					smb_dname, &link_target)) {
-			if (parse_msdfs_symlink(ctx, snum,
-					link_target,
-					&jucn[cnt].referral_list,
-					&jucn[cnt].referral_count)) {
-
-				jucn[cnt].service_name = talloc_strdup(ctx,
-								service_name);
-				jucn[cnt].volume_name = talloc_strdup(ctx,
-								dname);
-				if (!jucn[cnt].service_name ||
-						!jucn[cnt].volume_name) {
-					TALLOC_FREE(talloced);
-					goto out;
-				}
-				jucn[cnt].comment = "";
-				cnt++;
+
+		status = SMB_VFS_READ_DFS_PATHAT(conn,
+				ctx,
+				conn->cwd_fsp,
+				smb_dname,
+				&jucn[cnt].referral_list,
+				&jucn[cnt].referral_count);
+
+		if (NT_STATUS_IS_OK(status)) {
+			jucn[cnt].service_name = talloc_strdup(ctx,
+							service_name);
+			jucn[cnt].volume_name = talloc_strdup(ctx, dname);
+			if (!jucn[cnt].service_name || !jucn[cnt].volume_name) {
+				TALLOC_FREE(talloced);
+				goto out;
 			}
-			TALLOC_FREE(link_target);
+			jucn[cnt].comment = "";
+			cnt++;
 		}
 		TALLOC_FREE(talloced);
 		TALLOC_FREE(smb_dname);
@@ -1733,7 +1756,9 @@ out:
 	return cnt;
 }
 
-struct junction_map *enum_msdfs_links(TALLOC_CTX *ctx, size_t *p_num_jn)
+struct junction_map *enum_msdfs_links(TALLOC_CTX *ctx,
+				      struct auth_session_info *session_info,
+				      size_t *p_num_jn)
 {
 	struct junction_map *jn = NULL;
 	int i=0;
@@ -1753,7 +1778,7 @@ struct junction_map *enum_msdfs_links(TALLOC_CTX *ctx, size_t *p_num_jn)
 
 	for(i=0;i < sharecount;i++) {
 		if(lp_msdfs_root(i)) {
-			jn_count += count_dfs_links(ctx, i);
+			jn_count += count_dfs_links(ctx, session_info, i);
 		}
 	}
 	if (jn_count == 0) {
@@ -1768,7 +1793,9 @@ struct junction_map *enum_msdfs_links(TALLOC_CTX *ctx, size_t *p_num_jn)
 			break;
 		}
 		if(lp_msdfs_root(i)) {
-			*p_num_jn += form_junctions(ctx, i,
+			*p_num_jn += form_junctions(ctx,
+					session_info,
+					i,
 					&jn[*p_num_jn],
 					jn_count - *p_num_jn);
 		}
diff --git a/source3/smbd/negprot.c b/source3/smbd/negprot.c
index 2d5edf1282c..67ef60da852 100644
--- a/source3/smbd/negprot.c
+++ b/source3/smbd/negprot.c
@@ -66,7 +66,7 @@ static void get_challenge(struct smbXsrv_connection *xconn, uint8_t buff[8])
  Reply for the lanman 1.0 protocol.
 ****************************************************************************/
 
-static void reply_lanman1(struct smb_request *req, uint16_t choice)
+static NTSTATUS reply_lanman1(struct smb_request *req, uint16_t choice)
 {
 	int secword=0;
 	time_t t = time(NULL);
@@ -100,7 +100,7 @@ static void reply_lanman1(struct smb_request *req, uint16_t choice)
 	status = smbXsrv_connection_init_tables(xconn, PROTOCOL_LANMAN1);
 	if (!NT_STATUS_IS_OK(status)) {
 		reply_nterror(req, status);
-		return;
+		return status;
 	}
 
 	/* Reply, SMBlockread, SMBwritelock supported. */
@@ -115,14 +115,14 @@ static void reply_lanman1(struct smb_request *req, uint16_t choice)
 
 	srv_put_dos_date((char *)req->outbuf,smb_vwv8,t);
 
-	return;
+	return NT_STATUS_OK;
 }
 
 /****************************************************************************
  Reply for the lanman 2.0 protocol.
 ****************************************************************************/
 
-static void reply_lanman2(struct smb_request *req, uint16_t choice)
+static NTSTATUS reply_lanman2(struct smb_request *req, uint16_t choice)
 {
 	int secword=0;
 	time_t t = time(NULL);
@@ -158,7 +158,7 @@ static void reply_lanman2(struct smb_request *req, uint16_t choice)
 	status = smbXsrv_connection_init_tables(xconn, PROTOCOL_LANMAN2);
 	if (!NT_STATUS_IS_OK(status)) {
 		reply_nterror(req, status);
-		return;
+		return status;
 	}
 
 	/* Reply, SMBlockread, SMBwritelock supported. */
@@ -169,6 +169,7 @@ static void reply_lanman2(struct smb_request *req, uint16_t choice)
 	SSVAL(req->outbuf,smb_vwv5,raw); /* readbraw and/or writebraw */
 	SSVAL(req->outbuf,smb_vwv10, set_server_zone_offset(t)/60);
 	srv_put_dos_date((char *)req->outbuf,smb_vwv8,t);
+	return NT_STATUS_OK;
 }
 
 /****************************************************************************
@@ -266,7 +267,7 @@ DATA_BLOB negprot_spnego(TALLOC_CTX *ctx, struct smbXsrv_connection *xconn)
  Reply for the nt protocol.
 ****************************************************************************/
 
-static void reply_nt1(struct smb_request *req, uint16_t choice)
+static NTSTATUS reply_nt1(struct smb_request *req, uint16_t choice)
 {
 	/* dual names + lock_and_read + nt SMBs + remote API calls */
 	int capabilities = CAP_NT_FIND|CAP_LOCK_AND_READ|
@@ -359,7 +360,7 @@ static void reply_nt1(struct smb_request *req, uint16_t choice)
 	status = smbXsrv_connection_init_tables(xconn, PROTOCOL_NT1);
 	if (!NT_STATUS_IS_OK(status)) {
 		reply_nterror(req, status);
-		return;
+		return status;
 	}
 
 	SSVAL(req->outbuf,smb_vwv1+1, lp_max_mux()); /* maxmpx */
@@ -370,7 +371,7 @@ static void reply_nt1(struct smb_request *req, uint16_t choice)
 	SIVAL(req->outbuf,smb_vwv7+1, getpid()); /* session key */
 	SIVAL(req->outbuf,smb_vwv9+1, capabilities); /* capabilities */
 	clock_gettime(CLOCK_REALTIME,&ts);
-	put_long_date_timespec(TIMESTAMP_SET_NT_OR_BETTER,(char *)req->outbuf+smb_vwv11+1,ts);
+	put_long_date_full_timespec(TIMESTAMP_SET_NT_OR_BETTER,(char *)req->outbuf+smb_vwv11+1,&ts);
 	SSVALS(req->outbuf,smb_vwv15+1,set_server_zone_offset(ts.tv_sec)/60);
 
 	if (!negotiate_spnego) {
@@ -385,7 +386,7 @@ static void reply_nt1(struct smb_request *req, uint16_t choice)
 			if (ret == -1) {
 				DEBUG(0, ("Could not push challenge\n"));
 				reply_nterror(req, NT_STATUS_NO_MEMORY);
-				return;
+				return NT_STATUS_NO_MEMORY;
 			}
 			SCVAL(req->outbuf, smb_vwv16+1, ret);
 		}
@@ -395,7 +396,7 @@ static void reply_nt1(struct smb_request *req, uint16_t choice)
 		if (ret == -1) {
 			DEBUG(0, ("Could not push workgroup string\n"));
 			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			return;
+			return NT_STATUS_NO_MEMORY;
 		}
 		ret = message_push_string(&req->outbuf, lp_netbios_name(),
 					  STR_UNICODE|STR_TERMINATE
@@ -403,7 +404,7 @@ static void reply_nt1(struct smb_request *req, uint16_t choice)
 		if (ret == -1) {
 			DEBUG(0, ("Could not push netbios name string\n"));
 			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			return;
+			return NT_STATUS_NO_MEMORY;
 		}
 		DEBUG(3,("not using SPNEGO\n"));
 	} else {
@@ -411,14 +412,14 @@ static void reply_nt1(struct smb_request *req, uint16_t choice)
 
 		if (spnego_blob.data == NULL) {
 			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			return;
+			return NT_STATUS_NO_MEMORY;
 		}
 
 		ret = message_push_blob(&req->outbuf, spnego_blob);
 		if (ret == -1) {
 			DEBUG(0, ("Could not push spnego blob\n"));
 			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			return;
+			return NT_STATUS_NO_MEMORY;
 		}
 		data_blob_free(&spnego_blob);
 
@@ -426,7 +427,7 @@ static void reply_nt1(struct smb_request *req, uint16_t choice)
 		DEBUG(3,("using SPNEGO\n"));
 	}
 
-	return;
+	return NT_STATUS_OK;
 }
 
 /* these are the protocol lists used for auto architecture detection:
@@ -540,7 +541,7 @@ protocol [SMB 2.???]
 static const struct {
 	const char *proto_name;
 	const char *short_name;
-	void (*proto_reply_fn)(struct smb_request *req, uint16_t choice);
+	NTSTATUS (*proto_reply_fn)(struct smb_request *req, uint16_t choice);
 	int protocol_level;
 } supported_protocols[] = {
 	{"SMB 2.???",               "SMB2_FF",  reply_smb20ff,  PROTOCOL_SMB2_10},
@@ -579,6 +580,7 @@ void reply_negprot(struct smb_request *req)
 	bool signing_required = true;
 	int max_proto;
 	int min_proto;
+	NTSTATUS status;
 
 	START_PROFILE(SMBnegprot);
 
@@ -586,7 +588,6 @@ void reply_negprot(struct smb_request *req)
 		END_PROFILE(SMBnegprot);
 		exit_server_cleanly("multiple negprot's are not permitted");
 	}
-	xconn->smb1.negprot.done = true;
 
 	if (req->buflen == 0) {
 		DEBUG(0, ("negprot got no protocols\n"));
@@ -767,11 +768,17 @@ void reply_negprot(struct smb_request *req)
 
 	fstrcpy(remote_proto,supported_protocols[protocol].short_name);
 	reload_services(sconn, conn_snum_used, true);
-	supported_protocols[protocol].proto_reply_fn(req, choice);
+	status = supported_protocols[protocol].proto_reply_fn(req, choice);
+	if (!NT_STATUS_IS_OK(status)) {
+		exit_server_cleanly("negprot function failed\n");
+	}
+
 	DEBUG(3,("Selected protocol %s\n",supported_protocols[protocol].proto_name));
 
 	DBG_INFO("negprot index=%zu\n", choice);
 
+	xconn->smb1.negprot.done = true;
+
 	/* We always have xconn->smb1.signing_state also for >= SMB2_02 */
 	signing_required = smb_signing_is_mandatory(xconn->smb1.signing_state);
 	if (signing_required && (chosen_level < PROTOCOL_NT1)) {
diff --git a/source3/smbd/nttrans.c b/source3/smbd/nttrans.c
index a083f352261..d169a59a620 100644
--- a/source3/smbd/nttrans.c
+++ b/source3/smbd/nttrans.c
@@ -680,13 +680,13 @@ void reply_ntcreate_and_X(struct smb_request *req)
 		dos_filetime_timespec(&c_timespec);
 	}
 
-	put_long_date_timespec(conn->ts_res, p, create_timespec); /* create time. */
+	put_long_date_full_timespec(conn->ts_res, p, &create_timespec); /* create time. */
 	p += 8;
-	put_long_date_timespec(conn->ts_res, p, a_timespec); /* access time */
+	put_long_date_full_timespec(conn->ts_res, p, &a_timespec); /* access time */
 	p += 8;
-	put_long_date_timespec(conn->ts_res, p, m_timespec); /* write time */
+	put_long_date_full_timespec(conn->ts_res, p, &m_timespec); /* write time */
 	p += 8;
-	put_long_date_timespec(conn->ts_res, p, c_timespec); /* change time */
+	put_long_date_full_timespec(conn->ts_res, p, &c_timespec); /* change time */
 	p += 8;
 	SIVAL(p,0,fattr); /* File Attributes. */
 	p += 4;
@@ -1335,13 +1335,13 @@ static void call_nt_transact_create(connection_struct *conn,
 		dos_filetime_timespec(&c_timespec);
 	}
 
-	put_long_date_timespec(conn->ts_res, p, create_timespec); /* create time. */
+	put_long_date_full_timespec(conn->ts_res, p, &create_timespec); /* create time. */
 	p += 8;
-	put_long_date_timespec(conn->ts_res, p, a_timespec); /* access time */
+	put_long_date_full_timespec(conn->ts_res, p, &a_timespec); /* access time */
 	p += 8;
-	put_long_date_timespec(conn->ts_res, p, m_timespec); /* write time */
+	put_long_date_full_timespec(conn->ts_res, p, &m_timespec); /* write time */
 	p += 8;
-	put_long_date_timespec(conn->ts_res, p, c_timespec); /* change time */
+	put_long_date_full_timespec(conn->ts_res, p, &c_timespec); /* change time */
 	p += 8;
 	SIVAL(p,0,fattr); /* File Attributes. */
 	p += 4;
@@ -2603,6 +2603,8 @@ static void call_nt_transact_get_user_quota(connection_struct *conn,
 					    uint32_t data_count,
 					    uint32_t max_data_count)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	NTSTATUS nt_status = NT_STATUS_OK;
 	char *params = *ppparams;
 	char *pdata = *ppdata;
@@ -2625,7 +2627,7 @@ static void call_nt_transact_get_user_quota(connection_struct *conn,
 	/* access check */
 	if (get_current_uid(conn) != sec_initial_uid()) {
 		DEBUG(1,("get_user_quota: access_denied service [%s] user "
-			 "[%s]\n", lp_servicename(talloc_tos(), SNUM(conn)),
+			 "[%s]\n", lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 			 conn->session_info->unix_info->unix_name));
 		nt_status = NT_STATUS_ACCESS_DENIED;
 		goto error;
@@ -2733,6 +2735,8 @@ static void call_nt_transact_set_user_quota(connection_struct *conn,
 					    uint32_t data_count,
 					    uint32_t max_data_count)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *params = *ppparams;
 	char *pdata = *ppdata;
 	int data_len=0,param_len=0;
@@ -2749,7 +2753,7 @@ static void call_nt_transact_set_user_quota(connection_struct *conn,
 	/* access check */
 	if (get_current_uid(conn) != sec_initial_uid()) {
 		DEBUG(1,("set_user_quota: access_denied service [%s] user "
-			 "[%s]\n", lp_servicename(talloc_tos(), SNUM(conn)),
+			 "[%s]\n", lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 			 conn->session_info->unix_info->unix_name));
 		status = NT_STATUS_ACCESS_DENIED;
 		goto error;
diff --git a/source3/smbd/open.c b/source3/smbd/open.c
index fa990cacd5e..98770358cf1 100644
--- a/source3/smbd/open.c
+++ b/source3/smbd/open.c
@@ -1811,7 +1811,7 @@ static NTSTATUS open_mode_check(connection_struct *conn,
 	struct share_mode_data *d = lck->data;
 	struct open_mode_check_state state;
 	uint16_t new_flags;
-	bool ok, conflict;
+	bool ok, conflict, have_share_entries;
 
 	if (is_stat_open(access_mask)) {
 		/* Stat open that doesn't trigger oplock breaks or share mode
@@ -1836,7 +1836,12 @@ static NTSTATUS open_mode_check(connection_struct *conn,
 	}
 #endif
 
-	if (d->num_share_modes == 0) {
+	have_share_entries = share_mode_have_entries(lck);
+	if (!have_share_entries) {
+		/*
+		 * This is a fresh share mode lock where no conflicts
+		 * can happen.
+		 */
 		return NT_STATUS_OK;
 	}
 
@@ -2575,8 +2580,10 @@ grant:
 		}
 	}
 
-	if (granted & SMB2_LEASE_READ) {
+	if ((granted & SMB2_LEASE_READ) &&
+	    ((lck->data->flags & SHARE_MODE_LEASE_READ) == 0)) {
 		lck->data->flags |= SHARE_MODE_LEASE_READ;
+		lck->data->modified = true;
 	}
 
 	DBG_DEBUG("oplock type 0x%x on file %s\n",
@@ -2666,7 +2673,6 @@ static void defer_open_done(struct tevent_req *req);
 static void defer_open(struct share_mode_lock *lck,
 		       struct timeval timeout,
 		       struct smb_request *req,
-		       bool delayed_for_oplocks,
 		       struct file_id id)
 {
 	struct deferred_open_record *open_rec = NULL;
@@ -2680,11 +2686,10 @@ static void defer_open(struct share_mode_lock *lck,
 	abs_timeout = timeval_sum(&req->request_time, &timeout);
 
 	DBG_DEBUG("request time [%s] timeout [%s] mid [%" PRIu64 "] "
-		  "delayed_for_oplocks [%s] file_id [%s]\n",
+		  "file_id [%s]\n",
 		  timeval_str_buf(&req->request_time, false, true, &tvbuf1),
 		  timeval_str_buf(&abs_timeout, false, true, &tvbuf2),
 		  req->mid,
-		  delayed_for_oplocks ? "yes" : "no",
 		  file_id_str_buf(id, &fbuf));
 
 	open_rec = talloc_zero(NULL, struct deferred_open_record);
@@ -2702,10 +2707,11 @@ static void defer_open(struct share_mode_lock *lck,
 
 	DBG_DEBUG("defering mid %" PRIu64 "\n", req->mid);
 
-	watch_req = dbwrap_watched_watch_send(watch_state,
-					      req->sconn->ev_ctx,
-					      lck->data->record,
-					      (struct server_id){0});
+	watch_req = share_mode_watch_send(
+		watch_state,
+		req->sconn->ev_ctx,
+		lck->data->id,
+		(struct server_id){0});
 	if (watch_req == NULL) {
 		exit_server("Could not watch share mode record");
 	}
@@ -2730,7 +2736,7 @@ static void defer_open_done(struct tevent_req *req)
 	NTSTATUS status;
 	bool ret;
 
-	status = dbwrap_watched_watch_recv(req, NULL, NULL);
+	status = share_mode_watch_recv(req, NULL, NULL);
 	TALLOC_FREE(req);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(5, ("dbwrap_watched_watch_recv returned %s\n",
@@ -2822,13 +2828,13 @@ static bool setup_poll_open(
 	}
 
 	if (lck != NULL) {
-		open_rec->watch_req = dbwrap_watched_watch_send(
+		open_rec->watch_req = share_mode_watch_send(
 			open_rec,
 			req->sconn->ev_ctx,
-			lck->data->record,
+			lck->data->id,
 			(struct server_id) {0});
 		if (open_rec->watch_req == NULL) {
-			DBG_WARNING("dbwrap_watched_watch_send failed\n");
+			DBG_WARNING("share_mode_watch_send failed\n");
 			TALLOC_FREE(open_rec);
 			return false;
 		}
@@ -2858,7 +2864,7 @@ static void poll_open_done(struct tevent_req *subreq)
 	NTSTATUS status;
 	bool ok;
 
-	status = dbwrap_watched_watch_recv(subreq, NULL, NULL);
+	status = share_mode_watch_recv(subreq, NULL, NULL);
 	TALLOC_FREE(subreq);
 	DBG_DEBUG("dbwrap_watched_watch_recv returned %s\n",
 		  nt_errstr(status));
@@ -2972,7 +2978,7 @@ static void schedule_defer_open(struct share_mode_lock *lck,
 		return;
 	}
 
-	defer_open(lck, timeout, req, true, id);
+	defer_open(lck, timeout, req, id);
 }
 
 /****************************************************************************
@@ -3295,6 +3301,7 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 	SMB_STRUCT_STAT saved_stat = smb_fname->st;
 	struct timespec old_write_time;
 	struct file_id id;
+	bool setup_poll = false;
 	bool ok;
 
 	if (conn->printer) {
@@ -3590,7 +3597,15 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
-	fsp->file_id = vfs_file_id_from_sbuf(conn, &smb_fname->st);
+	if (VALID_STAT(smb_fname->st)) {
+		/*
+		 * Only try and create a file id before open
+		 * for an existing file. For a file being created
+		 * this won't do anything useful until the file
+		 * exists and has a valid stat struct.
+		 */
+		fsp->file_id = vfs_file_id_from_sbuf(conn, &smb_fname->st);
+	}
 	fsp->fh->private_options = private_flags;
 	fsp->access_mask = open_access_mask; /* We change this to the
 					      * requested access_mask after
@@ -3631,6 +3646,14 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 			     open_access_mask, &new_file_created);
 
 	if (NT_STATUS_EQUAL(fsp_open, NT_STATUS_NETWORK_BUSY)) {
+		if (file_existed && S_ISFIFO(fsp->fsp_name->st.st_ex_mode)) {
+			DEBUG(10, ("FIFO busy\n"));
+			return NT_STATUS_NETWORK_BUSY;
+		}
+		if (req == NULL) {
+			DEBUG(10, ("Internal open busy\n"));
+			return NT_STATUS_NETWORK_BUSY;
+		}
 		/*
 		 * This handles the kernel oplock case:
 		 *
@@ -3640,15 +3663,20 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 		 * "Samba locking.tdb oplocks" are handled below after acquiring
 		 * the sharemode lock with get_share_mode_lock().
 		 */
-		if (file_existed && S_ISFIFO(fsp->fsp_name->st.st_ex_mode)) {
-			DEBUG(10, ("FIFO busy\n"));
-			return NT_STATUS_NETWORK_BUSY;
-		}
-		if (req == NULL) {
-			DEBUG(10, ("Internal open busy\n"));
-			return NT_STATUS_NETWORK_BUSY;
-		}
+		setup_poll = true;
+	}
+
+	if (NT_STATUS_EQUAL(fsp_open, NT_STATUS_RETRY)) {
+		/*
+		 * EINTR from the open(2) syscall. Just setup a retry
+		 * in a bit. We can't use the sys_write() tight retry
+		 * loop here, as we might have to actually deal with
+		 * lease-break signals to avoid a deadlock.
+		 */
+		setup_poll = true;
+	}
 
+	if (setup_poll) {
 		/*
 		 * From here on we assume this is an oplock break triggered
 		 */
@@ -3679,7 +3707,9 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 	}
 
 	if (!NT_STATUS_IS_OK(fsp_open)) {
-		if (NT_STATUS_EQUAL(fsp_open, NT_STATUS_RETRY)) {
+		bool wait_for_aio = NT_STATUS_EQUAL(
+			fsp_open, NT_STATUS_MORE_PROCESSING_REQUIRED);
+		if (wait_for_aio) {
 			schedule_async_open(req);
 		}
 		return fsp_open;
@@ -4034,7 +4064,7 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 		 */
 		struct timespec write_time = get_share_mode_write_time(lck);
 
-		if (!null_timespec(write_time)) {
+		if (!is_omit_timespec(&write_time)) {
 			update_stat_ex_mtime(&fsp->fsp_name->st, write_time);
 		}
 	}
@@ -4048,6 +4078,8 @@ static NTSTATUS mkdir_internal(connection_struct *conn,
 			       struct smb_filename *smb_dname,
 			       uint32_t file_attributes)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	mode_t mode;
 	char *parent_dir = NULL;
 	NTSTATUS status;
@@ -4058,7 +4090,7 @@ static NTSTATUS mkdir_internal(connection_struct *conn,
 
 	if (!CAN_WRITE(conn) || (access_mask & ~(conn->share_access))) {
 		DEBUG(5,("mkdir_internal: failing share access "
-			 "%s\n", lp_servicename(talloc_tos(), SNUM(conn))));
+			 "%s\n", lp_servicename(talloc_tos(), lp_sub, SNUM(conn))));
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
@@ -4187,7 +4219,7 @@ static NTSTATUS open_directory(connection_struct *conn,
 			       files_struct **result)
 {
 	files_struct *fsp = NULL;
-	bool dir_existed = VALID_STAT(smb_dname->st) ? True : False;
+	bool dir_existed = VALID_STAT(smb_dname->st);
 	struct share_mode_lock *lck = NULL;
 	NTSTATUS status;
 	struct timespec mtimespec;
@@ -4205,15 +4237,16 @@ static NTSTATUS open_directory(connection_struct *conn,
 		file_attributes |= FILE_ATTRIBUTE_DIRECTORY;
 	}
 
-	DEBUG(5,("open_directory: opening directory %s, access_mask = 0x%x, "
-		 "share_access = 0x%x create_options = 0x%x, "
-		 "create_disposition = 0x%x, file_attributes = 0x%x\n",
+	DBG_INFO("opening directory %s, access_mask = 0x%"PRIx32", "
+		 "share_access = 0x%"PRIx32" create_options = 0x%"PRIx32", "
+		 "create_disposition = 0x%"PRIx32", "
+		 "file_attributes = 0x%"PRIx32"\n",
 		 smb_fname_str_dbg(smb_dname),
-		 (unsigned int)access_mask,
-		 (unsigned int)share_access,
-		 (unsigned int)create_options,
-		 (unsigned int)create_disposition,
-		 (unsigned int)file_attributes));
+		 access_mask,
+		 share_access,
+		 create_options,
+		 create_disposition,
+		 file_attributes);
 
 	status = smbd_calculate_access_mask(conn, smb_dname, false,
 					    access_mask, &access_mask);
@@ -4391,11 +4424,11 @@ static NTSTATUS open_directory(connection_struct *conn,
 	/* Don't store old timestamps for directory
 	   handles in the internal database. We don't
 	   update them in there if new objects
-	   are creaded in the directory. Currently
+	   are created in the directory. Currently
 	   we only update timestamps on file writes.
 	   See bug #9870.
 	*/
-	ZERO_STRUCT(mtimespec);
+	mtimespec = make_omit_timespec();
 
 #ifdef O_DIRECTORY
 	status = fd_open(conn, fsp, O_RDONLY|O_DIRECTORY, 0);
@@ -4520,7 +4553,7 @@ static NTSTATUS open_directory(connection_struct *conn,
 		 */
 		struct timespec write_time = get_share_mode_write_time(lck);
 
-		if (!null_timespec(write_time)) {
+		if (!is_omit_timespec(&write_time)) {
 			update_stat_ex_mtime(&fsp->fsp_name->st, write_time);
 		}
 	}
diff --git a/source3/smbd/oplock.c b/source3/smbd/oplock.c
index 6a3b1f77688..2c4449b10b2 100644
--- a/source3/smbd/oplock.c
+++ b/source3/smbd/oplock.c
@@ -653,13 +653,7 @@ NTSTATUS downgrade_lease(struct smbXsrv_connection *xconn,
 		  lease_state,
 		  nt_errstr(status));
 
-	/*
-	 * No, we did not modify the share mode array. We did modify
-	 * the leases_db. But without this we don't notify a lease
-	 * break waiter via dbwrap_watch_record. We need to make
-	 * leases_db watched too.
-	 */
-	lck->data->modified = true;
+	share_mode_wakeup_waiters(id);
 
 	fsps_lease_update(sconn, &id, key);
 
diff --git a/source3/smbd/password.c b/source3/smbd/password.c
index 0576d2563eb..9709a51a109 100644
--- a/source3/smbd/password.c
+++ b/source3/smbd/password.c
@@ -26,89 +26,34 @@
 #include "auth.h"
 #include "../libcli/security/security.h"
 
-enum server_allocated_state { SERVER_ALLOCATED_REQUIRED_YES,
-				SERVER_ALLOCATED_REQUIRED_NO,
-				SERVER_ALLOCATED_REQUIRED_ANY};
-
-static struct user_struct *get_valid_user_struct_internal(
-			struct smbd_server_connection *sconn,
-			uint64_t vuid,
-			enum server_allocated_state server_allocated)
-{
-	struct user_struct *usp;
-	int count=0;
-
-	if (vuid == UID_FIELD_INVALID)
-		return NULL;
-
-	usp=sconn->users;
-	for (;usp;usp=usp->next,count++) {
-		if (vuid == usp->vuid) {
-			switch (server_allocated) {
-				case SERVER_ALLOCATED_REQUIRED_YES:
-					if (usp->session_info == NULL) {
-						continue;
-					}
-					break;
-				case SERVER_ALLOCATED_REQUIRED_NO:
-					if (usp->session_info != NULL) {
-						continue;
-					}
-				case SERVER_ALLOCATED_REQUIRED_ANY:
-					break;
-			}
-			if (count > 10) {
-				DLIST_PROMOTE(sconn->users, usp);
-			}
-			return usp;
-		}
-	}
-
-	return NULL;
-}
-
-/****************************************************************************
- Check if a uid has been validated, and return an pointer to the user_struct
- if it has. NULL if not. vuid is biased by an offset. This allows us to
- tell random client vuid's (normally zero) from valid vuids.
-****************************************************************************/
-
-struct user_struct *get_valid_user_struct(struct smbd_server_connection *sconn,
-					  uint64_t vuid)
-{
-	return get_valid_user_struct_internal(sconn, vuid,
-			SERVER_ALLOCATED_REQUIRED_YES);
-}
-
 /****************************************************************************
  Invalidate a uid.
 ****************************************************************************/
 
 void invalidate_vuid(struct smbd_server_connection *sconn, uint64_t vuid)
 {
-	struct user_struct *vuser = NULL;
+	struct smbXsrv_session *session = NULL;
+	NTSTATUS status;
 
-	vuser = get_valid_user_struct_internal(sconn, vuid,
-			SERVER_ALLOCATED_REQUIRED_ANY);
-	if (vuser == NULL) {
+	status = get_valid_smbXsrv_session(sconn->client, vuid, &session);
+	if (!NT_STATUS_IS_OK(status)) {
 		return;
 	}
 
-	session_yield(vuser->session);
+	session_yield(session);
 
-	DLIST_REMOVE(sconn->users, vuser);
 	SMB_ASSERT(sconn->num_users > 0);
 	sconn->num_users--;
 
 	/* clear the vuid from the 'cache' on each connection, and
 	   from the vuid 'owner' of connections */
 	conn_clear_vuid_caches(sconn, vuid);
-
-	TALLOC_FREE(vuser);
 }
 
 int register_homes_share(const char *username)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int result;
 	struct passwd *pwd;
 
@@ -116,7 +61,7 @@ int register_homes_share(const char *username)
 	if (result != -1) {
 		DEBUG(3, ("Using static (or previously created) service for "
 			  "user '%s'; path = '%s'\n", username,
-			  lp_path(talloc_tos(), result)));
+			  lp_path(talloc_tos(), lp_sub, result)));
 		return result;
 	}
 
diff --git a/source3/smbd/perfcount.c b/source3/smbd/perfcount.c
index 1555ea24b64..c46cd3ebe83 100644
--- a/source3/smbd/perfcount.c
+++ b/source3/smbd/perfcount.c
@@ -174,9 +174,11 @@ void smb_init_perfcount_data(struct smb_perfcount_data *pcd)
 
 bool smb_perfcount_init(void)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *perfcount_object;
 
-	perfcount_object = lp_perfcount_module(talloc_tos());
+	perfcount_object = lp_perfcount_module(talloc_tos(), lp_sub);
 
 	/* don't init */
 	if (!perfcount_object || !perfcount_object[0])
diff --git a/source3/smbd/posix_acls.c b/source3/smbd/posix_acls.c
index 23aa5b575a0..56c481fae79 100644
--- a/source3/smbd/posix_acls.c
+++ b/source3/smbd/posix_acls.c
@@ -4639,7 +4639,9 @@ NTSTATUS set_unix_posix_acl(connection_struct *conn,
 
 ********************************************************************/
 
-NTSTATUS get_nt_acl_no_snum(TALLOC_CTX *ctx, const char *fname,
+NTSTATUS get_nt_acl_no_snum(TALLOC_CTX *ctx,
+			    struct auth_session_info *session_info,
+			    const char *fname,
 				uint32_t security_info_wanted,
 				struct security_descriptor **sd)
 {
@@ -4665,7 +4667,7 @@ NTSTATUS get_nt_acl_no_snum(TALLOC_CTX *ctx, const char *fname,
 	status = create_conn_struct_tos(global_messaging_context(),
 					-1,
 					"/",
-					NULL,
+					session_info,
 					&c);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0,("create_conn_struct returned %s.\n",
diff --git a/source3/smbd/process.c b/source3/smbd/process.c
index 0e0d45d2af1..70398b4967e 100644
--- a/source3/smbd/process.c
+++ b/source3/smbd/process.c
@@ -1503,6 +1503,8 @@ static void smb1srv_update_crypto_flags(struct smbXsrv_session *session,
 
 static connection_struct *switch_message(uint8_t type, struct smb_request *req)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int flags;
 	uint64_t session_tag;
 	connection_struct *conn = NULL;
@@ -1585,9 +1587,10 @@ static connection_struct *switch_message(uint8_t type, struct smb_request *req)
 		}
 	}
 
-	if (session != NULL && !(flags & AS_USER)) {
-		struct user_struct *vuser = session->compat;
-
+	if (session != NULL &&
+	    session->global->auth_session_info != NULL &&
+	    !(flags & AS_USER))
+	{
 		/*
 		 * change_to_user() implies set_current_user_info()
 		 * and chdir_connect_service().
@@ -1595,12 +1598,10 @@ static connection_struct *switch_message(uint8_t type, struct smb_request *req)
 		 * So we only call set_current_user_info if
 		 * we don't have AS_USER specified.
 		 */
-		if (vuser) {
-			set_current_user_info(
-				vuser->session_info->unix_info->sanitized_username,
-				vuser->session_info->unix_info->unix_name,
-				vuser->session_info->info->domain_name);
-		}
+		set_current_user_info(
+			session->global->auth_session_info->unix_info->sanitized_username,
+			session->global->auth_session_info->unix_info->unix_name,
+			session->global->auth_session_info->info->domain_name);
 	}
 
 	/* Does this call need to be run as the connected user? */
@@ -1671,7 +1672,7 @@ static connection_struct *switch_message(uint8_t type, struct smb_request *req)
 			if (req->cmd != SMBtrans2 && req->cmd != SMBtranss2) {
 				DEBUG(1,("service[%s] requires encryption"
 					"%s ACCESS_DENIED. mid=%llu\n",
-					lp_servicename(talloc_tos(), SNUM(conn)),
+					lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 					smb_fn_name(type),
 					(unsigned long long)req->mid));
 				reply_nterror(req, NT_STATUS_ACCESS_DENIED);
@@ -1699,6 +1700,8 @@ static connection_struct *switch_message(uint8_t type, struct smb_request *req)
 		bool update_session_global = false;
 		bool update_tcon_global = false;
 
+		req->session = session;
+
 		smb1srv_update_crypto_flags(session, req, type,
 					    &update_session_global,
 					    &update_tcon_global);
@@ -1968,7 +1971,14 @@ static void process_smb(struct smbXsrv_connection *xconn,
 		if (smbd_is_smb2_header(inbuf, nread)) {
 			const uint8_t *inpdu = inbuf + NBT_HDR_SIZE;
 			size_t pdulen = nread - NBT_HDR_SIZE;
-			smbd_smb2_process_negprot(xconn, 0, inpdu, pdulen);
+			NTSTATUS status = smbd_smb2_process_negprot(
+						xconn,
+						0,
+						inpdu,
+						pdulen);
+			if (!NT_STATUS_IS_OK(status)) {
+				exit_server_cleanly("SMB2 negprot fail");
+			}
 			return;
 		}
 		if (nread >= smb_size && valid_smb_header(inbuf)
@@ -3462,80 +3472,106 @@ fail:
 	return false;
 }
 
-static bool uid_in_use(const struct user_struct *user, uid_t uid)
+static bool uid_in_use(struct auth_session_info *session_info,
+		       uid_t uid)
 {
-	while (user) {
-		if (user->session_info &&
-		    (user->session_info->unix_token->uid == uid)) {
-			return true;
-		}
-		user = user->next;
+	if (session_info->unix_token->uid == uid) {
+		return true;
 	}
 	return false;
 }
 
-static bool gid_in_use(const struct user_struct *user, gid_t gid)
+static bool gid_in_use(struct auth_session_info *session_info,
+		       gid_t gid)
 {
-	while (user) {
-		if (user->session_info != NULL) {
-			int i;
-			struct security_unix_token *utok;
-
-			utok = user->session_info->unix_token;
-			if (utok->gid == gid) {
-				return true;
-			}
-			for(i=0; i<utok->ngroups; i++) {
-				if (utok->groups[i] == gid) {
-					return true;
-				}
-			}
+	int i;
+	struct security_unix_token *utok = NULL;
+
+	utok = session_info->unix_token;
+	if (utok->gid == gid) {
+		return true;
+	}
+
+	for(i = 0; i < utok->ngroups; i++) {
+		if (utok->groups[i] == gid) {
+			return true;
 		}
-		user = user->next;
 	}
 	return false;
 }
 
-static bool sid_in_use(const struct user_struct *user,
+static bool sid_in_use(struct auth_session_info *session_info,
 		       const struct dom_sid *psid)
 {
-	while (user) {
-		struct security_token *tok;
+	struct security_token *tok = NULL;
 
-		if (user->session_info == NULL) {
-			continue;
-		}
-		tok = user->session_info->security_token;
-		if (tok == NULL) {
-			/*
-			 * Not sure session_info->security_token can
-			 * ever be NULL. This check might be not
-			 * necessary.
-			 */
-			continue;
-		}
-		if (security_token_has_sid(tok, psid)) {
-			return true;
-		}
-		user = user->next;
+	tok = session_info->security_token;
+	if (tok == NULL) {
+		/*
+		 * Not sure session_info->security_token can
+		 * ever be NULL. This check might be not
+		 * necessary.
+		 */
+		return false;
+	}
+	if (security_token_has_sid(tok, psid)) {
+		return true;
 	}
 	return false;
 }
 
-static bool id_in_use(const struct user_struct *user,
-		      const struct id_cache_ref *id)
+struct id_in_use_state {
+	const struct id_cache_ref *id;
+	bool match;
+};
+
+static int id_in_use_cb(struct smbXsrv_session *session,
+			void *private_data)
 {
-	switch(id->type) {
+	struct id_in_use_state *state = (struct id_in_use_state *)
+		private_data;
+	struct auth_session_info *session_info =
+		session->global->auth_session_info;
+
+	switch(state->id->type) {
 	case UID:
-		return uid_in_use(user, id->id.uid);
+		state->match = uid_in_use(session_info, state->id->id.uid);
+		break;
 	case GID:
-		return gid_in_use(user, id->id.gid);
+		state->match = gid_in_use(session_info, state->id->id.gid);
+		break;
 	case SID:
-		return sid_in_use(user, &id->id.sid);
+		state->match = sid_in_use(session_info, &state->id->id.sid);
+		break;
 	default:
+		state->match = false;
 		break;
 	}
-	return false;
+	if (state->match) {
+		return -1;
+	}
+	return 0;
+}
+
+static bool id_in_use(struct smbd_server_connection *sconn,
+		      const struct id_cache_ref *id)
+{
+	struct id_in_use_state state;
+	NTSTATUS status;
+
+	state = (struct id_in_use_state) {
+		.id = id,
+		.match = false,
+	};
+
+	status = smbXsrv_session_local_traverse(sconn->client,
+						id_in_use_cb,
+						&state);
+	if (!NT_STATUS_IS_OK(status)) {
+		return false;
+	}
+
+	return state.match;
 }
 
 static void smbd_id_cache_kill(struct messaging_context *msg_ctx,
@@ -3556,7 +3592,7 @@ static void smbd_id_cache_kill(struct messaging_context *msg_ctx,
 		return;
 	}
 
-	if (id_in_use(sconn->users, &id)) {
+	if (id_in_use(sconn, &id)) {
 		exit_server_cleanly(msg);
 	}
 	id_cache_delete_from_cache(&id);
@@ -3899,6 +3935,8 @@ void smbd_process(struct tevent_context *ev_ctx,
 		.ev = ev_ctx,
 		.frame = talloc_stackframe(),
 	};
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smbXsrv_client *client = NULL;
 	struct smbd_server_connection *sconn = NULL;
 	struct smbXsrv_connection *xconn = NULL;
@@ -4029,7 +4067,7 @@ void smbd_process(struct tevent_context *ev_ctx,
 		exit_server("Could not open account policy tdb.\n");
 	}
 
-	chroot_dir = lp_root_directory(talloc_tos());
+	chroot_dir = lp_root_directory(talloc_tos(), lp_sub);
 	if (chroot_dir[0] != '\0') {
 		rc = chdir(chroot_dir);
 		if (rc != 0) {
@@ -4058,6 +4096,11 @@ void smbd_process(struct tevent_context *ev_ctx,
 	/* register our message handlers */
 	messaging_register(sconn->msg_ctx, sconn,
 			   MSG_SMB_FORCE_TDIS, msg_force_tdis);
+	messaging_register(
+		sconn->msg_ctx,
+		sconn,
+		MSG_SMB_FORCE_TDIS_DENIED,
+		msg_force_tdis_denied);
 	messaging_register(sconn->msg_ctx, sconn,
 			   MSG_SMB_CLOSE_FILE, msg_close_file);
 	messaging_register(sconn->msg_ctx, sconn,
diff --git a/source3/smbd/proto.h b/source3/smbd/proto.h
index 4bb0f9a54c8..96d574023a5 100644
--- a/source3/smbd/proto.h
+++ b/source3/smbd/proto.h
@@ -154,12 +154,22 @@ connection_struct *conn_new(struct smbd_server_connection *sconn);
 bool conn_idle_all(struct smbd_server_connection *sconn, time_t t);
 void conn_clear_vuid_caches(struct smbd_server_connection *sconn, uint64_t vuid);
 void conn_free(connection_struct *conn);
-void conn_force_tdis(struct smbd_server_connection *sconn, const char *sharename);
+void conn_force_tdis(
+	struct smbd_server_connection *sconn,
+	bool (*check_fn)(struct connection_struct *conn,
+			 void *private_data),
+	void *private_data);
 void msg_force_tdis(struct messaging_context *msg,
 		    void *private_data,
 		    uint32_t msg_type,
 		    struct server_id server_id,
 		    DATA_BLOB *data);
+void msg_force_tdis_denied(
+	struct messaging_context *msg,
+	void *private_data,
+	uint32_t msg_type,
+	struct server_id server_id,
+	DATA_BLOB *data);
 
 /* The following definitions come from smbd/connection.c  */
 
@@ -467,10 +477,16 @@ void reply_sendend(struct smb_request *req);
 
 /* The following definitions come from smbd/msdfs.c  */
 
+bool parse_msdfs_symlink(TALLOC_CTX *ctx,
+			bool shuffle_referrals,
+			const char *target,
+			struct referral **preflist,
+			size_t *refcount);
 bool is_msdfs_link(connection_struct *conn,
 		struct smb_filename *smb_fname);
 struct junction_map;
 NTSTATUS get_referred_path(TALLOC_CTX *ctx,
+			   struct auth_session_info *session_info,
 			   const char *dfs_path,
 			   const struct tsocket_address *remote_address,
 			   const struct tsocket_address *local_address,
@@ -486,9 +502,18 @@ bool create_junction(TALLOC_CTX *ctx,
 		const char *dfs_path,
 		bool allow_broken_path,
 		struct junction_map *jucn);
-bool create_msdfs_link(const struct junction_map *jucn);
-bool remove_msdfs_link(const struct junction_map *jucn);
-struct junction_map *enum_msdfs_links(TALLOC_CTX *ctx, size_t *p_num_jn);
+struct referral;
+char *msdfs_link_string(TALLOC_CTX *ctx,
+		const struct referral *reflist,
+		size_t referral_count);
+bool create_msdfs_link(const struct junction_map *jucn,
+		       struct auth_session_info *session_info);
+bool remove_msdfs_link(const struct junction_map *jucn,
+		       struct auth_session_info *session_info);
+
+struct junction_map *enum_msdfs_links(TALLOC_CTX *ctx,
+				      struct auth_session_info *session_info,
+				      size_t *p_num_jn);
 NTSTATUS resolve_dfspath_wcard(TALLOC_CTX *ctx,
 				connection_struct *conn,
 				const char *name_in,
@@ -744,8 +769,6 @@ struct kernel_oplocks *linux_init_kernel_oplocks(struct smbd_server_connection *
 
 /* The following definitions come from smbd/password.c  */
 
-struct user_struct *get_valid_user_struct(struct smbd_server_connection *sconn,
-					  uint64_t vuid);
 void invalidate_vuid(struct smbd_server_connection *sconn, uint64_t vuid);
 int register_homes_share(const char *username);
 
@@ -792,7 +815,9 @@ NTSTATUS set_unix_posix_default_acl(connection_struct *conn,
 NTSTATUS set_unix_posix_acl(connection_struct *conn, files_struct *fsp,
 				uint16_t num_acls,
 				const char *pdata);
-NTSTATUS get_nt_acl_no_snum( TALLOC_CTX *ctx, const char *fname,
+NTSTATUS get_nt_acl_no_snum(TALLOC_CTX *ctx,
+			    struct auth_session_info *session_info,
+			    const char *fname,
 			     uint32_t security_info_wanted,
 			     struct security_descriptor **sd);
 int posix_sys_acl_blob_get_file(vfs_handle_struct *handle,
@@ -1066,7 +1091,6 @@ int find_service(TALLOC_CTX *ctx, const char *service, char **p_service_out);
 connection_struct *make_connection_smb2(struct smbd_smb2_request *req,
 					struct smbXsrv_tcon *tcon,
 					int snum,
-					struct user_struct *vuser,
 					const char *pdev,
 					NTSTATUS *pstatus);
 connection_struct *make_connection(struct smb_request *req,
@@ -1250,6 +1274,7 @@ NTSTATUS vfs_streaminfo(connection_struct *conn,
 			TALLOC_CTX *mem_ctx,
 			unsigned int *num_streams,
 			struct stream_struct **streams);
+void init_smb_file_time(struct smb_file_time *ft);
 
 /* The following definitions come from smbd/avahi_register.c */
 
diff --git a/source3/smbd/pysmbd.c b/source3/smbd/pysmbd.c
index e5836b49f54..39fe875a385 100644
--- a/source3/smbd/pysmbd.c
+++ b/source3/smbd/pysmbd.c
@@ -424,19 +424,46 @@ static SMB_ACL_T make_simple_acl(TALLOC_CTX *mem_ctx,
  */
 static PyObject *py_smbd_set_simple_acl(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-	const char * const kwnames[] = { "fname", "mode", "gid", "service", NULL };
+	const char * const kwnames[] = {
+		"fname",
+		"mode",
+		"session_info",
+		"gid",
+		"service",
+		NULL
+	};
 	char *fname, *service = NULL;
+	PyObject *py_session = Py_None;
+	struct auth_session_info *session_info = NULL;
 	int ret;
 	int mode, gid = -1;
 	SMB_ACL_T acl;
 	TALLOC_CTX *frame;
 	connection_struct *conn;
 
-	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "si|iz",
+	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "siO|iz",
 					 discard_const_p(char *, kwnames),
-					 &fname, &mode, &gid, &service))
+					 &fname,
+					 &mode,
+					 &py_session,
+					 &gid,
+					 &service))
 		return NULL;
 
+	if (!py_check_dcerpc_type(py_session,
+				  "samba.dcerpc.auth",
+				  "session_info")) {
+		return NULL;
+	}
+	session_info = pytalloc_get_type(py_session,
+					 struct auth_session_info);
+	if (session_info == NULL) {
+		PyErr_Format(PyExc_TypeError,
+			     "Expected auth_session_info for session_info argument got %s",
+			     pytalloc_get_name(py_session));
+		return NULL;
+	}
+
 	frame = talloc_stackframe();
 
 	acl = make_simple_acl(frame, gid, mode);
@@ -445,7 +472,7 @@ static PyObject *py_smbd_set_simple_acl(PyObject *self, PyObject *args, PyObject
 		return NULL;
 	}
 
-	conn = get_conn_tos(service, NULL);
+	conn = get_conn_tos(service, session_info);
 	if (!conn) {
 		TALLOC_FREE(frame);
 		return NULL;
@@ -469,23 +496,50 @@ static PyObject *py_smbd_set_simple_acl(PyObject *self, PyObject *args, PyObject
  */
 static PyObject *py_smbd_chown(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-	const char * const kwnames[] = { "fname", "uid", "gid", "service", NULL };
+	const char * const kwnames[] = {
+		"fname",
+		"uid",
+		"gid",
+		"session_info",
+		"service",
+		NULL
+	};
 	connection_struct *conn;
 	int ret;
 	NTSTATUS status;
 	char *fname, *service = NULL;
+	PyObject *py_session = Py_None;
+	struct auth_session_info *session_info = NULL;
 	int uid, gid;
 	TALLOC_CTX *frame;
 	struct files_struct *fsp = NULL;
 
-	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "sii|z",
+	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "siiO|z",
 					 discard_const_p(char *, kwnames),
-					 &fname, &uid, &gid, &service))
+					 &fname,
+					 &uid,
+					 &gid,
+					 &py_session,
+					 &service))
 		return NULL;
 
+	if (!py_check_dcerpc_type(py_session,
+				  "samba.dcerpc.auth",
+				  "session_info")) {
+		return NULL;
+	}
+	session_info = pytalloc_get_type(py_session,
+					 struct auth_session_info);
+	if (session_info == NULL) {
+		PyErr_Format(PyExc_TypeError,
+			     "Expected auth_session_info for session_info argument got %s",
+			     pytalloc_get_name(py_session));
+		return NULL;
+	}
+
 	frame = talloc_stackframe();
 
-	conn = get_conn_tos(service, NULL);
+	conn = get_conn_tos(service, session_info);
 	if (!conn) {
 		TALLOC_FREE(frame);
 		return NULL;
@@ -540,23 +594,48 @@ static PyObject *py_smbd_chown(PyObject *self, PyObject *args, PyObject *kwargs)
  */
 static PyObject *py_smbd_unlink(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-	const char * const kwnames[] = { "fname", "service", NULL };
+	const char * const kwnames[] = {
+		"fname",
+		"session_info",
+		"service",
+		NULL
+	};
 	connection_struct *conn;
 	int ret;
 	struct smb_filename *smb_fname = NULL;
+	PyObject *py_session = Py_None;
+	struct auth_session_info *session_info = NULL;
 	char *fname, *service = NULL;
 	TALLOC_CTX *frame;
 
 	frame = talloc_stackframe();
 
-	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|z",
+	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "sO|z",
 					 discard_const_p(char *, kwnames),
-					 &fname, &service)) {
+					 &fname,
+					 &py_session ,
+					 &service)) {
 		TALLOC_FREE(frame);
 		return NULL;
 	}
 
-	conn = get_conn_tos(service, NULL);
+	if (!py_check_dcerpc_type(py_session,
+				  "samba.dcerpc.auth",
+				  "session_info")) {
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+	session_info = pytalloc_get_type(py_session,
+					 struct auth_session_info);
+	if (session_info == NULL) {
+		PyErr_Format(PyExc_TypeError,
+			     "Expected auth_session_info for session_info argument got %s",
+			     pytalloc_get_name(py_session));
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+
+	conn = get_conn_tos(service, session_info);
 	if (!conn) {
 		TALLOC_FREE(frame);
 		return NULL;
@@ -604,8 +683,13 @@ static PyObject *py_smbd_have_posix_acls(PyObject *self,
 static PyObject *py_smbd_set_nt_acl(PyObject *self, PyObject *args, PyObject *kwargs)
 {
 	const char * const kwnames[] = {
-		"fname", "security_info_sent", "sd",
-		"service", "session_info", NULL };
+		"fname",
+		"security_info_sent",
+		"sd",
+		"session_info",
+		"service",
+		NULL
+	};
 
 	NTSTATUS status;
 	char *fname, *service = NULL;
@@ -619,10 +703,13 @@ static PyObject *py_smbd_set_nt_acl(PyObject *self, PyObject *args, PyObject *kw
 
 	frame = talloc_stackframe();
 
-	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "siO|zO",
+	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "siOO|z",
 				         discard_const_p(char *, kwnames),
-					 &fname, &security_info_sent, &py_sd,
-					 &service, &py_session)) {
+					 &fname,
+					 &security_info_sent,
+					 &py_sd,
+					 &py_session,
+					 &service)) {
 		TALLOC_FREE(frame);
 		return NULL;
 	}
@@ -632,21 +719,19 @@ static PyObject *py_smbd_set_nt_acl(PyObject *self, PyObject *args, PyObject *kw
 		return NULL;
 	}
 
-	if (py_session != Py_None) {
-		if (!py_check_dcerpc_type(py_session,
-					  "samba.dcerpc.auth",
-					  "session_info")) {
-			TALLOC_FREE(frame);
-			return NULL;
-		}
-		session_info = pytalloc_get_type(py_session,
-						 struct auth_session_info);
-		if (!session_info) {
-			PyErr_Format(PyExc_TypeError,
-				     "Expected auth_session_info for session_info argument got %s",
-				     pytalloc_get_name(py_session));
-			return NULL;
-		}
+	if (!py_check_dcerpc_type(py_session,
+				  "samba.dcerpc.auth",
+				  "session_info")) {
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+	session_info = pytalloc_get_type(py_session,
+					 struct auth_session_info);
+	if (session_info == NULL) {
+		PyErr_Format(PyExc_TypeError,
+			     "Expected auth_session_info for session_info argument got %s",
+			     pytalloc_get_name(py_session));
+		return NULL;
 	}
 
 	conn = get_conn_tos(service, session_info);
@@ -669,11 +754,13 @@ static PyObject *py_smbd_set_nt_acl(PyObject *self, PyObject *args, PyObject *kw
  */
 static PyObject *py_smbd_get_nt_acl(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-	const char * const kwnames[] = { "fname",
-					 "security_info_wanted",
-					 "service",
-					 "session_info",
-					 NULL };
+	const char * const kwnames[] = {
+		"fname",
+		"security_info_wanted",
+		"session_info",
+		"service",
+		NULL
+	};
 	char *fname, *service = NULL;
 	int security_info_wanted;
 	PyObject *py_sd;
@@ -687,34 +774,32 @@ static PyObject *py_smbd_get_nt_acl(PyObject *self, PyObject *args, PyObject *kw
 
 	ret = PyArg_ParseTupleAndKeywords(args,
 					  kwargs,
-					  "si|zO",
+					  "siO|z",
 					  discard_const_p(char *, kwnames),
 					  &fname,
 					  &security_info_wanted,
-					  &service,
-					  &py_session);
+					  &py_session,
+					  &service);
 	if (!ret) {
 		TALLOC_FREE(frame);
 		return NULL;
 	}
 
-	if (py_session != Py_None) {
-		if (!py_check_dcerpc_type(py_session,
-					  "samba.dcerpc.auth",
-					  "session_info")) {
-			TALLOC_FREE(frame);
-			return NULL;
-		}
-		session_info = pytalloc_get_type(py_session,
-						 struct auth_session_info);
-		if (!session_info) {
-			PyErr_Format(
-				PyExc_TypeError,
-				"Expected auth_session_info for "
-				"session_info argument got %s",
-				pytalloc_get_name(py_session));
-			return NULL;
-		}
+	if (!py_check_dcerpc_type(py_session,
+				  "samba.dcerpc.auth",
+				  "session_info")) {
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+	session_info = pytalloc_get_type(py_session,
+					 struct auth_session_info);
+	if (session_info == NULL) {
+		PyErr_Format(
+			PyExc_TypeError,
+			"Expected auth_session_info for "
+			"session_info argument got %s",
+			pytalloc_get_name(py_session));
+		return NULL;
 	}
 
 	conn = get_conn_tos(service, session_info);
@@ -738,18 +823,31 @@ static PyObject *py_smbd_get_nt_acl(PyObject *self, PyObject *args, PyObject *kw
  */
 static PyObject *py_smbd_set_sys_acl(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-	const char * const kwnames[] = { "fname", "acl_type", "acl", "service", NULL };
+	const char * const kwnames[] = {
+		"fname",
+		"acl_type",
+		"acl",
+		"session_info",
+		"service",
+		NULL
+	};
 	TALLOC_CTX *frame = talloc_stackframe();
 	int ret;
 	char *fname, *service = NULL;
 	PyObject *py_acl;
+	PyObject *py_session = Py_None;
+	struct auth_session_info *session_info = NULL;
 	struct smb_acl_t *acl;
 	int acl_type;
 	connection_struct *conn;
 
-	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "siO|z",
+	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "siOO|z",
 					 discard_const_p(char *, kwnames),
-					 &fname, &acl_type, &py_acl, &service)) {
+					 &fname,
+					 &acl_type,
+					 &py_acl,
+					 &py_session,
+					 &service)) {
 		TALLOC_FREE(frame);
 		return NULL;
 	}
@@ -759,7 +857,23 @@ static PyObject *py_smbd_set_sys_acl(PyObject *self, PyObject *args, PyObject *k
 		return NULL;
 	}
 
-	conn = get_conn_tos(service, NULL);
+	if (!py_check_dcerpc_type(py_session,
+				  "samba.dcerpc.auth",
+				  "session_info")) {
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+	session_info = pytalloc_get_type(py_session,
+					 struct auth_session_info);
+	if (session_info == NULL) {
+		PyErr_Format(PyExc_TypeError,
+			     "Expected auth_session_info for session_info argument got %s",
+			     pytalloc_get_name(py_session));
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+
+	conn = get_conn_tos(service, session_info);
 	if (!conn) {
 		TALLOC_FREE(frame);
 		return NULL;
@@ -783,9 +897,17 @@ static PyObject *py_smbd_set_sys_acl(PyObject *self, PyObject *args, PyObject *k
  */
 static PyObject *py_smbd_get_sys_acl(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-	const char * const kwnames[] = { "fname", "acl_type", "service", NULL };
+	const char * const kwnames[] = {
+		"fname",
+		"acl_type",
+		"session_info",
+		"service",
+		NULL
+	};
 	char *fname;
 	PyObject *py_acl;
+	PyObject *py_session = Py_None;
+	struct auth_session_info *session_info = NULL;
 	struct smb_acl_t *acl;
 	int acl_type;
 	TALLOC_CTX *frame = talloc_stackframe();
@@ -793,14 +915,33 @@ static PyObject *py_smbd_get_sys_acl(PyObject *self, PyObject *args, PyObject *k
 	char *service = NULL;
 	struct smb_filename *smb_fname = NULL;
 
-	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "si|z",
+	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "siO|z",
 					 discard_const_p(char *, kwnames),
-					 &fname, &acl_type, &service)) {
+					 &fname,
+					 &acl_type,
+					 &py_session,
+					 &service)) {
 		TALLOC_FREE(frame);
 		return NULL;
 	}
 
-	conn = get_conn_tos(service, NULL);
+	if (!py_check_dcerpc_type(py_session,
+				  "samba.dcerpc.auth",
+				  "session_info")) {
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+	session_info = pytalloc_get_type(py_session,
+					 struct auth_session_info);
+	if (session_info == NULL) {
+		PyErr_Format(PyExc_TypeError,
+			     "Expected auth_session_info for session_info argument got %s",
+			     pytalloc_get_name(py_session));
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+
+	conn = get_conn_tos(service, session_info);
 	if (!conn) {
 		TALLOC_FREE(frame);
 		return NULL;
@@ -828,8 +969,15 @@ static PyObject *py_smbd_get_sys_acl(PyObject *self, PyObject *args, PyObject *k
 
 static PyObject *py_smbd_mkdir(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-	const char * const kwnames[] = { "fname", "service", NULL };
+	const char * const kwnames[] = {
+		"fname",
+		"session_info",
+		"service",
+		NULL
+	};
 	char *fname, *service = NULL;
+	PyObject *py_session = Py_None;
+	struct auth_session_info *session_info = NULL;
 	TALLOC_CTX *frame = talloc_stackframe();
 	struct connection_struct *conn = NULL;
 	struct smb_filename *smb_fname = NULL;
@@ -838,16 +986,33 @@ static PyObject *py_smbd_mkdir(PyObject *self, PyObject *args, PyObject *kwargs)
 
 	if (!PyArg_ParseTupleAndKeywords(args,
 					 kwargs,
-					 "s|z",
+					 "sO|z",
 					 discard_const_p(char *,
 							 kwnames),
 					 &fname,
+					 &py_session,
 					 &service)) {
 		TALLOC_FREE(frame);
 		return NULL;
 	}
 
-	conn = get_conn_tos(service, NULL);
+	if (!py_check_dcerpc_type(py_session,
+				  "samba.dcerpc.auth",
+				  "session_info")) {
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+	session_info = pytalloc_get_type(py_session,
+					 struct auth_session_info);
+	if (session_info == NULL) {
+		PyErr_Format(PyExc_TypeError,
+			     "Expected auth_session_info for session_info argument got %s",
+			     pytalloc_get_name(py_session));
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+
+	conn = get_conn_tos(service, session_info);
 	if (!conn) {
 		TALLOC_FREE(frame);
 		return NULL;
@@ -892,8 +1057,15 @@ static PyObject *py_smbd_mkdir(PyObject *self, PyObject *args, PyObject *kwargs)
  */
 static PyObject *py_smbd_create_file(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-	const char * const kwnames[] = { "fname", "service", NULL };
+	const char * const kwnames[] = {
+		"fname",
+		"session_info",
+		"service",
+		NULL
+	};
 	char *fname, *service = NULL;
+	PyObject *py_session = Py_None;
+	struct auth_session_info *session_info = NULL;
 	TALLOC_CTX *frame = talloc_stackframe();
 	struct connection_struct *conn = NULL;
 	struct files_struct *fsp = NULL;
@@ -901,16 +1073,33 @@ static PyObject *py_smbd_create_file(PyObject *self, PyObject *args, PyObject *k
 
 	if (!PyArg_ParseTupleAndKeywords(args,
 					 kwargs,
-					 "s|z",
+					 "sO|z",
 					 discard_const_p(char *,
 							 kwnames),
 					 &fname,
+					 &py_session,
 					 &service)) {
 		TALLOC_FREE(frame);
 		return NULL;
 	}
 
-	conn = get_conn_tos(service, NULL);
+	if (!py_check_dcerpc_type(py_session,
+				  "samba.dcerpc.auth",
+				  "session_info")) {
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+	session_info = pytalloc_get_type(py_session,
+					 struct auth_session_info);
+	if (session_info == NULL) {
+		PyErr_Format(PyExc_TypeError,
+			     "Expected auth_session_info for session_info argument got %s",
+			     pytalloc_get_name(py_session));
+		TALLOC_FREE(frame);
+		return NULL;
+	}
+
+	conn = get_conn_tos(service, session_info);
 	if (!conn) {
 		TALLOC_FREE(frame);
 		return NULL;
diff --git a/source3/smbd/reply.c b/source3/smbd/reply.c
index 9e126cd3692..40cd7483750 100644
--- a/source3/smbd/reply.c
+++ b/source3/smbd/reply.c
@@ -868,6 +868,8 @@ void reply_tcon(struct smb_request *req)
 
 void reply_tcon_and_X(struct smb_request *req)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	connection_struct *conn = req->conn;
 	const char *service = NULL;
 	TALLOC_CTX *ctx = talloc_tos();
@@ -1142,7 +1144,7 @@ void reply_tcon_and_X(struct smb_request *req)
 
 		if (lp_msdfs_root(SNUM(conn)) && lp_host_msdfs()) {
 			DEBUG(2,("Serving %s as a Dfs root\n",
-				 lp_servicename(ctx, SNUM(conn)) ));
+				 lp_servicename(ctx, lp_sub, SNUM(conn)) ));
 			optional_support |= SMB_SHARE_IN_DFS;
 		}
 
@@ -1183,6 +1185,8 @@ void reply_unknown_new(struct smb_request *req, uint8_t type)
 
 void reply_ioctl(struct smb_request *req)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	connection_struct *conn = req->conn;
 	uint16_t device;
 	uint16_t function;
@@ -1249,6 +1253,7 @@ void reply_ioctl(struct smb_request *req)
 				status = srvstr_push((char *)req->outbuf, req->flags2,
 					    p+18,
 					    lp_servicename(talloc_tos(),
+							   lp_sub,
 							   SNUM(conn)),
 					    13, STR_TERMINATE|STR_ASCII, &len);
 				if (!NT_STATUS_IS_OK(status)) {
@@ -1444,7 +1449,7 @@ void reply_getatr(struct smb_request *req)
 			ZERO_STRUCT(write_time_ts);
 			fileid = vfs_file_id_from_sbuf(conn, &smb_fname->st);
 			get_file_infos(fileid, 0, NULL, &write_time_ts);
-			if (!null_timespec(write_time_ts)) {
+			if (!is_omit_timespec(&write_time_ts)) {
 				update_stat_ex_mtime(&smb_fname->st, write_time_ts);
 			}
 		}
@@ -1498,6 +1503,7 @@ void reply_setatr(struct smb_request *req)
 	TALLOC_CTX *ctx = talloc_tos();
 
 	START_PROFILE(SMBsetatr);
+	init_smb_file_time(&ft);
 
 	if (req->wct < 2) {
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
@@ -1560,9 +1566,7 @@ void reply_setatr(struct smb_request *req)
 		}
 	}
 
-	ft = (struct smb_file_time) {
-		.mtime = convert_time_t_to_timespec(mtime)
-	};
+	ft.mtime = time_t_to_full_timespec(mtime);
 
 	status = smb_set_file_time(conn, NULL, smb_fname, &ft, true);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -1774,6 +1778,8 @@ void reply_search(struct smb_request *req)
 	struct smbXsrv_connection *xconn = req->xconn;
 	struct smbd_server_connection *sconn = req->sconn;
 	files_struct *fsp = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	START_PROFILE(SMBsearch);
 
@@ -2011,8 +2017,8 @@ void reply_search(struct smb_request *req)
 		maxentries = MIN(maxentries, available_space/DIR_STRUCT_SIZE);
 
 		DEBUG(8,("dirpath=<%s> dontdescend=<%s>\n",
-			 directory,lp_dont_descend(ctx, SNUM(conn))));
-		if (in_list(directory, lp_dont_descend(ctx, SNUM(conn)),True)) {
+			 directory,lp_dont_descend(ctx, lp_sub, SNUM(conn))));
+		if (in_list(directory, lp_dont_descend(ctx, lp_sub, SNUM(conn)),True)) {
 			check_descend = True;
 		}
 
@@ -2607,16 +2613,17 @@ void reply_open_and_X(struct smb_request *req)
 
 void reply_ulogoffX(struct smb_request *req)
 {
-	struct smbd_server_connection *sconn = req->sconn;
-	struct user_struct *vuser;
+	struct timeval now = timeval_current();
 	struct smbXsrv_session *session = NULL;
 	NTSTATUS status;
 
 	START_PROFILE(SMBulogoffX);
 
-	vuser = get_valid_user_struct(sconn, req->vuid);
-
-	if(vuser == NULL) {
+	status = smb1srv_session_lookup(req->xconn,
+					req->vuid,
+					timeval_to_nttime(&now),
+					&session);
+	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(3,("ulogoff, vuser id %llu does not map to user.\n",
 			 (unsigned long long)req->vuid));
 
@@ -2626,9 +2633,6 @@ void reply_ulogoffX(struct smb_request *req)
 		return;
 	}
 
-	session = vuser->session;
-	vuser = NULL;
-
 	/*
 	 * TODO: cancel all outstanding requests on the session
 	 */
@@ -2681,7 +2685,7 @@ void reply_mknew(struct smb_request *req)
 	TALLOC_CTX *ctx = talloc_tos();
 
 	START_PROFILE(SMBcreate);
-	ZERO_STRUCT(ft);
+	init_smb_file_time(&ft);
 
         if (req->wct < 3) {
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
@@ -2700,7 +2704,7 @@ void reply_mknew(struct smb_request *req)
 	}
 
 	/* mtime. */
-	ft.mtime = convert_time_t_to_timespec(srv_make_unix_date3(req->vwv+1));
+	ft.mtime = time_t_to_full_timespec(srv_make_unix_date3(req->vwv+1));
 
 	srvstr_get_path_req(ctx, req, &fname, (const char *)req->buf + 1,
 			    STR_TERMINATE, &status);
@@ -3620,6 +3624,25 @@ static void reply_readbraw_error(struct smbXsrv_connection *xconn)
 	smbd_unlock_socket(xconn);
 }
 
+/*******************************************************************
+ Ensure we don't use sendfile if server smb signing is active.
+********************************************************************/
+
+static bool lp_use_sendfile(int snum, struct smb_signing_state *signing_state)
+{
+	bool sign_active = false;
+
+	/* Using sendfile blows the brains out of any DOS or Win9x TCP stack... JRA. */
+	if (get_Protocol() < PROTOCOL_NT1) {
+		return false;
+	}
+	if (signing_state) {
+		sign_active = smb_signing_is_active(signing_state);
+	}
+	return (lp__use_sendfile(snum) &&
+			(get_remote_arch() != RA_WIN95) &&
+			!sign_active);
+}
 /****************************************************************************
  Use sendfile in readbraw.
 ****************************************************************************/
@@ -5626,7 +5649,7 @@ void reply_close(struct smb_request *req)
 		 */
 
 		t = srv_make_unix_date3(req->vwv+1);
-		set_close_write_time(fsp, convert_time_t_to_timespec(t));
+		set_close_write_time(fsp, time_t_to_full_timespec(t));
 	}
 
 	if (fsp->num_aio_requests != 0) {
@@ -5763,7 +5786,7 @@ void reply_writeclose(struct smb_request *req)
 
 	numtowrite = SVAL(req->vwv+1, 0);
 	startpos = IVAL_TO_SMB_OFF_T(req->vwv+2, 0);
-	mtime = convert_time_t_to_timespec(srv_make_unix_date3(req->vwv+4));
+	mtime = time_t_to_full_timespec(srv_make_unix_date3(req->vwv+4));
 	data = (const char *)req->buf + 1;
 
 	/*
@@ -6208,6 +6231,8 @@ void reply_printclose(struct smb_request *req)
 
 void reply_printqueue(struct smb_request *req)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	connection_struct *conn = req->conn;
 	int max_count;
 	int start_index;
@@ -6246,7 +6271,7 @@ void reply_printqueue(struct smb_request *req)
 		TALLOC_CTX *mem_ctx = talloc_tos();
 		NTSTATUS status;
 		WERROR werr;
-		const char *sharename = lp_servicename(mem_ctx, SNUM(conn));
+		const char *sharename = lp_servicename(mem_ctx, lp_sub, SNUM(conn));
 		struct rpc_pipe_client *cli = NULL;
 		struct dcerpc_binding_handle *b = NULL;
 		struct policy_handle handle;
@@ -8353,20 +8378,24 @@ uint64_t get_lock_offset(const uint8_t *data, int data_offset,
 	return offset;
 }
 
-NTSTATUS smbd_do_unlocking(struct smb_request *req,
-			   files_struct *fsp,
-			   uint16_t num_ulocks,
-			   struct smbd_lock_element *ulocks,
-			   enum brl_flavour lock_flav)
+struct smbd_do_unlocking_state {
+	struct files_struct *fsp;
+	uint16_t num_ulocks;
+	struct smbd_lock_element *ulocks;
+	enum brl_flavour lock_flav;
+	NTSTATUS status;
+};
+
+static void smbd_do_unlocking_fn(
+	TDB_DATA value, bool *pmodified_dependent, void *private_data)
 {
-	struct share_mode_lock *lck;
-	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
+	struct smbd_do_unlocking_state *state = private_data;
+	struct files_struct *fsp = state->fsp;
+	enum brl_flavour lock_flav = state->lock_flav;
 	uint16_t i;
 
-	lck = get_existing_share_mode_lock(talloc_tos(), fsp->file_id);
-
-	for(i = 0; i < num_ulocks; i++) {
-		struct smbd_lock_element *e = &ulocks[i];
+	for (i = 0; i < state->num_ulocks; i++) {
+		struct smbd_lock_element *e = &state->ulocks[i];
 
 		DBG_DEBUG("unlock start=%"PRIu64", len=%"PRIu64" for "
 			  "pid %"PRIu64", file %s\n",
@@ -8377,35 +8406,55 @@ NTSTATUS smbd_do_unlocking(struct smb_request *req,
 
 		if (e->brltype != UNLOCK_LOCK) {
 			/* this can only happen with SMB2 */
-			status = NT_STATUS_INVALID_PARAMETER;
-			goto done;
+			state->status = NT_STATUS_INVALID_PARAMETER;
+			return;
 		}
 
-		status = do_unlock(
-			fsp,
-			e->smblctx,
-			e->count,
-			e->offset,
-			lock_flav);
+		state->status = do_unlock(
+			fsp, e->smblctx, e->count, e->offset, lock_flav);
 
-		DEBUG(10, ("%s: unlock returned %s\n", __func__,
-			   nt_errstr(status)));
+		DBG_DEBUG("do_unlock returned %s\n",
+			  nt_errstr(state->status));
 
-		if (!NT_STATUS_IS_OK(status)) {
-			goto done;
+		if (!NT_STATUS_IS_OK(state->status)) {
+			return;
 		}
 	}
 
-	DEBUG(3, ("%s: %s num_ulocks=%d\n", __func__, fsp_fnum_dbg(fsp),
-		  num_ulocks));
+	*pmodified_dependent = true;
+}
 
-done:
-	if (NT_STATUS_IS_OK(status) && (lck != NULL)) {
-		lck->data->modified = true;
+NTSTATUS smbd_do_unlocking(struct smb_request *req,
+			   files_struct *fsp,
+			   uint16_t num_ulocks,
+			   struct smbd_lock_element *ulocks,
+			   enum brl_flavour lock_flav)
+{
+	struct smbd_do_unlocking_state state = {
+		.fsp = fsp,
+		.num_ulocks = num_ulocks,
+		.ulocks = ulocks,
+		.lock_flav = lock_flav,
+	};
+	NTSTATUS status;
+
+	DBG_NOTICE("%s num_ulocks=%"PRIu16"\n", fsp_fnum_dbg(fsp), num_ulocks);
+
+	status = share_mode_do_locked(
+		fsp->file_id, smbd_do_unlocking_fn, &state);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_DEBUG("share_mode_do_locked failed: %s\n",
+			  nt_errstr(status));
+		return status;
+	}
+	if (!NT_STATUS_IS_OK(state.status)) {
+		DBG_DEBUG("smbd_do_unlocking_fn failed: %s\n",
+			  nt_errstr(status));
+		return state.status;
 	}
 
-	TALLOC_FREE(lck);
-	return status;
+	return NT_STATUS_OK;
 }
 
 /****************************************************************************
@@ -8758,7 +8807,7 @@ void reply_setattrE(struct smb_request *req)
 	NTSTATUS status;
 
 	START_PROFILE(SMBsetattrE);
-	ZERO_STRUCT(ft);
+	init_smb_file_time(&ft);
 
 	if (req->wct < 7) {
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
@@ -8776,11 +8825,11 @@ void reply_setattrE(struct smb_request *req)
 	 * Convert the DOS times into unix times.
 	 */
 
-	ft.atime = convert_time_t_to_timespec(
+	ft.atime = time_t_to_full_timespec(
 	    srv_make_unix_date2(req->vwv+3));
-	ft.mtime = convert_time_t_to_timespec(
+	ft.mtime = time_t_to_full_timespec(
 	    srv_make_unix_date2(req->vwv+5));
-	ft.create_time = convert_time_t_to_timespec(
+	ft.create_time = time_t_to_full_timespec(
 	    srv_make_unix_date2(req->vwv+1));
 
 	reply_outbuf(req, 0, 0);
diff --git a/source3/smbd/scavenger.c b/source3/smbd/scavenger.c
index cd5c85d2871..de07719468b 100644
--- a/source3/smbd/scavenger.c
+++ b/source3/smbd/scavenger.c
@@ -250,6 +250,8 @@ static bool smbd_scavenger_start(struct smbd_scavenger_state *state)
 			return false;
 		}
 
+		reopen_logs();
+
 		state->am_scavenger = true;
 		*state->scavenger_id = messaging_server_id(state->msg);
 
diff --git a/source3/smbd/server.c b/source3/smbd/server.c
index 0cff4fcb39d..10ae5a42dac 100644
--- a/source3/smbd/server.c
+++ b/source3/smbd/server.c
@@ -419,7 +419,7 @@ static bool smbd_notifyd_init(struct messaging_context *msg, bool interactive,
 	}
 
 	if (pid != 0) {
-		if (am_parent != 0) {
+		if (am_parent != NULL) {
 			add_child_pid(am_parent, pid);
 		}
 		*ppid = pid_to_procid(pid);
@@ -433,6 +433,8 @@ static bool smbd_notifyd_init(struct messaging_context *msg, bool interactive,
 		exit(1);
 	}
 
+	reopen_logs();
+
 	/* Set up sighup handler for notifyd */
 	se = tevent_add_signal(ev,
 			       ev,
@@ -1252,6 +1254,8 @@ static bool open_sockets_smbd(struct smbd_parent_context *parent,
 	messaging_register(msg_ctx, NULL, MSG_DEBUG, smbd_msg_debug);
 	messaging_register(msg_ctx, NULL, MSG_SMB_FORCE_TDIS,
 			   smb_parent_send_to_children);
+	messaging_register(msg_ctx, NULL, MSG_SMB_FORCE_TDIS_DENIED,
+			   smb_parent_send_to_children);
 	messaging_register(msg_ctx, NULL, MSG_SMB_KILL_CLIENT_IP,
 			   smb_parent_send_to_children);
 	messaging_register(msg_ctx, NULL, MSG_SMB_TELL_NUM_CHILDREN,
@@ -1417,8 +1421,9 @@ struct smbd_claim_version_state {
 	char *version;
 };
 
-static void smbd_claim_version_parser(const struct g_lock_rec *locks,
-				      size_t num_locks,
+static void smbd_claim_version_parser(struct server_id exclusive,
+				      size_t num_shared,
+				      struct server_id *shared,
 				      const uint8_t *data,
 				      size_t datalen,
 				      void *private_data)
@@ -1482,7 +1487,7 @@ static NTSTATUS smbd_claim_version(struct messaging_context *msg,
 		return NT_STATUS_OK;
 	}
 
-	status = g_lock_lock(ctx, string_term_tdb_data(name), G_LOCK_WRITE,
+	status = g_lock_lock(ctx, string_term_tdb_data(name), G_LOCK_UPGRADE,
 			     (struct timeval) { .tv_sec = 60 });
 	if (!NT_STATUS_IS_OK(status)) {
 		DBG_WARNING("g_lock_lock(G_LOCK_WRITE) failed: %s\n",
@@ -1503,7 +1508,7 @@ static NTSTATUS smbd_claim_version(struct messaging_context *msg,
 		return status;
 	}
 
-	status = g_lock_lock(ctx, string_term_tdb_data(name), G_LOCK_READ,
+	status = g_lock_lock(ctx, string_term_tdb_data(name), G_LOCK_DOWNGRADE,
 			     (struct timeval) { .tv_sec = 60 });
 	if (!NT_STATUS_IS_OK(status)) {
 		DBG_WARNING("g_lock_lock(G_LOCK_READ) failed: %s\n",
@@ -1627,6 +1632,8 @@ extern void build_options(bool screen);
 	struct tevent_signal *se;
 	int profiling_level;
 	char *np_dir = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	static const struct smbd_shim smbd_shim_fns =
 	{
 		.send_stat_cache_delete_message = smbd_send_stat_cache_delete_message,
@@ -1740,7 +1747,7 @@ extern void build_options(bool screen);
 	gain_root_group_privilege();
 
 	fault_setup();
-	dump_core_setup("smbd", lp_logfile(talloc_tos()));
+	dump_core_setup("smbd", lp_logfile(talloc_tos(), lp_sub));
 
 	/* we are never interested in SIGPIPE */
 	BlockSignals(True,SIGPIPE);
@@ -2019,7 +2026,8 @@ extern void build_options(bool screen);
 	   after the fork on every single connection.  This is a small
 	   performance improvment and reduces the total number of system
 	   fds used. */
-	if (!share_info_db_init()) {
+	status = share_info_db_init();
+	if (!NT_STATUS_IS_OK(status)) {
 		exit_daemon("ERROR: failed to load share info db.", EACCES);
 	}
 
diff --git a/source3/smbd/server_reload.c b/source3/smbd/server_reload.c
index 0f0621e3e81..6e6f68e5716 100644
--- a/source3/smbd/server_reload.c
+++ b/source3/smbd/server_reload.c
@@ -58,6 +58,8 @@ void delete_and_reload_printers(void)
 	bool ok;
 	time_t pcap_last_update;
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	ok = pcap_cache_loaded(&pcap_last_update);
 	if (!ok) {
@@ -96,7 +98,7 @@ void delete_and_reload_printers(void)
 			continue;
 		}
 
-		pname = lp_printername(frame, snum);
+		pname = lp_printername(frame, lp_sub, snum);
 
 		/* check printer, but avoid removing non-autoloaded printers */
 		if (lp_autoloaded(snum) && !pcap_printername_ok(pname)) {
@@ -118,11 +120,13 @@ bool reload_services(struct smbd_server_connection *sconn,
 		     bool (*snumused) (struct smbd_server_connection *, int),
 		     bool test)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smbXsrv_connection *xconn = NULL;
 	bool ret;
 
 	if (lp_loaded()) {
-		char *fname = lp_next_configfile(talloc_tos());
+		char *fname = lp_next_configfile(talloc_tos(), lp_sub);
 		if (file_exist(fname) &&
 		    !strcsequal(fname, get_dyn_CONFIGFILE())) {
 			set_dyn_CONFIGFILE(fname);
diff --git a/source3/smbd/service.c b/source3/smbd/service.c
index 1a708fc622c..1abc23ad422 100644
--- a/source3/smbd/service.c
+++ b/source3/smbd/service.c
@@ -270,13 +270,15 @@ static NTSTATUS find_forced_group(bool force_user,
 {
 	NTSTATUS result = NT_STATUS_NO_SUCH_GROUP;
 	TALLOC_CTX *frame = talloc_stackframe();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct dom_sid group_sid;
 	enum lsa_SidType type;
 	char *groupname;
 	bool user_must_be_member = False;
 	gid_t gid;
 
-	groupname = lp_force_group(talloc_tos(), snum);
+	groupname = lp_force_group(talloc_tos(), lp_sub, snum);
 	if (groupname == NULL) {
 		DEBUG(1, ("talloc_strdup failed\n"));
 		result = NT_STATUS_NO_MEMORY;
@@ -405,9 +407,11 @@ static NTSTATUS create_connection_session_info(struct smbd_server_connection *sc
 
 NTSTATUS set_conn_force_user_group(connection_struct *conn, int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	NTSTATUS status;
 
-	if (*lp_force_user(talloc_tos(), snum)) {
+	if (*lp_force_user(talloc_tos(), lp_sub, snum)) {
 
 		/*
 		 * Replace conn->session_info with a completely faked up one
@@ -419,7 +423,7 @@ NTSTATUS set_conn_force_user_group(connection_struct *conn, int snum)
 		struct auth_session_info *forced_serverinfo;
 		bool guest;
 
-		fuser = talloc_string_sub(conn, lp_force_user(talloc_tos(), snum), "%S",
+		fuser = talloc_string_sub(conn, lp_force_user(talloc_tos(), lp_sub, snum), "%S",
 					  lp_const_servicename(snum));
 		if (fuser == NULL) {
 			return NT_STATUS_NO_MEMORY;
@@ -457,7 +461,7 @@ NTSTATUS set_conn_force_user_group(connection_struct *conn, int snum)
 	 * any groupid stored for the connecting user.
 	 */
 
-	if (*lp_force_group(talloc_tos(), snum)) {
+	if (*lp_force_group(talloc_tos(), lp_sub, snum)) {
 
 		status = find_forced_group(
 			conn->force_user, snum, conn->session_info->unix_info->unix_name,
@@ -526,10 +530,13 @@ static NTSTATUS notify_init_sconn(struct smbd_server_connection *sconn)
 
 static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 					connection_struct *conn,
-					int snum, struct user_struct *vuser,
+					int snum,
+					struct smbXsrv_session *session,
 					const char *pdev)
 {
 	struct smbd_server_connection *sconn = xconn->client->sconn;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smb_filename *smb_fname_cpath = NULL;
 	fstring dev;
 	int ret;
@@ -551,7 +558,7 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 	conn->params->service = snum;
 
 	status = create_connection_session_info(sconn,
-		conn, snum, vuser->session_info,
+		conn, snum, session->global->auth_session_info,
 		&conn->session_info);
 
 	if (!NT_STATUS_IS_OK(status)) {
@@ -608,7 +615,7 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 		goto err_root_exit;
 	}
 
-	conn->vuid = vuser->vuid;
+	conn->vuid = session->global->session_wire_id;
 
 	{
 		char *s = talloc_sub_full(talloc_tos(),
@@ -618,7 +625,7 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 					conn->session_info->unix_token->gid,
 					conn->session_info->unix_info->sanitized_username,
 					conn->session_info->info->domain_name,
-					lp_path(talloc_tos(), snum));
+					lp_path(talloc_tos(), lp_sub, snum));
 		if (!s) {
 			status = NT_STATUS_NO_MEMORY;
 			goto err_root_exit;
@@ -647,7 +654,7 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 	 */
 
 	status = check_user_share_access(conn,
-					vuser->session_info,
+					session->global->auth_session_info,
 					&conn->share_access,
 					&conn->read_only);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -726,7 +733,7 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 	/* Preexecs are done here as they might make the dir we are to ChDir
 	 * to below */
 	/* execute any "root preexec = " line */
-	if (*lp_root_preexec(talloc_tos(), snum)) {
+	if (*lp_root_preexec(talloc_tos(), lp_sub, snum)) {
 		char *cmd = talloc_sub_full(talloc_tos(),
 					lp_const_servicename(SNUM(conn)),
 					conn->session_info->unix_info->unix_name,
@@ -734,7 +741,7 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 					conn->session_info->unix_token->gid,
 					conn->session_info->unix_info->sanitized_username,
 					conn->session_info->info->domain_name,
-					lp_root_preexec(talloc_tos(), snum));
+					lp_root_preexec(talloc_tos(), lp_sub, snum));
 		DEBUG(5,("cmd=%s\n",cmd));
 		ret = smbrun(cmd, NULL, NULL);
 		TALLOC_FREE(cmd);
@@ -764,7 +771,7 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 	 * to below */
 
 	/* execute any "preexec = " line */
-	if (*lp_preexec(talloc_tos(), snum)) {
+	if (*lp_preexec(talloc_tos(), lp_sub, snum)) {
 		char *cmd = talloc_sub_full(talloc_tos(),
 					lp_const_servicename(SNUM(conn)),
 					conn->session_info->unix_info->unix_name,
@@ -772,7 +779,7 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 					conn->session_info->unix_token->gid,
 					conn->session_info->unix_info->sanitized_username,
 					conn->session_info->info->domain_name,
-					lp_preexec(talloc_tos(), snum));
+					lp_preexec(talloc_tos(), lp_sub, snum));
 		ret = smbrun(cmd, NULL, NULL);
 		TALLOC_FREE(cmd);
 		if (ret != 0 && lp_preexec_close(snum)) {
@@ -818,13 +825,13 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 	/* Add veto/hide lists */
 	if (!IS_IPC(conn) && !IS_PRINT(conn)) {
 		set_namearray( &conn->veto_list,
-			       lp_veto_files(talloc_tos(), snum));
+			       lp_veto_files(talloc_tos(), lp_sub, snum));
 		set_namearray( &conn->hide_list,
-			       lp_hide_files(talloc_tos(), snum));
+			       lp_hide_files(talloc_tos(), lp_sub, snum));
 		set_namearray( &conn->veto_oplock_list,
-			       lp_veto_oplock_files(talloc_tos(), snum));
+			       lp_veto_oplock_files(talloc_tos(), lp_sub, snum));
 		set_namearray( &conn->aio_write_behind_list,
-				lp_aio_write_behind(talloc_tos(), snum));
+				lp_aio_write_behind(talloc_tos(), lp_sub, snum));
 	}
 	smb_fname_cpath = synthetic_smb_fname(talloc_tos(),
 					conn->connectpath,
@@ -912,10 +919,12 @@ static NTSTATUS make_connection_snum(struct smbXsrv_connection *xconn,
 
 static connection_struct *make_connection_smb1(struct smb_request *req,
 					NTTIME now,
-					int snum, struct user_struct *vuser,
+					int snum,
 					const char *pdev,
 					NTSTATUS *pstatus)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smbXsrv_tcon *tcon;
 	NTSTATUS status;
 	struct connection_struct *conn;
@@ -943,7 +952,7 @@ static connection_struct *make_connection_smb1(struct smb_request *req,
 	*pstatus = make_connection_snum(req->xconn,
 					conn,
 					snum,
-					vuser,
+					req->session,
 					pdev);
 	if (!NT_STATUS_IS_OK(*pstatus)) {
 		conn_free(conn);
@@ -951,7 +960,7 @@ static connection_struct *make_connection_smb1(struct smb_request *req,
 		return NULL;
 	}
 
-	tcon->global->share_name = lp_servicename(tcon->global, SNUM(conn));
+	tcon->global->share_name = lp_servicename(tcon->global, lp_sub, SNUM(conn));
 	if (tcon->global->share_name == NULL) {
 		conn_free(conn);
 		TALLOC_FREE(tcon);
@@ -959,7 +968,7 @@ static connection_struct *make_connection_smb1(struct smb_request *req,
 		return NULL;
 	}
 	tcon->global->session_global_id =
-		vuser->session->global->session_global_id;
+		req->session->global->session_global_id;
 
 	tcon->compat = talloc_move(tcon, &conn);
 	tcon->status = NT_STATUS_OK;
@@ -981,7 +990,6 @@ static connection_struct *make_connection_smb1(struct smb_request *req,
 connection_struct *make_connection_smb2(struct smbd_smb2_request *req,
 					struct smbXsrv_tcon *tcon,
 					int snum,
-					struct user_struct *vuser,
 					const char *pdev,
 					NTSTATUS *pstatus)
 {
@@ -999,7 +1007,7 @@ connection_struct *make_connection_smb2(struct smbd_smb2_request *req,
 	*pstatus = make_connection_snum(req->xconn,
 					conn,
 					snum,
-					vuser,
+					req->session,
 					pdev);
 	if (!NT_STATUS_IS_OK(*pstatus)) {
 		conn_free(conn);
@@ -1021,8 +1029,10 @@ connection_struct *make_connection(struct smb_request *req,
 				   NTSTATUS *status)
 {
 	struct smbd_server_connection *sconn = req->sconn;
+	struct smbXsrv_session *session = req->session;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	uid_t euid;
-	struct user_struct *vuser = NULL;
 	char *service = NULL;
 	fstring dev;
 	int snum = -1;
@@ -1042,8 +1052,7 @@ connection_struct *make_connection(struct smb_request *req,
 		return NULL;
 	}
 
-	vuser = get_valid_user_struct(sconn, vuid);
-	if (!vuser) {
+	if (session == NULL) {
 		DEBUG(1,("make_connection: refusing to connect with "
 			 "no session setup\n"));
 		*status = NT_STATUS_ACCESS_DENIED;
@@ -1054,13 +1063,10 @@ connection_struct *make_connection(struct smb_request *req,
 	   without too many getpwnam() lookups.  This is particulary nasty for
 	   winbind usernames, where the share name isn't the same as unix
 	   username.
-
-	   The snum of the homes share is stored on the vuser at session setup
-	   time.
 	*/
 
 	if (strequal(service_in,HOMES_NAME)) {
-		if (vuser->homes_snum == -1) {
+		if (session->homes_snum == -1) {
 			DEBUG(2, ("[homes] share not available for "
 				  "this user because it was not found "
 				  "or created at session setup "
@@ -1071,17 +1077,15 @@ connection_struct *make_connection(struct smb_request *req,
 		DEBUG(5, ("making a connection to [homes] service "
 			  "created at session setup time\n"));
 		return make_connection_smb1(req, now,
-					    vuser->homes_snum,
-					    vuser,
+					    session->homes_snum,
 					    dev, status);
-	} else if ((vuser->homes_snum != -1)
+	} else if ((session->homes_snum != -1)
 		   && strequal(service_in,
-			       lp_const_servicename(vuser->homes_snum))) {
+			       lp_const_servicename(session->homes_snum))) {
 		DEBUG(5, ("making a connection to 'homes' service [%s] "
 			  "created at session setup time\n", service_in));
 		return make_connection_smb1(req, now,
-					    vuser->homes_snum,
-					    vuser,
+					    session->homes_snum,
 					    dev, status);
 	}
 
@@ -1121,17 +1125,17 @@ connection_struct *make_connection(struct smb_request *req,
 	}
 
 	/* Handle non-Dfs clients attempting connections to msdfs proxy */
-	if (lp_host_msdfs() && (*lp_msdfs_proxy(talloc_tos(), snum) != '\0'))  {
+	if (lp_host_msdfs() && (*lp_msdfs_proxy(talloc_tos(), lp_sub, snum) != '\0'))  {
 		DEBUG(3, ("refusing connection to dfs proxy share '%s' "
 			  "(pointing to %s)\n", 
-			service, lp_msdfs_proxy(talloc_tos(), snum)));
+			service, lp_msdfs_proxy(talloc_tos(), lp_sub, snum)));
 		*status = NT_STATUS_BAD_NETWORK_NAME;
 		return NULL;
 	}
 
 	DEBUG(5, ("making a connection to 'normal' service %s\n", service));
 
-	return make_connection_smb1(req, now, snum, vuser,
+	return make_connection_smb1(req, now, snum,
 				    dev, status);
 }
 
@@ -1143,6 +1147,8 @@ void close_cnum(connection_struct *conn, uint64_t vuid)
 {
 	char rootpath[2] = { '/', '\0'};
 	struct smb_filename root_fname = { .base_name = rootpath };
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	file_close_conn(conn);
 
@@ -1161,7 +1167,7 @@ void close_cnum(connection_struct *conn, uint64_t vuid)
 	SMB_VFS_DISCONNECT(conn);
 
 	/* execute any "postexec = " line */
-	if (*lp_postexec(talloc_tos(), SNUM(conn)) &&
+	if (*lp_postexec(talloc_tos(), lp_sub, SNUM(conn)) &&
 	    change_to_user_and_service(conn, vuid))  {
 		char *cmd = talloc_sub_full(talloc_tos(),
 					lp_const_servicename(SNUM(conn)),
@@ -1170,7 +1176,7 @@ void close_cnum(connection_struct *conn, uint64_t vuid)
 					conn->session_info->unix_token->gid,
 					conn->session_info->unix_info->sanitized_username,
 					conn->session_info->info->domain_name,
-					lp_postexec(talloc_tos(), SNUM(conn)));
+					lp_postexec(talloc_tos(), lp_sub, SNUM(conn)));
 		smbrun(cmd, NULL, NULL);
 		TALLOC_FREE(cmd);
 		change_to_root_user();
@@ -1178,7 +1184,7 @@ void close_cnum(connection_struct *conn, uint64_t vuid)
 
 	change_to_root_user();
 	/* execute any "root postexec = " line */
-	if (*lp_root_postexec(talloc_tos(), SNUM(conn)))  {
+	if (*lp_root_postexec(talloc_tos(), lp_sub, SNUM(conn)))  {
 		char *cmd = talloc_sub_full(talloc_tos(),
 					lp_const_servicename(SNUM(conn)),
 					conn->session_info->unix_info->unix_name,
@@ -1186,7 +1192,7 @@ void close_cnum(connection_struct *conn, uint64_t vuid)
 					conn->session_info->unix_token->gid,
 					conn->session_info->unix_info->sanitized_username,
 					conn->session_info->info->domain_name,
-					lp_root_postexec(talloc_tos(), SNUM(conn)));
+					lp_root_postexec(talloc_tos(), lp_sub, SNUM(conn)));
 		smbrun(cmd, NULL, NULL);
 		TALLOC_FREE(cmd);
 	}
diff --git a/source3/smbd/sesssetup.c b/source3/smbd/sesssetup.c
index 390933cd6cd..8efed438a52 100644
--- a/source3/smbd/sesssetup.c
+++ b/source3/smbd/sesssetup.c
@@ -302,24 +302,11 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
 			data_blob_clear_free(&session_info->session_key);
 		}
 
-		session->compat = talloc_zero(session, struct user_struct);
-		if (session->compat == NULL) {
-			data_blob_free(&out_blob);
-			TALLOC_FREE(session);
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			return;
-		}
-		session->compat->session = session;
-		session->compat->homes_snum = -1;
-		session->compat->session_info = session_info;
-		session->compat->session_keystr = NULL;
-		session->compat->vuid = session->global->session_wire_id;
-		DLIST_ADD(sconn->users, session->compat);
 		sconn->num_users++;
 
 		if (security_session_user_level(session_info, NULL) >= SECURITY_USER) {
 			is_authenticated = true;
-			session->compat->homes_snum =
+			session->homes_snum =
 				register_homes_share(session_info->unix_info->unix_name);
 		}
 
@@ -357,7 +344,7 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
 
 		if (!session_claim(session)) {
 			DEBUG(1, ("smb1: Failed to claim session for vuid=%llu\n",
-				  (unsigned long long)session->compat->vuid));
+				  (unsigned long long)session->global->session_wire_id));
 			data_blob_free(&out_blob);
 			TALLOC_FREE(session);
 			reply_nterror(req, NT_STATUS_LOGON_FAILURE);
@@ -367,7 +354,7 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
 		status = smbXsrv_session_update(session);
 		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(0, ("smb1: Failed to update session for vuid=%llu - %s\n",
-				  (unsigned long long)session->compat->vuid,
+				  (unsigned long long)session->global->session_wire_id,
 				  nt_errstr(status)));
 			data_blob_free(&out_blob);
 			TALLOC_FREE(session);
@@ -415,12 +402,8 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
 		talloc_steal(session_info, session_info->session_key.data);
 		TALLOC_FREE(session->global->auth_session_info);
 
-		session->compat->session_info = session_info;
-
-		session->compat->vuid = session->global->session_wire_id;
-
 		if (security_session_user_level(session_info, NULL) >= SECURITY_USER) {
-			session->compat->homes_snum =
+			session->homes_snum =
 				register_homes_share(session_info->unix_info->unix_name);
 		}
 
@@ -446,7 +429,7 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
 		status = smbXsrv_session_update(session);
 		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(0, ("smb1: Failed to update session for vuid=%llu - %s\n",
-				  (unsigned long long)session->compat->vuid,
+				  (unsigned long long)session->global->session_wire_id,
 				  nt_errstr(status)));
 			data_blob_free(&out_blob);
 			TALLOC_FREE(session);
@@ -454,7 +437,7 @@ static void reply_sesssetup_and_X_spnego(struct smb_request *req)
 			return;
 		}
 
-		conn_clear_vuid_caches(sconn, session->compat->vuid);
+		conn_clear_vuid_caches(sconn, session->global->session_wire_id);
 
 		/* current_user_info is changed on new vuid */
 		reload_services(sconn, conn_snum_used, true);
@@ -1064,24 +1047,11 @@ void reply_sesssetup_and_X(struct smb_request *req)
 		}
 	}
 
-	session->compat = talloc_zero(session, struct user_struct);
-	if (session->compat == NULL) {
-		TALLOC_FREE(session);
-		reply_nterror(req, NT_STATUS_NO_MEMORY);
-		END_PROFILE(SMBsesssetupX);
-		return;
-	}
-	session->compat->session = session;
-	session->compat->homes_snum = -1;
-	session->compat->session_info = session_info;
-	session->compat->session_keystr = NULL;
-	session->compat->vuid = session->global->session_wire_id;
-	DLIST_ADD(sconn->users, session->compat);
 	sconn->num_users++;
 
 	if (security_session_user_level(session_info, NULL) >= SECURITY_USER) {
 		is_authenticated = true;
-		session->compat->homes_snum =
+		session->homes_snum =
 			register_homes_share(session_info->unix_info->unix_name);
 	}
 
@@ -1114,7 +1084,7 @@ void reply_sesssetup_and_X(struct smb_request *req)
 	nt_status = smbXsrv_session_update(session);
 	if (!NT_STATUS_IS_OK(nt_status)) {
 		DEBUG(0, ("smb1: Failed to update session for vuid=%llu - %s\n",
-			  (unsigned long long)session->compat->vuid,
+			  (unsigned long long)session->global->session_wire_id,
 			  nt_errstr(nt_status)));
 		TALLOC_FREE(session);
 		reply_nterror(req, nt_status_squash(nt_status));
@@ -1124,7 +1094,7 @@ void reply_sesssetup_and_X(struct smb_request *req)
 
 	if (!session_claim(session)) {
 		DEBUG(1, ("smb1: Failed to claim session for vuid=%llu\n",
-			  (unsigned long long)session->compat->vuid));
+			  (unsigned long long)session->global->session_wire_id));
 		TALLOC_FREE(session);
 		reply_nterror(req, NT_STATUS_LOGON_FAILURE);
 		END_PROFILE(SMBsesssetupX);
diff --git a/source3/smbd/share_access.c b/source3/smbd/share_access.c
index 3cbf7f318a2..0b8f6e48e34 100644
--- a/source3/smbd/share_access.c
+++ b/source3/smbd/share_access.c
@@ -194,9 +194,12 @@ bool token_contains_name_in_list(const char *username,
 bool user_ok_token(const char *username, const char *domain,
 		   const struct security_token *token, int snum)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
 	if (lp_invalid_users(snum) != NULL) {
 		if (token_contains_name_in_list(username, domain,
-						lp_servicename(talloc_tos(), snum),
+						lp_servicename(talloc_tos(), lp_sub, snum),
 						token,
 						lp_invalid_users(snum))) {
 			DEBUG(10, ("User %s in 'invalid users'\n", username));
@@ -206,7 +209,7 @@ bool user_ok_token(const char *username, const char *domain,
 
 	if (lp_valid_users(snum) != NULL) {
 		if (!token_contains_name_in_list(username, domain,
-						 lp_servicename(talloc_tos(), snum),
+						 lp_servicename(talloc_tos(), lp_sub, snum),
 						 token,
 						 lp_valid_users(snum))) {
 			DEBUG(10, ("User %s not in 'valid users'\n",
@@ -216,7 +219,7 @@ bool user_ok_token(const char *username, const char *domain,
 	}
 
 	DEBUG(10, ("user_ok_token: share %s is ok for unix user %s\n",
-		   lp_servicename(talloc_tos(), snum), username));
+		   lp_servicename(talloc_tos(), lp_sub, snum), username));
 
 	return True;
 }
@@ -240,12 +243,14 @@ bool is_share_read_only_for_token(const char *username,
 				  const struct security_token *token,
 				  connection_struct *conn)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int snum = SNUM(conn);
 	bool result = conn->read_only;
 
 	if (lp_read_list(snum) != NULL) {
 		if (token_contains_name_in_list(username, domain,
-						lp_servicename(talloc_tos(), snum),
+						lp_servicename(talloc_tos(), lp_sub, snum),
 						token,
 						lp_read_list(snum))) {
 			result = True;
@@ -254,7 +259,7 @@ bool is_share_read_only_for_token(const char *username,
 
 	if (lp_write_list(snum) != NULL) {
 		if (token_contains_name_in_list(username, domain,
-						lp_servicename(talloc_tos(), snum),
+						lp_servicename(talloc_tos(), lp_sub, snum),
 						token,
 						lp_write_list(snum))) {
 			result = False;
@@ -262,7 +267,7 @@ bool is_share_read_only_for_token(const char *username,
 	}
 
 	DEBUG(10,("is_share_read_only_for_user: share %s is %s for unix user "
-		  "%s\n", lp_servicename(talloc_tos(), snum),
+		  "%s\n", lp_servicename(talloc_tos(), lp_sub, snum),
 		  result ? "read-only" : "read-write", username));
 
 	return result;
diff --git a/source3/smbd/smb2_close.c b/source3/smbd/smb2_close.c
index 93539d48845..ae0873e3bbe 100644
--- a/source3/smbd/smb2_close.c
+++ b/source3/smbd/smb2_close.c
@@ -132,14 +132,14 @@ static void smbd_smb2_request_close_done(struct tevent_req *subreq)
 	SSVAL(outbody.data, 0x00, 0x3C);	/* struct size */
 	SSVAL(outbody.data, 0x02, out_flags);
 	SIVAL(outbody.data, 0x04, 0);		/* reserved */
-	put_long_date_timespec(conn->ts_res,
-		(char *)outbody.data + 0x08, out_creation_ts);
-	put_long_date_timespec(conn->ts_res,
-		(char *)outbody.data + 0x10, out_last_access_ts);
-	put_long_date_timespec(conn->ts_res,
-		(char *)outbody.data + 0x18, out_last_write_ts);
-	put_long_date_timespec(conn->ts_res,
-		(char *)outbody.data + 0x20, out_change_ts);
+	put_long_date_full_timespec(conn->ts_res,
+		(char *)outbody.data + 0x08, &out_creation_ts);
+	put_long_date_full_timespec(conn->ts_res,
+		(char *)outbody.data + 0x10, &out_last_access_ts);
+	put_long_date_full_timespec(conn->ts_res,
+		(char *)outbody.data + 0x18, &out_last_write_ts);
+	put_long_date_full_timespec(conn->ts_res,
+		(char *)outbody.data + 0x20, &out_change_ts);
 	SBVAL(outbody.data, 0x28, out_allocation_size);
 	SBVAL(outbody.data, 0x30, out_end_of_file);
 	SIVAL(outbody.data, 0x38, out_file_attributes);
diff --git a/source3/smbd/smb2_create.c b/source3/smbd/smb2_create.c
index 6cf3499c411..bf0c3912c07 100644
--- a/source3/smbd/smb2_create.c
+++ b/source3/smbd/smb2_create.c
@@ -372,18 +372,18 @@ static void smbd_smb2_request_create_done(struct tevent_req *tsubreq)
 	SCVAL(outbody.data, 0x03, 0);		/* reserved */
 	SIVAL(outbody.data, 0x04,
 	      out_create_action);		/* create action */
-	put_long_date_timespec(conn->ts_res,
+	put_long_date_full_timespec(conn->ts_res,
 	      (char *)outbody.data + 0x08,
-	      out_creation_ts);			/* creation time */
-	put_long_date_timespec(conn->ts_res,
+	      &out_creation_ts);		/* creation time */
+	put_long_date_full_timespec(conn->ts_res,
 	      (char *)outbody.data + 0x10,
-	      out_last_access_ts);		/* last access time */
-	put_long_date_timespec(conn->ts_res,
+	      &out_last_access_ts);		/* last access time */
+	put_long_date_full_timespec(conn->ts_res,
 	      (char *)outbody.data + 0x18,
-	      out_last_write_ts);		/* last write time */
-	put_long_date_timespec(conn->ts_res,
+	      &out_last_write_ts);		/* last write time */
+	put_long_date_full_timespec(conn->ts_res,
 	      (char *)outbody.data + 0x20,
-	      out_change_ts);			/* change time */
+	      &out_change_ts);			/* change time */
 	SBVAL(outbody.data, 0x28,
 	      out_allocation_size);		/* allocation size */
 	SBVAL(outbody.data, 0x30,
@@ -1325,8 +1325,8 @@ static void smbd_smb2_create_after_exec(struct tevent_req *req)
 	if (state->mxac != NULL) {
 		NTTIME last_write_time;
 
-		last_write_time = unix_timespec_to_nt_time(
-			state->result->fsp_name->st.st_ex_mtime);
+		last_write_time = full_timespec_to_nt_time(
+			&state->result->fsp_name->st.st_ex_mtime);
 		if (last_write_time != state->max_access_time) {
 			uint8_t p[8];
 			uint32_t max_access_granted;
diff --git a/source3/smbd/smb2_glue.c b/source3/smbd/smb2_glue.c
index 6a73ec050e2..85f83c46205 100644
--- a/source3/smbd/smb2_glue.c
+++ b/source3/smbd/smb2_glue.c
@@ -41,11 +41,12 @@ struct smb_request *smbd_smb2_fake_smb_request(struct smbd_smb2_request *req)
 	}
 
 	smbreq->request_time = req->request_time;
-	smbreq->vuid = req->session->compat->vuid;
+	smbreq->vuid = req->session->global->session_wire_id;
 	smbreq->tid = req->tcon->compat->cnum;
 	smbreq->conn = req->tcon->compat;
 	smbreq->sconn = req->sconn;
 	smbreq->xconn = req->xconn;
+	smbreq->session = req->session;
 	smbreq->smbpid = (uint16_t)IVAL(inhdr, SMB2_HDR_PID);
 	smbreq->flags2 = FLAGS2_UNICODE_STRINGS |
 			 FLAGS2_32_BIT_ERROR_CODES |
diff --git a/source3/smbd/smb2_lock.c b/source3/smbd/smb2_lock.c
index 162748496c2..d1e63015753 100644
--- a/source3/smbd/smb2_lock.c
+++ b/source3/smbd/smb2_lock.c
@@ -546,8 +546,8 @@ static void smbd_smb2_lock_try(struct tevent_req *req)
 setup_retry:
 	DBG_DEBUG("Watching share mode lock\n");
 
-	subreq = dbwrap_watched_watch_send(
-		state, state->ev, lck->data->record, blocking_pid);
+	subreq = share_mode_watch_send(
+		state, state->ev, lck->data->id, blocking_pid);
 	TALLOC_FREE(lck);
 	if (tevent_req_nomem(subreq, req)) {
 		return;
@@ -585,7 +585,7 @@ static void smbd_smb2_lock_retry(struct tevent_req *subreq)
 		return;
 	}
 
-	status = dbwrap_watched_watch_recv(subreq, NULL, NULL);
+	status = share_mode_watch_recv(subreq, NULL, NULL);
 	TALLOC_FREE(subreq);
 	if (NT_STATUS_EQUAL(status, NT_STATUS_IO_TIMEOUT)) {
 		/*
diff --git a/source3/smbd/smb2_negprot.c b/source3/smbd/smb2_negprot.c
index 6e7201b1cd8..2c1d4185b28 100644
--- a/source3/smbd/smb2_negprot.c
+++ b/source3/smbd/smb2_negprot.c
@@ -36,7 +36,7 @@ extern fstring remote_proto;
  * this is the entry point if SMB2 is selected via
  * the SMB negprot and the given dialect.
  */
-static void reply_smb20xx(struct smb_request *req, uint16_t dialect)
+static NTSTATUS reply_smb20xx(struct smb_request *req, uint16_t dialect)
 {
 	uint8_t *smb2_inpdu;
 	uint8_t *smb2_hdr;
@@ -48,7 +48,7 @@ static void reply_smb20xx(struct smb_request *req, uint16_t dialect)
 	if (smb2_inpdu == NULL) {
 		DEBUG(0, ("Could not push spnego blob\n"));
 		reply_nterror(req, NT_STATUS_NO_MEMORY);
-		return;
+		return NT_STATUS_NO_MEMORY;
 	}
 	smb2_hdr = smb2_inpdu;
 	smb2_body = smb2_hdr + SMB2_HDR_BODY;
@@ -64,28 +64,27 @@ static void reply_smb20xx(struct smb_request *req, uint16_t dialect)
 
 	req->outbuf = NULL;
 
-	smbd_smb2_process_negprot(req->xconn, 0, smb2_inpdu, len);
-	return;
+	return smbd_smb2_process_negprot(req->xconn, 0, smb2_inpdu, len);
 }
 
 /*
  * this is the entry point if SMB2 is selected via
  * the SMB negprot and the "SMB 2.002" dialect.
  */
-void reply_smb2002(struct smb_request *req, uint16_t choice)
+NTSTATUS reply_smb2002(struct smb_request *req, uint16_t choice)
 {
-	reply_smb20xx(req, SMB2_DIALECT_REVISION_202);
+	return reply_smb20xx(req, SMB2_DIALECT_REVISION_202);
 }
 
 /*
  * this is the entry point if SMB2 is selected via
  * the SMB negprot and the "SMB 2.???" dialect.
  */
-void reply_smb20ff(struct smb_request *req, uint16_t choice)
+NTSTATUS reply_smb20ff(struct smb_request *req, uint16_t choice)
 {
 	struct smbXsrv_connection *xconn = req->xconn;
 	xconn->smb2.allow_2ff = true;
-	reply_smb20xx(req, SMB2_DIALECT_REVISION_2FF);
+	return reply_smb20xx(req, SMB2_DIALECT_REVISION_2FF);
 }
 
 enum protocol_types smbd_smb2_protocol_dialect_match(const uint8_t *indyn,
diff --git a/source3/smbd/smb2_query_directory.c b/source3/smbd/smb2_query_directory.c
index a8ba5eaa389..79a46e005cf 100644
--- a/source3/smbd/smb2_query_directory.c
+++ b/source3/smbd/smb2_query_directory.c
@@ -263,6 +263,8 @@ static struct tevent_req *smbd_smb2_query_directory_send(TALLOC_CTX *mem_ctx,
 	struct tevent_req *req;
 	struct smbd_smb2_query_directory_state *state;
 	connection_struct *conn = smb2req->tcon->compat;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	NTSTATUS status;
 	bool wcard_has_wild = false;
 	struct tm tm;
@@ -487,9 +489,9 @@ static struct tevent_req *smbd_smb2_query_directory_send(TALLOC_CTX *mem_ctx,
 
 	DEBUG(8,("smbd_smb2_query_directory_send: dirpath=<%s> dontdescend=<%s>, "
 		"in_output_buffer_length = %u\n",
-		fsp->fsp_name->base_name, lp_dont_descend(talloc_tos(), SNUM(conn)),
+		 fsp->fsp_name->base_name, lp_dont_descend(talloc_tos(), lp_sub, SNUM(conn)),
 		(unsigned int)in_output_buffer_length ));
-	if (in_list(fsp->fsp_name->base_name,lp_dont_descend(talloc_tos(), SNUM(conn)),
+	if (in_list(fsp->fsp_name->base_name,lp_dont_descend(talloc_tos(), lp_sub, SNUM(conn)),
 			conn->case_sensitive)) {
 		state->dont_descend = true;
 	}
@@ -928,7 +930,7 @@ static void fetch_write_time_done(struct tevent_req *subreq)
 	write_time = get_share_mode_write_time(lck);
 	TALLOC_FREE(lck);
 
-	if (null_timespec(write_time)) {
+	if (is_omit_timespec(&write_time)) {
 		tevent_req_done(req);
 		return;
 	}
@@ -948,9 +950,9 @@ static void fetch_write_time_done(struct tevent_req *subreq)
 		return;
 	}
 
-	put_long_date_timespec(state->conn->ts_res,
+	put_long_date_full_timespec(state->conn->ts_res,
 			       state->entry_marshall_buf + off,
-			       write_time);
+			       &write_time);
 
 	tevent_req_done(req);
 	return;
@@ -1074,9 +1076,9 @@ static void fetch_dos_mode_done(struct tevent_req *subreq)
 		dos_filetime_timespec(&btime_ts);
 	}
 
-	put_long_date_timespec(state->dir_fsp->conn->ts_res,
+	put_long_date_full_timespec(state->dir_fsp->conn->ts_res,
 			       (char *)state->entry_marshall_buf + btime_off,
-			       btime_ts);
+			       &btime_ts);
 
 	switch (state->info_level) {
 	case SMB_FIND_ID_BOTH_DIRECTORY_INFO:
diff --git a/source3/smbd/smb2_server.c b/source3/smbd/smb2_server.c
index 7044ecb991a..8c66d74c8de 100644
--- a/source3/smbd/smb2_server.c
+++ b/source3/smbd/smb2_server.c
@@ -1882,7 +1882,10 @@ static NTSTATUS smbd_smb2_request_check_tcon(struct smbd_smb2_request *req)
 		return status;
 	}
 
-	if (!change_to_user_and_service(tcon->compat, req->session->compat->vuid)) {
+	if (!change_to_user_and_service(
+		    tcon->compat,
+		    req->session->global->session_wire_id))
+	{
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
@@ -3629,7 +3632,7 @@ static NTSTATUS smbd_smb2_request_next_incoming(struct smbXsrv_connection *xconn
 	return NT_STATUS_OK;
 }
 
-void smbd_smb2_process_negprot(struct smbXsrv_connection *xconn,
+NTSTATUS smbd_smb2_process_negprot(struct smbXsrv_connection *xconn,
 			       uint64_t expected_seq_low,
 			       const uint8_t *inpdu, size_t size)
 {
@@ -3643,25 +3646,25 @@ void smbd_smb2_process_negprot(struct smbXsrv_connection *xconn,
 	status = smbd_initialize_smb2(xconn, expected_seq_low);
 	if (!NT_STATUS_IS_OK(status)) {
 		smbd_server_connection_terminate(xconn, nt_errstr(status));
-		return;
+		return status;
 	}
 
 	status = smbd_smb2_request_create(xconn, inpdu, size, &req);
 	if (!NT_STATUS_IS_OK(status)) {
 		smbd_server_connection_terminate(xconn, nt_errstr(status));
-		return;
+		return status;
 	}
 
 	status = smbd_smb2_request_validate(req);
 	if (!NT_STATUS_IS_OK(status)) {
 		smbd_server_connection_terminate(xconn, nt_errstr(status));
-		return;
+		return status;
 	}
 
 	status = smbd_smb2_request_setup_out(req);
 	if (!NT_STATUS_IS_OK(status)) {
 		smbd_server_connection_terminate(xconn, nt_errstr(status));
-		return;
+		return status;
 	}
 
 #ifdef WITH_PROFILE
@@ -3676,16 +3679,17 @@ void smbd_smb2_process_negprot(struct smbXsrv_connection *xconn,
 	status = smbd_smb2_request_dispatch(req);
 	if (!NT_STATUS_IS_OK(status)) {
 		smbd_server_connection_terminate(xconn, nt_errstr(status));
-		return;
+		return status;
 	}
 
 	status = smbd_smb2_request_next_incoming(xconn);
 	if (!NT_STATUS_IS_OK(status)) {
 		smbd_server_connection_terminate(xconn, nt_errstr(status));
-		return;
+		return status;
 	}
 
 	sconn->num_requests++;
+	return NT_STATUS_OK;
 }
 
 static int socket_error_from_errno(int ret,
diff --git a/source3/smbd/smb2_sesssetup.c b/source3/smbd/smb2_sesssetup.c
index 82ac1182ecc..3fa1a15910e 100644
--- a/source3/smbd/smb2_sesssetup.c
+++ b/source3/smbd/smb2_sesssetup.c
@@ -525,20 +525,10 @@ static NTSTATUS smbd_smb2_auth_generic_return(struct smbXsrv_session *session,
 	}
 	talloc_keep_secret(session_info->session_key.data);
 
-	session->compat = talloc_zero(session, struct user_struct);
-	if (session->compat == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-	session->compat->session = session;
-	session->compat->homes_snum = -1;
-	session->compat->session_info = session_info;
-	session->compat->session_keystr = NULL;
-	session->compat->vuid = session->global->session_wire_id;
-	DLIST_ADD(smb2req->sconn->users, session->compat);
 	smb2req->sconn->num_users++;
 
 	if (security_session_user_level(session_info, NULL) >= SECURITY_USER) {
-		session->compat->homes_snum =
+		session->homes_snum =
 			register_homes_share(session_info->unix_info->unix_name);
 	}
 
@@ -565,7 +555,7 @@ static NTSTATUS smbd_smb2_auth_generic_return(struct smbXsrv_session *session,
 	if (!session_claim(session)) {
 		DEBUG(1, ("smb2: Failed to claim session "
 			"for vuid=%llu\n",
-			(unsigned long long)session->compat->vuid));
+			(unsigned long long)session->global->session_wire_id));
 		return NT_STATUS_LOGON_FAILURE;
 	}
 
@@ -573,7 +563,7 @@ static NTSTATUS smbd_smb2_auth_generic_return(struct smbXsrv_session *session,
 	status = smbXsrv_session_update(session);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0, ("smb2: Failed to update session for vuid=%llu - %s\n",
-			  (unsigned long long)session->compat->vuid,
+			  (unsigned long long)session->global->session_wire_id,
 			  nt_errstr(status)));
 		return NT_STATUS_LOGON_FAILURE;
 	}
@@ -617,10 +607,7 @@ static NTSTATUS smbd_smb2_reauth_generic_return(struct smbXsrv_session *session,
 	}
 	talloc_keep_secret(session_info->session_key.data);
 
-	session->compat->session_info = session_info;
-	session->compat->vuid = session->global->session_wire_id;
-
-	session->compat->homes_snum =
+	session->homes_snum =
 			register_homes_share(session_info->unix_info->unix_name);
 
 	set_current_user_info(session_info->unix_info->sanitized_username,
@@ -652,12 +639,13 @@ static NTSTATUS smbd_smb2_reauth_generic_return(struct smbXsrv_session *session,
 	status = smbXsrv_session_update(session);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0, ("smb2: Failed to update session for vuid=%llu - %s\n",
-			  (unsigned long long)session->compat->vuid,
+			  (unsigned long long)session->global->session_wire_id,
 			  nt_errstr(status)));
 		return NT_STATUS_LOGON_FAILURE;
 	}
 
-	conn_clear_vuid_caches(xconn->client->sconn, session->compat->vuid);
+	conn_clear_vuid_caches(xconn->client->sconn,
+			       session->global->session_wire_id);
 
 	*out_session_id = session->global->session_wire_id;
 
@@ -792,7 +780,7 @@ static NTSTATUS smbd_smb2_bind_auth_return(struct smbXsrv_session *session,
 	status = smbXsrv_session_update(session);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0, ("smb2: Failed to update session for vuid=%llu - %s\n",
-			  (unsigned long long)session->compat->vuid,
+			  (unsigned long long)session->global->session_wire_id,
 			  nt_errstr(status)));
 		return NT_STATUS_LOGON_FAILURE;
 	}
diff --git a/source3/smbd/smb2_setinfo.c b/source3/smbd/smb2_setinfo.c
index cfb49fb8d14..43dc232a6d6 100644
--- a/source3/smbd/smb2_setinfo.c
+++ b/source3/smbd/smb2_setinfo.c
@@ -265,10 +265,10 @@ static struct tevent_req *delay_rename_for_lease_break(struct tevent_req *req,
 
 	talloc_set_destructor(rename_state, defer_rename_state_destructor);
 
-	subreq = dbwrap_watched_watch_send(
+	subreq = share_mode_watch_send(
 				rename_state,
 				ev,
-				lck->data->record,
+				lck->data->id,
 				(struct server_id){0});
 
 	if (subreq == NULL) {
@@ -296,7 +296,7 @@ static void defer_rename_done(struct tevent_req *subreq)
 	int ret_size = 0;
 	bool ok;
 
-	status = dbwrap_watched_watch_recv(subreq, NULL, NULL);
+	status = share_mode_watch_recv(subreq, NULL, NULL);
 	TALLOC_FREE(subreq);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(5, ("dbwrap_record_watch_recv returned %s\n",
@@ -308,8 +308,9 @@ static void defer_rename_done(struct tevent_req *subreq)
 	/*
 	 * Make sure we run as the user again
 	 */
-	ok = change_to_user_and_service(state->smb2req->tcon->compat,
-					state->smb2req->session->compat->vuid);
+	ok = change_to_user_and_service(
+		state->smb2req->tcon->compat,
+		state->smb2req->session->global->session_wire_id);
 	if (!ok) {
 		tevent_req_nterror(state->req, NT_STATUS_ACCESS_DENIED);
 		return;
diff --git a/source3/smbd/smb2_tcon.c b/source3/smbd/smb2_tcon.c
index c2a5cbc39aa..bf709d8686e 100644
--- a/source3/smbd/smb2_tcon.c
+++ b/source3/smbd/smb2_tcon.c
@@ -191,14 +191,18 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 				       uint32_t *out_tree_id,
 				       bool *disconnect)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smbXsrv_connection *conn = req->xconn;
+	struct smbXsrv_session *session = req->session;
+	struct auth_session_info *session_info =
+		session->global->auth_session_info;
 	const char *share = in_path;
 	char *service = NULL;
 	int snum = -1;
 	struct smbXsrv_tcon *tcon;
 	NTTIME now = timeval_to_nttime(&req->request_time);
 	connection_struct *compat_conn = NULL;
-	struct user_struct *compat_vuser = req->session->compat;
 	NTSTATUS status;
 	bool encryption_desired = req->session->global->encryption_flags & SMBXSRV_ENCRYPTION_DESIRED;
 	bool encryption_required = req->session->global->encryption_flags & SMBXSRV_ENCRYPTION_REQUIRED;
@@ -217,7 +221,7 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 	DEBUG(10,("smbd_smb2_tree_connect: path[%s] share[%s]\n",
 		  in_path, share));
 
-	if (security_session_user_level(compat_vuser->session_info, NULL) < SECURITY_USER) {
+	if (security_session_user_level(session_info, NULL) < SECURITY_USER) {
 		guest_session = true;
 	}
 
@@ -248,19 +252,19 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 
 	/* TODO: do more things... */
 	if (strequal(service,HOMES_NAME)) {
-		if (compat_vuser->homes_snum == -1) {
+		if (session->homes_snum == -1) {
 			DEBUG(2, ("[homes] share not available for "
 				"user %s because it was not found "
 				"or created at session setup "
 				"time\n",
-				compat_vuser->session_info->unix_info->unix_name));
+				session_info->unix_info->unix_name));
 			return NT_STATUS_BAD_NETWORK_NAME;
 		}
-		snum = compat_vuser->homes_snum;
-	} else if ((compat_vuser->homes_snum != -1)
+		snum = session->homes_snum;
+	} else if ((session->homes_snum != -1)
                    && strequal(service,
-			lp_servicename(talloc_tos(), compat_vuser->homes_snum))) {
-		snum = compat_vuser->homes_snum;
+			lp_servicename(talloc_tos(), lp_sub, session->homes_snum))) {
+		snum = session->homes_snum;
 	} else {
 		snum = find_service(talloc_tos(), service, &service);
 		if (!service) {
@@ -276,7 +280,7 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 
 	/* Handle non-DFS clients attempting connections to msdfs proxy */
 	if (lp_host_msdfs()) {
-		char *proxy = lp_msdfs_proxy(talloc_tos(), snum);
+		char *proxy = lp_msdfs_proxy(talloc_tos(), lp_sub, snum);
 
 		if ((proxy != NULL) && (*proxy != '\0')) {
 			DBG_NOTICE("refusing connection to dfs proxy share "
@@ -330,7 +334,6 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 
 	compat_conn = make_connection_smb2(req,
 					tcon, snum,
-					req->session->compat,
 					"???",
 					&status);
 	if (compat_conn == NULL) {
@@ -339,6 +342,7 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 	}
 
 	tcon->global->share_name = lp_servicename(tcon->global,
+						  lp_sub,
 						  SNUM(compat_conn));
 	if (tcon->global->share_name == NULL) {
 		conn_free(compat_conn);
diff --git a/source3/smbd/smbXsrv_session.c b/source3/smbd/smbXsrv_session.c
index 91fa0005737..ba542702213 100644
--- a/source3/smbd/smbXsrv_session.c
+++ b/source3/smbd/smbXsrv_session.c
@@ -1234,6 +1234,7 @@ NTSTATUS smbXsrv_session_create(struct smbXsrv_connection *conn,
 	session->idle_time = now;
 	session->status = NT_STATUS_MORE_PROCESSING_REQUIRED;
 	session->client = conn->client;
+	session->homes_snum = -1;
 
 	status = smbXsrv_session_global_allocate(table->global.db_ctx,
 						 session,
@@ -1661,15 +1662,13 @@ NTSTATUS smbXsrv_session_logoff(struct smbXsrv_session *session)
 	session->client = NULL;
 	session->status = NT_STATUS_USER_SESSION_DELETED;
 
-	if (session->compat) {
-		/*
-		 * For SMB2 this is a bit redundant as files are also close
-		 * below via smb2srv_tcon_disconnect_all() -> ... ->
-		 * smbXsrv_tcon_disconnect() -> close_cnum() ->
-		 * file_close_conn().
-		 */
-		file_close_user(sconn, session->compat->vuid);
-	}
+	/*
+	 * For SMB2 this is a bit redundant as files are also close
+	 * below via smb2srv_tcon_disconnect_all() -> ... ->
+	 * smbXsrv_tcon_disconnect() -> close_cnum() ->
+	 * file_close_conn().
+	 */
+	file_close_user(sconn, session->global->session_wire_id);
 
 	if (session->tcon_table != NULL) {
 		/*
@@ -1685,10 +1684,7 @@ NTSTATUS smbXsrv_session_logoff(struct smbXsrv_session *session)
 		}
 	}
 
-	if (session->compat) {
-		invalidate_vuid(sconn, session->compat->vuid);
-		session->compat = NULL;
-	}
+	invalidate_vuid(sconn, session->global->session_wire_id);
 
 	global_rec = session->global->db_rec;
 	session->global->db_rec = NULL;
@@ -1833,6 +1829,77 @@ static int smbXsrv_session_logoff_all_callback(struct db_record *local_rec,
 	return 0;
 }
 
+struct smbXsrv_session_local_trav_state {
+	NTSTATUS status;
+	int (*caller_cb)(struct smbXsrv_session *session,
+			 void *caller_data);
+	void *caller_data;
+};
+
+static int smbXsrv_session_local_traverse_cb(struct db_record *local_rec,
+					     void *private_data);
+
+NTSTATUS smbXsrv_session_local_traverse(
+	struct smbXsrv_client *client,
+	int (*caller_cb)(struct smbXsrv_session *session,
+			 void *caller_data),
+	void *caller_data)
+{
+	struct smbXsrv_session_table *table = client->session_table;
+	struct smbXsrv_session_local_trav_state state;
+	NTSTATUS status;
+	int count = 0;
+
+	state = (struct smbXsrv_session_local_trav_state) {
+		.status = NT_STATUS_OK,
+		.caller_cb = caller_cb,
+		.caller_data = caller_data,
+	};
+
+	if (table == NULL) {
+		DBG_DEBUG("empty session_table, nothing to do.\n");
+		return NT_STATUS_OK;
+	}
+
+	status = dbwrap_traverse(table->local.db_ctx,
+				 smbXsrv_session_local_traverse_cb,
+				 &state,
+				 &count);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_ERR("dbwrap_traverse() failed: %s\n", nt_errstr(status));
+		return status;
+	}
+	if (!NT_STATUS_IS_OK(state.status)) {
+		DBG_ERR("count[%d] status[%s]\n",
+			count, nt_errstr(state.status));
+		return state.status;
+	}
+
+	return NT_STATUS_OK;
+}
+
+static int smbXsrv_session_local_traverse_cb(struct db_record *local_rec,
+					     void *private_data)
+{
+	struct smbXsrv_session_local_trav_state *state =
+		(struct smbXsrv_session_local_trav_state *)private_data;
+	TDB_DATA val;
+	void *ptr = NULL;
+	struct smbXsrv_session *session = NULL;
+
+	val = dbwrap_record_get_value(local_rec);
+	if (val.dsize != sizeof(ptr)) {
+		state->status = NT_STATUS_INTERNAL_ERROR;
+		return -1;
+	}
+
+	memcpy(&ptr, val.dptr, val.dsize);
+	session = talloc_get_type_abort(ptr, struct smbXsrv_session);
+	session->db_rec = local_rec;
+
+	return state->caller_cb(session, state->caller_data);
+}
+
 NTSTATUS smb1srv_session_table_init(struct smbXsrv_connection *conn)
 {
 	/*
@@ -1853,6 +1920,105 @@ NTSTATUS smb1srv_session_lookup(struct smbXsrv_connection *conn,
 					    session);
 }
 
+NTSTATUS smbXsrv_session_info_lookup(struct smbXsrv_client *client,
+				     uint64_t session_wire_id,
+				     struct auth_session_info **si)
+{
+	struct smbXsrv_session_table *table = client->session_table;
+	uint8_t key_buf[SMBXSRV_SESSION_LOCAL_TDB_KEY_SIZE];
+	struct smbXsrv_session_local_fetch_state state = {
+		.session = NULL,
+		.status = NT_STATUS_INTERNAL_ERROR,
+	};
+	TDB_DATA key;
+	NTSTATUS status;
+
+	if (session_wire_id == 0) {
+		return NT_STATUS_USER_SESSION_DELETED;
+	}
+
+	if (table == NULL) {
+		/* this might happen before the end of negprot */
+		return NT_STATUS_USER_SESSION_DELETED;
+	}
+
+	if (table->local.db_ctx == NULL) {
+		return NT_STATUS_INTERNAL_ERROR;
+	}
+
+	key = smbXsrv_session_local_id_to_key(session_wire_id, key_buf);
+
+	status = dbwrap_parse_record(table->local.db_ctx, key,
+				     smbXsrv_session_local_fetch_parser,
+				     &state);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+	if (!NT_STATUS_IS_OK(state.status)) {
+		return state.status;
+	}
+	if (state.session->global->auth_session_info == NULL) {
+		return NT_STATUS_USER_SESSION_DELETED;
+	}
+
+	*si = state.session->global->auth_session_info;
+	return NT_STATUS_OK;
+}
+
+/*
+ * In memory of get_valid_user_struct()
+ *
+ * This function is similar to smbXsrv_session_local_lookup() and it's wrappers,
+ * but it doesn't implement the state checks of
+ * those. get_valid_smbXsrv_session() is NOT meant to be called to validate the
+ * session wire-id of incoming SMB requests, it MUST only be used in later
+ * internal processing where the session wire-id has already been validated.
+ */
+NTSTATUS get_valid_smbXsrv_session(struct smbXsrv_client *client,
+				   uint64_t session_wire_id,
+				   struct smbXsrv_session **session)
+{
+	struct smbXsrv_session_table *table = client->session_table;
+	uint8_t key_buf[SMBXSRV_SESSION_LOCAL_TDB_KEY_SIZE];
+	struct smbXsrv_session_local_fetch_state state = {
+		.session = NULL,
+		.status = NT_STATUS_INTERNAL_ERROR,
+	};
+	TDB_DATA key;
+	NTSTATUS status;
+
+	if (session_wire_id == 0) {
+		return NT_STATUS_USER_SESSION_DELETED;
+	}
+
+	if (table == NULL) {
+		/* this might happen before the end of negprot */
+		return NT_STATUS_USER_SESSION_DELETED;
+	}
+
+	if (table->local.db_ctx == NULL) {
+		return NT_STATUS_INTERNAL_ERROR;
+	}
+
+	key = smbXsrv_session_local_id_to_key(session_wire_id, key_buf);
+
+	status = dbwrap_parse_record(table->local.db_ctx, key,
+				     smbXsrv_session_local_fetch_parser,
+				     &state);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+	if (!NT_STATUS_IS_OK(state.status)) {
+		return state.status;
+	}
+	if (state.session->global->auth_session_info == NULL) {
+		return NT_STATUS_USER_SESSION_DELETED;
+	}
+
+	*session = state.session;
+	return NT_STATUS_OK;
+}
+
 NTSTATUS smb2srv_session_table_init(struct smbXsrv_connection *conn)
 {
 	/*
diff --git a/source3/smbd/smbXsrv_tcon.c b/source3/smbd/smbXsrv_tcon.c
index f7f4cd2aefb..d6c2bca0abc 100644
--- a/source3/smbd/smbXsrv_tcon.c
+++ b/source3/smbd/smbXsrv_tcon.c
@@ -1168,13 +1168,7 @@ NTSTATUS smb2srv_tcon_lookup(struct smbXsrv_session *session,
 
 NTSTATUS smb2srv_tcon_disconnect_all(struct smbXsrv_session *session)
 {
-	uint64_t vuid;
-
-	if (session->compat) {
-		vuid = session->compat->vuid;
-	} else {
-		vuid = 0;
-	}
+	uint64_t vuid = session->global->session_wire_id;
 
 	return smbXsrv_tcon_disconnect_all(session->tcon_table, vuid);
 }
diff --git a/source3/smbd/trans2.c b/source3/smbd/trans2.c
index d5000e83cb1..2cf669f4b4d 100644
--- a/source3/smbd/trans2.c
+++ b/source3/smbd/trans2.c
@@ -26,6 +26,7 @@
 #include "includes.h"
 #include "ntioctl.h"
 #include "system/filesys.h"
+#include "lib/util/time_basic.h"
 #include "version.h"
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
@@ -2058,10 +2059,10 @@ static NTSTATUS smbd_marshall_dir_entry(TALLOC_CTX *ctx,
 		was_8_3 = mangle_is_8_3(fname, True, conn->params);
 		p += 4;
 		SIVAL(p,0,reskey); p += 4;
-		put_long_date_timespec(conn->ts_res,p,create_date_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,adate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,mdate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,cdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&create_date_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&adate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&mdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&cdate_ts); p += 8;
 		SOFF_T(p,0,file_size); p += 8;
 		SOFF_T(p,0,allocation_size); p += 8;
 		SIVAL(p,0,mode); p += 4;
@@ -2132,10 +2133,10 @@ static NTSTATUS smbd_marshall_dir_entry(TALLOC_CTX *ctx,
 		DEBUG(10,("smbd_marshall_dir_entry: SMB_FIND_FILE_DIRECTORY_INFO\n"));
 		p += 4;
 		SIVAL(p,0,reskey); p += 4;
-		put_long_date_timespec(conn->ts_res,p,create_date_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,adate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,mdate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,cdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&create_date_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&adate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&mdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&cdate_ts); p += 8;
 		SOFF_T(p,0,file_size); p += 8;
 		SOFF_T(p,0,allocation_size); p += 8;
 		SIVAL(p,0,mode); p += 4;
@@ -2171,10 +2172,10 @@ static NTSTATUS smbd_marshall_dir_entry(TALLOC_CTX *ctx,
 		DEBUG(10,("smbd_marshall_dir_entry: SMB_FIND_FILE_FULL_DIRECTORY_INFO\n"));
 		p += 4;
 		SIVAL(p,0,reskey); p += 4;
-		put_long_date_timespec(conn->ts_res,p,create_date_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,adate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,mdate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,cdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&create_date_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&adate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&mdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&cdate_ts); p += 8;
 		SOFF_T(p,0,file_size); p += 8;
 		SOFF_T(p,0,allocation_size); p += 8;
 		SIVAL(p,0,mode); p += 4;
@@ -2254,10 +2255,10 @@ static NTSTATUS smbd_marshall_dir_entry(TALLOC_CTX *ctx,
 		DEBUG(10,("smbd_marshall_dir_entry: SMB_FIND_ID_FULL_DIRECTORY_INFO\n"));
 		p += 4;
 		SIVAL(p,0,reskey); p += 4;
-		put_long_date_timespec(conn->ts_res,p,create_date_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,adate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,mdate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,cdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&create_date_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&adate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&mdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&cdate_ts); p += 8;
 		SOFF_T(p,0,file_size); p += 8;
 		SOFF_T(p,0,allocation_size); p += 8;
 		SIVAL(p,0,mode); p += 4;
@@ -2305,10 +2306,10 @@ static NTSTATUS smbd_marshall_dir_entry(TALLOC_CTX *ctx,
 		was_8_3 = mangle_is_8_3(fname, True, conn->params);
 		p += 4;
 		SIVAL(p,0,reskey); p += 4;
-		put_long_date_timespec(conn->ts_res,p,create_date_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,adate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,mdate_ts); p += 8;
-		put_long_date_timespec(conn->ts_res,p,cdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&create_date_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&adate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&mdate_ts); p += 8;
+		put_long_date_full_timespec(conn->ts_res,p,&cdate_ts); p += 8;
 		SOFF_T(p,0,file_size); p += 8;
 		SOFF_T(p,0,allocation_size); p += 8;
 		SIVAL(p,0,mode); p += 4;
@@ -2721,6 +2722,8 @@ static void call_trans2findfirst(connection_struct *conn,
 	bool backup_priv = false;
 	bool as_root = false;
 	files_struct *fsp = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int ret;
 
 	if (total_params < 13) {
@@ -3008,9 +3011,9 @@ total_data=%u (should be %u)\n", (unsigned int)total_data, (unsigned int)IVAL(pd
 		a different TRANS2 call. */
 
 	DEBUG(8,("dirpath=<%s> dontdescend=<%s>\n",
-		 directory,lp_dont_descend(talloc_tos(), SNUM(conn))));
+		 directory,lp_dont_descend(talloc_tos(), lp_sub, SNUM(conn))));
 	if (in_list(directory,
-			lp_dont_descend(talloc_tos(), SNUM(conn)),
+		    lp_dont_descend(talloc_tos(), lp_sub, SNUM(conn)),
 			conn->case_sensitive)) {
 		dont_descend = True;
 	}
@@ -3203,6 +3206,8 @@ static void call_trans2findnext(connection_struct *conn,
 	bool backup_priv = false; 
 	bool as_root = false;
 	files_struct *fsp = NULL;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	if (total_params < 13) {
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
@@ -3386,8 +3391,8 @@ total_data=%u (should be %u)\n", (unsigned int)total_data, (unsigned int)IVAL(pd
 		a different TRANS2 call. */
 
 	DEBUG(8,("dirpath=<%s> dontdescend=<%s>\n",
-		 directory,lp_dont_descend(ctx, SNUM(conn))));
-	if (in_list(directory,lp_dont_descend(ctx, SNUM(conn)),conn->case_sensitive))
+		 directory,lp_dont_descend(ctx, lp_sub, SNUM(conn))));
+	if (in_list(directory,lp_dont_descend(ctx, lp_sub, SNUM(conn)),conn->case_sensitive))
 		dont_descend = True;
 
 	p = pdata;
@@ -3518,7 +3523,10 @@ total_data=%u (should be %u)\n", (unsigned int)total_data, (unsigned int)IVAL(pd
 
 unsigned char *create_volume_objectid(connection_struct *conn, unsigned char objid[16])
 {
-	E_md4hash(lp_servicename(talloc_tos(), SNUM(conn)),objid);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
+	E_md4hash(lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),objid);
 	return objid;
 }
 
@@ -3568,6 +3576,8 @@ NTSTATUS smbd_do_qfsinfo(struct smbXsrv_connection *xconn,
 			 char **ppdata,
 			 int *ret_data_len)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *pdata, *end_data;
 	int data_len = 0;
 	size_t len = 0;
@@ -3676,7 +3686,7 @@ cBytesSector=%u, cUnitTotal=%u, cUnitAvail=%d\n", (unsigned int)st.st_ex_dev, (u
 			 * Add volume serial number - hash of a combination of
 			 * the called hostname and the service name.
 			 */
-			SIVAL(pdata,0,str_checksum(lp_servicename(talloc_tos(), snum)) ^ (str_checksum(get_local_machine_name())<<16) );
+			SIVAL(pdata,0,str_checksum(lp_servicename(talloc_tos(), lp_sub, snum)) ^ (str_checksum(get_local_machine_name())<<16) );
 			/*
 			 * Win2k3 and previous mess this up by sending a name length
 			 * one byte short. I believe only older clients (OS/2 Win9x) use
@@ -3758,7 +3768,7 @@ cBytesSector=%u, cUnitTotal=%u, cUnitAvail=%d\n", (unsigned int)st.st_ex_dev, (u
 			 * Add volume serial number - hash of a combination of
 			 * the called hostname and the service name.
 			 */
-			SIVAL(pdata,8,str_checksum(lp_servicename(talloc_tos(), snum)) ^
+			SIVAL(pdata,8,str_checksum(lp_servicename(talloc_tos(), lp_sub, snum)) ^
 				(str_checksum(get_local_machine_name())<<16));
 
 			/* Max label len is 32 characters. */
@@ -3773,7 +3783,7 @@ cBytesSector=%u, cUnitTotal=%u, cUnitAvail=%d\n", (unsigned int)st.st_ex_dev, (u
 
 			DEBUG(5,("smbd_do_qfsinfo : SMB_QUERY_FS_VOLUME_INFO namelen = %d, vol=%s serv=%s\n",
 				(int)strlen(vname),vname,
-				lp_servicename(talloc_tos(), snum)));
+				lp_servicename(talloc_tos(), lp_sub, snum)));
 			if (max_data_bytes >= 24 && data_len > max_data_bytes) {
 				/* the client only requested a portion of the
 				   volume label */
@@ -3906,7 +3916,7 @@ cBytesSector=%u, cUnitTotal=%u, cUnitAvail=%d\n", (unsigned int)bsize, (unsigned
 			if (get_current_uid(conn) != 0) {
 				DEBUG(0,("get_user_quota: access_denied "
 					 "service [%s] user [%s]\n",
-					 lp_servicename(talloc_tos(), SNUM(conn)),
+					 lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 					 conn->session_info->unix_info->unix_name));
 				return NT_STATUS_ACCESS_DENIED;
 			}
@@ -3914,14 +3924,14 @@ cBytesSector=%u, cUnitTotal=%u, cUnitAvail=%d\n", (unsigned int)bsize, (unsigned
 			status = vfs_get_ntquota(&fsp, SMB_USER_FS_QUOTA_TYPE,
 						 NULL, &quotas);
 			if (!NT_STATUS_IS_OK(status)) {
-				DEBUG(0,("vfs_get_ntquota() failed for service [%s]\n",lp_servicename(talloc_tos(), SNUM(conn))));
+				DEBUG(0,("vfs_get_ntquota() failed for service [%s]\n",lp_servicename(talloc_tos(), lp_sub, SNUM(conn))));
 				return status;
 			}
 
 			data_len = 48;
 
 			DEBUG(10,("SMB_FS_QUOTA_INFORMATION: for service [%s]\n",
-				  lp_servicename(talloc_tos(), SNUM(conn))));
+				  lp_servicename(talloc_tos(), lp_sub, SNUM(conn))));
 
 			/* Unknown1 24 NULL bytes*/
 			SBIG_UINT(pdata,0,(uint64_t)0);
@@ -4067,7 +4077,7 @@ cBytesSector=%u, cUnitTotal=%u, cUnitAvail=%d\n", (unsigned int)bsize, (unsigned
 				return NT_STATUS_INVALID_LEVEL;
 #endif /* EOPNOTSUPP */
 			} else {
-				DEBUG(0,("vfs_statvfs() failed for service [%s]\n",lp_servicename(talloc_tos(), SNUM(conn))));
+				DEBUG(0,("vfs_statvfs() failed for service [%s]\n",lp_servicename(talloc_tos(), lp_sub, SNUM(conn))));
 				return NT_STATUS_DOS(ERRSRV, ERRerror);
 			}
 			break;
@@ -4198,6 +4208,8 @@ static NTSTATUS smb_set_fsquota(connection_struct *conn,
 			files_struct *fsp,
 			const DATA_BLOB *qdata)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	NTSTATUS status;
 	SMB_NTQUOTA_STRUCT quotas;
 
@@ -4206,7 +4218,7 @@ static NTSTATUS smb_set_fsquota(connection_struct *conn,
 	/* access check */
 	if ((get_current_uid(conn) != 0) || !CAN_WRITE(conn)) {
 		DEBUG(3, ("set_fsquota: access_denied service [%s] user [%s]\n",
-			  lp_servicename(talloc_tos(), SNUM(conn)),
+			  lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 			  conn->session_info->unix_info->unix_name));
 		return NT_STATUS_ACCESS_DENIED;
 	}
@@ -4243,7 +4255,7 @@ static NTSTATUS smb_set_fsquota(connection_struct *conn,
 	/* now set the quotas */
 	if (vfs_set_ntquota(fsp, SMB_USER_FS_QUOTA_TYPE, NULL, &quotas)!=0) {
 		DEBUG(1, ("vfs_set_ntquota() failed for service [%s]\n",
-			  lp_servicename(talloc_tos(), SNUM(conn))));
+			  lp_servicename(talloc_tos(), lp_sub, SNUM(conn))));
 		status =  map_nt_error_from_unix(errno);
 	} else {
 		status = NT_STATUS_OK;
@@ -4339,13 +4351,15 @@ static void call_trans2setfsinfo(connection_struct *conn,
 				 char **ppdata, int total_data,
 				 unsigned int max_data_bytes)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	struct smbXsrv_connection *xconn = req->xconn;
 	char *pdata = *ppdata;
 	char *params = *pparams;
 	uint16_t info_level;
 
 	DEBUG(10,("call_trans2setfsinfo: for service [%s]\n",
-		  lp_servicename(talloc_tos(), SNUM(conn))));
+		  lp_servicename(talloc_tos(), lp_sub, SNUM(conn))));
 
 	/*  */
 	if (total_params < 4) {
@@ -4672,9 +4686,9 @@ static char *store_file_unix_basic(connection_struct *conn,
 	SOFF_T(pdata,0,SMB_VFS_GET_ALLOC_SIZE(conn,fsp,psbuf)); /* Number of bytes used on disk - 64 Bit */
 	pdata += 8;
 
-	put_long_date_timespec(TIMESTAMP_SET_NT_OR_BETTER, pdata, psbuf->st_ex_ctime);       /* Change Time 64 Bit */
-	put_long_date_timespec(TIMESTAMP_SET_NT_OR_BETTER ,pdata+8, psbuf->st_ex_atime);     /* Last access time 64 Bit */
-	put_long_date_timespec(TIMESTAMP_SET_NT_OR_BETTER, pdata+16, psbuf->st_ex_mtime);    /* Last modification time 64 Bit */
+	put_long_date_full_timespec(TIMESTAMP_SET_NT_OR_BETTER, pdata, &psbuf->st_ex_ctime);       /* Change Time 64 Bit */
+	put_long_date_full_timespec(TIMESTAMP_SET_NT_OR_BETTER ,pdata+8, &psbuf->st_ex_atime);     /* Last access time 64 Bit */
+	put_long_date_full_timespec(TIMESTAMP_SET_NT_OR_BETTER, pdata+16, &psbuf->st_ex_mtime);    /* Last modification time 64 Bit */
 	pdata += 24;
 
 	SIVAL(pdata,0,psbuf->st_ex_uid);               /* user id for the owner */
@@ -4814,7 +4828,7 @@ static char *store_file_unix_basic_info2(connection_struct *conn,
 	pdata = store_file_unix_basic(conn, pdata, fsp, psbuf);
 
 	/* Create (birth) time 64 bit */
-	put_long_date_timespec(TIMESTAMP_SET_NT_OR_BETTER,pdata, psbuf->st_ex_btime);
+	put_long_date_full_timespec(TIMESTAMP_SET_NT_OR_BETTER,pdata, &psbuf->st_ex_btime);
 	pdata += 8;
 
 	map_info2_flags_from_sbuf(psbuf, &file_flags, &flags_mask);
@@ -5207,7 +5221,9 @@ NTSTATUS smbd_do_qfilepathinfo(connection_struct *conn,
 	dstart = pdata;
 	dend = dstart + data_size - 1;
 
-	if (!null_timespec(write_time_ts) && !INFO_LEVEL_IS_UNIX(info_level)) {
+	if (!is_omit_timespec(&write_time_ts) &&
+	    !INFO_LEVEL_IS_UNIX(info_level))
+	{
 		update_stat_ex_mtime(psbuf, write_time_ts);
 	}
 
@@ -5429,10 +5445,10 @@ NTSTATUS smbd_do_qfilepathinfo(connection_struct *conn,
 				data_size = 40;
 				SIVAL(pdata,36,0);
 			}
-			put_long_date_timespec(conn->ts_res,pdata,create_time_ts);
-			put_long_date_timespec(conn->ts_res,pdata+8,atime_ts);
-			put_long_date_timespec(conn->ts_res,pdata+16,mtime_ts); /* write time */
-			put_long_date_timespec(conn->ts_res,pdata+24,ctime_ts); /* change time */
+			put_long_date_full_timespec(conn->ts_res,pdata,&create_time_ts);
+			put_long_date_full_timespec(conn->ts_res,pdata+8,&atime_ts);
+			put_long_date_full_timespec(conn->ts_res,pdata+16,&mtime_ts); /* write time */
+			put_long_date_full_timespec(conn->ts_res,pdata+24,&ctime_ts); /* change time */
 			SIVAL(pdata,32,mode);
 
 			DEBUG(5,("SMB_QFBI - "));
@@ -5515,7 +5531,7 @@ NTSTATUS smbd_do_qfilepathinfo(connection_struct *conn,
 		{
 			char *nfname = NULL;
 
-			if (!fsp->conn->sconn->using_smb2) {
+			if (fsp == NULL || !fsp->conn->sconn->using_smb2) {
 				return NT_STATUS_INVALID_LEVEL;
 			}
 
@@ -5588,10 +5604,10 @@ NTSTATUS smbd_do_qfilepathinfo(connection_struct *conn,
 			unsigned int ea_size =
 			    estimate_ea_size(conn, fsp, smb_fname);
 			DEBUG(10,("smbd_do_qfilepathinfo: SMB_FILE_ALL_INFORMATION\n"));
-			put_long_date_timespec(conn->ts_res,pdata,create_time_ts);
-			put_long_date_timespec(conn->ts_res,pdata+8,atime_ts);
-			put_long_date_timespec(conn->ts_res,pdata+16,mtime_ts); /* write time */
-			put_long_date_timespec(conn->ts_res,pdata+24,ctime_ts); /* change time */
+			put_long_date_full_timespec(conn->ts_res,pdata,&create_time_ts);
+			put_long_date_full_timespec(conn->ts_res,pdata+8,&atime_ts);
+			put_long_date_full_timespec(conn->ts_res,pdata+16,&mtime_ts); /* write time */
+			put_long_date_full_timespec(conn->ts_res,pdata+24,&ctime_ts); /* change time */
 			SIVAL(pdata,32,mode);
 			SIVAL(pdata,36,0); /* padding. */
 			pdata += 40;
@@ -5623,10 +5639,10 @@ NTSTATUS smbd_do_qfilepathinfo(connection_struct *conn,
 			unsigned int ea_size =
 			    estimate_ea_size(conn, fsp, smb_fname);
 			DEBUG(10,("smbd_do_qfilepathinfo: SMB2_FILE_ALL_INFORMATION\n"));
-			put_long_date_timespec(conn->ts_res,pdata+0x00,create_time_ts);
-			put_long_date_timespec(conn->ts_res,pdata+0x08,atime_ts);
-			put_long_date_timespec(conn->ts_res,pdata+0x10,mtime_ts); /* write time */
-			put_long_date_timespec(conn->ts_res,pdata+0x18,ctime_ts); /* change time */
+			put_long_date_full_timespec(conn->ts_res,pdata+0x00,&create_time_ts);
+			put_long_date_full_timespec(conn->ts_res,pdata+0x08,&atime_ts);
+			put_long_date_full_timespec(conn->ts_res,pdata+0x10,&mtime_ts); /* write time */
+			put_long_date_full_timespec(conn->ts_res,pdata+0x18,&ctime_ts); /* change time */
 			SIVAL(pdata,	0x20, mode);
 			SIVAL(pdata,	0x24, 0); /* padding. */
 			SBVAL(pdata,	0x28, allocation_size);
@@ -5773,10 +5789,10 @@ NTSTATUS smbd_do_qfilepathinfo(connection_struct *conn,
 
 		case SMB_FILE_NETWORK_OPEN_INFORMATION:
 			DEBUG(10,("smbd_do_qfilepathinfo: SMB_FILE_NETWORK_OPEN_INFORMATION\n"));
-			put_long_date_timespec(conn->ts_res,pdata,create_time_ts);
-			put_long_date_timespec(conn->ts_res,pdata+8,atime_ts);
-			put_long_date_timespec(conn->ts_res,pdata+16,mtime_ts); /* write time */
-			put_long_date_timespec(conn->ts_res,pdata+24,ctime_ts); /* change time */
+			put_long_date_full_timespec(conn->ts_res,pdata,&create_time_ts);
+			put_long_date_full_timespec(conn->ts_res,pdata+8,&atime_ts);
+			put_long_date_full_timespec(conn->ts_res,pdata+16,&mtime_ts); /* write time */
+			put_long_date_full_timespec(conn->ts_res,pdata+24,&ctime_ts); /* change time */
 			SOFF_T(pdata,32,allocation_size);
 			SOFF_T(pdata,40,file_size);
 			SIVAL(pdata,48,mode);
@@ -6487,6 +6503,7 @@ NTSTATUS smb_set_file_time(connection_struct *conn,
 			   bool setting_write_time)
 {
 	struct smb_filename smb_fname_base;
+	struct timeval_buf tbuf[4];
 	uint32_t action =
 		FILE_NOTIFY_CHANGE_LAST_ACCESS
 		|FILE_NOTIFY_CHANGE_LAST_WRITE
@@ -6497,15 +6514,15 @@ NTSTATUS smb_set_file_time(connection_struct *conn,
 	}
 
 	/* get some defaults (no modifications) if any info is zero or -1. */
-	if (null_timespec(ft->create_time)) {
+	if (is_omit_timespec(&ft->create_time)) {
 		action &= ~FILE_NOTIFY_CHANGE_CREATION;
 	}
 
-	if (null_timespec(ft->atime)) {
+	if (is_omit_timespec(&ft->atime)) {
 		action &= ~FILE_NOTIFY_CHANGE_LAST_ACCESS;
 	}
 
-	if (null_timespec(ft->mtime)) {
+	if (is_omit_timespec(&ft->mtime)) {
 		action &= ~FILE_NOTIFY_CHANGE_LAST_WRITE;
 	}
 
@@ -6522,14 +6539,14 @@ NTSTATUS smb_set_file_time(connection_struct *conn,
 	round_timespec(conn->ts_res, &ft->atime);
 	round_timespec(conn->ts_res, &ft->mtime);
 
-	DEBUG(5,("smb_set_filetime: actime: %s\n ",
-		time_to_asc(convert_timespec_to_time_t(ft->atime))));
-	DEBUG(5,("smb_set_filetime: modtime: %s\n ",
-		time_to_asc(convert_timespec_to_time_t(ft->mtime))));
-	DEBUG(5,("smb_set_filetime: ctime: %s\n ",
-		time_to_asc(convert_timespec_to_time_t(ft->ctime))));
-	DEBUG(5,("smb_set_file_time: createtime: %s\n ",
-		time_to_asc(convert_timespec_to_time_t(ft->create_time))));
+	DBG_DEBUG("smb_set_filetime: actime: %s\n ",
+		  timespec_string_buf(&ft->atime, true, &tbuf[0]));
+	DBG_DEBUG("smb_set_filetime: modtime: %s\n ",
+		  timespec_string_buf(&ft->mtime, true, &tbuf[1]));
+	DBG_DEBUG("smb_set_filetime: ctime: %s\n ",
+		  timespec_string_buf(&ft->ctime, true, &tbuf[2]));
+	DBG_DEBUG("smb_set_file_time: createtime: %s\n ",
+		  timespec_string_buf(&ft->create_time, true, &tbuf[3]));
 
 	if (setting_write_time) {
 		/*
@@ -6542,8 +6559,8 @@ NTSTATUS smb_set_file_time(connection_struct *conn,
 		 * away and will set it on file close and after a write. JRA.
 		 */
 
-		DEBUG(10,("smb_set_file_time: setting pending modtime to %s\n",
-			  time_to_asc(convert_timespec_to_time_t(ft->mtime))));
+		DBG_DEBUG("setting pending modtime to %s\n",
+			  timespec_string_buf(&ft->mtime, true, &tbuf[0]));
 
 		if (fsp != NULL) {
 			if (fsp->base_fsp) {
@@ -7767,7 +7784,7 @@ static NTSTATUS smb_set_file_basic_info(connection_struct *conn,
 	uint32_t dosmode = 0;
 	NTSTATUS status = NT_STATUS_OK;
 
-	ZERO_STRUCT(ft);
+	init_smb_file_time(&ft);
 
 	if (total_data < 36) {
 		return NT_STATUS_INVALID_PARAMETER;
@@ -7786,16 +7803,16 @@ static NTSTATUS smb_set_file_basic_info(connection_struct *conn,
 	}
 
 	/* create time */
-	ft.create_time = interpret_long_date(pdata);
+	ft.create_time = pull_long_date_full_timespec(pdata);
 
 	/* access time */
-	ft.atime = interpret_long_date(pdata+8);
+	ft.atime = pull_long_date_full_timespec(pdata+8);
 
 	/* write time. */
-	ft.mtime = interpret_long_date(pdata+16);
+	ft.mtime = pull_long_date_full_timespec(pdata+16);
 
 	/* change time. */
-	ft.ctime = interpret_long_date(pdata+24);
+	ft.ctime = pull_long_date_full_timespec(pdata+24);
 
 	DEBUG(10, ("smb_set_file_basic_info: file %s\n",
 		   smb_fname_str_dbg(smb_fname)));
@@ -7817,18 +7834,18 @@ static NTSTATUS smb_set_info_standard(connection_struct *conn,
 	NTSTATUS status;
 	struct smb_file_time ft;
 
-	ZERO_STRUCT(ft);
+	init_smb_file_time(&ft);
 
 	if (total_data < 12) {
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
 	/* create time */
-	ft.create_time = convert_time_t_to_timespec(srv_make_unix_date2(pdata));
+	ft.create_time = time_t_to_full_timespec(srv_make_unix_date2(pdata));
 	/* access time */
-	ft.atime = convert_time_t_to_timespec(srv_make_unix_date2(pdata+4));
+	ft.atime = time_t_to_full_timespec(srv_make_unix_date2(pdata+4));
 	/* write time */
-	ft.mtime = convert_time_t_to_timespec(srv_make_unix_date2(pdata+8));
+	ft.mtime = time_t_to_full_timespec(srv_make_unix_date2(pdata+8));
 
 	DEBUG(10,("smb_set_info_standard: file %s\n",
 		smb_fname_str_dbg(smb_fname)));
@@ -8109,7 +8126,7 @@ static NTSTATUS smb_set_file_unix_basic(connection_struct *conn,
 	struct file_id id;
 	SMB_STRUCT_STAT sbuf;
 
-	ZERO_STRUCT(ft);
+	init_smb_file_time(&ft);
 
 	if (total_data < 100) {
 		return NT_STATUS_INVALID_PARAMETER;
@@ -8121,8 +8138,8 @@ static NTSTATUS smb_set_file_unix_basic(connection_struct *conn,
 		size |= (((off_t)IVAL(pdata,4)) << 32);
 	}
 
-	ft.atime = interpret_long_date(pdata+24); /* access_time */
-	ft.mtime = interpret_long_date(pdata+32); /* modification_time */
+	ft.atime = pull_long_date_full_timespec(pdata+24); /* access_time */
+	ft.mtime = pull_long_date_full_timespec(pdata+32); /* modification_time */
 	set_owner = (uid_t)IVAL(pdata,40);
 	set_grp = (gid_t)IVAL(pdata,48);
 	raw_unixmode = IVAL(pdata,84);
@@ -8268,7 +8285,7 @@ static NTSTATUS smb_set_file_unix_basic(connection_struct *conn,
 	}
 
 	/* Deal with any time changes. */
-	if (null_timespec(ft.mtime) && null_timespec(ft.atime)) {
+	if (is_omit_timespec(&ft.mtime) && is_omit_timespec(&ft.atime)) {
 		/* No change, don't cancel anything. */
 		return status;
 	}
@@ -8290,7 +8307,7 @@ static NTSTATUS smb_set_file_unix_basic(connection_struct *conn,
 	 * we need. Just remember if we modified
 	 * mtime and send the notify ourselves.
 	 */
-	if (null_timespec(ft.mtime)) {
+	if (is_omit_timespec(&ft.mtime)) {
 		modify_mtime = false;
 	}
 
@@ -9663,6 +9680,8 @@ static void call_trans2ioctl(connection_struct *conn,
 			     char **ppdata, int total_data,
 			     unsigned int max_data_bytes)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *pdata = *ppdata;
 	files_struct *fsp = file_fsp(req, SVAL(req->vwv+15, 0));
 	NTSTATUS status;
@@ -9698,7 +9717,7 @@ static void call_trans2ioctl(connection_struct *conn,
 			return;
 		}
 		status = srvstr_push(pdata, req->flags2, pdata+18,
-			    lp_servicename(talloc_tos(), SNUM(conn)), 13,
+			    lp_servicename(talloc_tos(), lp_sub, SNUM(conn)), 13,
 			    STR_ASCII|STR_TERMINATE, &len); /* Service name */
 		if (!NT_STATUS_IS_OK(status)) {
 			reply_nterror(req, status);
diff --git a/source3/smbd/uid.c b/source3/smbd/uid.c
index 304d3f818f7..9b983df80db 100644
--- a/source3/smbd/uid.c
+++ b/source3/smbd/uid.c
@@ -308,6 +308,8 @@ static bool change_to_user_impersonate(connection_struct *conn,
 				       const struct auth_session_info *session_info,
 				       uint64_t vuid)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int snum;
 	gid_t gid;
 	uid_t uid;
@@ -350,7 +352,7 @@ static bool change_to_user_impersonate(connection_struct *conn,
 	 * See if we should force group for this service. If so this overrides
 	 * any group set in the force user code.
 	 */
-	force_group_name = lp_force_group(talloc_tos(), snum);
+	force_group_name = lp_force_group(talloc_tos(), lp_sub, snum);
 	group_c = *force_group_name;
 
 	if ((group_c != '\0') && (conn->force_group_gid == (gid_t)-1)) {
@@ -435,8 +437,9 @@ static bool change_to_user_impersonate(connection_struct *conn,
  **/
 bool change_to_user_and_service(connection_struct *conn, uint64_t vuid)
 {
-	struct user_struct *vuser;
 	int snum = SNUM(conn);
+	struct auth_session_info *si = NULL;
+	NTSTATUS status;
 	bool ok;
 
 	if (conn == NULL) {
@@ -444,16 +447,17 @@ bool change_to_user_and_service(connection_struct *conn, uint64_t vuid)
 		return false;
 	}
 
-	vuser = get_valid_user_struct(conn->sconn, vuid);
-	if (vuser == NULL) {
-		/* Invalid vuid sent */
+	status = smbXsrv_session_info_lookup(conn->sconn->client,
+					     vuid,
+					     &si);
+	if (!NT_STATUS_IS_OK(status)) {
 		DBG_WARNING("Invalid vuid %llu used on share %s.\n",
 			    (unsigned long long)vuid,
 			    lp_const_servicename(snum));
 		return false;
 	}
 
-	ok = change_to_user_impersonate(conn, vuser->session_info, vuid);
+	ok = change_to_user_impersonate(conn, si, vuid);
 	if (!ok) {
 		return false;
 	}
@@ -623,8 +627,9 @@ void smbd_unbecome_root(void)
 
 bool become_user_without_service(connection_struct *conn, uint64_t vuid)
 {
-	struct user_struct *vuser;
+	struct auth_session_info *session_info = NULL;
 	int snum = SNUM(conn);
+	NTSTATUS status;
 	bool ok;
 
 	if (conn == NULL) {
@@ -632,8 +637,10 @@ bool become_user_without_service(connection_struct *conn, uint64_t vuid)
 		return false;
 	}
 
-	vuser = get_valid_user_struct(conn->sconn, vuid);
-	if (vuser == NULL) {
+	status = smbXsrv_session_info_lookup(conn->sconn->client,
+					     vuid,
+					     &session_info);
+	if (!NT_STATUS_IS_OK(status)) {
 		/* Invalid vuid sent */
 		DBG_WARNING("Invalid vuid %llu used on share %s.\n",
 			    (unsigned long long)vuid,
@@ -648,7 +655,7 @@ bool become_user_without_service(connection_struct *conn, uint64_t vuid)
 
 	push_conn_ctx();
 
-	ok = change_to_user_impersonate(conn, vuser->session_info, vuid);
+	ok = change_to_user_impersonate(conn, session_info, vuid);
 	if (!ok) {
 		pop_sec_ctx();
 		pop_conn_ctx();
diff --git a/source3/smbd/vfs.c b/source3/smbd/vfs.c
index dbf42cd56f4..7dc15158ccb 100644
--- a/source3/smbd/vfs.c
+++ b/source3/smbd/vfs.c
@@ -1451,6 +1451,16 @@ NTSTATUS vfs_stat_fsp(files_struct *fsp)
 	return NT_STATUS_OK;
 }
 
+void init_smb_file_time(struct smb_file_time *ft)
+{
+	*ft = (struct smb_file_time) {
+		.atime = make_omit_timespec(),
+		.ctime = make_omit_timespec(),
+		.mtime = make_omit_timespec(),
+		.create_time = make_omit_timespec()
+	};
+}
+
 /**
  * Initialize num_streams and streams, then call VFS op streaminfo
  */
@@ -1553,6 +1563,36 @@ NTSTATUS smb_vfs_call_get_dfs_referrals(struct vfs_handle_struct *handle,
 	return handle->fns->get_dfs_referrals_fn(handle, r);
 }
 
+NTSTATUS smb_vfs_call_create_dfs_pathat(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				const struct referral *reflist,
+				size_t referral_count)
+{
+	VFS_FIND(create_dfs_pathat);
+	return handle->fns->create_dfs_pathat_fn(handle,
+						dirfsp,
+						smb_fname,
+						reflist,
+						referral_count);
+}
+
+NTSTATUS smb_vfs_call_read_dfs_pathat(struct vfs_handle_struct *handle,
+				TALLOC_CTX *mem_ctx,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				struct referral **ppreflist,
+				size_t *preferral_count)
+{
+	VFS_FIND(read_dfs_pathat);
+	return handle->fns->read_dfs_pathat_fn(handle,
+						mem_ctx,
+						dirfsp,
+						smb_fname,
+						ppreflist,
+						preferral_count);
+}
+
 DIR *smb_vfs_call_opendir(struct vfs_handle_struct *handle,
 					const struct smb_filename *smb_fname,
 					const char *mask,
diff --git a/source3/torture/cmd_vfs.c b/source3/torture/cmd_vfs.c
index be4990db3fc..81068fb84a0 100644
--- a/source3/torture/cmd_vfs.c
+++ b/source3/torture/cmd_vfs.c
@@ -104,7 +104,10 @@ static NTSTATUS cmd_show_data(struct vfs_state *vfs, TALLOC_CTX *mem_ctx, int ar
 
 static NTSTATUS cmd_connect(struct vfs_state *vfs, TALLOC_CTX *mem_ctx, int argc, const char **argv)
 {
-	SMB_VFS_CONNECT(vfs->conn, lp_servicename(talloc_tos(), SNUM(vfs->conn)), "vfstest");
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
+	SMB_VFS_CONNECT(vfs->conn, lp_servicename(talloc_tos(), lp_sub, SNUM(vfs->conn)), "vfstest");
 	return NT_STATUS_OK;
 }
 
@@ -1000,10 +1003,10 @@ static NTSTATUS cmd_utime(struct vfs_state *vfs, TALLOC_CTX *mem_ctx, int argc,
 		return NT_STATUS_OK;
 	}
 
-	ZERO_STRUCT(ft);
+	init_smb_file_time(&ft);
 
-	ft.atime = convert_time_t_to_timespec(atoi(argv[2]));
-	ft.mtime = convert_time_t_to_timespec(atoi(argv[3]));
+	ft.atime = time_t_to_full_timespec(atoi(argv[2]));
+	ft.mtime = time_t_to_full_timespec(atoi(argv[3]));
 
 	smb_fname = synthetic_smb_fname_split(mem_ctx,
 					argv[1],
diff --git a/source3/torture/pdbtest.c b/source3/torture/pdbtest.c
index fdf72187b6c..5d74aa9ab78 100644
--- a/source3/torture/pdbtest.c
+++ b/source3/torture/pdbtest.c
@@ -278,9 +278,14 @@ static bool test_auth(TALLOC_CTX *mem_ctx, struct samu *pdb_entry)
 	NTSTATUS status;
 	bool ok;
 	uint8_t authoritative = 0;
+	int rc;
+
+	rc = SMBOWFencrypt(pdb_get_nt_passwd(pdb_entry), challenge_8,
+			   local_nt_response);
+	if (rc != 0) {
+		return False;
+	}
 
-	SMBOWFencrypt(pdb_get_nt_passwd(pdb_entry), challenge_8,
-		      local_nt_response);
 	SMBsesskeygen_ntv1(pdb_get_nt_passwd(pdb_entry), local_nt_session_key);
 
 	if (tsocket_address_inet_from_strings(NULL, "ip", NULL, 0, &remote_address) != 0) {
diff --git a/source3/torture/proto.h b/source3/torture/proto.h
index f1896d5624e..73a28991735 100644
--- a/source3/torture/proto.h
+++ b/source3/torture/proto.h
@@ -114,6 +114,7 @@ bool run_notify_bench3(int dummy);
 bool run_dbwrap_watch1(int dummy);
 bool run_dbwrap_watch2(int dummy);
 bool run_dbwrap_watch3(int dummy);
+bool run_dbwrap_watch4(int dummy);
 bool run_dbwrap_do_locked1(int dummy);
 bool run_idmap_tdb_common_test(int dummy);
 bool run_local_dbwrap_ctdb(int dummy);
@@ -134,8 +135,10 @@ bool run_g_lock1(int dummy);
 bool run_g_lock2(int dummy);
 bool run_g_lock3(int dummy);
 bool run_g_lock4(int dummy);
+bool run_g_lock4a(int dummy);
 bool run_g_lock5(int dummy);
 bool run_g_lock6(int dummy);
+bool run_g_lock7(int dummy);
 bool run_g_lock_ping_pong(int dummy);
 bool run_local_namemap_cache1(int dummy);
 bool run_local_idmap_cache1(int dummy);
diff --git a/source3/torture/test_dbwrap_do_locked.c b/source3/torture/test_dbwrap_do_locked.c
index a5b9d4400cf..7226ec14128 100644
--- a/source3/torture/test_dbwrap_do_locked.c
+++ b/source3/torture/test_dbwrap_do_locked.c
@@ -31,7 +31,10 @@ struct do_locked1_state {
 	NTSTATUS status;
 };
 
-static void do_locked1_cb(struct db_record *rec, void *private_data)
+static void do_locked1_cb(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
 	struct do_locked1_state *state =
 		(struct do_locked1_state *)private_data;
@@ -55,7 +58,10 @@ static void do_locked1_check(TDB_DATA key, TDB_DATA value,
 	state->status = NT_STATUS_OK;
 }
 
-static void do_locked1_del(struct db_record *rec, void *private_data)
+static void do_locked1_del(
+	struct db_record *rec,
+	TDB_DATA value,
+	void *private_data)
 {
 	struct do_locked1_state *state =
 		(struct do_locked1_state *)private_data;
diff --git a/source3/torture/test_dbwrap_watch.c b/source3/torture/test_dbwrap_watch.c
index cdfd8117522..d66bdaa9914 100644
--- a/source3/torture/test_dbwrap_watch.c
+++ b/source3/torture/test_dbwrap_watch.c
@@ -25,38 +25,94 @@
 #include "lib/dbwrap/dbwrap_watch.h"
 #include "lib/util/util_tdb.h"
 
-bool run_dbwrap_watch1(int dummy)
+static bool test_dbwrap_watch_init(
+	TALLOC_CTX *mem_ctx,
+	const char *dbname,
+	struct tevent_context **pev,
+	struct messaging_context **pmsg,
+	struct db_context **pbackend,
+	struct db_context **pdb)
 {
 	struct tevent_context *ev = NULL;
 	struct messaging_context *msg = NULL;
 	struct db_context *backend = NULL;
 	struct db_context *db = NULL;
-	const char *keystr = "key";
-	TDB_DATA key = string_term_tdb_data(keystr);
-	struct db_record *rec = NULL;
-	struct tevent_req *req = NULL;
-	NTSTATUS status;
-	bool ret = false;
 
-	ev = samba_tevent_context_init(talloc_tos());
+	ev = samba_tevent_context_init(mem_ctx);
 	if (ev == NULL) {
 		fprintf(stderr, "tevent_context_init failed\n");
 		goto fail;
 	}
+
 	msg = messaging_init(ev, ev);
 	if (msg == NULL) {
 		fprintf(stderr, "messaging_init failed\n");
 		goto fail;
 	}
-	backend = db_open(msg, "test_watch.tdb", 0, TDB_CLEAR_IF_FIRST,
-			  O_CREAT|O_RDWR, 0644, DBWRAP_LOCK_ORDER_1,
-			  DBWRAP_FLAG_NONE);
+
+	backend = db_open(
+		msg,
+		dbname,
+		0,
+		TDB_CLEAR_IF_FIRST,
+		O_CREAT|O_RDWR,
+		0644,
+		DBWRAP_LOCK_ORDER_1,
+		DBWRAP_FLAG_NONE);
 	if (backend == NULL) {
 		fprintf(stderr, "db_open failed: %s\n", strerror(errno));
 		goto fail;
 	}
 
-	db = db_open_watched(ev, &backend, msg);
+	{
+		struct db_context *backend_copy = backend;
+
+		db = db_open_watched(ev, &backend_copy, msg);
+		if (db == NULL) {
+			fprintf(stderr, "db_open_watched failed\n");
+			goto fail;
+		}
+	}
+
+	if (pev != NULL) {
+		*pev = ev;
+	}
+	if (pmsg != NULL) {
+		*pmsg = msg;
+	}
+	if (pbackend != NULL) {
+		*pbackend = backend;
+	}
+	if (pdb != NULL) {
+		*pdb = db;
+	}
+	return true;
+
+fail:
+	TALLOC_FREE(backend);
+	TALLOC_FREE(msg);
+	TALLOC_FREE(ev);
+	return false;
+}
+
+bool run_dbwrap_watch1(int dummy)
+{
+	struct tevent_context *ev = NULL;
+	struct messaging_context *msg = NULL;
+	struct db_context *backend = NULL;
+	struct db_context *db = NULL;
+	const char *keystr = "key";
+	TDB_DATA key = string_term_tdb_data(keystr);
+	struct db_record *rec = NULL;
+	struct tevent_req *req = NULL;
+	NTSTATUS status;
+	bool ret = false;
+
+	ret = test_dbwrap_watch_init(
+		talloc_tos(), "test_watch.tdb", &ev, &msg, &backend, &db);
+	if (!ret) {
+		goto fail;
+	}
 
 	rec = dbwrap_fetch_locked(db, db, key);
 	if (rec == NULL) {
@@ -124,21 +180,9 @@ bool run_dbwrap_watch2(int dummy)
 	NTSTATUS status;
 	bool ret = false;
 
-	ev = samba_tevent_context_init(talloc_tos());
-	if (ev == NULL) {
-		fprintf(stderr, "tevent_context_init failed\n");
-		goto fail;
-	}
-	msg = messaging_init(ev, ev);
-	if (msg == NULL) {
-		fprintf(stderr, "messaging_init failed\n");
-		goto fail;
-	}
-	backend = db_open(msg, "test_watch.tdb", 0, TDB_CLEAR_IF_FIRST,
-			  O_CREAT|O_RDWR, 0644, DBWRAP_LOCK_ORDER_1,
-			  DBWRAP_FLAG_NONE);
-	if (backend == NULL) {
-		fprintf(stderr, "db_open failed: %s\n", strerror(errno));
+	ret = test_dbwrap_watch_init(
+		talloc_tos(), "test_watch.tdb", &ev, &msg, &backend, &db);
+	if (!ret) {
 		goto fail;
 	}
 
@@ -153,13 +197,6 @@ bool run_dbwrap_watch2(int dummy)
 		goto fail;
 	}
 
-	db = db_open_watched(ev, &backend, msg);
-	if (db == NULL) {
-		fprintf(stderr, "db_open_watched failed\n");
-		goto fail;
-	}
-	backend = NULL;		/* open_watch talloc_moves backend */
-
 	status = dbwrap_parse_record(db, key, NULL, NULL);
 	if (!NT_STATUS_EQUAL(status, NT_STATUS_NOT_FOUND)) {
 		fprintf(stderr, "dbwrap_parse_record returned %s, expected "
@@ -203,27 +240,9 @@ bool run_dbwrap_watch3(int dummy)
 		goto fail;
 	}
 
-	ev = samba_tevent_context_init(talloc_tos());
-	if (ev == NULL) {
-		fprintf(stderr, "tevent_context_init failed\n");
-		goto fail;
-	}
-	msg = messaging_init(ev, ev);
-	if (msg == NULL) {
-		fprintf(stderr, "messaging_init failed\n");
-		goto fail;
-	}
-	backend = db_open(msg, "test_watch.tdb", 0, TDB_CLEAR_IF_FIRST,
-			  O_CREAT|O_RDWR, 0644, DBWRAP_LOCK_ORDER_1,
-			  DBWRAP_FLAG_NONE);
-	if (backend == NULL) {
-		fprintf(stderr, "db_open failed: %s\n", strerror(errno));
-		goto fail;
-	}
-
-	db = db_open_watched(ev, &backend, msg);
-	if (db == NULL) {
-		fprintf(stderr, "db_open_watched failed\n");
+	ret = test_dbwrap_watch_init(
+		talloc_tos(), "test_watch.tdb", &ev, &msg, &backend, &db);
+	if (!ret) {
 		goto fail;
 	}
 
@@ -278,3 +297,170 @@ fail:
 	TALLOC_FREE(ev);
 	return ret;
 }
+
+/*
+ * Test that we can't add two watchers in the same
+ * fetch_lock/do_locked round
+ */
+
+struct dbwrap_watch4_state {
+	TALLOC_CTX *mem_ctx;
+	struct tevent_context *ev;
+	struct db_context *db;
+	TDB_DATA key;
+
+	NTSTATUS status;
+
+	struct tevent_req *req1;
+	NTSTATUS status1;
+
+	struct tevent_req *req2;
+	NTSTATUS status2;
+};
+
+static void dbwrap_watch4_done1(struct tevent_req *subreq);
+static void dbwrap_watch4_done2(struct tevent_req *subreq);
+
+static void dbwrap_watch4_fn(struct db_record *rec,
+			     TDB_DATA value,
+			     void *private_data)
+{
+	struct dbwrap_watch4_state *state = private_data;
+	bool ok;
+
+	state->req1 = dbwrap_watched_watch_send(
+		state->mem_ctx, state->ev, rec, (struct server_id) { .pid=0 });
+	if (state->req1 == NULL) {
+		goto nomem;
+	}
+	tevent_req_set_callback(state->req1, dbwrap_watch4_done1, state);
+	state->status1 = NT_STATUS_EVENT_PENDING;
+
+	ok = tevent_req_set_endtime(
+		state->req1, state->ev, timeval_current_ofs(1, 0));
+	if (!ok) {
+		goto nomem;
+	}
+
+	state->req2 = dbwrap_watched_watch_send(
+		state->mem_ctx, state->ev, rec, (struct server_id) { .pid=0 });
+	if (state->req2 == NULL) {
+		goto nomem;
+	}
+	tevent_req_set_callback(state->req2, dbwrap_watch4_done2, state);
+	state->status2 = NT_STATUS_EVENT_PENDING;
+
+	ok = tevent_req_set_endtime(
+		state->req2, state->ev, timeval_current_ofs(1, 0));
+	if (!ok) {
+		goto nomem;
+	}
+
+	state->status = NT_STATUS_OK;
+	return;
+
+	nomem:
+	state->status = NT_STATUS_NO_MEMORY;
+}
+
+static void dbwrap_watch4_done1(struct tevent_req *subreq)
+{
+	struct dbwrap_watch4_state *state = tevent_req_callback_data_void(subreq);
+	state->status1 = dbwrap_watched_watch_recv(subreq, NULL, NULL);
+	TALLOC_FREE(subreq);
+	printf("req1 finished: %s\n", nt_errstr(state->status1));
+	state->req1 = NULL;
+}
+
+static void dbwrap_watch4_done2(struct tevent_req *subreq)
+{
+	struct dbwrap_watch4_state *state = tevent_req_callback_data_void(subreq);
+	state->status2 = dbwrap_watched_watch_recv(subreq, NULL, NULL);
+	TALLOC_FREE(subreq);
+	printf("req2 finished: %s\n", nt_errstr(state->status2));
+	state->req2 = NULL;
+}
+
+bool run_dbwrap_watch4(int dummy)
+{
+	struct tevent_context *ev = NULL;
+	struct messaging_context *msg = NULL;
+	struct db_context *backend = NULL;
+	struct db_context *db = NULL;
+	const char *keystr = "key";
+	TDB_DATA key = string_term_tdb_data(keystr);
+	struct dbwrap_watch4_state state = { 0 };
+	NTSTATUS status;
+	bool ret = false;
+	bool ok;
+
+	ok = test_dbwrap_watch_init(
+		talloc_tos(), "test_watch.tdb", &ev, &msg, &backend, &db);
+	if (!ok) {
+		goto fail;
+	}
+
+	state = (struct dbwrap_watch4_state) {
+		.mem_ctx = talloc_tos(),
+		.ev = ev,
+		.db = db,
+		.key = key,
+	};
+
+	status = dbwrap_do_locked(db, key, dbwrap_watch4_fn, &state);
+	if (!NT_STATUS_IS_OK(status)) {
+		fprintf(stderr,
+			"dbwrap_do_locked failed: %s\n",
+			nt_errstr(status));
+		goto fail;
+	}
+	if (!NT_STATUS_IS_OK(state.status)) {
+		fprintf(stderr,
+			"dbwrap_watch4_fn failed: %s\n",
+			nt_errstr(status));
+		goto fail;
+	}
+
+	status = dbwrap_store(db, key, key, 0);
+	if (!NT_STATUS_IS_OK(status)) {
+		fprintf(stderr,
+			"dbwrap_store failed: %s\n",
+			nt_errstr(status));
+		goto fail;
+	}
+
+	while (NT_STATUS_EQUAL(state.status1, NT_STATUS_EVENT_PENDING) ||
+	       NT_STATUS_EQUAL(state.status2, NT_STATUS_EVENT_PENDING)) {
+		int res = tevent_loop_once(ev);
+		if (res != 0) {
+			fprintf(stderr,
+				"tevent_loop_once failed: %s\n",
+				strerror(errno));
+			goto fail;
+		}
+	}
+
+	if (!NT_STATUS_IS_OK(state.status1)) {
+		fprintf(stderr,
+			"req1 returned %s\n",
+			nt_errstr(state.status1));
+		goto fail;
+	}
+
+	if (!NT_STATUS_EQUAL(state.status2, NT_STATUS_REQUEST_NOT_ACCEPTED)) {
+		fprintf(stderr,
+			"req2 returned %s\n",
+			nt_errstr(state.status2));
+		goto fail;
+	}
+
+	(void)unlink("test_watch.tdb");
+	ret = true;
+fail:
+	TALLOC_FREE(state.req2);
+	TALLOC_FREE(state.req1);
+	TALLOC_FREE(db);
+	TALLOC_FREE(msg);
+	TALLOC_FREE(ev);
+	return ret;
+}
diff --git a/source3/torture/test_g_lock.c b/source3/torture/test_g_lock.c
index 615f7fcfbe8..05b6cecfc41 100644
--- a/source3/torture/test_g_lock.c
+++ b/source3/torture/test_g_lock.c
@@ -68,7 +68,7 @@ bool run_g_lock1(int dummy)
 		goto fail;
 	}
 
-	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_READ,
+	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_WRITE,
 			     (struct timeval) { .tv_sec = 1 });
 	if (!NT_STATUS_IS_OK(status)) {
 		fprintf(stderr, "g_lock_lock failed: %s\n",
@@ -76,7 +76,7 @@ bool run_g_lock1(int dummy)
 		goto fail;
 	}
 
-	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_READ,
+	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_WRITE,
 			     (struct timeval) { .tv_sec = 1 });
 	if (!NT_STATUS_EQUAL(status, NT_STATUS_WAS_LOCKED)) {
 		fprintf(stderr, "Double lock got %s\n",
@@ -111,8 +111,9 @@ struct lock2_parser_state {
 	bool ok;
 };
 
-static void lock2_parser(const struct g_lock_rec *locks,
-			 size_t num_locks,
+static void lock2_parser(struct server_id exclusive,
+			 size_t num_shared,
+			 struct server_id *shared,
 			 const uint8_t *data,
 			 size_t datalen,
 			 void *private_data)
@@ -211,13 +212,16 @@ struct lock3_parser_state {
 	bool ok;
 };
 
-static void lock3_parser(const struct g_lock_rec *locks,
-			 size_t num_locks,
+static void lock3_parser(struct server_id exclusive,
+			 size_t num_shared,
+			 struct server_id *shared,
 			 const uint8_t *data,
 			 size_t datalen,
 			 void *private_data)
 {
 	struct lock3_parser_state *state = private_data;
+	size_t num_locks = num_shared + ((exclusive.pid != 0) ? 1 : 0);
+	struct server_id *pid;
 
 	if (datalen != 0) {
 		fprintf(stderr, "datalen=%zu\n", datalen);
@@ -227,15 +231,25 @@ static void lock3_parser(const struct g_lock_rec *locks,
 		fprintf(stderr, "num_locks=%zu\n", num_locks);
 		return;
 	}
-	if (locks[0].lock_type != state->lock_type) {
-		fprintf(stderr, "found type %d, expected %d\n",
-			(int)locks[0].lock_type, (int)state->lock_type);
-		return;
+
+	if (state->lock_type == G_LOCK_WRITE) {
+		if (exclusive.pid == 0) {
+			fprintf(stderr, "Found READ, expected WRITE\n");
+			return;
+		}
+	} else {
+		if (exclusive.pid != 0) {
+			fprintf(stderr, "Found WRITE, expected READ\n");
+			return;
+		}
 	}
-	if (!server_id_equal(&locks[0].pid, &state->self)) {
+
+	pid = (exclusive.pid != 0) ? &exclusive : &shared[0];
+
+	if (!server_id_equal(pid, &state->self)) {
 		struct server_id_buf tmp1, tmp2;
 		fprintf(stderr, "found pid %s, expected %s\n",
-			server_id_str_buf(locks[0].pid, &tmp1),
+			server_id_str_buf(*pid, &tmp1),
 			server_id_str_buf(state->self, &tmp2));
 		return;
 	}
@@ -273,14 +287,6 @@ bool run_g_lock3(int dummy)
 		goto fail;
 	}
 
-	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_READ,
-			     (struct timeval) { .tv_sec = 1 });
-	if (!NT_STATUS_EQUAL(status, NT_STATUS_WAS_LOCKED)) {
-		fprintf(stderr, "g_lock_lock returned %s, expected %s\n",
-			nt_errstr(status), nt_errstr(NT_STATUS_WAS_LOCKED));
-		goto fail;
-	}
-
 	state.lock_type = G_LOCK_READ;
 	state.ok = false;
 
@@ -295,7 +301,7 @@ bool run_g_lock3(int dummy)
 		goto fail;
 	}
 
-	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_WRITE,
+	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_UPGRADE,
 			     (struct timeval) { .tv_sec = 1 });
 	if (!NT_STATUS_IS_OK(status)) {
 		fprintf(stderr, "g_lock_lock returned %s\n",
@@ -327,7 +333,9 @@ fail:
 }
 
 static bool lock4_child(const char *lockname,
-			int ready_pipe, int exit_pipe)
+			enum g_lock_type lock_type,
+			int ready_pipe,
+			int exit_pipe)
 {
 	struct tevent_context *ev = NULL;
 	struct messaging_context *msg = NULL;
@@ -341,8 +349,11 @@ static bool lock4_child(const char *lockname,
 		return false;
 	}
 
-	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_WRITE,
-			     (struct timeval) { .tv_sec = 1 });
+	status = g_lock_lock(
+		ctx,
+		string_term_tdb_data(lockname),
+		lock_type,
+		(struct timeval) { .tv_sec = 1 });
 	if (!NT_STATUS_IS_OK(status)) {
 		fprintf(stderr, "child: g_lock_lock returned %s\n",
 			nt_errstr(status));
@@ -408,30 +419,31 @@ struct lock4_check_state {
 	bool ok;
 };
 
-static void lock4_check(const struct g_lock_rec *locks,
-			size_t num_locks,
+static void lock4_check(struct server_id exclusive,
+			size_t num_shared,
+			struct server_id *shared,
 			const uint8_t *data,
 			size_t datalen,
 			void *private_data)
 {
 	struct lock4_check_state *state = private_data;
+	size_t num_locks = num_shared + ((exclusive.pid != 0) ? 1 : 0);
 
 	if (num_locks != 1) {
 		fprintf(stderr, "num_locks=%zu\n", num_locks);
 		return;
 	}
 
-	if (!server_id_equal(&state->me, &locks[0].pid)) {
-		struct server_id_buf buf1, buf2;
-		fprintf(stderr, "me=%s, locker=%s\n",
-			server_id_str_buf(state->me, &buf1),
-			server_id_str_buf(locks[0].pid, &buf2));
+	if (exclusive.pid == 0) {
+		fprintf(stderr, "Wrong lock type, not WRITE\n");
 		return;
 	}
 
-	if (locks[0].lock_type != G_LOCK_WRITE) {
-		fprintf(stderr, "wrong lock type: %d\n",
-			(int)locks[0].lock_type);
+	if (!server_id_equal(&state->me, &exclusive)) {
+		struct server_id_buf buf1, buf2;
+		fprintf(stderr, "me=%s, locker=%s\n",
+			server_id_str_buf(state->me, &buf1),
+			server_id_str_buf(exclusive, &buf2));
 		return;
 	}
 
@@ -439,7 +451,7 @@ static void lock4_check(const struct g_lock_rec *locks,
 }
 
 /*
- * Test a lock conflict
+ * Test a lock conflict: Contend with a WRITE lock
  */
 
 bool run_g_lock4(int dummy)
@@ -448,6 +460,7 @@ bool run_g_lock4(int dummy)
 	struct messaging_context *msg = NULL;
 	struct g_lock_ctx *ctx = NULL;
 	const char *lockname = "lock4";
+	TDB_DATA key = string_term_tdb_data(lockname);
 	pid_t child;
 	int ready_pipe[2];
 	int exit_pipe[2];
@@ -477,7 +490,8 @@ bool run_g_lock4(int dummy)
 	if (child == 0) {
 		close(ready_pipe[0]);
 		close(exit_pipe[1]);
-		ok = lock4_child(lockname, ready_pipe[1], exit_pipe[0]);
+		ok = lock4_child(
+			lockname, G_LOCK_WRITE, ready_pipe[1], exit_pipe[0]);
 		exit(ok ? 0 : 1);
 	}
 
@@ -494,24 +508,23 @@ bool run_g_lock4(int dummy)
 		return false;
 	}
 
-	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_WRITE,
-			     (struct timeval) { .tv_usec = 1 });
+	status = g_lock_lock(
+		ctx, key, G_LOCK_WRITE, (struct timeval) { .tv_usec = 1 });
 	if (!NT_STATUS_EQUAL(status, NT_STATUS_IO_TIMEOUT)) {
 		fprintf(stderr, "g_lock_lock returned %s\n",
 			nt_errstr(status));
 		goto fail;
 	}
 
-	status = g_lock_lock(ctx, string_term_tdb_data(lockname), G_LOCK_READ,
-			     (struct timeval) { .tv_usec = 1 });
+	status = g_lock_lock(
+		ctx, key, G_LOCK_READ, (struct timeval) { .tv_usec = 1 });
 	if (!NT_STATUS_EQUAL(status, NT_STATUS_IO_TIMEOUT)) {
 		fprintf(stderr, "g_lock_lock returned %s\n",
 			nt_errstr(status));
 		goto fail;
 	}
 
-	req = g_lock_lock_send(ev, ev, ctx, string_term_tdb_data(lockname),
-			       G_LOCK_WRITE);
+	req = g_lock_lock_send(ev, ev, ctx, key, G_LOCK_WRITE);
 	if (req == NULL) {
 		fprintf(stderr, "g_lock_lock send failed\n");
 		goto fail;
@@ -540,8 +553,138 @@ bool run_g_lock4(int dummy)
 			.me = messaging_server_id(msg)
 		};
 
-		status = g_lock_dump(ctx, string_term_tdb_data(lockname),
-				     lock4_check, &state);
+		status = g_lock_dump(ctx, key, lock4_check, &state);
+		if (!NT_STATUS_IS_OK(status)) {
+			fprintf(stderr, "g_lock_dump failed: %s\n",
+				nt_errstr(status));
+			goto fail;
+		}
+		if (!state.ok) {
+			fprintf(stderr, "lock4_check failed\n");
+			goto fail;
+		}
+	}
+
+	ret = true;
+fail:
+	TALLOC_FREE(ctx);
+	TALLOC_FREE(msg);
+	TALLOC_FREE(ev);
+	return ret;
+}
+
+/*
+ * Test a lock conflict: Contend with a READ lock
+ */
+
+bool run_g_lock4a(int dummy)
+{
+	struct tevent_context *ev = NULL;
+	struct messaging_context *msg = NULL;
+	struct g_lock_ctx *ctx = NULL;
+	const char *lockname = "lock4a";
+	TDB_DATA key = string_term_tdb_data(lockname);
+	pid_t child;
+	int ready_pipe[2];
+	int exit_pipe[2];
+	NTSTATUS status;
+	bool ret = false;
+	struct tevent_req *req;
+	bool ok;
+	int done;
+
+	if ((pipe(ready_pipe) != 0) || (pipe(exit_pipe) != 0)) {
+		perror("pipe failed");
+		return false;
+	}
+
+	child = fork();
+
+	ok = get_g_lock_ctx(talloc_tos(), &ev, &msg, &ctx);
+	if (!ok) {
+		goto fail;
+	}
+
+	if (child == -1) {
+		perror("fork failed");
+		return false;
+	}
+
+	if (child == 0) {
+		close(ready_pipe[0]);
+		close(exit_pipe[1]);
+		ok = lock4_child(
+			lockname, G_LOCK_READ, ready_pipe[1], exit_pipe[0]);
+		exit(ok ? 0 : 1);
+	}
+
+	close(ready_pipe[1]);
+	close(exit_pipe[0]);
+
+	if (sys_read(ready_pipe[0], &ok, sizeof(ok)) != sizeof(ok)) {
+		perror("read failed");
+		return false;
+	}
+
+	if (!ok) {
+		fprintf(stderr, "child returned error\n");
+		return false;
+	}
+
+	status = g_lock_lock(
+		ctx, key, G_LOCK_WRITE, (struct timeval) { .tv_usec = 1 });
+	if (!NT_STATUS_EQUAL(status, NT_STATUS_IO_TIMEOUT)) {
+		fprintf(stderr, "g_lock_lock returned %s\n",
+			nt_errstr(status));
+		goto fail;
+	}
+
+	status = g_lock_lock(
+		ctx, key, G_LOCK_READ, (struct timeval) { .tv_usec = 1 });
+	if (!NT_STATUS_IS_OK(status)) {
+		fprintf(stderr, "g_lock_lock returned %s\n",
+			nt_errstr(status));
+		goto fail;
+	}
+
+	status = g_lock_unlock(ctx, key);
+	if (!NT_STATUS_IS_OK(status)) {
+		fprintf(stderr,
+			"g_lock_unlock returned %s\n",
+			nt_errstr(status));
+		goto fail;
+	}
+
+	req = g_lock_lock_send(ev, ev, ctx, key, G_LOCK_WRITE);
+	if (req == NULL) {
+		fprintf(stderr, "g_lock_lock send failed\n");
+		goto fail;
+	}
+	tevent_req_set_callback(req, lock4_done, &done);
+
+	req = tevent_wakeup_send(ev, ev, timeval_current_ofs(1, 0));
+	if (req == NULL) {
+		fprintf(stderr, "tevent_wakeup_send failed\n");
+		goto fail;
+	}
+	tevent_req_set_callback(req, lock4_waited, &exit_pipe[1]);
+
+	done = 0;
+
+	while (done == 0) {
+		int tevent_ret = tevent_loop_once(ev);
+		if (tevent_ret != 0) {
+			perror("tevent_loop_once failed");
+			goto fail;
+		}
+	}
+
+	{
+		struct lock4_check_state state = {
+			.me = messaging_server_id(msg)
+		};
+
+		status = g_lock_dump(ctx, key, lock4_check, &state);
 		if (!NT_STATUS_IS_OK(status)) {
 			fprintf(stderr, "g_lock_dump failed: %s\n",
 				nt_errstr(status));
@@ -565,14 +708,15 @@ struct lock5_parser_state {
 	size_t num_locks;
 };
 
-static void lock5_parser(const struct g_lock_rec *locks,
-			 size_t num_locks,
+static void lock5_parser(struct server_id exclusive,
+			 size_t num_shared,
+			 struct server_id *shared,
 			 const uint8_t *data,
 			 size_t datalen,
 			 void *private_data)
 {
 	struct lock5_parser_state *state = private_data;
-	state->num_locks = num_locks;
+	state->num_locks = num_shared + ((exclusive.pid != 0) ? 1 : 0);
 }
 
 /*
@@ -711,14 +855,15 @@ struct lock6_parser_state {
 	size_t num_locks;
 };
 
-static void lock6_parser(const struct g_lock_rec *locks,
-			 size_t num_locks,
+static void lock6_parser(struct server_id exclusive,
+			 size_t num_shared,
+			 struct server_id *shared,
 			 const uint8_t *data,
 			 size_t datalen,
 			 void *private_data)
 {
 	struct lock6_parser_state *state = private_data;
-	state->num_locks = num_locks;
+	state->num_locks = num_shared + ((exclusive.pid != 0) ? 1 : 0);
 }
 
 /*
@@ -886,7 +1031,7 @@ bool run_g_lock6(int dummy)
 		}
 	}
 
-	status = g_lock_lock(ctx, lockname, G_LOCK_WRITE,
+	status = g_lock_lock(ctx, lockname, G_LOCK_UPGRADE,
 			     (struct timeval) { .tv_sec = 1 });
 	if (!NT_STATUS_IS_OK(status)) {
 		fprintf(stderr, "g_lock_lock failed: %s\n",
@@ -897,6 +1042,171 @@ bool run_g_lock6(int dummy)
 	return true;
 }
 
+/*
+ * Test upgrade deadlock
+ */
+
+bool run_g_lock7(int dummy)
+{
+	struct tevent_context *ev = NULL;
+	struct messaging_context *msg = NULL;
+	struct g_lock_ctx *ctx = NULL;
+	const char *lockname = "lock7";
+	TDB_DATA key = string_term_tdb_data(lockname);
+	pid_t child;
+	int ready_pipe[2];
+	int down_pipe[2];
+	ssize_t n;
+	NTSTATUS status;
+	bool ret = false;
+	bool ok = true;
+
+	if ((pipe(ready_pipe) != 0) || (pipe(down_pipe) != 0)) {
+		perror("pipe failed");
+		return false;
+	}
+
+	child = fork();
+
+	ok = get_g_lock_ctx(talloc_tos(), &ev, &msg, &ctx);
+	if (!ok) {
+		goto fail;
+	}
+
+	if (child == -1) {
+		perror("fork failed");
+		return false;
+	}
+
+	if (child == 0) {
+		struct tevent_req *req = NULL;
+
+		close(ready_pipe[0]);
+		ready_pipe[0] = -1;
+		close(down_pipe[1]);
+		down_pipe[1] = -1;
+
+		status = reinit_after_fork(msg, ev, false, "");
+		if (!NT_STATUS_IS_OK(status)) {
+			fprintf(stderr,
+				"reinit_after_fork failed: %s\n",
+				nt_errstr(status));
+			exit(1);
+		}
+
+		printf("%d: locking READ\n", (int)getpid());
+
+		status = g_lock_lock(
+			ctx,
+			key,
+			G_LOCK_READ,
+			(struct timeval) { .tv_usec = 1 });
+		if (!NT_STATUS_IS_OK(status)) {
+			fprintf(stderr,
+				"g_lock_lock(READ) failed: %s\n",
+				nt_errstr(status));
+			exit(1);
+		}
+
+		ok = true;
+
+		n = sys_write(ready_pipe[1], &ok, sizeof(ok));
+		if (n != sizeof(ok)) {
+			fprintf(stderr,
+				"sys_write failed: %s\n",
+				strerror(errno));
+			exit(1);
+		}
+
+		n = sys_read(down_pipe[0], &ok, sizeof(ok));
+		if (n != sizeof(ok)) {
+			fprintf(stderr,
+				"sys_read failed: %s\n",
+				strerror(errno));
+			exit(1);
+		}
+
+		printf("%d: starting UPGRADE\n", (int)getpid());
+
+		req = g_lock_lock_send(
+			msg,
+			ev,
+			ctx,
+			key,
+			G_LOCK_UPGRADE);
+		if (req == NULL) {
+			fprintf(stderr, "g_lock_lock_send(UPGRADE) failed\n");
+			exit(1);
+		}
+
+		n = sys_write(ready_pipe[1], &ok, sizeof(ok));
+		if (n != sizeof(ok)) {
+			fprintf(stderr,
+				"sys_write failed: %s\n",
+				strerror(errno));
+			exit(1);
+		}
+
+		exit(0);
+	}
+
+	close(ready_pipe[1]);
+	close(down_pipe[0]);
+
+	if (sys_read(ready_pipe[0], &ok, sizeof(ok)) != sizeof(ok)) {
+		perror("read failed");
+		return false;
+	}
+	if (!ok) {
+		fprintf(stderr, "child returned error\n");
+		return false;
+	}
+
+	status = g_lock_lock(
+		ctx,
+		key,
+		G_LOCK_READ,
+		(struct timeval) { .tv_usec = 1 });
+	if (!NT_STATUS_IS_OK(status)) {
+		fprintf(stderr,
+			"g_lock_lock(READ) failed: %s\n",
+			nt_errstr(status));
+		goto fail;
+	}
+
+	n = sys_write(down_pipe[1], &ok, sizeof(ok));
+	if (n != sizeof(ok)) {
+		fprintf(stderr,
+			"sys_write failed: %s\n",
+			strerror(errno));
+		goto fail;
+	}
+
+	if (sys_read(ready_pipe[0], &ok, sizeof(ok)) != sizeof(ok)) {
+		perror("read failed");
+		goto fail;
+	}
+
+	status = g_lock_lock(
+		ctx,
+		key,
+		G_LOCK_UPGRADE,
+		(struct timeval) { .tv_sec = 10 });
+	if (!NT_STATUS_EQUAL(status, NT_STATUS_POSSIBLE_DEADLOCK)) {
+		fprintf(stderr,
+			"g_lock_lock returned %s\n",
+			nt_errstr(status));
+		goto fail;
+	}
+
+	ret = true;
+fail:
+	TALLOC_FREE(ctx);
+	TALLOC_FREE(msg);
+	TALLOC_FREE(ev);
+	return ret;
+}
+
 extern int torture_numops;
 extern int torture_nprocs;
 
diff --git a/source3/torture/torture.c b/source3/torture/torture.c
index bfc2a2e24c9..2ff735b3d22 100644
--- a/source3/torture/torture.c
+++ b/source3/torture/torture.c
@@ -3342,7 +3342,9 @@ static bool run_locktest12(int dummy)
 
 	ret = true;
 done:
-	torture_close_connection(cli);
+	if (cli != NULL) {
+		torture_close_connection(cli);
+	}
 	return ret;
 }
 
@@ -3543,7 +3545,9 @@ static bool run_locktest13(int dummy)
 
 	ret = true;
 done:
-	torture_close_connection(cli);
+	if (cli != NULL) {
+		torture_close_connection(cli);
+	}
 	return ret;
 }
 
@@ -14667,6 +14671,10 @@ static struct {
 		.name  = "LOCAL-DBWRAP-WATCH3",
 		.fn    = run_dbwrap_watch3,
 	},
+	{
+		.name  = "LOCAL-DBWRAP-WATCH4",
+		.fn    = run_dbwrap_watch4,
+	},
 	{
 		.name  = "LOCAL-DBWRAP-DO-LOCKED1",
 		.fn    = run_dbwrap_do_locked1,
@@ -14803,6 +14811,10 @@ static struct {
 		.name  = "LOCAL-G-LOCK4",
 		.fn    = run_g_lock4,
 	},
+	{
+		.name  = "LOCAL-G-LOCK4A",
+		.fn    = run_g_lock4a,
+	},
 	{
 		.name  = "LOCAL-G-LOCK5",
 		.fn    = run_g_lock5,
@@ -14811,6 +14823,10 @@ static struct {
 		.name  = "LOCAL-G-LOCK6",
 		.fn    = run_g_lock6,
 	},
+	{
+		.name  = "LOCAL-G-LOCK7",
+		.fn    = run_g_lock7,
+	},
 	{
 		.name  = "LOCAL-G-LOCK-PING-PONG",
 		.fn    = run_g_lock_ping_pong,
diff --git a/source3/utils/net.c b/source3/utils/net.c
index 71b9b07d7d7..683b46794e4 100644
--- a/source3/utils/net.c
+++ b/source3/utils/net.c
@@ -51,6 +51,7 @@
 #include "cmdline_contexts.h"
 #include "lib/gencache.h"
 #include "auth/credentials/credentials.h"
+#include "source3/utils/passwd_proto.h"
 
 #ifdef WITH_FAKE_KASERVER
 #include "utils/net_afs.h"
diff --git a/source3/utils/net_ads_gpo.c b/source3/utils/net_ads_gpo.c
index cd77f93ffd3..4a2d19a4ba5 100644
--- a/source3/utils/net_ads_gpo.c
+++ b/source3/utils/net_ads_gpo.c
@@ -134,29 +134,7 @@ static int net_ads_gpo_refresh(struct net_context *c, int argc, const char **arg
 		d_printf(_("* dumping GPO list\n"));
 
 		for (gpo = gpo_list; gpo; gpo = gpo->next) {
-
 			dump_gpo(gpo, 0);
-#if 0
-		char *server, *share, *nt_path, *unix_path;
-
-		d_printf("--------------------------------------\n");
-		d_printf("Name:\t\t\t%s\n", gpo->display_name);
-		d_printf("LDAP GPO version:\t%d (user: %d, machine: %d)\n",
-			gpo->version,
-			GPO_VERSION_USER(gpo->version),
-			GPO_VERSION_MACHINE(gpo->version));
-
-		result = gpo_explode_filesyspath(mem_ctx, gpo->file_sys_path,
-						 &server, &share, &nt_path,
-						 &unix_path);
-		if (!NT_STATUS_IS_OK(result)) {
-			d_printf("got: %s\n", nt_errstr(result));
-		}
-
-		d_printf("GPO stored on server: %s, share: %s\n", server, share);
-		d_printf("\tremote path:\t%s\n", nt_path);
-		d_printf("\tlocal path:\t%s\n", unix_path);
-#endif
 		}
 	}
 
@@ -179,30 +157,7 @@ static int net_ads_gpo_refresh(struct net_context *c, int argc, const char **arg
 		d_printf(_("* dumping GPO list from registry\n"));
 
 		for (gpo = read_list; gpo; gpo = gpo->next) {
-
 			dump_gpo(gpo, 0);
-
-#if 0
-		char *server, *share, *nt_path, *unix_path;
-
-		d_printf("--------------------------------------\n");
-		d_printf("Name:\t\t\t%s\n", gpo->display_name);
-		d_printf("LDAP GPO version:\t%d (user: %d, machine: %d)\n",
-			gpo->version,
-			GPO_VERSION_USER(gpo->version),
-			GPO_VERSION_MACHINE(gpo->version));
-
-		result = gpo_explode_filesyspath(mem_ctx, gpo->file_sys_path,
-						 &server, &share, &nt_path,
-						 &unix_path);
-		if (!NT_STATUS_IS_OK(result)) {
-			d_printf("got: %s\n", nt_errstr(result));
-		}
-
-		d_printf("GPO stored on server: %s, share: %s\n", server, share);
-		d_printf("\tremote path:\t%s\n", nt_path);
-		d_printf("\tlocal path:\t%s\n", unix_path);
-#endif
 		}
 	}
 
diff --git a/source3/utils/net_conf.c b/source3/utils/net_conf.c
index 097baa1b82e..267c4c802df 100644
--- a/source3/utils/net_conf.c
+++ b/source3/utils/net_conf.c
@@ -745,6 +745,7 @@ static int net_conf_delshare(struct net_context *c,
 	int ret = -1;
 	const char *sharename = NULL;
 	sbcErr err;
+	NTSTATUS status;
 	TALLOC_CTX *mem_ctx = talloc_stackframe();
 
 	if (argc != 1 || c->display_usage) {
@@ -764,6 +765,14 @@ static int net_conf_delshare(struct net_context *c,
 		goto done;
 	}
 
+	status = delete_share_security(sharename);
+	if (!NT_STATUS_IS_OK(status) &&
+	    !NT_STATUS_EQUAL(status, NT_STATUS_NOT_FOUND)) {
+		d_fprintf(stderr, _("deleting share acl failed for %s: %s\n"),
+			  sharename, nt_errstr(status));
+		goto done;
+	}
+
 	ret = 0;
 done:
 	TALLOC_FREE(mem_ctx);
diff --git a/source3/utils/net_g_lock.c b/source3/utils/net_g_lock.c
index 8dd58b2c1ba..3652fc7b13f 100644
--- a/source3/utils/net_g_lock.c
+++ b/source3/utils/net_g_lock.c
@@ -111,19 +111,24 @@ done:
 	return result;
 }
 
-static void net_g_lock_dump_fn(const struct g_lock_rec *locks,
-			       size_t num_locks,
-			       const uint8_t *data,
-			       size_t datalen,
-			       void *private_data)
+static void net_g_lock_dump_fn(struct server_id exclusive,
+				size_t num_shared,
+				struct server_id *shared,
+				const uint8_t *data,
+				size_t datalen,
+				void *private_data)
 {
-	size_t i;
-
-	for (i=0; i<num_locks; i++) {
-		const struct g_lock_rec *l = &locks[i];
-		struct server_id_buf idbuf;
-		d_printf("%s: %s\n", server_id_str_buf(l->pid, &idbuf),
-			 (l->lock_type & 1) ? "WRITE" : "READ");
+	struct server_id_buf idbuf;
+
+	if (exclusive.pid != 0) {
+		d_printf("%s: WRITE\n",
+			 server_id_str_buf(exclusive, &idbuf));
+	} else {
+		size_t i;
+		for (i=0; i<num_shared; i++) {
+			d_printf("%s: READ\n",
+				 server_id_str_buf(shared[i], &idbuf));
+		}
 	}
 	dump_data_file(data, datalen, true, stdout);
 }
diff --git a/source3/utils/net_proto.h b/source3/utils/net_proto.h
index 13058be8b8b..d5387f50e46 100644
--- a/source3/utils/net_proto.h
+++ b/source3/utils/net_proto.h
@@ -439,11 +439,6 @@ NTSTATUS net_lookup_name_from_sid(struct net_context *c,
 NTSTATUS net_lookup_sid_from_name(struct net_context *c, TALLOC_CTX *ctx,
 				  const char *full_name, struct dom_sid *pret_sid);
 
-/* The following definitions come from utils/passwd_util.c  */
-
-char *stdin_new_passwd( void);
-char *get_pass( const char *prompt, bool stdin_get);
-
 /* The following definitions come from utils/net_g_lock.c  */
 int net_g_lock(struct net_context *c, int argc, const char **argv);
 
diff --git a/source3/utils/net_rpc.c b/source3/utils/net_rpc.c
index 96c94e5179b..e4cf7ef05f5 100644
--- a/source3/utils/net_rpc.c
+++ b/source3/utils/net_rpc.c
@@ -7472,8 +7472,9 @@ bool net_rpc_check(struct net_context *c, unsigned flags)
 		}
 		return false;
 	}
-	status = smbXcli_negprot(cli->conn, cli->timeout, PROTOCOL_CORE,
-				 PROTOCOL_NT1);
+	status = smbXcli_negprot(cli->conn, cli->timeout,
+				 lp_client_min_protocol(),
+				 lp_client_max_protocol());
 	if (!NT_STATUS_IS_OK(status))
 		goto done;
 	if (smbXcli_conn_protocol(cli->conn) < PROTOCOL_NT1)
diff --git a/source3/utils/net_tdb.c b/source3/utils/net_tdb.c
index a03cc0e2c09..0b81acf18e5 100644
--- a/source3/utils/net_tdb.c
+++ b/source3/utils/net_tdb.c
@@ -51,7 +51,9 @@ static int net_tdb_locking_fetch(TALLOC_CTX *mem_ctx, const char *hexkey,
 
 	blob = strhex_to_data_blob(mem_ctx, hexkey);
 	if (blob.length != sizeof(struct file_id)) {
-		d_printf("Invalid length of key\n");
+		d_printf("Invalid length %zu of key, expected %zu\n",
+			 blob.length,
+			 sizeof(struct file_id));
 		return -1;
 	}
 
@@ -93,10 +95,20 @@ static int net_tdb_locking(struct net_context *c, int argc, const char **argv)
 	if (argc == 2 && strequal(argv[1], "dump")) {
 		ret = net_tdb_locking_dump(mem_ctx, lock->data);
 	} else {
+		NTSTATUS status;
+		size_t num_share_modes = 0;
+
+		status = share_mode_count_entries(
+			lock->data->id, &num_share_modes);
+		if (!NT_STATUS_IS_OK(status)) {
+			d_fprintf(stderr,
+				  "Could not count share entries: %s\n",
+				  nt_errstr(status));
+		}
+
 		d_printf("Share path:            %s\n", lock->data->servicepath);
 		d_printf("Name:                  %s\n", lock->data->base_name);
-		d_printf("Number of share modes: %" PRIu32 "\n",
-			 lock->data->num_share_modes);
+		d_printf("Number of share modes: %zu\n", num_share_modes);
 	}
 
 out:
diff --git a/source3/utils/net_time.c b/source3/utils/net_time.c
index 5e6cf2ea15d..d102f84614f 100644
--- a/source3/utils/net_time.c
+++ b/source3/utils/net_time.c
@@ -47,8 +47,9 @@ static time_t cli_servertime(const char *host,
 		goto done;
 	}
 
-	status = smbXcli_negprot(cli->conn, cli->timeout, PROTOCOL_CORE,
-				 PROTOCOL_NT1);
+	status = smbXcli_negprot(cli->conn, cli->timeout,
+				 lp_client_min_protocol(),
+				 lp_client_max_protocol());
 	if (!NT_STATUS_IS_OK(status)) {
 		fprintf(stderr, _("Protocol negotiation failed: %s\n"),
 			nt_errstr(status));
diff --git a/source3/utils/net_usershare.c b/source3/utils/net_usershare.c
index f5b126aa3d1..637ef801352 100644
--- a/source3/utils/net_usershare.c
+++ b/source3/utils/net_usershare.c
@@ -135,7 +135,9 @@ int net_usershare_usage(struct net_context *c, int argc, const char **argv)
 
 static char *get_basepath(TALLOC_CTX *ctx)
 {
-	char *basepath = lp_usershare_path(ctx);
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+	char *basepath = lp_usershare_path(ctx, lp_sub);
 
 	if (!basepath) {
 		return NULL;
@@ -152,6 +154,8 @@ static char *get_basepath(TALLOC_CTX *ctx)
 
 static int net_usershare_delete(struct net_context *c, int argc, const char **argv)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	char *us_path;
 	char *sharename;
 
@@ -174,7 +178,7 @@ static int net_usershare_delete(struct net_context *c, int argc, const char **ar
 
 	us_path = talloc_asprintf(talloc_tos(),
 				"%s/%s",
-				lp_usershare_path(talloc_tos()),
+				lp_usershare_path(talloc_tos(), lp_sub),
 				sharename);
 	if (!us_path) {
 		TALLOC_FREE(sharename);
@@ -1075,6 +1079,8 @@ static int net_usershare_list(struct net_context *c, int argc,
 
 int net_usershare(struct net_context *c, int argc, const char **argv)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	DIR *dp;
 
 	struct functable func[] = {
@@ -1120,13 +1126,13 @@ int net_usershare(struct net_context *c, int argc, const char **argv)
 		return -1;
 	}
 
-	dp = opendir(lp_usershare_path(talloc_tos()));
+	dp = opendir(lp_usershare_path(talloc_tos(), lp_sub));
 	if (!dp) {
 		int err = errno;
 		d_fprintf(stderr,
 			_("net usershare: cannot open usershare directory %s. "
 			  "Error %s\n"),
-			lp_usershare_path(talloc_tos()), strerror(err) );
+			lp_usershare_path(talloc_tos(), lp_sub), strerror(err) );
 		if (err == EACCES) {
 			d_fprintf(stderr,
 				_("You do not have permission to create a "
diff --git a/source3/utils/net_vfs.c b/source3/utils/net_vfs.c
index c9e115292b3..d5f6beddb88 100644
--- a/source3/utils/net_vfs.c
+++ b/source3/utils/net_vfs.c
@@ -114,6 +114,8 @@ static bool net_vfs_make_session_info(struct auth_session_info **session_info)
 
 static int net_vfs_init(struct net_context *c, int argc, const char **argv)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char *service = NULL;
 	char *share_root = NULL;
 	int snum;
@@ -166,7 +168,7 @@ static int net_vfs_init(struct net_context *c, int argc, const char **argv)
 		goto done;
 	}
 
-	share_root = lp_path(state.mem_ctx, snum);
+	share_root = lp_path(state.mem_ctx, lp_sub, snum);
 	if (share_root == NULL) {
 		fprintf(stderr, "Failed to find share root for service: %s\n",
 			service);
diff --git a/source3/utils/ntlm_auth.c b/source3/utils/ntlm_auth.c
index 750115528ad..7f8d2688978 100644
--- a/source3/utils/ntlm_auth.c
+++ b/source3/utils/ntlm_auth.c
@@ -47,6 +47,7 @@
 #include "lib/param/loadparm.h"
 #include "lib/util/base64.h"
 #include "cmdline_contexts.h"
+#include "lib/util/tevent_ntstatus.h"
 
 #include <gnutls/gnutls.h>
 #include <gnutls/crypto.h>
@@ -940,91 +941,246 @@ static NTSTATUS ntlm_auth_set_challenge(struct auth4_context *auth_ctx, const ui
  * Return the session keys used on the connection.
  */
 
-static NTSTATUS winbind_pw_check(struct auth4_context *auth4_context,
-				 TALLOC_CTX *mem_ctx,
-				 const struct auth_usersupplied_info *user_info,
-				 uint8_t *pauthoritative,
-				 void **server_returned_info,
-				 DATA_BLOB *session_key, DATA_BLOB *lm_session_key)
+struct winbind_pw_check_state {
+	uint8_t authoritative;
+	void *server_info;
+	DATA_BLOB nt_session_key;
+	DATA_BLOB lm_session_key;
+};
+
+static struct tevent_req *winbind_pw_check_send(
+	TALLOC_CTX *mem_ctx,
+	struct tevent_context *ev,
+	struct auth4_context *auth4_context,
+	const struct auth_usersupplied_info *user_info)
 {
+	struct tevent_req *req = NULL;
+	struct winbind_pw_check_state *state = NULL;
 	NTSTATUS nt_status;
 	char *error_string = NULL;
 	uint8_t lm_key[8];
 	uint8_t user_sess_key[16];
 	char *unix_name = NULL;
 
-	nt_status = contact_winbind_auth_crap(user_info->client.account_name, user_info->client.domain_name,
-					      user_info->workstation_name,
-					      &auth4_context->challenge.data,
-					      &user_info->password.response.lanman,
-					      &user_info->password.response.nt,
-					      WBFLAG_PAM_LMKEY | WBFLAG_PAM_USER_SESSION_KEY | WBFLAG_PAM_UNIX_NAME,
-					      0,
-					      lm_key, user_sess_key,
-					      pauthoritative,
-					      &error_string, &unix_name);
-
-	if (NT_STATUS_IS_OK(nt_status)) {
-		if (!all_zero(lm_key, 8)) {
-			*lm_session_key = data_blob_talloc(mem_ctx, NULL, 16);
-			memcpy(lm_session_key->data, lm_key, 8);
-			memset(lm_session_key->data+8, '\0', 8);
+	req = tevent_req_create(
+		mem_ctx, &state, struct winbind_pw_check_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	nt_status = contact_winbind_auth_crap(
+		user_info->client.account_name,
+		user_info->client.domain_name,
+		user_info->workstation_name,
+		&auth4_context->challenge.data,
+		&user_info->password.response.lanman,
+		&user_info->password.response.nt,
+		WBFLAG_PAM_LMKEY |
+		WBFLAG_PAM_USER_SESSION_KEY |
+		WBFLAG_PAM_UNIX_NAME,
+		0,
+		lm_key, user_sess_key,
+		&state->authoritative,
+		&error_string,
+		&unix_name);
+
+	if (tevent_req_nterror(req, nt_status)) {
+		if (NT_STATUS_EQUAL(nt_status, NT_STATUS_ACCESS_DENIED)) {
+			DBG_ERR("Login for user [%s]\\[%s]@[%s] failed due "
+				"to [%s]\n",
+				user_info->client.domain_name,
+				user_info->client.account_name,
+				user_info->workstation_name,
+				error_string ?
+				error_string :
+				"unknown error (NULL)");
+		} else {
+			DBG_NOTICE("Login for user [%s]\\[%s]@[%s] failed due "
+				   "to [%s]\n",
+				   user_info->client.domain_name,
+				   user_info->client.account_name,
+				   user_info->workstation_name,
+				   error_string ?
+				   error_string :
+				   "unknown error (NULL)");
 		}
+		goto done;
+	}
 
-		if (!all_zero(user_sess_key, 16)) {
-			*session_key = data_blob_talloc(mem_ctx, user_sess_key, 16);
+	if (!all_zero(lm_key, 8)) {
+		state->lm_session_key = data_blob_talloc(state, NULL, 16);
+		if (tevent_req_nomem(state->lm_session_key.data, req)) {
+			goto done;
 		}
-		*server_returned_info = talloc_strdup(mem_ctx,
-						      unix_name);
-	} else {
-		DEBUG(NT_STATUS_EQUAL(nt_status, NT_STATUS_ACCESS_DENIED) ? 0 : 3, 
-		      ("Login for user [%s]\\[%s]@[%s] failed due to [%s]\n",
-		       user_info->client.domain_name, user_info->client.account_name,
-		       user_info->workstation_name,
-		       error_string ? error_string : "unknown error (NULL)"));
+		memcpy(state->lm_session_key.data, lm_key, 8);
+		memset(state->lm_session_key.data+8, '\0', 8);
+	}
+	if (!all_zero(user_sess_key, 16)) {
+		state->nt_session_key = data_blob_talloc(
+			state, user_sess_key, 16);
+		if (tevent_req_nomem(state->nt_session_key.data, req)) {
+			goto done;
+		}
+	}
+	state->server_info = talloc_strdup(state, unix_name);
+	if (tevent_req_nomem(state->server_info, req)) {
+		goto done;
 	}
+	tevent_req_done(req);
 
+done:
 	SAFE_FREE(error_string);
 	SAFE_FREE(unix_name);
-	return nt_status;
+	return tevent_req_post(req, ev);
 }
 
-static NTSTATUS local_pw_check(struct auth4_context *auth4_context,
-				TALLOC_CTX *mem_ctx,
-				const struct auth_usersupplied_info *user_info,
-				uint8_t *pauthoritative,
-				void **server_returned_info,
-				DATA_BLOB *session_key, DATA_BLOB *lm_session_key)
+static NTSTATUS winbind_pw_check_recv(struct tevent_req *req,
+				      TALLOC_CTX *mem_ctx,
+				      uint8_t *pauthoritative,
+				      void **server_returned_info,
+				      DATA_BLOB *nt_session_key,
+				      DATA_BLOB *lm_session_key)
 {
-	NTSTATUS nt_status;
+	struct winbind_pw_check_state *state = tevent_req_data(
+		req, struct winbind_pw_check_state);
+	NTSTATUS status;
+
+	if (pauthoritative != NULL) {
+		*pauthoritative = state->authoritative;
+	}
+
+	if (tevent_req_is_nterror(req, &status)) {
+		return status;
+	}
+
+	if (server_returned_info != NULL) {
+		*server_returned_info = talloc_move(
+			mem_ctx, &state->server_info);
+	}
+	if (nt_session_key != NULL) {
+		*nt_session_key = (DATA_BLOB) {
+			.data = talloc_move(
+				mem_ctx, &state->nt_session_key.data),
+			.length = state->nt_session_key.length,
+		};
+	}
+	if (lm_session_key != NULL) {
+		*lm_session_key = (DATA_BLOB) {
+			.data = talloc_move(
+				mem_ctx, &state->lm_session_key.data),
+			.length = state->lm_session_key.length,
+		};
+	}
+
+	return NT_STATUS_OK;
+}
+
+struct local_pw_check_state {
+	uint8_t authoritative;
+	void *server_info;
+	DATA_BLOB nt_session_key;
+	DATA_BLOB lm_session_key;
+};
+
+static struct tevent_req *local_pw_check_send(
+	TALLOC_CTX *mem_ctx,
+	struct tevent_context *ev,
+	struct auth4_context *auth4_context,
+	const struct auth_usersupplied_info *user_info)
+{
+	struct tevent_req *req = NULL;
+	struct local_pw_check_state *state = NULL;
 	struct samr_Password lm_pw, nt_pw;
+	NTSTATUS nt_status;
+
+	req = tevent_req_create(
+		mem_ctx, &state, struct local_pw_check_state);
+	if (req == NULL) {
+		return NULL;
+	}
+	state->authoritative = 1;
 
 	nt_lm_owf_gen (opt_password, nt_pw.hash, lm_pw.hash);
 
-	*pauthoritative = 1;
+	nt_status = ntlm_password_check(
+		state,
+		true,
+		NTLM_AUTH_ON,
+		0,
+		&auth4_context->challenge.data,
+		&user_info->password.response.lanman,
+		&user_info->password.response.nt,
+		user_info->client.account_name,
+		user_info->client.account_name,
+		user_info->client.domain_name,
+		&lm_pw,
+		&nt_pw,
+		&state->nt_session_key,
+		&state->lm_session_key);
+
+	if (tevent_req_nterror(req, nt_status)) {
+		DBG_NOTICE("Login for user [%s]\\[%s]@[%s] failed due to "
+			   "[%s]\n",
+			   user_info->client.domain_name,
+			   user_info->client.account_name,
+			   user_info->workstation_name,
+			   nt_errstr(nt_status));
+		return tevent_req_post(req, ev);
+	}
+
+	state->server_info = talloc_asprintf(
+		state,
+		"%s%c%s",
+		user_info->client.domain_name,
+		*lp_winbind_separator(),
+		user_info->client.account_name);
+	if (tevent_req_nomem(state->server_info, req)) {
+		return tevent_req_post(req, ev);
+	}
+
+	tevent_req_done(req);
+	return tevent_req_post(req, ev);
+}
 
-	nt_status = ntlm_password_check(mem_ctx,
-					true, NTLM_AUTH_ON, 0,
-					&auth4_context->challenge.data,
-					&user_info->password.response.lanman,
-					&user_info->password.response.nt,
-					user_info->client.account_name,
-					user_info->client.account_name,
-					user_info->client.domain_name,
-					&lm_pw, &nt_pw, session_key, lm_session_key);
-
-	if (NT_STATUS_IS_OK(nt_status)) {
-		*server_returned_info = talloc_asprintf(mem_ctx,
-							"%s%c%s", user_info->client.domain_name,
-							*lp_winbind_separator(),
-							user_info->client.account_name);
-	} else {
-		DEBUG(3, ("Login for user [%s]\\[%s]@[%s] failed due to [%s]\n",
-			  user_info->client.domain_name, user_info->client.account_name,
-			  user_info->workstation_name,
-			  nt_errstr(nt_status)));
+static NTSTATUS local_pw_check_recv(struct tevent_req *req,
+				    TALLOC_CTX *mem_ctx,
+				    uint8_t *pauthoritative,
+				    void **server_returned_info,
+				    DATA_BLOB *nt_session_key,
+				    DATA_BLOB *lm_session_key)
+{
+	struct local_pw_check_state *state = tevent_req_data(
+		req, struct local_pw_check_state);
+	NTSTATUS status;
+
+	if (pauthoritative != NULL) {
+		*pauthoritative = state->authoritative;
 	}
-	return nt_status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		return status;
+	}
+
+	if (server_returned_info != NULL) {
+		*server_returned_info = talloc_move(
+			mem_ctx, &state->server_info);
+	}
+	if (nt_session_key != NULL) {
+		*nt_session_key = (DATA_BLOB) {
+			.data = talloc_move(
+				mem_ctx, &state->nt_session_key.data),
+			.length = state->nt_session_key.length,
+		};
+	}
+	if (lm_session_key != NULL) {
+		*lm_session_key = (DATA_BLOB) {
+			.data = talloc_move(
+				mem_ctx, &state->lm_session_key.data),
+			.length = state->lm_session_key.length,
+		};
+	}
+
+	return NT_STATUS_OK;
 }
 
 static NTSTATUS ntlm_auth_prepare_gensec_client(TALLOC_CTX *mem_ctx,
@@ -1111,9 +1267,13 @@ static struct auth4_context *make_auth4_context_ntlm_auth(TALLOC_CTX *mem_ctx, b
 	auth4_context->get_ntlm_challenge = ntlm_auth_get_challenge;
 	auth4_context->set_ntlm_challenge = ntlm_auth_set_challenge;
 	if (local_pw) {
-		auth4_context->check_ntlm_password = local_pw_check;
+		auth4_context->check_ntlm_password_send = local_pw_check_send;
+		auth4_context->check_ntlm_password_recv = local_pw_check_recv;
 	} else {
-		auth4_context->check_ntlm_password = winbind_pw_check;
+		auth4_context->check_ntlm_password_send =
+			winbind_pw_check_send;
+		auth4_context->check_ntlm_password_recv =
+			winbind_pw_check_recv;
 	}
 	auth4_context->private_data = NULL;
 	return auth4_context;
@@ -1197,7 +1357,7 @@ static NTSTATUS ntlm_auth_prepare_gensec_server(TALLOC_CTX *mem_ctx,
 	 */
 	server_credentials = cli_credentials_init_anon(tmp_ctx);
 	if (!server_credentials) {
-		DEBUG(0, ("auth_generic_prepare: Failed to init server credentials\n"));
+		DBG_ERR("Failed to init server credentials\n");
 		return NT_STATUS_NO_MEMORY;
 	}
 
@@ -1315,9 +1475,20 @@ static void manage_gensec_request(enum stdio_helper_mode stdio_helper_mode,
 	TALLOC_CTX *mem_ctx;
 
 	mem_ctx = talloc_named(NULL, 0, "manage_gensec_request internal mem_ctx");
+	if (mem_ctx == NULL) {
+		printf("BH No Memory\n");
+		exit(1);
+	}
 
 	if (*private1) {
-		state = (struct gensec_ntlm_state *)*private1;
+		state = talloc_get_type(*private1, struct gensec_ntlm_state);
+		if (state == NULL) {
+			DBG_WARNING("*private1 is of type %s\n",
+				    talloc_get_name(*private1));
+			printf("BH *private1 is of type %s\n",
+			       talloc_get_name(*private1));
+			exit(1);
+		}
 	} else {
 		state = talloc_zero(NULL, struct gensec_ntlm_state);
 		if (!state) {
@@ -1980,8 +2151,13 @@ static void manage_ntlm_change_password_1_request(enum stdio_helper_mode stdio_h
 					gnutls_cipher_deinit(cipher_hnd);
 					return;
 				}
-				E_old_pw_hash(new_nt_hash, old_lm_hash,
+				rc = E_old_pw_hash(new_nt_hash, old_lm_hash,
 					      old_lm_hash_enc.data);
+				if (rc != 0) {
+					DBG_ERR("E_old_pw_hash failed: %s\n",
+						gnutls_strerror(rc));
+					return;
+				}
 			} else {
 				new_lm_pswd.data = NULL;
 				new_lm_pswd.length = 0;
@@ -1999,8 +2175,13 @@ static void manage_ntlm_change_password_1_request(enum stdio_helper_mode stdio_h
 			if (rc < 0) {
 				return;
 			}
-			E_old_pw_hash(new_nt_hash, old_nt_hash,
+			rc = E_old_pw_hash(new_nt_hash, old_nt_hash,
 				      old_nt_hash_enc.data);
+			if (rc != 0) {
+				DBG_ERR("E_old_pw_hash failed: %s\n",
+					gnutls_strerror(rc));
+				return;
+			}
 
 			ZERO_ARRAY(old_nt_hash);
 			ZERO_ARRAY(old_lm_hash);
diff --git a/source3/utils/passwd_proto.h b/source3/utils/passwd_proto.h
index 104e00a65c3..40998998ae7 100644
--- a/source3/utils/passwd_proto.h
+++ b/source3/utils/passwd_proto.h
@@ -26,7 +26,6 @@
 
 /* The following definitions come from utils/passwd_util.c  */
 
-char *stdin_new_passwd( void);
 char *get_pass( const char *prompt, bool stdin_get);
 
 #endif /*  _PASSWD_PROTO_H_  */
diff --git a/source3/utils/passwd_util.c b/source3/utils/passwd_util.c
index 4884d63bf10..edd2c52e242 100644
--- a/source3/utils/passwd_util.c
+++ b/source3/utils/passwd_util.c
@@ -25,12 +25,13 @@
 */
 
 #include "includes.h"
+#include "passwd_proto.h"
 
 /*************************************************************
  Utility function to prompt for passwords from stdin. Each
  password entered must end with a newline.
 *************************************************************/
-char *stdin_new_passwd( void)
+static char *stdin_new_passwd( void)
 {
 	static fstring new_pw;
 	size_t len;
diff --git a/source3/utils/pdbedit.c b/source3/utils/pdbedit.c
index b6ee806e190..e0645a67423 100644
--- a/source3/utils/pdbedit.c
+++ b/source3/utils/pdbedit.c
@@ -26,6 +26,7 @@
 #include "../libcli/security/security.h"
 #include "passdb.h"
 #include "cmdline_contexts.h"
+#include "passwd_proto.h"
 
 #define BIT_BACKEND	0x00000004
 #define BIT_VERBOSE	0x00000008
diff --git a/source3/utils/sharesec.c b/source3/utils/sharesec.c
index 510505f0032..454c5bfe36b 100644
--- a/source3/utils/sharesec.c
+++ b/source3/utils/sharesec.c
@@ -163,6 +163,7 @@ static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename, char *th
 	struct security_descriptor *old = NULL;
 	size_t sd_size = 0;
 	uint32_t i, j;
+	NTSTATUS status;
 
 	if (mode != SMB_ACL_SET && mode != SMB_SD_DELETE) {
 	    if (!(old = get_share_security( mem_ctx, sharename, &sd_size )) ) {
@@ -245,7 +246,8 @@ static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename, char *th
 	    old = sd;
 	    break;
 	case SMB_SD_DELETE:
-	    if (!delete_share_security(sharename)) {
+	    status = delete_share_security(sharename);
+	    if (!NT_STATUS_IS_OK(status)) {
 		fprintf( stderr, "Failed to delete security descriptor for "
 			 "share [%s]\n", sharename );
 		return -1;
@@ -259,7 +261,8 @@ static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename, char *th
 	/* Denied ACE entries must come before allowed ones */
 	sort_acl(old->dacl);
 
-	if ( !set_share_security( sharename, old ) ) {
+	status = set_share_security(sharename, old);
+	if (!NT_STATUS_IS_OK(status)) {
 	    fprintf( stderr, "Failed to store acl for share [%s]\n", sharename );
 	    return 2;
 	}
@@ -269,7 +272,7 @@ static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename, char *th
 static int set_sharesec_sddl(const char *sharename, const char *sddl)
 {
 	struct security_descriptor *sd;
-	bool ret;
+	NTSTATUS status;
 
 	sd = sddl_decode(talloc_tos(), sddl, get_global_sam_sid());
 	if (sd == NULL) {
@@ -277,9 +280,9 @@ static int set_sharesec_sddl(const char *sharename, const char *sddl)
 		return -1;
 	}
 
-	ret = set_share_security(sharename, sd);
+	status = set_share_security(sharename, sd);
 	TALLOC_FREE(sd);
-	if (!ret) {
+	if (!NT_STATUS_IS_OK(status)) {
 		fprintf(stderr, "Failed to store acl for share [%s]\n",
 			sharename);
 		return -1;
@@ -531,7 +534,9 @@ int main(int argc, const char *argv[])
 
 		for (i=0; i<lp_numservices(); i++) {
 			TALLOC_CTX *frame = talloc_stackframe();
-			const char *service = lp_servicename(frame, i);
+			const struct loadparm_substitution *lp_sub =
+				loadparm_s3_global_substitution();
+			const char *service = lp_servicename(frame, lp_sub, i);
 
 			if (service == NULL) {
 				continue;
diff --git a/source3/utils/smbcontrol.c b/source3/utils/smbcontrol.c
index 35cb7d39a02..d779f0d14ea 100644
--- a/source3/utils/smbcontrol.c
+++ b/source3/utils/smbcontrol.c
@@ -807,6 +807,30 @@ static bool do_closeshare(struct tevent_context *ev_ctx,
 			    strlen(argv[1]) + 1);
 }
 
+/*
+ * Close a share if access denied by now
+ **/
+
+static bool do_close_denied_share(
+	struct tevent_context *ev_ctx,
+	struct messaging_context *msg_ctx,
+	const struct server_id pid,
+	const int argc, const char **argv)
+{
+	if (argc != 2) {
+		fprintf(stderr, "Usage: smbcontrol <dest> close-denied-share "
+			"<sharename>\n");
+		return False;
+	}
+
+	return send_message(
+		msg_ctx,
+		pid,
+		MSG_SMB_FORCE_TDIS_DENIED,
+		argv[1],
+		strlen(argv[1]) + 1);
+}
+
 /* Kill a client by IP address */
 static bool do_kill_client_by_ip(struct tevent_context *ev_ctx,
 				 struct messaging_context *msg_ctx,
@@ -1433,6 +1457,11 @@ static const struct {
 		.fn   = do_closeshare,
 		.help = "Forcibly disconnect a share",
 	},
+	{
+		.name = "close-denied-share",
+		.fn   = do_close_denied_share,
+		.help = "Forcibly disconnect users from shares disallowed now",
+	},
 	{
 		.name = "kill-client-ip",
 		.fn   = do_kill_client_by_ip,
diff --git a/source3/utils/smbpasswd.c b/source3/utils/smbpasswd.c
index a6509abe5cb..40131205265 100644
--- a/source3/utils/smbpasswd.c
+++ b/source3/utils/smbpasswd.c
@@ -24,6 +24,7 @@
 #include "libsmb/proto.h"
 #include "passdb.h"
 #include "cmdline_contexts.h"
+#include "passwd_proto.h"
 
 /*
  * Next two lines needed for SunOS and don't
@@ -295,7 +296,7 @@ static bool store_ldap_admin_pw (char* pw)
 	if (!secrets_init())
 		return False;
 
-	return secrets_store_ldap_pw(lp_ldap_admin_dn(talloc_tos()), pw);
+	return secrets_store_ldap_pw(lp_ldap_admin_dn(), pw);
 }
 
 
@@ -310,7 +311,7 @@ static int process_root(int local_flags)
 	char *old_passwd = NULL;
 
 	if (local_flags & LOCAL_SET_LDAP_ADMIN_PW) {
-		char *ldap_admin_dn = lp_ldap_admin_dn(talloc_tos());
+		const char *ldap_admin_dn = lp_ldap_admin_dn();
 		if ( ! *ldap_admin_dn ) {
 			DEBUG(0,("ERROR: 'ldap admin dn' not defined! Please check your smb.conf\n"));
 			goto done;
diff --git a/source3/utils/testparm.c b/source3/utils/testparm.c
index f4e94b6ef74..e4c805da9a3 100644
--- a/source3/utils/testparm.c
+++ b/source3/utils/testparm.c
@@ -211,6 +211,8 @@ static int do_global_checks(void)
 	int ret = 0;
 	SMB_STRUCT_STAT st;
 	const char *socket_options;
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 
 	if (lp_security() >= SEC_DOMAIN && !lp_encrypt_passwords()) {
 		fprintf(stderr, "ERROR: in 'security=domain' mode the "
@@ -373,8 +375,8 @@ static int do_global_checks(void)
 		if (!lp_pam_password_change()) {
 #endif
 
-			if((lp_passwd_program(talloc_tos()) == NULL) ||
-			   (strlen(lp_passwd_program(talloc_tos())) == 0))
+			if((lp_passwd_program(talloc_tos(), lp_sub) == NULL) ||
+			   (strlen(lp_passwd_program(talloc_tos(), lp_sub)) == 0))
 			{
 				fprintf(stderr,
 					"ERROR: the 'unix password sync' "
@@ -386,7 +388,7 @@ static int do_global_checks(void)
 				char *truncated_prog = NULL;
 				const char *p;
 
-				passwd_prog = lp_passwd_program(talloc_tos());
+				passwd_prog = lp_passwd_program(talloc_tos(), lp_sub);
 				p = passwd_prog;
 				next_token_talloc(talloc_tos(),
 						&p,
@@ -407,7 +409,7 @@ static int do_global_checks(void)
 		}
 #endif
 
-		if(lp_passwd_chat(talloc_tos()) == NULL) {
+		if(lp_passwd_chat(talloc_tos(), lp_sub) == NULL) {
 			fprintf(stderr,
 				"ERROR: the 'unix password sync' parameter is "
 				"set and there is no valid 'passwd chat' "
@@ -415,15 +417,15 @@ static int do_global_checks(void)
 			ret = 1;
 		}
 
-		if ((lp_passwd_program(talloc_tos()) != NULL) &&
-		    (strlen(lp_passwd_program(talloc_tos())) > 0))
+		if ((lp_passwd_program(talloc_tos(), lp_sub) != NULL) &&
+		    (strlen(lp_passwd_program(talloc_tos(), lp_sub)) > 0))
 		{
 			/* check if there's a %u parameter present */
-			if(strstr_m(lp_passwd_program(talloc_tos()), "%u") == NULL) {
+			if(strstr_m(lp_passwd_program(talloc_tos(), lp_sub), "%u") == NULL) {
 				fprintf(stderr,
 					"ERROR: the 'passwd program' (%s) "
 					"requires a '%%u' parameter.\n\n",
-					lp_passwd_program(talloc_tos()));
+					lp_passwd_program(talloc_tos(), lp_sub));
 				ret = 1;
 			}
 		}
@@ -434,14 +436,14 @@ static int do_global_checks(void)
 		 */
 
 		if(lp_encrypt_passwords()) {
-			if(strstr_m( lp_passwd_chat(talloc_tos()), "%o")!=NULL) {
+			if(strstr_m( lp_passwd_chat(talloc_tos(), lp_sub), "%o")!=NULL) {
 				fprintf(stderr,
 					"ERROR: the 'passwd chat' script [%s] "
 					"expects to use the old plaintext "
 					"password via the %%o substitution. With "
 					"encrypted passwords this is not "
 					"possible.\n\n",
-					lp_passwd_chat(talloc_tos()) );
+					lp_passwd_chat(talloc_tos(), lp_sub) );
 				ret = 1;
 			}
 		}
@@ -530,6 +532,8 @@ static int do_global_checks(void)
  */
 static void do_per_share_checks(int s)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	const char **deny_list = lp_hosts_deny(s);
 	const char **allow_list = lp_hosts_allow(s);
 	const char **vfs_objects = NULL;
@@ -548,7 +552,7 @@ static void do_per_share_checks(int s)
 					"(%s) for service %s.\n\n",
 					hasstar ? *hasstar : *hasquery,
 					deny_list[i],
-					lp_servicename(talloc_tos(), s));
+					lp_servicename(talloc_tos(), lp_sub, s));
 			}
 		}
 	}
@@ -563,7 +567,7 @@ static void do_per_share_checks(int s)
 					"list (%s) for service %s.\n\n",
 					hasstar ? *hasstar : *hasquery,
 					allow_list[i],
-					lp_servicename(talloc_tos(), s));
+					lp_servicename(talloc_tos(), lp_sub, s));
 			}
 		}
 	}
@@ -572,7 +576,7 @@ static void do_per_share_checks(int s)
 		fprintf(stderr, "Invalid combination of parameters for service "
 				"%s. Level II oplocks can only be set if oplocks "
 				"are also set.\n\n",
-				lp_servicename(talloc_tos(), s));
+				lp_servicename(talloc_tos(), lp_sub, s));
 	}
 
 	if (!lp_store_dos_attributes(s) && lp_map_hidden(s)
@@ -582,7 +586,7 @@ static void do_per_share_checks(int s)
 			"Invalid combination of parameters for service %s. Map "
 			"hidden can only work if create mask includes octal "
 			"01 (S_IXOTH).\n\n",
-			lp_servicename(talloc_tos(), s));
+			lp_servicename(talloc_tos(), lp_sub, s));
 	}
 	if (!lp_store_dos_attributes(s) && lp_map_hidden(s)
 	    && (lp_force_create_mode(s) & S_IXOTH))
@@ -591,7 +595,7 @@ static void do_per_share_checks(int s)
 			"Invalid combination of parameters for service "
 			"%s. Map hidden can only work if force create mode "
 			"excludes octal 01 (S_IXOTH).\n\n",
-			lp_servicename(talloc_tos(), s));
+			lp_servicename(talloc_tos(), lp_sub, s));
 	}
 	if (!lp_store_dos_attributes(s) && lp_map_system(s)
 	    && !(lp_create_mask(s) & S_IXGRP))
@@ -600,7 +604,7 @@ static void do_per_share_checks(int s)
 			"Invalid combination of parameters for service "
 			"%s. Map system can only work if create mask includes "
 			"octal 010 (S_IXGRP).\n\n",
-			lp_servicename(talloc_tos(), s));
+			lp_servicename(talloc_tos(), lp_sub, s));
 	}
 	if (!lp_store_dos_attributes(s) && lp_map_system(s)
 	    && (lp_force_create_mode(s) & S_IXGRP))
@@ -609,13 +613,13 @@ static void do_per_share_checks(int s)
 			"Invalid combination of parameters for service "
 			"%s. Map system can only work if force create mode "
 			"excludes octal 010 (S_IXGRP).\n\n",
-			lp_servicename(talloc_tos(), s));
+			lp_servicename(talloc_tos(), lp_sub, s));
 	}
 	if (lp_printing(s) == PRINT_CUPS && *(lp_print_command(s)) != '\0') {
 		fprintf(stderr,
 			"Warning: Service %s defines a print command, but "
 			"parameter is ignored when using CUPS libraries.\n\n",
-			lp_servicename(talloc_tos(), s));
+			lp_servicename(talloc_tos(), lp_sub, s));
 	}
 
 	vfs_objects = lp_vfs_objects(s);
@@ -636,6 +640,8 @@ static void do_per_share_checks(int s)
  int main(int argc, const char *argv[])
 {
 	const char *config_file = get_dyn_CONFIGFILE();
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	int s;
 	static int silent_mode = False;
 	static int show_all_parameters = False;
@@ -815,10 +821,10 @@ static void do_per_share_checks(int s)
 				if (allow_access(lp_hosts_deny(-1), lp_hosts_allow(-1), cname, caddr)
 				    && allow_access(lp_hosts_deny(s), lp_hosts_allow(s), cname, caddr)) {
 					fprintf(stderr,"Allow connection from %s (%s) to %s\n",
-						   cname,caddr,lp_servicename(talloc_tos(), s));
+						   cname,caddr,lp_servicename(talloc_tos(), lp_sub, s));
 				} else {
 					fprintf(stderr,"Deny connection from %s (%s) to %s\n",
-						   cname,caddr,lp_servicename(talloc_tos(), s));
+						   cname,caddr,lp_servicename(talloc_tos(), lp_sub, s));
 				}
 			}
 		}
diff --git a/source3/winbindd/winbindd.c b/source3/winbindd/winbindd.c
index 59b4ffc684b..57d93f5a769 100644
--- a/source3/winbindd/winbindd.c
+++ b/source3/winbindd/winbindd.c
@@ -101,10 +101,12 @@ struct imessaging_context *winbind_imessaging_context(void)
 
 static bool reload_services_file(const char *lfile)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	bool ret;
 
 	if (lp_loaded()) {
-		char *fname = lp_next_configfile(talloc_tos());
+		char *fname = lp_next_configfile(talloc_tos(), lp_sub);
 
 		if (file_exist(fname) && !strcsequal(fname,get_dyn_CONFIGFILE())) {
 			set_dyn_CONFIGFILE(fname);
@@ -764,6 +766,8 @@ static struct tevent_req *process_request_send(
 	ok = false;
 
 	if (i < ARRAY_SIZE(bool_dispatch_table)) {
+		cli_state->cmd_name = bool_dispatch_table[i].cmd_name;
+
 		DBG_DEBUG("process_request: request fn %s\n",
 			  bool_dispatch_table[i].cmd_name);
 		ok = bool_dispatch_table[i].fn(cli_state);
@@ -1648,6 +1652,8 @@ int main(int argc, const char **argv)
 		POPT_COMMON_SAMBA
 		POPT_TABLEEND
 	};
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
 	poptContext pc;
 	int opt;
 	TALLOC_CTX *frame;
@@ -1677,7 +1683,7 @@ int main(int argc, const char **argv)
  	CatchSignal(SIGUSR2, SIG_IGN);
 
 	fault_setup();
-	dump_core_setup("winbindd", lp_logfile(talloc_tos()));
+	dump_core_setup("winbindd", lp_logfile(talloc_tos(), lp_sub));
 
 	smb_init_locale();
 
@@ -1737,7 +1743,7 @@ int main(int argc, const char **argv)
 	 * is often not related to the path where winbindd is actually run
 	 * in production.
 	 */
-	dump_core_setup("winbindd", lp_logfile(talloc_tos()));
+	dump_core_setup("winbindd", lp_logfile(talloc_tos(), lp_sub));
 	if (is_daemon && interactive) {
 		d_fprintf(stderr,"\nERROR: "
 			  "Option -i|--interactive is not allowed together with -D|--daemon\n\n");
@@ -1781,7 +1787,7 @@ int main(int argc, const char **argv)
 	 * as the log file might have been set in the configuration and cores's
 	 * path is by default basename(lp_logfile()).
 	 */
-	dump_core_setup("winbindd", lp_logfile(talloc_tos()));
+	dump_core_setup("winbindd", lp_logfile(talloc_tos(), lp_sub));
 
 	if (lp_server_role() == ROLE_ACTIVE_DIRECTORY_DC
 	    && !lp_parm_bool(-1, "server role check", "inhibit", false)) {
diff --git a/source3/winbindd/winbindd_cache.c b/source3/winbindd/winbindd_cache.c
index 9122e2bc5d6..63368fd1821 100644
--- a/source3/winbindd/winbindd_cache.c
+++ b/source3/winbindd/winbindd_cache.c
@@ -710,6 +710,7 @@ static struct cache_entry *wcache_fetch(struct winbind_cache *cache,
 	va_list ap;
 	char *kstr;
 	struct cache_entry *centry;
+	int ret;
 
 	if (!winbindd_use_cache() ||
 	    is_my_own_sam_domain(domain) ||
@@ -720,9 +721,13 @@ static struct cache_entry *wcache_fetch(struct winbind_cache *cache,
 	refresh_sequence_number(domain);
 
 	va_start(ap, format);
-	smb_xvasprintf(&kstr, format, ap);
+	ret = vasprintf(&kstr, format, ap);
 	va_end(ap);
 
+	if (ret == -1) {
+		return NULL;
+	}
+
 	centry = wcache_fetch_raw(kstr);
 	if (centry == NULL) {
 		free(kstr);
@@ -752,11 +757,16 @@ static void wcache_delete(const char *format, ...)
 	va_list ap;
 	char *kstr;
 	TDB_DATA key;
+	int ret;
 
 	va_start(ap, format);
-	smb_xvasprintf(&kstr, format, ap);
+	ret = vasprintf(&kstr, format, ap);
 	va_end(ap);
 
+	if (ret == -1) {
+		return;
+	}
+
 	key = string_tdb_data(kstr);
 
 	tdb_delete(wcache->tdb, key);
@@ -927,15 +937,20 @@ static void centry_end(struct cache_entry *centry, const char *format, ...)
 	va_list ap;
 	char *kstr;
 	TDB_DATA key, data;
+	int ret;
 
 	if (!winbindd_use_cache()) {
 		return;
 	}
 
 	va_start(ap, format);
-	smb_xvasprintf(&kstr, format, ap);
+	ret = vasprintf(&kstr, format, ap);
 	va_end(ap);
 
+	if (ret == -1) {
+		return;
+	}
+
 	key = string_tdb_data(kstr);
 	data.dptr = centry->data;
 	data.dsize = centry->ofs;
diff --git a/source3/winbindd/winbindd_dual.c b/source3/winbindd/winbindd_dual.c
index 6e3277e5529..8188ed097df 100644
--- a/source3/winbindd/winbindd_dual.c
+++ b/source3/winbindd/winbindd_dual.c
@@ -757,13 +757,16 @@ void setup_child(struct winbindd_domain *domain, struct winbindd_child *child,
 		 const char *logprefix,
 		 const char *logname)
 {
+	const struct loadparm_substitution *lp_sub =
+		loadparm_s3_global_substitution();
+
 	if (logprefix && logname) {
 		char *logbase = NULL;
 
-		if (*lp_logfile(talloc_tos())) {
+		if (*lp_logfile(talloc_tos(), lp_sub)) {
 			char *end = NULL;
 
-			if (asprintf(&logbase, "%s", lp_logfile(talloc_tos())) < 0) {
+			if (asprintf(&logbase, "%s", lp_logfile(talloc_tos(), lp_sub)) < 0) {
 				smb_panic("Internal error: asprintf failed");
 			}
 
diff --git a/source3/winbindd/winbindd_getgrgid.c b/source3/winbindd/winbindd_getgrgid.c
index aa99e6e2561..24d70161770 100644
--- a/source3/winbindd/winbindd_getgrgid.c
+++ b/source3/winbindd/winbindd_getgrgid.c
@@ -79,6 +79,10 @@ static void winbindd_getgrgid_gid2sid_done(struct tevent_req *subreq)
 	if (tevent_req_nterror(req, status)) {
 		return;
 	}
+	if (is_null_sid(state->sid)) {
+		tevent_req_nterror(req, NT_STATUS_NO_SUCH_GROUP);
+		return;
+	}
 
 	subreq = wb_getgrsid_send(state, state->ev, state->sid,
 				  lp_winbind_expand_groups());
diff --git a/source3/winbindd/winbindd_misc.c b/source3/winbindd/winbindd_misc.c
index cc0701e597a..d27ed76e81e 100644
--- a/source3/winbindd/winbindd_misc.c
+++ b/source3/winbindd/winbindd_misc.c
@@ -477,5 +477,10 @@ bool winbindd_priv_pipe_dir(struct winbindd_cli_state *state)
 	state->response->length +=
 		strlen((char *)state->response->extra_data.data) + 1;
 
+	DBG_NOTICE("[%s (%u)]: response location of privileged pipe: %s\n",
+		   state->client_name,
+		   (unsigned int)state->pid,
+		   priv_dir);
+
 	return true;
 }
diff --git a/source3/winbindd/winbindd_pam.c b/source3/winbindd/winbindd_pam.c
index 771a130bd6e..a3d8716f781 100644
--- a/source3/winbindd/winbindd_pam.c
+++ b/source3/winbindd/winbindd_pam.c
@@ -47,6 +47,7 @@
 #include "libads/krb5_errs.h"
 #include "param/param.h"
 #include "messaging/messaging.h"
+#include "lib/crypto/gnutls_helpers.h"
 
 #include "lib/crypto/gnutls_helpers.h"
 #include <gnutls/crypto.h>
@@ -1714,6 +1715,73 @@ static NTSTATUS winbind_samlogon_retry_loop(struct winbindd_domain *domain,
 	return NT_STATUS_OK;
 }
 
+static NTSTATUS nt_dual_auth_passdb(TALLOC_CTX *mem_ctx,
+				    fstring name_user,
+				    fstring name_domain,
+				    const char *pass,
+				    uint64_t logon_id,
+				    const char *client_name,
+				    const int client_pid,
+				    const struct tsocket_address *remote,
+				    const struct tsocket_address *local,
+				    uint8_t *authoritative,
+				    struct netr_SamInfo3 **info3)
+{
+	unsigned char local_nt_response[24];
+	uchar chal[8];
+	DATA_BLOB chal_blob;
+	DATA_BLOB lm_resp;
+	DATA_BLOB nt_resp;
+
+	/* do password magic */
+
+	generate_random_buffer(chal, sizeof(chal));
+	chal_blob = data_blob_const(chal, sizeof(chal));
+
+	if (lp_client_ntlmv2_auth()) {
+		DATA_BLOB server_chal;
+		DATA_BLOB names_blob;
+		server_chal = data_blob_const(chal, 8);
+
+		/* note that the 'workgroup' here is for the local
+		   machine.  The 'server name' must match the
+		   'workstation' passed to the actual SamLogon call.
+		*/
+		names_blob = NTLMv2_generate_names_blob(mem_ctx,
+							lp_netbios_name(),
+							lp_workgroup());
+
+		if (!SMBNTLMv2encrypt(mem_ctx, name_user, name_domain,
+				      pass, &server_chal, &names_blob,
+				      &lm_resp, &nt_resp, NULL, NULL)) {
+			data_blob_free(&names_blob);
+			DEBUG(0, ("SMBNTLMv2encrypt() failed!\n"));
+			return NT_STATUS_NO_MEMORY;
+		}
+		data_blob_free(&names_blob);
+	} else {
+		int rc;
+		lm_resp = data_blob_null;
+
+		rc = SMBNTencrypt(pass, chal, local_nt_response);
+		if (rc != 0) {
+			DEBUG(0, ("SMBNTencrypt() failed!\n"));
+			return gnutls_error_to_ntstatus(rc,
+				    NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
+
+		nt_resp = data_blob_talloc(mem_ctx, local_nt_response,
+					   sizeof(local_nt_response));
+	}
+
+	return winbindd_dual_auth_passdb(talloc_tos(), 0, name_domain,
+					 name_user, logon_id, client_name,
+					 client_pid, &chal_blob, &lm_resp,
+					 &nt_resp, remote, local,
+					 true, /* interactive */
+					 authoritative, info3);
+}
+
 static NTSTATUS winbindd_dual_pam_auth_samlogon(
 	TALLOC_CTX *mem_ctx,
 	struct winbindd_domain *domain,
@@ -1728,16 +1796,11 @@ static NTSTATUS winbindd_dual_pam_auth_samlogon(
 	uint16_t *_validation_level,
 	union netr_Validation **_validation)
 {
-
-	uchar chal[8];
-	DATA_BLOB lm_resp;
-	DATA_BLOB nt_resp;
-	unsigned char local_nt_response[24];
 	fstring name_namespace, name_domain, name_user;
 	NTSTATUS result;
 	uint8_t authoritative = 0;
 	uint32_t flags = 0;
-	uint16_t validation_level;
+	uint16_t validation_level = 0;
 	union netr_Validation *validation = NULL;
 	struct netr_SamBaseInfo *base_info = NULL;
 	bool ok;
@@ -1761,55 +1824,12 @@ static NTSTATUS winbindd_dual_pam_auth_samlogon(
 	 * we need to check against domain->name.
 	 */
 	if (strequal(domain->name, get_global_sam_name())) {
-		DATA_BLOB chal_blob = data_blob_const(chal, sizeof(chal));
 		struct netr_SamInfo3 *info3 = NULL;
 
-		/* do password magic */
-
-		generate_random_buffer(chal, sizeof(chal));
-
-		if (lp_client_ntlmv2_auth()) {
-			DATA_BLOB server_chal;
-			DATA_BLOB names_blob;
-			server_chal = data_blob_const(chal, 8);
-
-			/* note that the 'workgroup' here is for the local
-			   machine.  The 'server name' must match the
-			   'workstation' passed to the actual SamLogon call.
-			*/
-			names_blob = NTLMv2_generate_names_blob(
-				mem_ctx, lp_netbios_name(), lp_workgroup());
-
-			if (!SMBNTLMv2encrypt(mem_ctx, name_user, name_domain,
-					      pass,
-					      &server_chal,
-					      &names_blob,
-					      &lm_resp, &nt_resp, NULL, NULL)) {
-				data_blob_free(&names_blob);
-				DEBUG(0, ("winbindd_pam_auth: SMBNTLMv2encrypt() failed!\n"));
-				result = NT_STATUS_NO_MEMORY;
-				goto done;
-			}
-			data_blob_free(&names_blob);
-		} else {
-			lm_resp = data_blob_null;
-			SMBNTencrypt(pass, chal, local_nt_response);
-
-			nt_resp = data_blob_talloc(mem_ctx, local_nt_response,
-						   sizeof(local_nt_response));
-		}
-
-		result = winbindd_dual_auth_passdb(
-			talloc_tos(), 0, name_domain, name_user,
-			logon_id,
-			client_name,
-			client_pid,
-			&chal_blob, &lm_resp, &nt_resp,
-			remote,
-			local,
-			true, /* interactive */
-			&authoritative,
-			&info3);
+		result = nt_dual_auth_passdb(mem_ctx, name_user, name_domain,
+					     pass, logon_id, client_name,
+					     client_pid, remote, local,
+					     &authoritative, &info3);
 
 		/*
 		 * We need to try the remote NETLOGON server if this is
diff --git a/source3/winbindd/wscript_build b/source3/winbindd/wscript_build
index a23c44566ed..534dd0b206b 100644
--- a/source3/winbindd/wscript_build
+++ b/source3/winbindd/wscript_build
@@ -116,7 +116,7 @@ bld.SAMBA3_MODULE('idmap_autorid',
 
 bld.SAMBA3_LIBRARY('nss_info',
                    source='nss_info.c',
-                   deps='samba-util smbconf',
+                   deps='samba-util smbconf samba-modules',
                    private_library=True)
 
 bld.SAMBA3_MODULE('nss_info_template',
@@ -171,114 +171,122 @@ bld.SAMBA3_MODULE('idmap_script',
                  internal_module=bld.SAMBA3_IS_STATIC_MODULE('idmap_script'),
                  enabled=bld.SAMBA3_IS_ENABLED_MODULE('idmap_script'))
 
+bld.SAMBA3_SUBSYSTEM('winbindd-lib',
+                    source='''
+                    winbindd_group.c
+                    winbindd_util.c
+                    winbindd_cache.c
+                    winbindd_pam.c
+                    winbindd_misc.c
+                    winbindd_cm.c
+                    winbindd_wins_byip.c
+                    winbindd_wins_byname.c
+                    winbindd_msrpc.c
+                    winbindd_rpc.c
+                    winbindd_reconnect.c
+                    winbindd_reconnect_ads.c
+                    winbindd_ads.c
+                    winbindd_samr.c
+                    winbindd_dual.c
+                    winbindd_dual_ndr.c
+                    winbindd_dual_srv.c
+                    winbindd_async.c
+                    winbindd_creds.c
+                    winbindd_cred_cache.c
+                    winbindd_ccache_access.c
+                    winbindd_domain.c
+                    winbindd_idmap.c
+                    winbindd_locator.c
+                    winbindd_ndr.c
+                    wb_lookupsid.c
+                    wb_lookupsids.c
+                    wb_lookupname.c
+                    wb_sids2xids.c
+                    wb_xids2sids.c
+                    wb_queryuser.c
+                    wb_lookupuseraliases.c
+                    wb_lookupusergroups.c
+                    wb_getpwsid.c
+                    wb_gettoken.c
+                    wb_seqnum.c
+                    wb_seqnums.c
+                    wb_group_members.c
+                    wb_getgrsid.c
+                    wb_query_user_list.c
+                    wb_query_group_list.c
+                    wb_next_pwent.c
+                    wb_next_grent.c
+                    wb_dsgetdcname.c
+                    winbindd_lookupsid.c
+                    winbindd_lookupsids.c
+                    winbindd_lookupname.c
+                    winbindd_sids_to_xids.c
+                    winbindd_xids_to_sids.c
+                    winbindd_allocate_uid.c
+                    winbindd_allocate_gid.c
+                    winbindd_getpwsid.c
+                    winbindd_getpwnam.c
+                    winbindd_getpwuid.c
+                    winbindd_getsidaliases.c
+                    winbindd_getuserdomgroups.c
+                    winbindd_getgroups.c
+                    winbindd_show_sequence.c
+                    winbindd_getgrgid.c
+                    winbindd_getgrnam.c
+                    winbindd_getusersids.c
+                    winbindd_lookuprids.c
+                    winbindd_setpwent.c
+                    winbindd_getpwent.c
+                    winbindd_endpwent.c
+                    winbindd_setgrent.c
+                    winbindd_getgrent.c
+                    winbindd_endgrent.c
+                    winbindd_dsgetdcname.c
+                    winbindd_getdcname.c
+                    winbindd_list_users.c
+                    winbindd_list_groups.c
+                    winbindd_check_machine_acct.c
+                    winbindd_change_machine_acct.c
+                    winbindd_irpc.c
+                    winbindd_ping_dc.c
+                    winbindd_domain_info.c
+                    winbindd_pam_auth.c
+                    winbindd_pam_logoff.c
+                    winbindd_pam_chauthtok.c
+                    winbindd_pam_auth_crap.c
+                    winbindd_pam_chng_pswd_auth_crap.c
+                    winbindd_gpupdate.c''',
+                    deps='''
+                    talloc
+                    tevent
+                    pdb
+                    popt_samba3
+                    idmap
+                    ads
+                    msrpc3
+                    nss_info
+                    LIBAFS
+                    LIBADS_SERVER
+                    LIBCLI_SAMR
+                    SLCACHE
+                    RPC_NDR_DSSETUP
+                    RPC_NDR_WINBIND
+                    SRV_NDR_WINBIND
+                    RPC_SAMR
+                    RPC_LSARPC
+                    RPC_SERVER
+                    WB_REQTRANS
+                    TDB_VALIDATE
+                    MESSAGING
+                    LIBLSA
+                    ''')
+
 bld.SAMBA3_BINARY('winbindd',
-                 source='''winbindd.c
-                 winbindd_group.c
-                 winbindd_util.c
-                 winbindd_cache.c
-                 winbindd_pam.c
-                 winbindd_misc.c
-                 winbindd_cm.c
-                 winbindd_wins_byip.c
-                 winbindd_wins_byname.c
-                 winbindd_msrpc.c
-                 winbindd_rpc.c
-                 winbindd_reconnect.c
-                 winbindd_reconnect_ads.c
-                 winbindd_ads.c
-                 winbindd_samr.c
-                 winbindd_dual.c
-                 winbindd_dual_ndr.c
-                 winbindd_dual_srv.c
-                 winbindd_async.c
-                 winbindd_creds.c
-                 winbindd_cred_cache.c
-                 winbindd_ccache_access.c
-                 winbindd_domain.c
-                 winbindd_idmap.c
-                 winbindd_locator.c
-                 winbindd_ndr.c
-                 wb_lookupsid.c
-                 wb_lookupsids.c
-                 wb_lookupname.c
-                 wb_sids2xids.c
-                 wb_xids2sids.c
-                 wb_queryuser.c
-                 wb_lookupuseraliases.c
-                 wb_lookupusergroups.c
-                 wb_getpwsid.c
-                 wb_gettoken.c
-                 wb_seqnum.c
-                 wb_seqnums.c
-                 wb_group_members.c
-                 wb_getgrsid.c
-                 wb_query_user_list.c
-                 wb_query_group_list.c
-                 wb_next_pwent.c
-                 wb_next_grent.c
-                 wb_dsgetdcname.c
-                 winbindd_lookupsid.c
-                 winbindd_lookupsids.c
-                 winbindd_lookupname.c
-                 winbindd_sids_to_xids.c
-                 winbindd_xids_to_sids.c
-                 winbindd_allocate_uid.c
-                 winbindd_allocate_gid.c
-                 winbindd_getpwsid.c
-                 winbindd_getpwnam.c
-                 winbindd_getpwuid.c
-                 winbindd_getsidaliases.c
-                 winbindd_getuserdomgroups.c
-                 winbindd_getgroups.c
-                 winbindd_show_sequence.c
-                 winbindd_getgrgid.c
-                 winbindd_getgrnam.c
-                 winbindd_getusersids.c
-                 winbindd_lookuprids.c
-                 winbindd_setpwent.c
-                 winbindd_getpwent.c
-                 winbindd_endpwent.c
-                 winbindd_setgrent.c
-                 winbindd_getgrent.c
-                 winbindd_endgrent.c
-                 winbindd_dsgetdcname.c
-                 winbindd_getdcname.c
-                 winbindd_list_users.c
-                 winbindd_list_groups.c
-                 winbindd_check_machine_acct.c
-                 winbindd_change_machine_acct.c
-                 winbindd_irpc.c
-                 winbindd_ping_dc.c
-                 winbindd_domain_info.c
-                 winbindd_pam_auth.c
-                 winbindd_pam_logoff.c
-                 winbindd_pam_chauthtok.c
-                 winbindd_pam_auth_crap.c
-                 winbindd_pam_chng_pswd_auth_crap.c
-                 winbindd_gpupdate.c''',
+                 source='''
+                 winbindd.c
+                 ''',
                  deps='''
-                 talloc
-                 tevent
-                 pdb
-                 popt_samba3
-                 idmap
-                 ads
-                 msrpc3
-                 nss_info
-                 LIBAFS
-                 LIBADS_SERVER
-                 LIBCLI_SAMR
-                 SLCACHE
-                 RPC_NDR_DSSETUP
-                 RPC_NDR_WINBIND
-                 SRV_NDR_WINBIND
-                 RPC_SAMR
-                 RPC_LSARPC
-                 RPC_SERVER
-                 WB_REQTRANS
-                 TDB_VALIDATE
-                 MESSAGING
-                 LIBLSA
+                 winbindd-lib
                  ''',
                  enabled=bld.env.build_winbind,
                  install_path='${SBINDIR}')
diff --git a/source3/wscript b/source3/wscript
index 28f43fa72b9..85466b493fa 100644
--- a/source3/wscript
+++ b/source3/wscript
@@ -650,7 +650,7 @@ msg.msg_accrightslen = sizeof(fd);
             conf.CHECK_CFG(path=conf.env.CUPS_CONFIG, args="--cflags --ldflags",
                            package="", uselib_store="CUPS")
         conf.CHECK_HEADERS('cups/cups.h cups/language.h', lib='cups')
-        conf.CHECK_FUNCS_IN('httpConnect httpConnectEncrypt', 'cups')
+        conf.CHECK_FUNCS_IN('httpConnect httpConnect2 httpConnectEncrypt', 'cups')
         if conf.CONFIG_SET('HAVE_CUPS_CUPS_H') and conf.CONFIG_SET('HAVE_CUPS_LANGUAGE_H'):
             conf.DEFINE('HAVE_CUPS', '1')
         else:
@@ -1711,13 +1711,13 @@ main() {
     if (Options.options.with_cephfs and
         conf.CHECK_HEADERS('cephfs/libcephfs.h', False, False, 'cephfs') and
         conf.CHECK_LIB('cephfs', shlib=True)):
-        if Options.options.with_acl_support:
+        if (Options.options.with_acl_support and
+            conf.CHECK_FUNCS_IN('ceph_statx', 'cephfs',
+                                headers='cephfs/libcephfs.h')):
             conf.DEFINE('HAVE_CEPH', '1')
-            if conf.CHECK_FUNCS_IN('ceph_statx', 'cephfs',
-                                   headers='cephfs/libcephfs.h'):
-                conf.DEFINE('HAVE_CEPH_STATX', '1')
         else:
-            Logs.warn("ceph support disabled due to --without-acl-support")
+            Logs.warn('''Ceph support disabled due to --without-acl-support
+                      or lack of ceph_statx support''')
             conf.undefine('HAVE_CEPH')
 
     if Options.options.with_glusterfs:
@@ -1754,6 +1754,14 @@ main() {
                                       and conf.CHECK_LIB('dbus-1', shlib=True)):
             conf.DEFINE('HAVE_DBUS', '1')
 
+    if conf.CHECK_CFG(package='liburing', args='--cflags --libs',
+                      msg='Checking for liburing package', uselib_store="URING"):
+        if (conf.CHECK_HEADERS('liburing.h', lib='uring')
+                                      and conf.CHECK_LIB('uring', shlib=True)):
+            conf.CHECK_FUNCS_IN('io_uring_ring_dontfork', 'uring',
+                                headers='liburing.h')
+            conf.DEFINE('HAVE_LIBURING', '1')
+
     conf.env.build_regedit = False
     if not Options.options.with_regedit == False:
         conf.PROCESS_SEPARATE_RULE('system_ncurses')
@@ -1899,7 +1907,7 @@ main() {
                                       vfs_commit vfs_worm vfs_crossrename vfs_linux_xfs_sgid
                                       vfs_time_audit vfs_offline vfs_virusfilter
                                   '''))
-    default_shared_modules.extend(TO_LIST('auth_script idmap_tdb2 idmap_script'))
+    default_shared_modules.extend(TO_LIST('idmap_tdb2 idmap_script'))
     # these have broken dependencies
     forced_shared_modules.extend(TO_LIST('idmap_autorid idmap_rid idmap_hash'))
 
@@ -1932,6 +1940,9 @@ main() {
     if (conf.CONFIG_SET('HAVE_STRUCT_MSGHDR_MSG_CONTROL') or conf.CONFIG_SET('HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS')):
         default_shared_modules.extend(TO_LIST('vfs_aio_fork'))
 
+    if conf.CONFIG_SET('HAVE_LIBURING'):
+        default_shared_modules.extend(TO_LIST('vfs_io_uring'))
+
     if Options.options.with_pthreadpool:
         default_shared_modules.extend(TO_LIST('vfs_aio_pthread'))
 
diff --git a/source3/wscript_build b/source3/wscript_build
index 1cf734fe4c7..10d9f71ae76 100644
--- a/source3/wscript_build
+++ b/source3/wscript_build
@@ -112,7 +112,7 @@ bld.SAMBA3_BINARY('test_tldap',
                        smbconf
                        cmocka
                        ''',
-                  install=False)
+                  for_selftest=True)
 
 # libpdb.so should not expose internal symbols that are only usable
 # to the statically linked modules that are merged into libpdb.
@@ -177,6 +177,7 @@ bld.SAMBA3_SUBSYSTEM('pdb',
                         LIBCLI_AUTH
                         flag_mapping
                         samba-credentials
+                        samba-modules
                         nscd
                         ''')
 
@@ -207,7 +208,7 @@ bld.SAMBA_BINARY('test_registry_regfio',
                  source='registry/tests/test_regfio.c',
                  deps='cmocka samba3-util smbconf REGFIO',
                  local_include=False,
-                 install=False)
+                 for_selftest=True)
 
 # Do not link against this use 'smbconf'
 bld.SAMBA3_SUBSYSTEM('SMBREGISTRY',
@@ -278,7 +279,7 @@ bld.SAMBA3_LIBRARY('popt_samba3_cmdline',
 
 bld.SAMBA3_LIBRARY('util_cmdline',
                    source='lib/util_cmdline.c',
-                   deps='secrets3',
+                   deps='secrets3 samba-credentials',
                    private_library=True)
 
 bld.SAMBA3_LIBRARY('cmdline_contexts',
@@ -433,6 +434,7 @@ bld.SAMBA3_SUBSYSTEM('samba3core',
                         talloc_report_printf
                         access
                         TDB_LIB
+                        z
                         ''')
 
 bld.SAMBA3_LIBRARY('smbd_shim',
@@ -505,6 +507,8 @@ bld.SAMBA3_LIBRARY('secrets3',
                         smbconf
                         samba3util
                         dbwrap
+                        krb5samba
+                        LIBCLI_AUTH
                         ''',
                    private_library=True)
 
@@ -591,7 +595,7 @@ bld.SAMBA3_LIBRARY('smbconf',
                         SAMBA_VERSION
                         cap
                         charset
-                        cli_smb_common
+                        samba-hostconfig
                         errors3
                         SMBCONF_PARAM
                         samba-util
@@ -1158,7 +1162,7 @@ bld.SAMBA3_BINARY('smbspool_krb5_wrapper',
 
 bld.SAMBA3_BINARY('smbspool_argv_wrapper',
 		  source='script/tests/smbspool_argv_wrapper.c',
-		  install=False)
+		  for_selftest=True)
 
 bld.SAMBA3_BINARY('locktest2',
                  source='torture/locktest2.c',
@@ -1168,7 +1172,7 @@ bld.SAMBA3_BINARY('locktest2',
                       libsmb
                       LOCKING
                       ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA3_BINARY('smbtorture' + bld.env.suffix3,
                  source='''
@@ -1225,7 +1229,7 @@ bld.SAMBA3_BINARY('smbtorture' + bld.env.suffix3,
                       samba-cluster-support
                       ''',
                  cflags='-DWINBINDD_SOCKET_DIR=\"%s\"' % bld.env.WINBINDD_SOCKET_DIR,
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA3_BINARY('smbconftort',
                  source='lib/smbconf/testsuite.c',
@@ -1234,7 +1238,7 @@ bld.SAMBA3_BINARY('smbconftort',
                       smbconf
                       popt_samba3
                       ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA3_BINARY('msgtest',
                  source='torture/msgtest.c',
@@ -1276,7 +1280,7 @@ bld.SAMBA3_BINARY('test_mdsparser_es',
                  popt_samba3_cmdline
                  ''',
                  enabled=bld.env.spotlight_backend_es,
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA3_BINARY('pdbtest',
                  source='torture/pdbtest.c',
@@ -1287,7 +1291,7 @@ bld.SAMBA3_BINARY('pdbtest',
                       AUTH_COMMON
                       auth
                       ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA3_BINARY('vfstest',
                  source='''
@@ -1301,7 +1305,7 @@ bld.SAMBA3_BINARY('vfstest',
                       smbconf
                       SMBREADLINE
                       ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA3_BINARY('versiontest',
                  source='lib/version_test.c',
@@ -1313,7 +1317,7 @@ bld.SAMBA3_BINARY('versiontest',
 
 bld.SAMBA3_BINARY('timelimit',
                  source='script/tests/timelimit.c',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA3_BINARY('rpc_open_tcp',
                  source='torture/rpc_open_tcp.c',
@@ -1321,7 +1325,7 @@ bld.SAMBA3_BINARY('rpc_open_tcp',
                       talloc
                       msrpc3
                       ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA3_BINARY('vlp',
                  source='printing/tests/vlp.c',
@@ -1329,7 +1333,7 @@ bld.SAMBA3_BINARY('vlp',
                       talloc
                       smbconf
                       ''',
-                 install=False)
+                 for_selftest=True)
 
 
 pyrpc_util = bld.pyembed_libname('pyrpc_util')
@@ -1380,7 +1384,7 @@ bld.SAMBA3_BINARY('tevent_glib_glue_test',
                  popt_samba3
                  tevent-glib-glue''',
                  enabled=bld.CONFIG_SET('WITH_TEVENT_GLIB_GLUE'),
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA3_BINARY('tevent_glib_tracker',
                  source='utils/async-tracker.c',
diff --git a/source4/auth/gensec/gensec_gssapi.c b/source4/auth/gensec/gensec_gssapi.c
index 3f541885dfd..d66abf32a7f 100644
--- a/source4/auth/gensec/gensec_gssapi.c
+++ b/source4/auth/gensec/gensec_gssapi.c
@@ -242,7 +242,7 @@ static NTSTATUS gensec_gssapi_start(struct gensec_security *gensec_security)
 	}
 
 	/* don't do DNS lookups of any kind, it might/will fail for a netbios name */
-	ret = gsskrb5_set_dns_canonicalize(gensec_setting_bool(gensec_security->settings, "krb5", "set_dns_canonicalize", false));
+	ret = gsskrb5_set_dns_canonicalize(false);
 	if (ret) {
 		DEBUG(1,("gensec_gssapi_start: gsskrb5_set_dns_canonicalize failed\n"));
 		talloc_free(gensec_gssapi_state);
diff --git a/source4/auth/gensec/pygensec.c b/source4/auth/gensec/pygensec.c
index bc9d6bdcb16..986f32904e7 100644
--- a/source4/auth/gensec/pygensec.c
+++ b/source4/auth/gensec/pygensec.c
@@ -679,7 +679,7 @@ static PyMethodDef py_gensec_security_methods[] = {
 		"S.have_feature()\n Return True if GENSEC negotiated a particular feature." },
 	{ "set_max_update_size",  (PyCFunction)py_gensec_set_max_update_size, METH_VARARGS,
 		"S.set_max_update_size(max_size) \n Some mechs can fragment update packets, needs to be use before the mech is started." },
-	{ "max_update_size",  (PyCFunction)py_gensec_max_update_size, 0,
+	{ "max_update_size",  (PyCFunction)py_gensec_max_update_size, METH_NOARGS,
 		"S.max_update_size() \n Return the current max_update_size." },
 	{ "update",  (PyCFunction)py_gensec_update, METH_VARARGS,
 		"S.update(blob_in) -> (finished, blob_out)\nPerform one step in a GENSEC dance.  Repeat with new packets until finished is true or exception." },
diff --git a/source4/auth/kerberos/krb5_init_context.c b/source4/auth/kerberos/krb5_init_context.c
index fff261daa8e..639718cb6a6 100644
--- a/source4/auth/kerberos/krb5_init_context.c
+++ b/source4/auth/kerberos/krb5_init_context.c
@@ -511,6 +511,12 @@ smb_krb5_init_context_basic(TALLOC_CTX *tmp_ctx,
 		return ret;
 	}
 
+	/*
+	 * This is already called in smb_krb5_init_context_common(),
+	 * but krb5_set_config_files() may resets it.
+	 */
+	krb5_set_dns_canonicalize_hostname(krb5_ctx, false);
+
 	realm = lpcfg_realm(lp_ctx);
 	if (realm != NULL) {
 		ret = krb5_set_default_realm(krb5_ctx, realm);
@@ -578,12 +584,6 @@ krb5_error_code smb_krb5_init_context(void *parent_ctx,
 		return ret;
 	}
 	krb5_set_warn_dest(kctx, logf);
-
-	/* Set options in kerberos */
-
-	krb5_set_dns_canonicalize_hostname(kctx,
-			lpcfg_parm_bool(lp_ctx, NULL, "krb5",
-					"set_dns_canonicalize", false));
 #endif
 	talloc_steal(parent_ctx, *smb_krb5_context);
 	talloc_free(tmp_ctx);
diff --git a/source4/auth/ntlm/auth_util.c b/source4/auth/ntlm/auth_util.c
index 7e72cb5123d..a0d061dca2a 100644
--- a/source4/auth/ntlm/auth_util.c
+++ b/source4/auth/ntlm/auth_util.c
@@ -28,6 +28,7 @@
 #include "auth/ntlm/auth_proto.h"
 #include "librpc/gen_ndr/drsuapi.h"
 #include "dsdb/samdb/samdb.h"
+#include "lib/crypto/gnutls_helpers.h"
 
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_AUTH
@@ -41,6 +42,7 @@ NTSTATUS encrypt_user_info(TALLOC_CTX *mem_ctx, struct auth4_context *auth_conte
 			   const struct auth_usersupplied_info *user_info_in,
 			   const struct auth_usersupplied_info **user_info_encrypted)
 {
+	int rc;
 	NTSTATUS nt_status;
 	struct auth_usersupplied_info *user_info_temp;
 	switch (to_state) {
@@ -103,12 +105,17 @@ NTSTATUS encrypt_user_info(TALLOC_CTX *mem_ctx, struct auth4_context *auth_conte
 				data_blob_free(&ntlmv2_session_key);
 			} else {
 				DATA_BLOB blob = data_blob_talloc(mem_ctx, NULL, 24);
-				SMBOWFencrypt(user_info_in->password.hash.nt->hash, chal, blob.data);
-
+				rc = SMBOWFencrypt(user_info_in->password.hash.nt->hash, chal, blob.data);
+				if (rc != 0) {
+					return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+				}
 				user_info_temp->password.response.nt = blob;
 				if (lpcfg_client_lanman_auth(auth_context->lp_ctx) && user_info_in->password.hash.lanman) {
 					DATA_BLOB lm_blob = data_blob_talloc(mem_ctx, NULL, 24);
-					SMBOWFencrypt(user_info_in->password.hash.lanman->hash, chal, blob.data);
+					rc = SMBOWFencrypt(user_info_in->password.hash.lanman->hash, chal, blob.data);
+					if (rc != 0) {
+						return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+					}
 					user_info_temp->password.response.lanman = lm_blob;
 				} else {
 					/* if not sending the LM password, send the NT password twice */
diff --git a/source4/auth/wscript_build b/source4/auth/wscript_build
index daf5c8a422d..381a7b19bf0 100644
--- a/source4/auth/wscript_build
+++ b/source4/auth/wscript_build
@@ -46,7 +46,7 @@ bld.SAMBA_BINARY('test_kerberos',
         source='tests/kerberos.c',
         deps='cmocka authkrb5 krb5samba com_err CREDENTIALS_KRB5',
         local_include=False,
-        install=False
+        for_selftest=True
         )
 
 pytalloc_util = bld.pyembed_libname('pytalloc-util')
diff --git a/source4/dsdb/common/util.c b/source4/dsdb/common/util.c
index bad2ee7a494..d88688a8ec1 100644
--- a/source4/dsdb/common/util.c
+++ b/source4/dsdb/common/util.c
@@ -47,6 +47,7 @@
 #include "libds/common/flag_mapping.h"
 #include "lib/util/access.h"
 #include "lib/util/util_str_hex.h"
+#include "lib/util/sys_rw_data.h"
 #include "libcli/util/ntstatus.h"
 
 /*
@@ -2041,6 +2042,8 @@ enum samr_ValidationStatus samdb_check_password(TALLOC_CTX *mem_ctx,
 						const uint32_t pwdProperties,
 						const uint32_t minPwdLength)
 {
+	const struct loadparm_substitution *lp_sub =
+		lpcfg_noop_substitution();
 	char *password_script = NULL;
 	const char *utf8_pw = (const char *)utf8_blob->data;
 
@@ -2074,7 +2077,7 @@ enum samr_ValidationStatus samdb_check_password(TALLOC_CTX *mem_ctx,
 		return SAMR_VALIDATION_STATUS_NOT_COMPLEX_ENOUGH;
 	}
 
-	password_script = lpcfg_check_password_script(lp_ctx, mem_ctx);
+	password_script = lpcfg_check_password_script(lp_ctx, lp_sub, mem_ctx);
 	if (password_script != NULL && *password_script != '\0') {
 		int check_ret = 0;
 		int error = 0;
@@ -2141,9 +2144,9 @@ enum samr_ValidationStatus samdb_check_password(TALLOC_CTX *mem_ctx,
 
 		cps_stdin = samba_runcmd_export_stdin(req);
 
-		nwritten = write(cps_stdin, utf8_blob->data,
-				 utf8_blob->length);
-		if (nwritten != utf8_blob->length) {
+		nwritten = write_data(
+			cps_stdin, utf8_blob->data, utf8_blob->length);
+		if (nwritten == -1) {
 			close(cps_stdin);
 			TALLOC_FREE(password_script);
 			TALLOC_FREE(event_ctx);
@@ -5437,7 +5440,8 @@ NTSTATUS dsdb_update_bad_pwd_count(TALLOC_CTX *mem_ctx,
 				   struct ldb_message *pso_msg,
 				   struct ldb_message **_mod_msg)
 {
-	int i, ret, badPwdCount;
+	int ret, badPwdCount;
+	unsigned int i;
 	int64_t lockoutThreshold, lockOutObservationWindow;
 	struct dom_sid *sid;
 	struct timeval tv_now = timeval_current();
@@ -5535,7 +5539,8 @@ int dsdb_user_obj_set_defaults(struct ldb_context *ldb,
 			       struct ldb_message *usr_obj,
 			       struct ldb_request *req)
 {
-	int i, ret;
+	size_t i;
+	int ret;
 	const struct attribute_values {
 		const char *name;
 		const char *value;
diff --git a/source4/dsdb/kcc/scavenge_dns_records.c b/source4/dsdb/kcc/scavenge_dns_records.c
index 6c0684b3153..8e916cf7b06 100644
--- a/source4/dsdb/kcc/scavenge_dns_records.c
+++ b/source4/dsdb/kcc/scavenge_dns_records.c
@@ -128,6 +128,8 @@ NTSTATUS dns_tombstone_records_zone(TALLOC_CTX *mem_ctx,
 	struct ldb_message_element *el = NULL;
 	struct ldb_message_element *tombstone_el = NULL;
 	struct ldb_message_element *old_el = NULL;
+	struct ldb_message *new_msg = NULL;
+	struct ldb_message *old_msg = NULL;
 	int ret;
 	struct GUID guid;
 	struct GUID_txt_buf buf_guid;
@@ -184,12 +186,29 @@ NTSTATUS dns_tombstone_records_zone(TALLOC_CTX *mem_ctx,
 	 * change.  This prevents race conditions.
 	 */
 	for (i = 0; i < res->count; i++) {
-		old_el = ldb_msg_find_element(res->msgs[i], "dnsRecord");
+		old_msg = ldb_msg_copy(mem_ctx, res->msgs[i]);
+		if (old_msg == NULL) {
+			return NT_STATUS_INTERNAL_ERROR;
+		}
+
+		old_el = ldb_msg_find_element(old_msg, "dnsRecord");
+		if (old_el == NULL) {
+			TALLOC_FREE(old_msg);
+			return NT_STATUS_INTERNAL_ERROR;
+		}
+
 		old_el->flags = LDB_FLAG_MOD_DELETE;
+		new_msg = ldb_msg_copy(mem_ctx, old_msg);
+		if (new_msg == NULL) {
+			TALLOC_FREE(old_msg);
+			return NT_STATUS_INTERNAL_ERROR;
+		}
 
 		ret = ldb_msg_add_empty(
-		    res->msgs[i], "dnsRecord", LDB_FLAG_MOD_ADD, &el);
+		    new_msg, "dnsRecord", LDB_FLAG_MOD_ADD, &el);
 		if (ret != LDB_SUCCESS) {
+			TALLOC_FREE(old_msg);
+			TALLOC_FREE(new_msg);
 			return NT_STATUS_INTERNAL_ERROR;
 		}
 
@@ -197,12 +216,16 @@ NTSTATUS dns_tombstone_records_zone(TALLOC_CTX *mem_ctx,
 		status = copy_current_records(mem_ctx, old_el, el, t);
 
 		if (!NT_STATUS_IS_OK(status)) {
+			TALLOC_FREE(old_msg);
+			TALLOC_FREE(new_msg);
 			return NT_STATUS_INTERNAL_ERROR;
 		}
 
 		/* If nothing was expired, do nothing. */
 		if (el->num_values == old_el->num_values &&
 		    el->num_values != 0) {
+			TALLOC_FREE(old_msg);
+			TALLOC_FREE(new_msg);
 			continue;
 		}
 
@@ -213,14 +236,16 @@ NTSTATUS dns_tombstone_records_zone(TALLOC_CTX *mem_ctx,
 			el->values = tombstone_blob;
 			el->num_values = 1;
 
-			tombstone_el = ldb_msg_find_element(res->msgs[i],
+			tombstone_el = ldb_msg_find_element(new_msg,
 						  "dnsTombstoned");
 			if (tombstone_el == NULL) {
-				ret = ldb_msg_add_value(res->msgs[i],
+				ret = ldb_msg_add_value(new_msg,
 							"dnsTombstoned",
 							true_struct,
 							&tombstone_el);
 				if (ret != LDB_SUCCESS) {
+					TALLOC_FREE(old_msg);
+					TALLOC_FREE(new_msg);
 					return NT_STATUS_INTERNAL_ERROR;
 				}
 				tombstone_el->flags = LDB_FLAG_MOD_ADD;
@@ -234,13 +259,15 @@ NTSTATUS dns_tombstone_records_zone(TALLOC_CTX *mem_ctx,
 			 * Do not change the status of dnsTombstoned
 			 * if we found any live records
 			 */
-			ldb_msg_remove_attr(res->msgs[i],
+			ldb_msg_remove_attr(new_msg,
 					    "dnsTombstoned");
 		}
 
 		/* Set DN to the GUID in case the object was moved. */
-		el = ldb_msg_find_element(res->msgs[i], "objectGUID");
+		el = ldb_msg_find_element(new_msg, "objectGUID");
 		if (el == NULL) {
+			TALLOC_FREE(old_msg);
+			TALLOC_FREE(new_msg);
 			*error_string =
 			    talloc_asprintf(mem_ctx,
 					    "record has no objectGUID "
@@ -251,20 +278,24 @@ NTSTATUS dns_tombstone_records_zone(TALLOC_CTX *mem_ctx,
 
 		status = GUID_from_ndr_blob(el->values, &guid);
 		if (!NT_STATUS_IS_OK(status)) {
+			TALLOC_FREE(old_msg);
+			TALLOC_FREE(new_msg);
 			*error_string =
 			    discard_const_p(char, "Error: Invalid GUID.\n");
 			return NT_STATUS_INTERNAL_ERROR;
 		}
 
 		GUID_buf_string(&guid, &buf_guid);
-		res->msgs[i]->dn =
+		new_msg->dn =
 		    ldb_dn_new_fmt(mem_ctx, samdb, "<GUID=%s>", buf_guid.buf);
 
 		/* Remove the GUID so we're not trying to modify it. */
-		ldb_msg_remove_attr(res->msgs[i], "objectGUID");
+		ldb_msg_remove_attr(new_msg, "objectGUID");
 
-		ret = ldb_modify(samdb, res->msgs[i]);
+		ret = ldb_modify(samdb, new_msg);
 		if (ret != LDB_SUCCESS) {
+			TALLOC_FREE(old_msg);
+			TALLOC_FREE(new_msg);
 			*error_string =
 			    talloc_asprintf(mem_ctx,
 					    "Failed to modify dns record "
@@ -273,6 +304,8 @@ NTSTATUS dns_tombstone_records_zone(TALLOC_CTX *mem_ctx,
 					    ldb_errstring(samdb));
 			return NT_STATUS_INTERNAL_ERROR;
 		}
+		TALLOC_FREE(old_msg);
+		TALLOC_FREE(new_msg);
 	}
 
 	return NT_STATUS_OK;
diff --git a/source4/dsdb/samdb/ldb_modules/acl_util.c b/source4/dsdb/samdb/ldb_modules/acl_util.c
index 6d645b10fe2..b9931795e19 100644
--- a/source4/dsdb/samdb/ldb_modules/acl_util.c
+++ b/source4/dsdb/samdb/ldb_modules/acl_util.c
@@ -286,7 +286,7 @@ uint32_t dsdb_request_sd_flags(struct ldb_request *req, bool *explicit)
 
 int dsdb_module_schedule_sd_propagation(struct ldb_module *module,
 					struct ldb_dn *nc_root,
-					struct ldb_dn *dn,
+					struct GUID guid,
 					bool include_self)
 {
 	struct ldb_context *ldb = ldb_module_get_ctx(module);
@@ -299,7 +299,7 @@ int dsdb_module_schedule_sd_propagation(struct ldb_module *module,
 	}
 
 	op->nc_root = nc_root;
-	op->dn = dn;
+	op->guid = guid;
 	op->include_self = include_self;
 
 	ret = dsdb_module_extended(module, op, NULL,
diff --git a/source4/dsdb/samdb/ldb_modules/audit_log.c b/source4/dsdb/samdb/ldb_modules/audit_log.c
index ef674950100..7cc3ff67d77 100644
--- a/source4/dsdb/samdb/ldb_modules/audit_log.c
+++ b/source4/dsdb/samdb/ldb_modules/audit_log.c
@@ -109,7 +109,7 @@ struct audit_private {
  */
 static bool has_password_changed(const struct ldb_message *message)
 {
-	int i;
+	unsigned int i;
 	if (message == NULL) {
 		return false;
 	}
diff --git a/source4/dsdb/samdb/ldb_modules/descriptor.c b/source4/dsdb/samdb/ldb_modules/descriptor.c
index 9018b750ab5..daa08c2ebc7 100644
--- a/source4/dsdb/samdb/ldb_modules/descriptor.c
+++ b/source4/dsdb/samdb/ldb_modules/descriptor.c
@@ -46,9 +46,8 @@
 
 struct descriptor_changes {
 	struct descriptor_changes *prev, *next;
-	struct descriptor_changes *children;
 	struct ldb_dn *nc_root;
-	struct ldb_dn *dn;
+	struct GUID guid;
 	bool force_self;
 	bool force_children;
 	struct ldb_dn *stopped_dn;
@@ -771,7 +770,8 @@ static int descriptor_modify(struct ldb_module *module, struct ldb_request *req)
 				    current_attrs,
 				    DSDB_FLAG_NEXT_MODULE |
 				    DSDB_FLAG_AS_SYSTEM |
-				    DSDB_SEARCH_SHOW_RECYCLED,
+				    DSDB_SEARCH_SHOW_RECYCLED |
+				    DSDB_SEARCH_SHOW_EXTENDED_DN,
 				    req);
 	if (ret != LDB_SUCCESS) {
 		ldb_debug(ldb, LDB_DEBUG_ERROR,"descriptor_modify: Could not find %s\n",
@@ -832,7 +832,7 @@ static int descriptor_modify(struct ldb_module *module, struct ldb_request *req)
 		user_sd = old_sd;
 	}
 
-	sd = get_new_descriptor(module, dn, req,
+	sd = get_new_descriptor(module, current_res->msgs[0]->dn, req,
 				objectclass, parent_sd,
 				user_sd, old_sd, sd_flags);
 	if (sd == NULL) {
@@ -869,15 +869,32 @@ static int descriptor_modify(struct ldb_module *module, struct ldb_request *req)
 			return ldb_oom(ldb);
 		}
 	} else if (cmp_ret != 0) {
+		struct GUID guid;
 		struct ldb_dn *nc_root;
+		NTSTATUS status;
 
-		ret = dsdb_find_nc_root(ldb, msg, dn, &nc_root);
+		ret = dsdb_find_nc_root(ldb,
+					msg,
+					current_res->msgs[0]->dn,
+					&nc_root);
 		if (ret != LDB_SUCCESS) {
 			return ldb_oom(ldb);
 		}
 
-		ret = dsdb_module_schedule_sd_propagation(module, nc_root,
-							  dn, false);
+		status = dsdb_get_extended_dn_guid(current_res->msgs[0]->dn,
+						   &guid,
+						   "GUID");
+		if (!NT_STATUS_IS_OK(status)) {
+			return ldb_operr(ldb);
+		}
+
+		/*
+		 * Force SD propagation on children of this record
+		 */
+		ret = dsdb_module_schedule_sd_propagation(module,
+							  nc_root,
+							  guid,
+							  false);
 		if (ret != LDB_SUCCESS) {
 			return ldb_operr(ldb);
 		}
@@ -960,16 +977,31 @@ static int descriptor_rename(struct ldb_module *module, struct ldb_request *req)
 
 	if (ldb_dn_compare(olddn, newdn) != 0) {
 		struct ldb_dn *nc_root;
+		struct GUID guid;
 
 		ret = dsdb_find_nc_root(ldb, req, newdn, &nc_root);
 		if (ret != LDB_SUCCESS) {
 			return ldb_oom(ldb);
 		}
 
-		ret = dsdb_module_schedule_sd_propagation(module, nc_root,
-							  newdn, true);
-		if (ret != LDB_SUCCESS) {
-			return ldb_operr(ldb);
+		ret = dsdb_module_guid_by_dn(module,
+					     olddn,
+					     &guid,
+					     req);
+		if (ret == LDB_SUCCESS) {
+			/*
+			 * Without disturbing any errors if the olddn
+			 * does not exit, force SD propagation on
+			 * this record (get a new inherited SD from
+			 * the potentially new parent
+			 */
+			ret = dsdb_module_schedule_sd_propagation(module,
+								  nc_root,
+								  guid,
+								  true);
+			if (ret != LDB_SUCCESS) {
+				return ldb_operr(ldb);
+			}
 		}
 	}
 
@@ -985,9 +1017,7 @@ static int descriptor_extended_sec_desc_propagation(struct ldb_module *module,
 	struct ldb_context *ldb = ldb_module_get_ctx(module);
 	struct dsdb_extended_sec_desc_propagation_op *op;
 	TALLOC_CTX *parent_mem = NULL;
-	struct descriptor_changes *parent_change = NULL;
 	struct descriptor_changes *c;
-	int ret;
 
 	op = talloc_get_type(req->op.extended.data,
 			     struct dsdb_extended_sec_desc_propagation_op);
@@ -1004,32 +1034,6 @@ static int descriptor_extended_sec_desc_propagation(struct ldb_module *module,
 
 	parent_mem = descriptor_private->trans_mem;
 
-	for (c = descriptor_private->changes; c; c = c->next) {
-		ret = ldb_dn_compare(c->nc_root, op->nc_root);
-		if (ret != 0) {
-			continue;
-		}
-
-		ret = ldb_dn_compare(c->dn, op->dn);
-		if (ret == 0) {
-			if (op->include_self) {
-				c->force_self = true;
-			} else {
-				c->force_children = true;
-			}
-			return ldb_module_done(req, NULL, NULL, LDB_SUCCESS);
-		}
-
-		ret = ldb_dn_compare_base(c->dn, op->dn);
-		if (ret != 0) {
-			continue;
-		}
-
-		parent_mem = c;
-		parent_change = c;
-		break;
-	}
-
 	c = talloc_zero(parent_mem, struct descriptor_changes);
 	if (c == NULL) {
 		return ldb_module_oom(module);
@@ -1038,21 +1042,14 @@ static int descriptor_extended_sec_desc_propagation(struct ldb_module *module,
 	if (c->nc_root == NULL) {
 		return ldb_module_oom(module);
 	}
-	c->dn = ldb_dn_copy(c, op->dn);
-	if (c->dn == NULL) {
-		return ldb_module_oom(module);
-	}
+	c->guid = op->guid;
 	if (op->include_self) {
 		c->force_self = true;
 	} else {
 		c->force_children = true;
 	}
 
-	if (parent_change != NULL) {
-		DLIST_ADD_END(parent_change->children, c);
-	} else {
-		DLIST_ADD_END(descriptor_private->changes, c);
-	}
+	DLIST_ADD_END(descriptor_private->changes, c);
 
 	return ldb_module_done(req, NULL, NULL, LDB_SUCCESS);
 }
@@ -1172,38 +1169,75 @@ static int descriptor_sd_propagation_msg_sort(struct ldb_message **m1,
 	return ldb_dn_compare(dn2, dn1);
 }
 
-static int descriptor_sd_propagation_dn_sort(struct ldb_dn *dn1,
-					     struct ldb_dn *dn2)
-{
-	/*
-	 * This sorts in tree order, parents first
-	 */
-	return ldb_dn_compare(dn2, dn1);
-}
-
 static int descriptor_sd_propagation_recursive(struct ldb_module *module,
 					       struct descriptor_changes *change)
 {
-	struct ldb_context *ldb = ldb_module_get_ctx(module);
+	struct ldb_result *guid_res = NULL;
 	struct ldb_result *res = NULL;
 	unsigned int i;
 	const char * const no_attrs[] = { "@__NONE__", NULL };
-	struct descriptor_changes *c;
-	struct descriptor_changes *stopped_stack = NULL;
-	enum ldb_scope scope;
+	struct ldb_dn *stopped_dn = NULL;
+	struct GUID_txt_buf guid_buf;
 	int ret;
+	bool stop = false;
 
 	/*
-	 * First confirm this object has children, or exists (depending on change->force_self)
+	 * First confirm this object has children, or exists
+	 * (depending on change->force_self)
 	 * 
 	 * LDB_SCOPE_SUBTREE searches are expensive.
 	 *
-	 * Note: that we do not search for deleted/recycled objects
+	 * We know this is safe against a rename race as we are in the
+	 * prepare_commit(), so must be in a transaction.
+	 */
+
+	/* Find the DN by GUID, as this is stable under rename */
+	ret = dsdb_module_search(module,
+				 change,
+				 &guid_res,
+				 change->nc_root,
+				 LDB_SCOPE_SUBTREE,
+				 no_attrs,
+				 DSDB_FLAG_NEXT_MODULE |
+				 DSDB_FLAG_AS_SYSTEM |
+				 DSDB_SEARCH_SHOW_DELETED |
+				 DSDB_SEARCH_SHOW_RECYCLED,
+				 NULL, /* parent_req */
+				 "(objectGUID=%s)",
+				 GUID_buf_string(&change->guid,
+						 &guid_buf));
+
+	if (ret != LDB_SUCCESS) {
+		return ret;
+	}
+
+	if (guid_res->count != 1) {
+		/*
+		 * We were just given this GUID during the same
+		 * transaction, if it is missing this is a big
+		 * problem.
+		 *
+		 * Cleanup of tombstones does not trigger this module
+		 * as it just does a delete.
+		 */
+		ldb_asprintf_errstring(ldb_module_get_ctx(module),
+				       "failed to find GUID %s under %s "
+				       "for transaction-end SD inheritance: %d results",
+				       GUID_buf_string(&change->guid,
+						       &guid_buf),
+				       ldb_dn_get_linearized(change->nc_root),
+				       guid_res->count);
+		return LDB_ERR_OPERATIONS_ERROR;
+	}
+
+	/*
+	 * OK, so there was a parent, are there children?  Note: that
+	 * this time we do not search for deleted/recycled objects
 	 */
 	ret = dsdb_module_search(module,
 				 change,
 				 &res,
-				 change->dn,
+				 guid_res->msgs[0]->dn,
 				 LDB_SCOPE_ONELEVEL,
 				 no_attrs,
 				 DSDB_FLAG_NEXT_MODULE |
@@ -1211,26 +1245,55 @@ static int descriptor_sd_propagation_recursive(struct ldb_module *module,
 				 NULL, /* parent_req */
 				 "(objectClass=*)");
 	if (ret != LDB_SUCCESS) {
+		/*
+		 * LDB_ERR_NO_SUCH_OBJECT, say if the DN was a deleted
+		 * object, is ignored by the caller
+		 */
 		return ret;
 	}
 
 	if (res->count == 0 && !change->force_self) {
+		/* All done, no children */
 		TALLOC_FREE(res);
 		return LDB_SUCCESS;
-	} else if (res->count == 0 && change->force_self) {
-		scope = LDB_SCOPE_BASE;
-	} else {
-		scope = LDB_SCOPE_SUBTREE;
 	}
 
 	/*
+	 * First, if we are in force_self mode (eg renamed under new
+	 * parent) then apply the SD to the top object
+	 */
+	if (change->force_self) {
+		ret = descriptor_sd_propagation_object(module,
+						       guid_res->msgs[0],
+						       &stop);
+		if (ret != LDB_SUCCESS) {
+			TALLOC_FREE(guid_res);
+			return ret;
+		}
+
+		if (stop == true && !change->force_children) {
+			/* There was no change, nothing more to do */
+			TALLOC_FREE(guid_res);
+			return LDB_SUCCESS;
+		}
+
+		if (res->count == 0) {
+			/* All done! */
+			TALLOC_FREE(guid_res);
+			return LDB_SUCCESS;
+		}
+	}
+
+	/*
+	 * Look for children
+	 *
 	 * Note: that we do not search for deleted/recycled objects
 	 */
 	ret = dsdb_module_search(module,
 				 change,
 				 &res,
-				 change->dn,
-				 scope,
+				 guid_res->msgs[0]->dn,
+				 LDB_SCOPE_SUBTREE,
 				 no_attrs,
 				 DSDB_FLAG_NEXT_MODULE |
 				 DSDB_FLAG_AS_SYSTEM,
@@ -1243,83 +1306,39 @@ static int descriptor_sd_propagation_recursive(struct ldb_module *module,
 	TYPESAFE_QSORT(res->msgs, res->count,
 		       descriptor_sd_propagation_msg_sort);
 
-	for (c = change->children; c; c = c->next) {
-		struct ldb_message *msg = NULL;
-
-		BINARY_ARRAY_SEARCH_P(res->msgs, res->count, dn, c->dn,
-				      descriptor_sd_propagation_dn_sort,
-				      msg);
-
-		if (msg == NULL) {
-			ldb_debug(ldb, LDB_DEBUG_WARNING,
-				"descriptor_sd_propagation_recursive: "
-				"%s not found under %s",
-				ldb_dn_get_linearized(c->dn),
-				ldb_dn_get_linearized(change->dn));
-			continue;
-		}
-
-		msg->elements = (struct ldb_message_element *)c;
-	}
-
-	DLIST_ADD(stopped_stack, change);
-
-	if (change->force_self) {
-		i = 0;
-	} else {
-		i = 1;
-	}
-
-	for (; i < res->count; i++) {
-		struct descriptor_changes *cur;
-		bool stop = false;
-
-		cur = talloc_get_type(res->msgs[i]->elements,
-				      struct descriptor_changes);
-		res->msgs[i]->elements = NULL;
-		res->msgs[i]->num_elements = 0;
-
-		if (cur != NULL) {
-			DLIST_REMOVE(change->children, cur);
-		}
-
-		for (c = stopped_stack; c; c = stopped_stack) {
-			ret = ldb_dn_compare_base(c->dn,
-						  res->msgs[i]->dn);
-			if (ret == 0) {
-				break;
-			}
-
-			c->stopped_dn = NULL;
-			DLIST_REMOVE(stopped_stack, c);
-		}
-
-		if (cur != NULL) {
-			DLIST_ADD(stopped_stack, cur);
-		}
-
-		if (stopped_stack->stopped_dn != NULL) {
-			ret = ldb_dn_compare_base(stopped_stack->stopped_dn,
+	/* We start from 1, the top object has been done */
+	for (i = 1; i < res->count; i++) {
+		/*
+		 * ldb_dn_compare_base() does not match for NULL but
+		 * this is clearer
+		 */
+		if (stopped_dn != NULL) {
+			ret = ldb_dn_compare_base(stopped_dn,
 						  res->msgs[i]->dn);
+			/*
+			 * Skip further processing of this
+			 * sub-subtree
+			 */
 			if (ret == 0) {
 				continue;
 			}
-			stopped_stack->stopped_dn = NULL;
 		}
-
-		ret = descriptor_sd_propagation_object(module, res->msgs[i],
+		ret = descriptor_sd_propagation_object(module,
+						       res->msgs[i],
 						       &stop);
 		if (ret != LDB_SUCCESS) {
 			return ret;
 		}
 
-		if (cur != NULL && cur->force_children) {
-			continue;
-		}
-
 		if (stop) {
-			stopped_stack->stopped_dn = res->msgs[i]->dn;
-			continue;
+			/*
+			 * If this child didn't change, then nothing
+			 * under it needs to change
+			 *
+			 * res has been sorted into tree order so the
+			 * next few entries can be skipped
+			 */
+			stopped_dn = res->msgs[i]->dn;
 		}
 	}
 
diff --git a/source4/dsdb/samdb/ldb_modules/encrypted_secrets.c b/source4/dsdb/samdb/ldb_modules/encrypted_secrets.c
index 7e6d4b160d4..d3ce7e31642 100644
--- a/source4/dsdb/samdb/ldb_modules/encrypted_secrets.c
+++ b/source4/dsdb/samdb/ldb_modules/encrypted_secrets.c
@@ -263,7 +263,7 @@ static int load_keys(struct ldb_module *module, struct es_data *data)
  */
 static bool should_encrypt(const struct ldb_message_element *el)
 {
-	int i;
+	size_t i;
 
 	for (i = 0; i < ARRAY_SIZE(secret_attributes); i++) {
 		if (strcasecmp(secret_attributes[i], el->name) == 0) {
@@ -748,7 +748,7 @@ static struct ldb_message_element *encrypt_element(
 	const struct es_data *data)
 {
 	struct ldb_message_element* enc;
-	int i;
+	unsigned int i;
 
 	enc = talloc_zero(ctx, struct ldb_message_element);
 	if (enc == NULL) {
@@ -818,10 +818,9 @@ static const struct ldb_message *encrypt_secret_attributes(
 	const struct ldb_message *msg,
 	const struct es_data *data)
 {
-
 	struct ldb_message *encrypted_msg = NULL;
 
-	int i;
+	unsigned int i;
 
 	if (ldb_dn_is_special(msg->dn)) {
 		return NULL;
@@ -1003,7 +1002,7 @@ static struct ldb_message_element *decrypt_element(
 	struct ldb_message_element* el,
 	struct es_data *data)
 {
-	int i;
+	unsigned int i;
 	struct ldb_message_element* dec =
 		talloc_zero(ctx, struct ldb_message_element);
 
@@ -1069,8 +1068,8 @@ static int decrypt_secret_attributes(struct ldb_context *ldb,
 				      struct ldb_message *msg,
 				      struct es_data *data)
 {
-
-	int i, ret;
+	size_t i;
+	int ret;
 
 	if (ldb_dn_is_special(msg->dn)) {
 		return LDB_SUCCESS;
diff --git a/source4/dsdb/samdb/ldb_modules/objectclass_attrs.c b/source4/dsdb/samdb/ldb_modules/objectclass_attrs.c
index e5f86d260f4..0b9725e2767 100644
--- a/source4/dsdb/samdb/ldb_modules/objectclass_attrs.c
+++ b/source4/dsdb/samdb/ldb_modules/objectclass_attrs.c
@@ -133,7 +133,16 @@ static int oc_auto_normalise(struct ldb_context *ldb, const struct dsdb_attribut
 	for (i=0; i<el->num_values; i++) {
 		struct ldb_val v;
 		int ret;
-		ret = attr->ldb_schema_attribute->syntax->canonicalise_fn(ldb, el->values, &el->values[i], &v);
+		/*
+		 * We use msg->elements (owned by this module due to
+		 * ldb_msg_copy_shallow()) as a memory context and
+		 * then steal from there to the right spot if we don't
+		 * free it.
+		 */
+		ret = attr->ldb_schema_attribute->syntax->canonicalise_fn(ldb,
+									  msg->elements,
+									  &el->values[i],
+									  &v);
 		if (ret != LDB_SUCCESS) {
 			return ret;
 		}
@@ -156,6 +165,12 @@ static int oc_auto_normalise(struct ldb_context *ldb, const struct dsdb_attribut
 		}
 
 		el->values[i] = v;
+
+		/*
+		 * By now el->values is a talloc pointer under
+		 * msg->elements and may now be used
+		 */
+		talloc_steal(el->values, v.data);
 	}
 	return LDB_SUCCESS;
 }
diff --git a/source4/dsdb/samdb/ldb_modules/repl_meta_data.c b/source4/dsdb/samdb/ldb_modules/repl_meta_data.c
index c16ea7bb616..a8a61d5df7c 100644
--- a/source4/dsdb/samdb/ldb_modules/repl_meta_data.c
+++ b/source4/dsdb/samdb/ldb_modules/repl_meta_data.c
@@ -5634,9 +5634,19 @@ static int replmd_replicated_apply_add(struct replmd_replicated_request *ar)
 	replmd_ldb_message_sort(msg, ar->schema);
 
 	if (!remote_isDeleted) {
+		/*
+		 * Ensure any local ACL inheritence is applied from
+		 * the parent object.
+		 *
+		 * This is needed because descriptor is above
+		 * repl_meta_data in the module stack, so this will
+		 * not be trigered 'naturally' by the flow of
+		 * operations.
+		 */
 		ret = dsdb_module_schedule_sd_propagation(ar->module,
 							  ar->objs->partition_dn,
-							  msg->dn, true);
+							  ar->objs->objects[ar->index_current].object_guid,
+							  true);
 		if (ret != LDB_SUCCESS) {
 			return replmd_replicated_request_error(ar, ret);
 		}
@@ -5878,7 +5888,7 @@ static int replmd_replicated_apply_search_for_parent(struct replmd_replicated_re
 static int replmd_replicated_handle_rename(struct replmd_replicated_request *ar,
 					   struct ldb_message *msg,
 					   struct ldb_request *parent,
-					   bool *renamed)
+					   bool *renamed_to_conflict)
 {
 	int ret;
 	TALLOC_CTX *tmp_ctx = talloc_new(msg);
@@ -5897,7 +5907,6 @@ static int replmd_replicated_handle_rename(struct replmd_replicated_request *ar,
 				 DSDB_FLAG_NEXT_MODULE, ar->req);
 	if (ret == LDB_SUCCESS) {
 		talloc_free(tmp_ctx);
-		*renamed = true;
 		return ret;
 	}
 
@@ -5948,7 +5957,7 @@ static int replmd_replicated_handle_rename(struct replmd_replicated_request *ar,
 		}
 
 		msg->dn = new_dn;
-		*renamed = true;
+		*renamed_to_conflict = true;
 		talloc_free(tmp_ctx);
 		return LDB_SUCCESS;
 	}
@@ -5997,7 +6006,10 @@ static int replmd_replicated_handle_rename(struct replmd_replicated_request *ar,
 		 ldb_dn_get_linearized(ar->search_msg->dn),
 		 ldb_dn_get_linearized(msg->dn)));
 
-
+	/*
+	 * With the other record out of the way, do the rename we had
+	 * at the top again
+	 */
 	ret = dsdb_module_rename(ar->module, ar->search_msg->dn, msg->dn,
 				 DSDB_FLAG_NEXT_MODULE, ar->req);
 	if (ret != LDB_SUCCESS) {
@@ -6050,6 +6062,7 @@ static int replmd_replicated_apply_merge(struct replmd_replicated_request *ar)
 	bool take_remote_isDeleted = false;
 	bool sd_updated = false;
 	bool renamed = false;
+	bool renamed_to_conflict = false;
 	bool is_schema_nc = false;
 	NTSTATUS nt_status;
 	const struct ldb_val *old_rdn, *new_rdn;
@@ -6150,7 +6163,18 @@ static int replmd_replicated_apply_merge(struct replmd_replicated_request *ar)
 		 * the peer has an older name to what we have (see
 		 * replmd_replicated_apply_search_callback())
 		 */
-		ret = replmd_replicated_handle_rename(ar, msg, ar->req, &renamed);
+		ret = replmd_replicated_handle_rename(ar, msg, ar->req, &renamed_to_conflict);
+
+		/*
+		 * This looks strange, but we must set this after any
+		 * rename, otherwise the SD propegation will not
+		 * happen (which might matter if we have a new parent)
+		 *
+		 * The additional case of calling
+		 * replmd_op_name_modify_callback (below) is
+		 * controlled by renamed_to_conflict.
+		 */
+		renamed = true;
 	}
 
 	if (ret != LDB_SUCCESS) {
@@ -6162,7 +6186,7 @@ static int replmd_replicated_apply_merge(struct replmd_replicated_request *ar)
 		return replmd_replicated_request_werror(ar, WERR_DS_DRA_DB_ERROR);
 	}
 
-	if (renamed == true) {
+	if (renamed_to_conflict == true) {
 		/*
 		 * Set the callback to one that will fix up the name
 		 * metadata on the new conflict DN
@@ -6316,13 +6340,39 @@ static int replmd_replicated_apply_merge(struct replmd_replicated_request *ar)
 		  ar->index_current, msg->num_elements);
 
 	if (renamed) {
-		sd_updated = true;
+		/*
+		 * This is an new name for this object, so we must
+		 * inherit from the parent
+		 *
+		 * This is needed because descriptor is above
+		 * repl_meta_data in the module stack, so this will
+		 * not be trigered 'naturally' by the flow of
+		 * operations.
+		 */
+		ret = dsdb_module_schedule_sd_propagation(ar->module,
+							  ar->objs->partition_dn,
+							  ar->objs->objects[ar->index_current].object_guid,
+							  true);
+		if (ret != LDB_SUCCESS) {
+			return ldb_operr(ldb);
+		}
 	}
 
 	if (sd_updated && !isDeleted) {
+		/*
+		 * This is an existing object, so there is no need to
+		 * inherit from the parent, but we must inherit any
+		 * incoming changes to our child objects.
+		 *
+		 * This is needed because descriptor is above
+		 * repl_meta_data in the module stack, so this will
+		 * not be trigered 'naturally' by the flow of
+		 * operations.
+		 */
 		ret = dsdb_module_schedule_sd_propagation(ar->module,
 							  ar->objs->partition_dn,
-							  msg->dn, true);
+							  ar->objs->objects[ar->index_current].object_guid,
+							  false);
 		if (ret != LDB_SUCCESS) {
 			return ldb_operr(ldb);
 		}
diff --git a/source4/dsdb/samdb/ldb_modules/tests/test_encrypted_secrets.c b/source4/dsdb/samdb/ldb_modules/tests/test_encrypted_secrets.c
index 6357deab7ce..e639d4cbb0a 100644
--- a/source4/dsdb/samdb/ldb_modules/tests/test_encrypted_secrets.c
+++ b/source4/dsdb/samdb/ldb_modules/tests/test_encrypted_secrets.c
@@ -672,7 +672,8 @@ static void test_message_encryption_decryption(void **state)
 		struct es_data);
 	struct ldb_message_element *el = NULL;
 	int ret = LDB_SUCCESS;
-	int i, j;
+	size_t i;
+	unsigned int j;
 
 	msg->dn = ldb_dn_new(msg, ldb, "dc=test");
 	ldb_msg_add_string(msg, "cmocka_test_name01", "value01");
diff --git a/source4/dsdb/samdb/ldb_modules/wscript_build b/source4/dsdb/samdb/ldb_modules/wscript_build
index 89629ab1cb8..c3e8b54f0ba 100644
--- a/source4/dsdb/samdb/ldb_modules/wscript_build
+++ b/source4/dsdb/samdb/ldb_modules/wscript_build
@@ -27,7 +27,7 @@ bld.SAMBA_BINARY('test_unique_object_sids',
             cmocka
             DSDB_MODULE_HELPERS
         ''',
-        install=False)
+        for_selftest=True)
 bld.SAMBA_BINARY('test_encrypted_secrets_tdb',
         source='tests/test_encrypted_secrets.c',
         cflags='-DTEST_BE=\"tdb\"',
@@ -40,7 +40,7 @@ bld.SAMBA_BINARY('test_encrypted_secrets_tdb',
             gnutls
             DSDB_MODULE_HELPERS
         ''',
-        install=False)
+        for_selftest=True)
 if conf.env.HAVE_LMDB:
     bld.SAMBA_BINARY('test_encrypted_secrets_mdb',
             source='tests/test_encrypted_secrets.c',
@@ -54,7 +54,7 @@ if conf.env.HAVE_LMDB:
                 gnutls
                 DSDB_MODULE_HELPERS
             ''',
-            install=False)
+            for_selftest=True)
 
 if bld.AD_DC_BUILD_IS_ENABLED():
     bld.PROCESS_SEPARATE_RULE("server")
diff --git a/source4/dsdb/samdb/ldb_modules/wscript_build_server b/source4/dsdb/samdb/ldb_modules/wscript_build_server
index 2eec7c4fa7d..4d0febc7152 100644
--- a/source4/dsdb/samdb/ldb_modules/wscript_build_server
+++ b/source4/dsdb/samdb/ldb_modules/wscript_build_server
@@ -21,7 +21,7 @@ bld.SAMBA_BINARY('test_audit_util',
                  audit_logging
                  DSDB_MODULE_HELPERS
                  ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA_BINARY('test_audit_log',
                  source='tests/test_audit_log.c',
@@ -35,7 +35,7 @@ bld.SAMBA_BINARY('test_audit_log',
                  DSDB_MODULE_HELPERS
                  DSDB_MODULE_HELPERS_AUDIT
                  ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA_BINARY('test_audit_log_errors',
                  source='tests/test_audit_log_errors.c',
@@ -54,7 +54,7 @@ bld.SAMBA_BINARY('test_audit_log_errors',
                      -Wl,--wrap,json_add_version
                      -Wl,--wrap,json_add_timestamp
                  ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA_BINARY('test_group_audit',
                  source='tests/test_group_audit.c',
@@ -68,7 +68,7 @@ bld.SAMBA_BINARY('test_group_audit',
                  DSDB_MODULE_HELPERS
                  DSDB_MODULE_HELPERS_AUDIT
                  ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA_BINARY('test_group_audit_errors',
                  source='tests/test_group_audit_errors.c',
@@ -87,7 +87,7 @@ bld.SAMBA_BINARY('test_group_audit_errors',
                      -Wl,--wrap,json_add_version
                      -Wl,--wrap,json_add_timestamp
                  ''',
-                 install=False)
+                 for_selftest=True)
 
 bld.SAMBA_MODULE('ldb_samba_dsdb',
 	source='samba_dsdb.c',
diff --git a/source4/dsdb/samdb/samdb.h b/source4/dsdb/samdb/samdb.h
index fd8d4e4497e..b0fdfeb3967 100644
--- a/source4/dsdb/samdb/samdb.h
+++ b/source4/dsdb/samdb/samdb.h
@@ -292,7 +292,7 @@ struct dsdb_fsmo_extended_op {
 #define DSDB_EXTENDED_SEC_DESC_PROPAGATION_OID "1.3.6.1.4.1.7165.4.4.7"
 struct dsdb_extended_sec_desc_propagation_op {
 	struct ldb_dn *nc_root;
-	struct ldb_dn *dn;
+	struct GUID guid;
 	bool include_self;
 };
 
diff --git a/source4/heimdal/kdc/krb5tgs.c b/source4/heimdal/kdc/krb5tgs.c
index ff7d93138c0..ee3ac3d8f53 100644
--- a/source4/heimdal/kdc/krb5tgs.c
+++ b/source4/heimdal/kdc/krb5tgs.c
@@ -1975,30 +1975,42 @@ server_lookup:
 	    if (ret)
 		goto out;
 
+	    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,
+				NULL, &s4u2self_impersonated_clientdb,
+				&s4u2self_impersonated_client);
+	    if (ret) {
+		const char *msg;
+
+		/*
+		 * If the client belongs to the same realm as our krbtgt, it
+		 * should exist in the local database.
+		 *
+		 */
+
+		if (ret == HDB_ERR_NOENTRY)
+		    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
+		msg = krb5_get_error_message(context, ret);
+		kdc_log(context, config, 1,
+			"S2U4Self principal to impersonate %s not found in database: %s",
+			tpn, msg);
+		krb5_free_error_message(context, msg);
+		goto out;
+	    }
+
+	    /* Ignore pw_end attributes (as Windows does),
+	     * since S4U2Self is not password authentication. */
+	    free(s4u2self_impersonated_client->entry.pw_end);
+	    s4u2self_impersonated_client->entry.pw_end = NULL;
+
+	    ret = kdc_check_flags(context, config, s4u2self_impersonated_client, tpn,
+				  NULL, NULL, FALSE);
+	    if (ret)
+		goto out;
+
 	    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */
 	    if(rspac.data) {
 		krb5_pac p = NULL;
 		krb5_data_free(&rspac);
-		ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,
-				    NULL, &s4u2self_impersonated_clientdb, &s4u2self_impersonated_client);
-		if (ret) {
-		    const char *msg;
-
-		    /*
-		     * If the client belongs to the same realm as our krbtgt, it
-		     * should exist in the local database.
-		     *
-		     */
-
-		    if (ret == HDB_ERR_NOENTRY)
-			ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
-		    msg = krb5_get_error_message(context, ret);
-		    kdc_log(context, config, 1,
-			    "S2U4Self principal to impersonate %s not found in database: %s",
-			    tpn, msg);
-		    krb5_free_error_message(context, msg);
-		    goto out;
-		}
 		ret = _kdc_pac_generate(context, s4u2self_impersonated_client, NULL, &p);
 		if (ret) {
 		    kdc_log(context, config, 0, "PAC generation failed for -- %s",
@@ -2034,10 +2046,12 @@ server_lookup:
 
 	    /*
 	     * If the service isn't trusted for authentication to
-	     * delegation, remove the forward flag.
+	     * delegation or if the impersonate client is disallowed
+	     * forwardable, remove the forwardable flag.
 	     */
 
-	    if (client->entry.flags.trusted_for_delegation) {
+	    if (client->entry.flags.trusted_for_delegation &&
+		s4u2self_impersonated_client->entry.flags.forwardable) {
 		str = "[forwardable]";
 	    } else {
 		b->kdc_options.forwardable = 0;
diff --git a/source4/heimdal_build/krb5-types.h b/source4/heimdal_build/include/krb5-types.h
similarity index 100%
rename from source4/heimdal_build/krb5-types.h
rename to source4/heimdal_build/include/krb5-types.h
diff --git a/source4/heimdal_build/wscript_build b/source4/heimdal_build/wscript_build
index c9a974ca0fb..e031d9831ff 100644
--- a/source4/heimdal_build/wscript_build
+++ b/source4/heimdal_build/wscript_build
@@ -57,16 +57,16 @@ def HEIMDAL_ASN1(name, source,
     # SRC[0].abspath(env) gives the absolute path to the source directory for the first
     # source file. Note that in the case of a option_file, we have more than
     # one source file
-    cd_rule = 'cd "${TGT[0].parent.abspath(env)}"'
+    cd_rule = 'cd "${TGT[0].parent.abspath(env)}" &&'
     env = LOAD_ENVIRONMENT()
     if env.ADDRESS_SANITIZER:
         # If address sanitizer is enabled, we need to suppress leak checking
         # in the asn1 tool.
-        no_leak_check = " && export ASAN_OPTIONS=detect_leaks=0"
+        no_leak_check = " ASAN_OPTIONS=detect_leaks=0"
     else:
         no_leak_check = ""
 
-    asn1_rule = cd_rule + no_leak_check + ' && "${ASN1_COMPILE}" ${OPTION_FILE} ${ASN1OPTIONS} --one-code-file "${SRC[0].abspath(env)}" ${ASN1NAME}'
+    asn1_rule = cd_rule + no_leak_check + ' "${ASN1_COMPILE}" ${OPTION_FILE} ${ASN1OPTIONS} --one-code-file "${SRC[0].abspath(env)}" ${ASN1NAME}'
 
     source = to_list(source)
 
@@ -140,7 +140,7 @@ def HEIMDAL_ASN1(name, source,
             samba_cflags   = CURRENT_CFLAGS(bld, name, ''),
             depends_on     = '',
             samba_deps     = to_list('roken replace'),
-            samba_includes = includes + ["/usr/include/heimdal"],
+            samba_includes = includes,
             local_include  = True)
 
 
@@ -397,7 +397,7 @@ if not bld.CONFIG_SET('USING_SYSTEM_ROKEN'):
 
     HEIMDAL_LIBRARY('roken',
         ROKEN_SOURCE,
-        includes='../heimdal/lib/roken ../heimdal/include',
+        includes='../heimdal/lib/roken ../heimdal/include ../heimdal_build/include',
         deps='resolv util replace',
         vnum='19.0.1',
         version_script='lib/roken/version-script.map',
@@ -407,7 +407,7 @@ if not bld.CONFIG_SET('USING_SYSTEM_ROKEN'):
         ROKEN_HOSTCC_SOURCE,
         use_hostcc=True,
         use_global_deps=False,
-        includes='../heimdal/lib/roken',
+        includes='../heimdal/lib/roken ../heimdal/include ../heimdal_build/include',
         cflags='-DSOCKET_WRAPPER_DISABLE=1 -D_SAMBA_HOSTCC_',
         group='compiler_libraries',
         deps='LIBREPLACE_HOSTCC',
diff --git a/source4/kdc/mit-kdb/kdb_samba.h b/source4/kdc/mit-kdb/kdb_samba.h
index b9c571f26cb..22ef9085b6a 100644
--- a/source4/kdc/mit-kdb/kdb_samba.h
+++ b/source4/kdc/mit-kdb/kdb_samba.h
@@ -1,30 +1,23 @@
-/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
 /*
- * plugins/kdb/samba/kdb_samba.h
- *
- * Copyright (c) 2009, Simo Sorce <idra@samba.org>
- * All Rights Reserved.
- *
- *   Export of this software from the United States of America may
- *   require a specific license from the United States Government.
- *   It is the responsibility of any person or organization contemplating
- *   export to obtain such a license before exporting.
- *
- * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
- * distribute this software and its documentation for any purpose and
- * without fee is hereby granted, provided that the above copyright
- * notice appear in all copies and that both that copyright notice and
- * this permission notice appear in supporting documentation, and that
- * the name of M.I.T. not be used in advertising or publicity pertaining
- * to distribution of the software without specific, written prior
- * permission.  Furthermore if you modify this software you must label
- * your software as modified software and not distribute it in such a
- * fashion that it might be confused with the original M.I.T. software.
- * M.I.T. makes no representations about the suitability of
- * this software for any purpose.  It is provided "as is" without express
- * or implied warranty.
- *
- */
+   Unix SMB/CIFS implementation.
+
+   Samba KDB plugin for MIT Kerberos
+
+   Copyright (c) 2009      Simo Sorce <idra@samba.org>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
 
 #ifndef _KDB_SAMBA_H_
 #define _KDB_SAMBA_H_
diff --git a/source4/kdc/mit_samba.c b/source4/kdc/mit_samba.c
index 54dcd545ea1..5a4f6e73e97 100644
--- a/source4/kdc/mit_samba.c
+++ b/source4/kdc/mit_samba.c
@@ -304,6 +304,11 @@ fetch_referral_principal:
 
 	sdb_free_entry(&sentry);
 
+	if ((kflags & KRB5_KDB_FLAG_CLIENT_REFERRALS_ONLY) == 0) {
+		kentry->attributes &= ~KRB5_KDB_DISALLOW_FORWARDABLE;
+		kentry->attributes &= ~KRB5_KDB_DISALLOW_PROXIABLE;
+	}
+
 done:
 	krb5_free_principal(ctx->context, referral_principal);
 	referral_principal = NULL;
diff --git a/source4/kdc/sdb_to_kdb.c b/source4/kdc/sdb_to_kdb.c
index 1411b0f5f66..2981f180333 100644
--- a/source4/kdc/sdb_to_kdb.c
+++ b/source4/kdc/sdb_to_kdb.c
@@ -36,18 +36,13 @@ static int SDBFlags_to_kflags(const struct SDBFlags *s,
 	if (s->initial) {
 		*k |= KRB5_KDB_DISALLOW_TGT_BASED;
 	}
-	/*
-	 * Do not set any disallow rules for forwardable, proxiable,
-	 * renewable, postdate and server.
-	 *
-	 * The KDC will take care setting the flags based on the incoming
-	 * ticket.
-	 */
-	if (s->forwardable) {
-		;
+	/* The forwardable and proxiable flags are set according to client and
+	 * server attributes. */
+	if (!s->forwardable) {
+		*k |= KRB5_KDB_DISALLOW_FORWARDABLE;
 	}
-	if (s->proxiable) {
-		;
+	if (!s->proxiable) {
+		*k |= KRB5_KDB_DISALLOW_PROXIABLE;
 	}
 	if (s->renewable) {
 		;
diff --git a/source4/lib/messaging/wscript_build b/source4/lib/messaging/wscript_build
index 4688aa7bda4..3408396ebd0 100644
--- a/source4/lib/messaging/wscript_build
+++ b/source4/lib/messaging/wscript_build
@@ -9,7 +9,17 @@ bld.SAMBA_LIBRARY('MESSAGING_SEND',
 
 bld.SAMBA_LIBRARY('MESSAGING',
 	source='messaging.c messaging_handlers.c',
-	public_deps='samba-util NDR_IRPC UNIX_PRIVS cluster ndr dcerpc messages_util server_id_db talloc_report',
+	public_deps='''
+            samba-util
+            NDR_IRPC
+            UNIX_PRIVS
+            cluster
+            ndr
+            dcerpc
+            messages_util
+            server_id_db
+            talloc_report_printf
+            ''',
 	private_library=True
 	)
 
diff --git a/source4/lib/policy/gp_filesys.c b/source4/lib/policy/gp_filesys.c
index 69fb143c687..5a300f134fe 100644
--- a/source4/lib/policy/gp_filesys.c
+++ b/source4/lib/policy/gp_filesys.c
@@ -421,7 +421,7 @@ static NTSTATUS push_recursive (struct gp_context *gp_ctx, const char *local_pat
 	struct dirent *dirent;
 	char *entry_local_path = NULL;
 	char *entry_remote_path = NULL;
-	int local_fd, remote_fd;
+	int local_fd = -1, remote_fd = -1;
 	int buf[1024];
 	int nread, total_read;
 	struct stat s;
@@ -494,7 +494,9 @@ static NTSTATUS push_recursive (struct gp_context *gp_ctx, const char *local_pat
 			}
 
 			close(local_fd);
+			local_fd = -1;
 			smbcli_close(gp_ctx->cli->tree, remote_fd);
+			remote_fd = -1;
 		}
 		TALLOC_FREE(entry_local_path);
 		TALLOC_FREE(entry_remote_path);
@@ -502,6 +504,12 @@ static NTSTATUS push_recursive (struct gp_context *gp_ctx, const char *local_pat
 
 	status = NT_STATUS_OK;
 done:
+	if (local_fd != -1) {
+		close(local_fd);
+	}
+	if (remote_fd != -1) {
+		smbcli_close(gp_ctx->cli->tree, remote_fd);
+	}
 	talloc_free(entry_local_path);
 	talloc_free(entry_remote_path);
 
diff --git a/source4/libcli/rap/rap.c b/source4/libcli/rap/rap.c
index 9f41e17d278..1b2cadb753d 100644
--- a/source4/libcli/rap/rap.c
+++ b/source4/libcli/rap/rap.c
@@ -476,6 +476,7 @@ static enum ndr_err_code ndr_pull_rap_NetPrintQEnum_data(struct ndr_pull *ndr, s
 		NDR_CHECK(ndr_pull_rap_printq_info(ndr, NDR_SCALARS, &r->out.info[cntr_info_0]));
 	}
 	for (cntr_info_0 = 0; cntr_info_0 < r->out.count; cntr_info_0++) {
+		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->out.info[cntr_info_0], r->in.level));
 		NDR_CHECK(ndr_pull_rap_printq_info(ndr, NDR_BUFFERS, &r->out.info[cntr_info_0]));
 	}
 	NDR_PULL_SET_MEM_CTX(ndr, _mem_save_info_0, 0);
@@ -864,6 +865,7 @@ static enum ndr_err_code ndr_pull_rap_NetPrintJobEnum_data(struct ndr_pull *ndr,
 		NDR_CHECK(ndr_pull_rap_printj_info(ndr, NDR_SCALARS, &r->out.info[cntr_info_0]));
 	}
 	for (cntr_info_0 = 0; cntr_info_0 < r->out.count; cntr_info_0++) {
+		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->out.info[cntr_info_0], r->in.level));
 		NDR_CHECK(ndr_pull_rap_printj_info(ndr, NDR_BUFFERS, &r->out.info[cntr_info_0]));
 	}
 	NDR_PULL_SET_MEM_CTX(ndr, _mem_save_info_0, 0);
@@ -1413,6 +1415,7 @@ static enum ndr_err_code ndr_pull_rap_NetSessionEnum_data(struct ndr_pull *ndr,
 		NDR_CHECK(ndr_pull_rap_session_info(ndr, NDR_SCALARS, &r->out.info[cntr_info_0]));
 	}
 	for (cntr_info_0 = 0; cntr_info_0 < r->out.count; cntr_info_0++) {
+		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->out.info[cntr_info_0], r->in.level));
 		NDR_CHECK(ndr_pull_rap_session_info(ndr, NDR_BUFFERS, &r->out.info[cntr_info_0]));
 	}
 	NDR_PULL_SET_MEM_CTX(ndr, _mem_save_info_0, 0);
diff --git a/source4/libcli/smb2/util.c b/source4/libcli/smb2/util.c
index 94072bee3ea..882dcb9468b 100644
--- a/source4/libcli/smb2/util.c
+++ b/source4/libcli/smb2/util.c
@@ -99,6 +99,52 @@ NTSTATUS smb2_util_setatr(struct smb2_tree *tree, const char *name, uint32_t att
 }
 
 
+/*
+  get file attribute with SMB2
+*/
+NTSTATUS smb2_util_getatr(struct smb2_tree *tree, const char *fname,
+			  uint16_t *attr, size_t *size, time_t *t)
+{
+	union smb_fileinfo parms;
+	NTSTATUS status;
+	struct smb2_create create_io = {0};
+
+	create_io.in.desired_access = SEC_FILE_READ_ATTRIBUTE;
+	create_io.in.share_access = NTCREATEX_SHARE_ACCESS_NONE;
+	create_io.in.create_disposition = FILE_OPEN;
+	create_io.in.fname = fname;
+	status = smb2_create(tree, tree, &create_io);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	ZERO_STRUCT(parms);
+	parms.all_info2.level = RAW_FILEINFO_SMB2_ALL_INFORMATION;
+	parms.all_info2.in.file.handle = create_io.out.file.handle;
+	status = smb2_getinfo_file(tree, tree, &parms);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	status = smb2_util_close(tree, create_io.out.file.handle);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	if (size) {
+		*size = parms.all_info2.out.size;
+	}
+
+	if (t) {
+		*t = parms.all_info2.out.write_time;
+	}
+
+	if (attr) {
+		*attr = parms.all_info2.out.attrib;
+	}
+
+	return status;
+}
 
 
 /* 
diff --git a/source4/libnet/libnet_passwd.c b/source4/libnet/libnet_passwd.c
index 704a94a5864..868f9442cd0 100644
--- a/source4/libnet/libnet_passwd.c
+++ b/source4/libnet/libnet_passwd.c
@@ -115,7 +115,11 @@ static NTSTATUS libnet_ChangePassword_samr(struct libnet_context *ctx, TALLOC_CT
 		goto disconnect;
 	}
 
-	E_old_pw_hash(new_lm_hash, old_lm_hash, lm_verifier.hash);
+	rc = E_old_pw_hash(new_lm_hash, old_lm_hash, lm_verifier.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto disconnect;
+	}
 
 	encode_pw_buffer(nt_pass.data,  r->samr.in.newpassword, STR_UNICODE);
 
@@ -137,7 +141,11 @@ static NTSTATUS libnet_ChangePassword_samr(struct libnet_context *ctx, TALLOC_CT
 		goto disconnect;
 	}
 
-	E_old_pw_hash(new_nt_hash, old_nt_hash, nt_verifier.hash);
+	rc = E_old_pw_hash(new_nt_hash, old_nt_hash, nt_verifier.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto disconnect;
+	}
 
 	pw3.in.server = &server;
 	pw3.in.account = &account;
@@ -189,7 +197,11 @@ static NTSTATUS libnet_ChangePassword_samr(struct libnet_context *ctx, TALLOC_CT
 		goto disconnect;
 	}
 
-	E_old_pw_hash(new_lm_hash, old_lm_hash, lm_verifier.hash);
+	rc = E_old_pw_hash(new_lm_hash, old_lm_hash, lm_verifier.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto disconnect;
+	}
 
 	encode_pw_buffer(nt_pass.data, r->samr.in.newpassword, STR_UNICODE);
 
@@ -210,7 +222,11 @@ static NTSTATUS libnet_ChangePassword_samr(struct libnet_context *ctx, TALLOC_CT
 		goto disconnect;
 	}
 
-	E_old_pw_hash(new_nt_hash, old_nt_hash, nt_verifier.hash);
+	rc = E_old_pw_hash(new_nt_hash, old_nt_hash, nt_verifier.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto disconnect;
+	}
 
 	pw2.in.server = &server;
 	pw2.in.account = &account;
@@ -260,7 +276,11 @@ static NTSTATUS libnet_ChangePassword_samr(struct libnet_context *ctx, TALLOC_CT
 		goto disconnect;
 	}
 
-	E_old_pw_hash(new_lm_hash, old_lm_hash, lm_verifier.hash);
+	rc = E_old_pw_hash(new_lm_hash, old_lm_hash, lm_verifier.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto disconnect;
+	}
 
 	oe2.in.server = &a_server;
 	oe2.in.account = &a_account;
diff --git a/source4/librpc/idl/wscript_build b/source4/librpc/idl/wscript_build
index f8dca6af4a7..58555e6bf55 100644
--- a/source4/librpc/idl/wscript_build
+++ b/source4/librpc/idl/wscript_build
@@ -7,7 +7,7 @@ topinclude=os.path.join(bld.srcnode.abspath(), 'librpc/idl')
 bld.SAMBA_PIDL_LIST('PIDL',
 		    source='''ntp_signd.idl
                               opendb.idl sasl_helpers.idl
-                              winsif.idl winsrepl.idl winstation.idl''',
+                              winsif.idl winsrepl.idl''',
                     options="--includedir=%s --header --ndr-parser" % topinclude,
                     output_dir='../gen_ndr')
 
diff --git a/source4/librpc/rpc/dcerpc.h b/source4/librpc/rpc/dcerpc.h
index b5ef1fd3be4..6b0b841d64d 100644
--- a/source4/librpc/rpc/dcerpc.h
+++ b/source4/librpc/rpc/dcerpc.h
@@ -258,9 +258,5 @@ NTSTATUS dcerpc_secondary_auth_connection(struct dcerpc_pipe *p,
 
 struct composite_context* dcerpc_secondary_connection_send(struct dcerpc_pipe *p,
 							   const struct dcerpc_binding *b);
-void dcerpc_log_packet(const char *lockdir, 
-		       const struct ndr_interface_table *ndr,
-		       uint32_t opnum, uint32_t flags,
-		       const DATA_BLOB *pkt);
 
 #endif /* __S4_DCERPC_H__ */
diff --git a/source4/librpc/tests/dnsp-DnssrvRpcRecord.txt b/source4/librpc/tests/dnsp-DnssrvRpcRecord.txt
new file mode 100644
index 00000000000..fd169223c74
--- /dev/null
+++ b/source4/librpc/tests/dnsp-DnssrvRpcRecord.txt
@@ -0,0 +1,32 @@
+pull returned Success
+    dnsp_DnssrvRpcRecord: struct dnsp_DnssrvRpcRecord
+        wDataLength              : 0x0005 (5)
+        wType                    : DNS_TYPE_MX (15)
+        version                  : 0x05 (5)
+        rank                     : DNS_RANK_ZONE (240)
+        flags                    : 0x0000 (0)
+        dwSerial                 : 0x000000b7 (183)
+        dwTtlSeconds             : 0x00000384 (900)
+        dwReserved               : 0x00000000 (0)
+        dwTimeStamp              : 0x00000000 (0)
+        data                     : union dnsRecordData(case 15)
+        mx: struct dnsp_mx
+            wPriority                : 0x000a (10)
+            nameTarget               : 
+push returned Success
+pull returned Success
+    dnsp_DnssrvRpcRecord: struct dnsp_DnssrvRpcRecord
+        wDataLength              : 0x0005 (5)
+        wType                    : DNS_TYPE_MX (15)
+        version                  : 0x05 (5)
+        rank                     : DNS_RANK_ZONE (240)
+        flags                    : 0x0000 (0)
+        dwSerial                 : 0x000000b7 (183)
+        dwTtlSeconds             : 0x00000384 (900)
+        dwReserved               : 0x00000000 (0)
+        dwTimeStamp              : 0x00000000 (0)
+        data                     : union dnsRecordData(case 15)
+        mx: struct dnsp_mx
+            wPriority                : 0x000a (10)
+            nameTarget               : 
+dump OK
diff --git a/source4/librpc/tests/fuzzed_drsuapi_DsAddEntry_1.b64.txt b/source4/librpc/tests/fuzzed_drsuapi_DsAddEntry_1.b64.txt
new file mode 100644
index 00000000000..2004462e072
--- /dev/null
+++ b/source4/librpc/tests/fuzzed_drsuapi_DsAddEntry_1.b64.txt
@@ -0,0 +1 @@
+AAAAAG38HKtrYtJKu7r2SJ3wBjACAAAAAgAAAAAAAAAAAAIAAAAAAAsAAAAEAAIAggAAADwBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBAAAAQwBOAD0ATgBUAEQAUwAgAFMAZQB0AHQAaQBuAGcAcwAsAEMATgA9AHMAbQBiAHQAbwByAHQAdQByAGUAZABjACwAQwBOAD0AUwBlAHIAdgBlAHIAcwAsAEMATgA9AEQAZQBmAGEAdQBsAHQALQBGAGkAcgBzAHQALQBTAGkAdABlAC0ATgBhAG0AZQAsAEMATgA9AFMAaQB0AGUAcwAsAEMATgA9AEMAbwBuAGYAaQBnAHUAcgBhAHQAaQBvAG4ALABE/0MAPQBzAGEAbQBiAGEAMgAwADAAOAByADIALABEAEMAPQBlAHgAYQBtAHAAbABlACwARABDAD3+AAAAAAAAAAALAAAAGQECAAEAAAAIAAIAAAAAAAEAAAAMAAIADgMJAAEAAAAQAAIAcwACAAEAAAAUAAIADgACAAMAAAAYAAIALAcJAAMAAAAcAAIAJAACAAEAAAAgAAIAHAcJAAEAAAAkAAIAswUJAAEAAACDAAIAdwEJAAEAAAAsAAIAAwAJAAEAAAAwAAIAAQAAAKAAAAA0AAIAoAAAAAEABIAUAAAAMAAAAAAAAABMAAAAAQUAAAAAAAUVAAAAS31jTHRMr+ateOGxAAIAAAEFAAAAAAAFFQAAAEt9Y0x0TK/mrXjhsQACAAACAFQAAwAAAAAAFACUAAIAAQEAAAAAAAULAAAAAAAkAP0BDwABBQAAAAAABRUAAABLfWNMdEyv5q144bEAAgAAAAAUAP8BDwABAQAAAAAABRIAAAABAAAABAAAADgAAgADAAAALwAXAAEAAADIAAAAPAACAMgAAADIAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARwAAAEMATgA9AE4AVABEAFMALQBEAFMAQQWaAEMATgA9AFMAYwBoAGUAbQBhACwAQwBOAD0AQwBvAG4AZgBpAGcAdQByAGEAdABpAG8AbgAsAEQAQwA9AHMAYQBtAGIAYQAyADAAMAA4AHIAMgAsAEQAQwA9AGUAeABhAG0AcABsAGUALABEAEMAPQBjAG8AbQAAAAEAAAAQAAAAQAACABAAAAAbcOooBthZR6nsXn3lUhbcAwAAAJwAAABEAAIAegAAAEgAAgCwAAAATAACAJwAAACcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMQAAAEMATgA9AEMAbwBuAGYAaQBnAHUAcgBhAHQAaQBvAG4ALABEAEMAPQBzAGEAbQBiAGEAMgAwADAAOAByADIALABEAEMAPQBlAHgAYQBtAHAAbABlACwARABDAD0AYwBvAG0AAAB6AAAAegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAABEAEMAPQBzAGEAbQBiAGEAMgAwADAAOAByADIALABEAEMAPQBlAHgAYQBtAHAAbABlACwARABDAD0AYwBvAG0AAAAAALAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOwAAAEMATgA9AFMAYwBoAGUAbQBhACwAQwBOAD0AQwBvAG4AZgBpAGcAdQByAGEAdABpAG8AbgAsAEQAQwA9AHMAYQBtAGIAYQAyADAAMAA4AHIAMgAsAEQAQwA9AGUAeABhAG0AcABsAGUALABEAEMAPQBjAG8AbQAAAAMAAACcAAAAUAACAHoAAABUAAIAsAAAAFgAAgCcAAAAnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEAAABDAE4APQBDAG8AbgBmAGkAZwB1AHIAYQB0AGkAbwBuACwARABDAD0AcwBhAG0AYgBhADIAMAAwADgAcgAyACwARABDAD0AZQB4AGEAbQBwAGwAZQAsAEQAQwA9AGMAbwBtAAAAegAAAHoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAARABDAD0AcwBhAG0AYgBhADIAMAAwADgAcgAyACwARABDAD0AZQB4AGEAbQBwAGwAZQAsAEQAQwA9AGMAbwBtAAAAAACwAAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsAAABDAE4APQBTAGMAaABkAG0AYQAsAEMATgA9AEMAbwBuAGYAaQBnAHUAcgBhAHQAaQBvAG4ALABEAEMAPQBzAGEAbQBiAGEAMgAwADAAOAByADIALABEAEMAPQBlAHgAYQBtAHAAbABlACwARABDAD0AYwBvAG0AAAABAAAAsAAAAFwAAgCwAAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAADsAAABDAE4APQBTAGMAaABlAG0ABYSZza4ATv89AEMAbwBuAGYAaQBnAHUAcgBhAHQAaQBvAG4ALABEAEMAPQBzAGEAbQBiAGEAMgAwADAAOAByADIALABEAEMAPQBlAHgAYQBtAHAAbABlACwARABDAD0AYwBvAG0AAAABAAAAegAAAGAAAgB6AAAAegAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAABEAEMAPQBzAGEAbQBiAGEAMgAwADAAOAByADIALABEAEMAPQBlAHgAYQBtAHAAbABlACwARABDAD0AYwBvAG0AAAAAAAEAAAAEAAAAZAACAAQAAAAEAAAAAQAAAAQAAABoAAIABAAAAAAAAAIBAAAAtAAAAGwAAgC0AAAAtAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD0AAABDAE4APQBzAG0AYgB0AG8AcgB0AHUAcgBlAGQAYwAsAEMATgA9AEMAbwBtAHAAdQB0AGUAcgBzACwARABDAD0AcwBhAG0AYgBhADIAMAAwADgAcgAyACwARABDAD0AZQB4AGEAbQBwAGwAZQAsAEQAQwA9AGMAbwBtAOsAAT0BsQFpOxKN7SeSaRtLcWeFbQVEWmptqhYpN0lAzfUGr3aRSJAkOIGKonAOV2g=
diff --git a/source4/librpc/tests/fuzzed_drsuapi_DsAddEntry_1.txt b/source4/librpc/tests/fuzzed_drsuapi_DsAddEntry_1.txt
new file mode 100644
index 00000000000..79b289db491
--- /dev/null
+++ b/source4/librpc/tests/fuzzed_drsuapi_DsAddEntry_1.txt
@@ -0,0 +1,508 @@
+pull returned Success
+WARNING! 47 unread bytes
+[0000] 01 3D 01 B1 01 69 3B 12   8D ED 27 92 69 1B 4B 71   .=...i;. ..'.i.Kq
+[0010] 67 85 6D 05 44 5A 6A 6D   AA 16 29 37 49 40 CD F5   g.m.DZjm ..)7I@..
+[0020] 06 AF 76 91 48 90 24 38   81 8A A2 70 0E 57 68      ..v.H.$8 ...p.Wh
+    drsuapi_DsAddEntry: struct drsuapi_DsAddEntry
+        in: struct drsuapi_DsAddEntry
+            bind_handle              : *
+                bind_handle: struct policy_handle
+                    handle_type              : 0x00000000 (0)
+                    uuid                     : ab1cfc6d-626b-4ad2-bbba-f6489df00630
+            level                    : 0x00000002 (2)
+            req                      : *
+                req                      : union drsuapi_DsAddEntryRequest(case 2)
+                req2: struct drsuapi_DsAddEntryRequest2
+                    first_object: struct drsuapi_DsReplicaObjectListItem
+                        next_object              : NULL
+                        object: struct drsuapi_DsReplicaObject
+                            identifier               : *
+                                identifier: struct drsuapi_DsReplicaObjectIdentifier
+                                    __ndr_size               : 0x0000013c (316)
+                                    __ndr_size_sid           : 0x00000000 (0)
+                                    guid                     : 00000000-0000-0000-0000-000000000000
+                                    sid                      : S-0-0
+                                    __ndr_size_dn            : 0x00000081 (129)
+                                    dn                       : 'CN=NTDS Settings,CN=smbtorturedc,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,C=samba2008r2,DC=example,DC'
+                            flags                    : 0x00000000 (0)
+                                   0: DRSUAPI_DS_REPLICA_OBJECT_FROM_MASTER
+                                   0: DRSUAPI_DS_REPLICA_OBJECT_DYNAMIC
+                                   0: DRSUAPI_DS_REPLICA_OBJECT_REMOTE_MODIFY
+                            attribute_ctr: struct drsuapi_DsReplicaAttributeCtr
+                                num_attributes           : 0x0000000b (11)
+                                attributes               : *
+                                    attributes: ARRAY(11)
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_ntSecurityDescriptor (0x20119)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000a0 (160)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=160
+[0000] 01 00 04 80 14 00 00 00   30 00 00 00 00 00 00 00   ........ 0.......
+[0010] 4C 00 00 00 01 05 00 00   00 00 00 05 15 00 00 00   L....... ........
+[0020] 4B 7D 63 4C 74 4C AF E6   AD 78 E1 B1 00 02 00 00   K}cLtL.. .x......
+[0030] 01 05 00 00 00 00 00 05   15 00 00 00 4B 7D 63 4C   ........ ....K}cL
+[0040] 74 4C AF E6 AD 78 E1 B1   00 02 00 00 02 00 54 00   tL...x.. ......T.
+[0050] 03 00 00 00 00 00 14 00   94 00 02 00 01 01 00 00   ........ ........
+[0060] 00 00 00 05 0B 00 00 00   00 00 24 00 FD 01 0F 00   ........ ..$.....
+[0070] 01 05 00 00 00 00 00 05   15 00 00 00 4B 7D 63 4C   ........ ....K}cL
+[0080] 74 4C AF E6 AD 78 E1 B1   00 02 00 00 00 00 14 00   tL...x.. ........
+[0090] FF 01 0F 00 01 01 00 00   00 00 00 05 12 00 00 00   ........ ........
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_objectClass (0x0)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            attid                    : DATA_BLOB length=3
+[0000] 2F 00 17                                           /.. 
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_objectCategory (0x9030E)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000c8 (200)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=200
+[0000] C8 00 00 00 00 00 00 00   00 00 00 00 00 00 02 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 47 00 00 00   43 00 4E 00 3D 00 4E 00   ....G... C.N.=.N.
+[0040] 54 00 44 00 53 00 2D 00   44 00 53 00 41 05 9A 00   T.D.S.-. D.S.A...
+[0050] 43 00 4E 00 3D 00 53 00   63 00 68 00 65 00 6D 00   C.N.=.S. c.h.e.m.
+[0060] 61 00 2C 00 43 00 4E 00   3D 00 43 00 6F 00 6E 00   a.,.C.N. =.C.o.n.
+[0070] 66 00 69 00 67 00 75 00   72 00 61 00 74 00 69 00   f.i.g.u. r.a.t.i.
+[0080] 6F 00 6E 00 2C 00 44 00   43 00 3D 00 73 00 61 00   o.n.,.D. C.=.s.a.
+[0090] 6D 00 62 00 61 00 32 00   30 00 30 00 38 00 72 00   m.b.a.2. 0.0.8.r.
+[00A0] 32 00 2C 00 44 00 43 00   3D 00 65 00 78 00 61 00   2.,.D.C. =.e.x.a.
+[00B0] 6D 00 70 00 6C 00 65 00   2C 00 44 00 43 00 3D 00   m.p.l.e. ,.D.C.=.
+[00C0] 63 00 6F 00 6D 00 00 00                             c.o.m... 
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_invocationId (0x20073)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x00000010 (16)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=16
+[0000] 1B 70 EA 28 06 D8 59 47   A9 EC 5E 7D E5 52 16 DC   .p.(..YG ..^}.R..
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_hasMasterNCs (0x2000E)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000003 (3)
+                                                values                   : *
+                                                    values: ARRAY(3)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000009c (156)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=156
+[0000] 9C 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 31 00 00 00   43 00 4E 00 3D 00 43 00   ....1... C.N.=.C.
+[0040] 6F 00 6E 00 66 00 69 00   67 00 75 00 72 00 61 00   o.n.f.i. g.u.r.a.
+[0050] 74 00 69 00 6F 00 6E 00   2C 00 44 00 43 00 3D 00   t.i.o.n. ,.D.C.=.
+[0060] 73 00 61 00 6D 00 62 00   61 00 32 00 30 00 30 00   s.a.m.b. a.2.0.0.
+[0070] 38 00 72 00 32 00 2C 00   44 00 43 00 3D 00 65 00   8.r.2.,. D.C.=.e.
+[0080] 78 00 61 00 6D 00 70 00   6C 00 65 00 2C 00 44 00   x.a.m.p. l.e.,.D.
+[0090] 43 00 3D 00 63 00 6F 00   6D 00 00 00               C.=.c.o. m...
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000007a (122)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=122
+[0000] 7A 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   z....... ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 20 00 00 00   44 00 43 00 3D 00 73 00   .... ... D.C.=.s.
+[0040] 61 00 6D 00 62 00 61 00   32 00 30 00 30 00 38 00   a.m.b.a. 2.0.0.8.
+[0050] 72 00 32 00 2C 00 44 00   43 00 3D 00 65 00 78 00   r.2.,.D. C.=.e.x.
+[0060] 61 00 6D 00 70 00 6C 00   65 00 2C 00 44 00 43 00   a.m.p.l. e.,.D.C.
+[0070] 3D 00 63 00 6F 00 6D 00   00 00                     =.c.o.m. ..
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000b0 (176)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=176
+[0000] B0 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+[0010] 00 00 00 00 00 00 00 00   08 00 00 00 00 00 00 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 3B 00 00 00   43 00 4E 00 3D 00 53 00   ....;... C.N.=.S.
+[0040] 63 00 68 00 65 00 6D 00   61 00 2C 00 43 00 4E 00   c.h.e.m. a.,.C.N.
+[0050] 3D 00 43 00 6F 00 6E 00   66 00 69 00 67 00 75 00   =.C.o.n. f.i.g.u.
+[0060] 72 00 61 00 74 00 69 00   6F 00 6E 00 2C 00 44 00   r.a.t.i. o.n.,.D.
+[0070] 43 00 3D 00 73 00 61 00   6D 00 62 00 61 00 32 00   C.=.s.a. m.b.a.2.
+[0080] 30 00 30 00 38 00 72 00   32 00 2C 00 44 00 43 00   0.0.8.r. 2.,.D.C.
+[0090] 3D 00 65 00 78 00 61 00   6D 00 70 00 6C 00 65 00   =.e.x.a. m.p.l.e.
+[00A0] 2C 00 44 00 43 00 3D 00   63 00 6F 00 6D 00 00 00   ,.D.C.=. c.o.m...
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_msDS_hasMasterNCs (0x9072C)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000003 (3)
+                                                values                   : *
+                                                    values: ARRAY(3)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000009c (156)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=156
+[0000] 9C 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 31 00 00 00   43 00 4E 00 3D 00 43 00   ....1... C.N.=.C.
+[0040] 6F 00 6E 00 66 00 69 00   67 00 75 00 72 00 61 00   o.n.f.i. g.u.r.a.
+[0050] 74 00 69 00 6F 00 6E 00   2C 00 44 00 43 00 3D 00   t.i.o.n. ,.D.C.=.
+[0060] 73 00 61 00 6D 00 62 00   61 00 32 00 30 00 30 00   s.a.m.b. a.2.0.0.
+[0070] 38 00 72 00 32 00 2C 00   44 00 43 00 3D 00 65 00   8.r.2.,. D.C.=.e.
+[0080] 78 00 61 00 6D 00 70 00   6C 00 65 00 2C 00 44 00   x.a.m.p. l.e.,.D.
+[0090] 43 00 3D 00 63 00 6F 00   6D 00 00 00               C.=.c.o. m...
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000007a (122)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=122
+[0000] 7A 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   z....... ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 20 00 00 00   44 00 43 00 3D 00 73 00   .... ... D.C.=.s.
+[0040] 61 00 6D 00 62 00 61 00   32 00 30 00 30 00 38 00   a.m.b.a. 2.0.0.8.
+[0050] 72 00 32 00 2C 00 44 00   43 00 3D 00 65 00 78 00   r.2.,.D. C.=.e.x.
+[0060] 61 00 6D 00 70 00 6C 00   65 00 2C 00 44 00 43 00   a.m.p.l. e.,.D.C.
+[0070] 3D 00 63 00 6F 00 6D 00   00 00                     =.c.o.m. ..
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000b0 (176)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=176
+[0000] B0 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 3B 00 00 00   43 00 4E 00 3D 00 53 00   ....;... C.N.=.S.
+[0040] 63 00 68 00 64 00 6D 00   61 00 2C 00 43 00 4E 00   c.h.d.m. a.,.C.N.
+[0050] 3D 00 43 00 6F 00 6E 00   66 00 69 00 67 00 75 00   =.C.o.n. f.i.g.u.
+[0060] 72 00 61 00 74 00 69 00   6F 00 6E 00 2C 00 44 00   r.a.t.i. o.n.,.D.
+[0070] 43 00 3D 00 73 00 61 00   6D 00 62 00 61 00 32 00   C.=.s.a. m.b.a.2.
+[0080] 30 00 30 00 38 00 72 00   32 00 2C 00 44 00 43 00   0.0.8.r. 2.,.D.C.
+[0090] 3D 00 65 00 78 00 61 00   6D 00 70 00 6C 00 65 00   =.e.x.a. m.p.l.e.
+[00A0] 2C 00 44 00 43 00 3D 00   63 00 6F 00 6D 00 00 00   ,.D.C.=. c.o.m...
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_dMDLocation (0x20024)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            string                   : ''
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_msDS_HasDomainNCs (0x9071C)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000007a (122)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=122
+[0000] 7A 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   z....... ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 20 00 00 00   44 00 43 00 3D 00 73 00   .... ... D.C.=.s.
+[0040] 61 00 6D 00 62 00 61 00   32 00 30 00 30 00 38 00   a.m.b.a. 2.0.0.8.
+[0050] 72 00 32 00 2C 00 44 00   43 00 3D 00 65 00 78 00   r.2.,.D. C.=.e.x.
+[0060] 61 00 6D 00 70 00 6C 00   65 00 2C 00 44 00 43 00   a.m.p.l. e.,.D.C.
+[0070] 3D 00 63 00 6F 00 6D 00   00 00                     =.c.o.m. ..
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_msDS_Behavior_Version (0x905B3)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x00000004 (4)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=4
+[0000] 04 00 00 00                                        .... 
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_systemFlags (0x90177)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x00000004 (4)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=4
+[0000] 00 00 00 02                                        .... 
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_replPropertyMetaData (0x90003)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000b4 (180)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=180
+[0000] B4 00 00 00 00 00 00 00   00 00 00 00 00 00 00 02   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 3D 00 00 00   43 00 4E 00 3D 00 73 00   ....=... C.N.=.s.
+[0040] 6D 00 62 00 74 00 6F 00   72 00 74 00 75 00 72 00   m.b.t.o. r.t.u.r.
+[0050] 65 00 64 00 63 00 2C 00   43 00 4E 00 3D 00 43 00   e.d.c.,. C.N.=.C.
+[0060] 6F 00 6D 00 70 00 75 00   74 00 65 00 72 00 73 00   o.m.p.u. t.e.r.s.
+[0070] 2C 00 44 00 43 00 3D 00   73 00 61 00 6D 00 62 00   ,.D.C.=. s.a.m.b.
+[0080] 61 00 32 00 30 00 30 00   38 00 72 00 32 00 2C 00   a.2.0.0. 8.r.2.,.
+[0090] 44 00 43 00 3D 00 65 00   78 00 61 00 6D 00 70 00   D.C.=.e. x.a.m.p.
+[00A0] 6C 00 65 00 2C 00 44 00   43 00 3D 00 63 00 6F 00   l.e.,.D. C.=.c.o.
+[00B0] 6D 00 EB 00                                        m... 
+push returned Success
+pull returned Success
+    drsuapi_DsAddEntry: struct drsuapi_DsAddEntry
+        in: struct drsuapi_DsAddEntry
+            bind_handle              : *
+                bind_handle: struct policy_handle
+                    handle_type              : 0x00000000 (0)
+                    uuid                     : ab1cfc6d-626b-4ad2-bbba-f6489df00630
+            level                    : 0x00000002 (2)
+            req                      : *
+                req                      : union drsuapi_DsAddEntryRequest(case 2)
+                req2: struct drsuapi_DsAddEntryRequest2
+                    first_object: struct drsuapi_DsReplicaObjectListItem
+                        next_object              : NULL
+                        object: struct drsuapi_DsReplicaObject
+                            identifier               : *
+                                identifier: struct drsuapi_DsReplicaObjectIdentifier
+                                    __ndr_size               : 0x00000136 (310)
+                                    __ndr_size_sid           : 0x00000000 (0)
+                                    guid                     : 00000000-0000-0000-0000-000000000000
+                                    sid                      : S-0-0
+                                    __ndr_size_dn            : 0x0000007e (126)
+                                    dn                       : 'CN=NTDS Settings,CN=smbtorturedc,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,C=samba2008r2,DC=example,DC'
+                            flags                    : 0x00000000 (0)
+                                   0: DRSUAPI_DS_REPLICA_OBJECT_FROM_MASTER
+                                   0: DRSUAPI_DS_REPLICA_OBJECT_DYNAMIC
+                                   0: DRSUAPI_DS_REPLICA_OBJECT_REMOTE_MODIFY
+                            attribute_ctr: struct drsuapi_DsReplicaAttributeCtr
+                                num_attributes           : 0x0000000b (11)
+                                attributes               : *
+                                    attributes: ARRAY(11)
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_ntSecurityDescriptor (0x20119)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000a0 (160)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=160
+[0000] 01 00 04 80 14 00 00 00   30 00 00 00 00 00 00 00   ........ 0.......
+[0010] 4C 00 00 00 01 05 00 00   00 00 00 05 15 00 00 00   L....... ........
+[0020] 4B 7D 63 4C 74 4C AF E6   AD 78 E1 B1 00 02 00 00   K}cLtL.. .x......
+[0030] 01 05 00 00 00 00 00 05   15 00 00 00 4B 7D 63 4C   ........ ....K}cL
+[0040] 74 4C AF E6 AD 78 E1 B1   00 02 00 00 02 00 54 00   tL...x.. ......T.
+[0050] 03 00 00 00 00 00 14 00   94 00 02 00 01 01 00 00   ........ ........
+[0060] 00 00 00 05 0B 00 00 00   00 00 24 00 FD 01 0F 00   ........ ..$.....
+[0070] 01 05 00 00 00 00 00 05   15 00 00 00 4B 7D 63 4C   ........ ....K}cL
+[0080] 74 4C AF E6 AD 78 E1 B1   00 02 00 00 00 00 14 00   tL...x.. ........
+[0090] FF 01 0F 00 01 01 00 00   00 00 00 05 12 00 00 00   ........ ........
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_objectClass (0x0)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            attid                    : DATA_BLOB length=3
+[0000] 2F 00 17                                           /.. 
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_objectCategory (0x9030E)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000c8 (200)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=200
+[0000] C8 00 00 00 00 00 00 00   00 00 00 00 00 00 02 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 47 00 00 00   43 00 4E 00 3D 00 4E 00   ....G... C.N.=.N.
+[0040] 54 00 44 00 53 00 2D 00   44 00 53 00 41 05 9A 00   T.D.S.-. D.S.A...
+[0050] 43 00 4E 00 3D 00 53 00   63 00 68 00 65 00 6D 00   C.N.=.S. c.h.e.m.
+[0060] 61 00 2C 00 43 00 4E 00   3D 00 43 00 6F 00 6E 00   a.,.C.N. =.C.o.n.
+[0070] 66 00 69 00 67 00 75 00   72 00 61 00 74 00 69 00   f.i.g.u. r.a.t.i.
+[0080] 6F 00 6E 00 2C 00 44 00   43 00 3D 00 73 00 61 00   o.n.,.D. C.=.s.a.
+[0090] 6D 00 62 00 61 00 32 00   30 00 30 00 38 00 72 00   m.b.a.2. 0.0.8.r.
+[00A0] 32 00 2C 00 44 00 43 00   3D 00 65 00 78 00 61 00   2.,.D.C. =.e.x.a.
+[00B0] 6D 00 70 00 6C 00 65 00   2C 00 44 00 43 00 3D 00   m.p.l.e. ,.D.C.=.
+[00C0] 63 00 6F 00 6D 00 00 00                             c.o.m... 
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_invocationId (0x20073)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x00000010 (16)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=16
+[0000] 1B 70 EA 28 06 D8 59 47   A9 EC 5E 7D E5 52 16 DC   .p.(..YG ..^}.R..
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_hasMasterNCs (0x2000E)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000003 (3)
+                                                values                   : *
+                                                    values: ARRAY(3)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000009c (156)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=156
+[0000] 9C 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 31 00 00 00   43 00 4E 00 3D 00 43 00   ....1... C.N.=.C.
+[0040] 6F 00 6E 00 66 00 69 00   67 00 75 00 72 00 61 00   o.n.f.i. g.u.r.a.
+[0050] 74 00 69 00 6F 00 6E 00   2C 00 44 00 43 00 3D 00   t.i.o.n. ,.D.C.=.
+[0060] 73 00 61 00 6D 00 62 00   61 00 32 00 30 00 30 00   s.a.m.b. a.2.0.0.
+[0070] 38 00 72 00 32 00 2C 00   44 00 43 00 3D 00 65 00   8.r.2.,. D.C.=.e.
+[0080] 78 00 61 00 6D 00 70 00   6C 00 65 00 2C 00 44 00   x.a.m.p. l.e.,.D.
+[0090] 43 00 3D 00 63 00 6F 00   6D 00 00 00               C.=.c.o. m...
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000007a (122)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=122
+[0000] 7A 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   z....... ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 20 00 00 00   44 00 43 00 3D 00 73 00   .... ... D.C.=.s.
+[0040] 61 00 6D 00 62 00 61 00   32 00 30 00 30 00 38 00   a.m.b.a. 2.0.0.8.
+[0050] 72 00 32 00 2C 00 44 00   43 00 3D 00 65 00 78 00   r.2.,.D. C.=.e.x.
+[0060] 61 00 6D 00 70 00 6C 00   65 00 2C 00 44 00 43 00   a.m.p.l. e.,.D.C.
+[0070] 3D 00 63 00 6F 00 6D 00   00 00                     =.c.o.m. ..
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000b0 (176)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=176
+[0000] B0 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+[0010] 00 00 00 00 00 00 00 00   08 00 00 00 00 00 00 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 3B 00 00 00   43 00 4E 00 3D 00 53 00   ....;... C.N.=.S.
+[0040] 63 00 68 00 65 00 6D 00   61 00 2C 00 43 00 4E 00   c.h.e.m. a.,.C.N.
+[0050] 3D 00 43 00 6F 00 6E 00   66 00 69 00 67 00 75 00   =.C.o.n. f.i.g.u.
+[0060] 72 00 61 00 74 00 69 00   6F 00 6E 00 2C 00 44 00   r.a.t.i. o.n.,.D.
+[0070] 43 00 3D 00 73 00 61 00   6D 00 62 00 61 00 32 00   C.=.s.a. m.b.a.2.
+[0080] 30 00 30 00 38 00 72 00   32 00 2C 00 44 00 43 00   0.0.8.r. 2.,.D.C.
+[0090] 3D 00 65 00 78 00 61 00   6D 00 70 00 6C 00 65 00   =.e.x.a. m.p.l.e.
+[00A0] 2C 00 44 00 43 00 3D 00   63 00 6F 00 6D 00 00 00   ,.D.C.=. c.o.m...
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_msDS_hasMasterNCs (0x9072C)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000003 (3)
+                                                values                   : *
+                                                    values: ARRAY(3)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000009c (156)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=156
+[0000] 9C 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 31 00 00 00   43 00 4E 00 3D 00 43 00   ....1... C.N.=.C.
+[0040] 6F 00 6E 00 66 00 69 00   67 00 75 00 72 00 61 00   o.n.f.i. g.u.r.a.
+[0050] 74 00 69 00 6F 00 6E 00   2C 00 44 00 43 00 3D 00   t.i.o.n. ,.D.C.=.
+[0060] 73 00 61 00 6D 00 62 00   61 00 32 00 30 00 30 00   s.a.m.b. a.2.0.0.
+[0070] 38 00 72 00 32 00 2C 00   44 00 43 00 3D 00 65 00   8.r.2.,. D.C.=.e.
+[0080] 78 00 61 00 6D 00 70 00   6C 00 65 00 2C 00 44 00   x.a.m.p. l.e.,.D.
+[0090] 43 00 3D 00 63 00 6F 00   6D 00 00 00               C.=.c.o. m...
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000007a (122)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=122
+[0000] 7A 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   z....... ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 20 00 00 00   44 00 43 00 3D 00 73 00   .... ... D.C.=.s.
+[0040] 61 00 6D 00 62 00 61 00   32 00 30 00 30 00 38 00   a.m.b.a. 2.0.0.8.
+[0050] 72 00 32 00 2C 00 44 00   43 00 3D 00 65 00 78 00   r.2.,.D. C.=.e.x.
+[0060] 61 00 6D 00 70 00 6C 00   65 00 2C 00 44 00 43 00   a.m.p.l. e.,.D.C.
+[0070] 3D 00 63 00 6F 00 6D 00   00 00                     =.c.o.m. ..
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000b0 (176)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=176
+[0000] B0 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 3B 00 00 00   43 00 4E 00 3D 00 53 00   ....;... C.N.=.S.
+[0040] 63 00 68 00 64 00 6D 00   61 00 2C 00 43 00 4E 00   c.h.d.m. a.,.C.N.
+[0050] 3D 00 43 00 6F 00 6E 00   66 00 69 00 67 00 75 00   =.C.o.n. f.i.g.u.
+[0060] 72 00 61 00 74 00 69 00   6F 00 6E 00 2C 00 44 00   r.a.t.i. o.n.,.D.
+[0070] 43 00 3D 00 73 00 61 00   6D 00 62 00 61 00 32 00   C.=.s.a. m.b.a.2.
+[0080] 30 00 30 00 38 00 72 00   32 00 2C 00 44 00 43 00   0.0.8.r. 2.,.D.C.
+[0090] 3D 00 65 00 78 00 61 00   6D 00 70 00 6C 00 65 00   =.e.x.a. m.p.l.e.
+[00A0] 2C 00 44 00 43 00 3D 00   63 00 6F 00 6D 00 00 00   ,.D.C.=. c.o.m...
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_dMDLocation (0x20024)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            string                   : ''
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_msDS_HasDomainNCs (0x9071C)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x0000007a (122)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=122
+[0000] 7A 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   z....... ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 20 00 00 00   44 00 43 00 3D 00 73 00   .... ... D.C.=.s.
+[0040] 61 00 6D 00 62 00 61 00   32 00 30 00 30 00 38 00   a.m.b.a. 2.0.0.8.
+[0050] 72 00 32 00 2C 00 44 00   43 00 3D 00 65 00 78 00   r.2.,.D. C.=.e.x.
+[0060] 61 00 6D 00 70 00 6C 00   65 00 2C 00 44 00 43 00   a.m.p.l. e.,.D.C.
+[0070] 3D 00 63 00 6F 00 6D 00   00 00                     =.c.o.m. ..
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_msDS_Behavior_Version (0x905B3)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x00000004 (4)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=4
+[0000] 04 00 00 00                                        .... 
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_systemFlags (0x90177)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x00000004 (4)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=4
+[0000] 00 00 00 02                                        .... 
+                                        attributes: struct drsuapi_DsReplicaAttribute
+                                            attid                    : DRSUAPI_ATTID_replPropertyMetaData (0x90003)
+                                            value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                num_values               : 0x00000001 (1)
+                                                values                   : *
+                                                    values: ARRAY(1)
+                                                        values: struct drsuapi_DsAttributeValue
+                                                            __ndr_size               : 0x000000b4 (180)
+                                                            blob                     : *
+                                                                blob                     : DATA_BLOB length=180
+[0000] B4 00 00 00 00 00 00 00   00 00 00 00 00 00 00 02   ........ ........
+skipping zero buffer bytes
+[0030] 00 00 00 00 3D 00 00 00   43 00 4E 00 3D 00 73 00   ....=... C.N.=.s.
+[0040] 6D 00 62 00 74 00 6F 00   72 00 74 00 75 00 72 00   m.b.t.o. r.t.u.r.
+[0050] 65 00 64 00 63 00 2C 00   43 00 4E 00 3D 00 43 00   e.d.c.,. C.N.=.C.
+[0060] 6F 00 6D 00 70 00 75 00   74 00 65 00 72 00 73 00   o.m.p.u. t.e.r.s.
+[0070] 2C 00 44 00 43 00 3D 00   73 00 61 00 6D 00 62 00   ,.D.C.=. s.a.m.b.
+[0080] 61 00 32 00 30 00 30 00   38 00 72 00 32 00 2C 00   a.2.0.0. 8.r.2.,.
+[0090] 44 00 43 00 3D 00 65 00   78 00 61 00 6D 00 70 00   D.C.=.e. x.a.m.p.
+[00A0] 6C 00 65 00 2C 00 44 00   43 00 3D 00 63 00 6F 00   l.e.,.D. C.=.c.o.
+[00B0] 6D 00 EB 00                                        m... 
+WARNING! orig bytes:2555 validated pushed bytes:2504
+WARNING! orig pulled bytes:2508 validated pulled bytes:2504
+WARNING! orig and validated differ at byte 0x30 (48)
+WARNING! orig byte[0x30] = 0x82 validated byte[0x30] = 0x7F
+dump OK
diff --git a/source4/librpc/tests/fuzzed_drsuapi_DsGetNCChanges.txt b/source4/librpc/tests/fuzzed_drsuapi_DsGetNCChanges.txt
new file mode 100644
index 00000000000..d688e7b40e9
--- /dev/null
+++ b/source4/librpc/tests/fuzzed_drsuapi_DsGetNCChanges.txt
@@ -0,0 +1,76 @@
+pull returned Success
+WARNING! 4 unread bytes
+[0000] 00 00 00 00                                        .... 
+    drsuapi_DsGetNCChanges: struct drsuapi_DsGetNCChanges
+        out: struct drsuapi_DsGetNCChanges
+            level_out                : *
+                level_out                : 0x00000001 (1)
+            ctr                      : *
+                ctr                      : union drsuapi_DsGetNCChangesCtr(case 1)
+                ctr1: struct drsuapi_DsGetNCChangesCtr1
+                    source_dsa_guid          : 00aa0006-0000-0006-aa06-000300010000
+                    source_dsa_invocation_id : 13000600-0000-0000-0000-0000ff000000
+                    naming_context           : NULL
+                    old_highwatermark: struct drsuapi_DsReplicaHighWaterMark
+                        tmp_highest_usn          : 0x0000000000000000 (0)
+                        reserved_usn             : 0x005b000000000000 (25614222880669696)
+                        highest_usn              : 0x0000000000000000 (0)
+                    new_highwatermark: struct drsuapi_DsReplicaHighWaterMark
+                        tmp_highest_usn          : 0x0000010000110900 (1099512744192)
+                        reserved_usn             : 0x0000000000000100 (256)
+                        highest_usn              : 0x0000000000000000 (0)
+                    uptodateness_vector      : NULL
+                    mapping_ctr: struct drsuapi_DsReplicaOIDMapping_Ctr
+                        num_mappings             : 0x00000000 (0)
+                        mappings                 : NULL
+                    extended_ret             : UNKNOWN_ENUM_VALUE (0xF900)
+                    object_count             : 0x00000000 (0)
+                    __ndr_size               : 0xf8000001 (4160749569)
+                    first_object             : *
+                        first_object: struct drsuapi_DsReplicaObjectListItemEx
+                            next_object              : *
+                            object: struct drsuapi_DsReplicaObject
+                                identifier               : NULL
+                                flags                    : 0x3f000000 (1056964608)
+                                       0: DRSUAPI_DS_REPLICA_OBJECT_FROM_MASTER
+                                       0: DRSUAPI_DS_REPLICA_OBJECT_DYNAMIC
+                                       0: DRSUAPI_DS_REPLICA_OBJECT_REMOTE_MODIFY
+                                attribute_ctr: struct drsuapi_DsReplicaAttributeCtr
+                                    num_attributes           : 0x00000000 (0)
+                                    attributes               : NULL
+                            is_nc_prefix             : 0x00000000 (0)
+                            parent_object_guid       : NULL
+                            meta_data_ctr            : *
+                                meta_data_ctr: struct drsuapi_DsReplicaMetaDataCtr
+                                    count                    : 0x00000000 (0)
+                                    meta_data: ARRAY(0)
+                        next_object: struct drsuapi_DsReplicaObjectListItemEx
+                            next_object              : NULL
+                            object: struct drsuapi_DsReplicaObject
+                                identifier               : NULL
+                                flags                    : 0x00100006 (1048582)
+                                       0: DRSUAPI_DS_REPLICA_OBJECT_FROM_MASTER
+                                       1: DRSUAPI_DS_REPLICA_OBJECT_DYNAMIC
+                                       0: DRSUAPI_DS_REPLICA_OBJECT_REMOTE_MODIFY
+                                attribute_ctr: struct drsuapi_DsReplicaAttributeCtr
+                                    num_attributes           : 0x00000001 (1)
+                                    attributes               : *
+                                        attributes: ARRAY(1)
+                                            attributes: struct drsuapi_DsReplicaAttribute
+                                                attid                    : DRSUAPI_ATTID_cn (0x3)
+                                                value_ctr: struct drsuapi_DsAttributeValueCtr
+                                                    num_values               : 0x00000001 (1)
+                                                    values                   : *
+                                                        values: ARRAY(1)
+                                                            values: struct drsuapi_DsAttributeValue
+                                                                string                   : 'NULL'
+                            is_nc_prefix             : 0x00000001 (1)
+                            parent_object_guid       : *
+                                parent_object_guid       : 00100006-0001-0008-0100-000000000000
+                            meta_data_ctr            : *
+                                meta_data_ctr: struct drsuapi_DsReplicaMetaDataCtr
+                                    count                    : 0x00000000 (0)
+                                    meta_data: ARRAY(0)
+                    more_data                : 0x00000000 (0)
+            result                   : DOS code 0x00000100
+dump OK
diff --git a/source4/librpc/tests/fuzzed_drsuapi_DsReplicaAttribute.b64.txt b/source4/librpc/tests/fuzzed_drsuapi_DsReplicaAttribute.b64.txt
new file mode 100644
index 00000000000..783d06305ec
--- /dev/null
+++ b/source4/librpc/tests/fuzzed_drsuapi_DsReplicaAttribute.b64.txt
@@ -0,0 +1 @@
+AAAAAAEAAAABAACAAQAAAAEAAAAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
diff --git a/source4/librpc/tests/fuzzed_drsuapi_DsReplicaAttribute.txt b/source4/librpc/tests/fuzzed_drsuapi_DsReplicaAttribute.txt
new file mode 100644
index 00000000000..9e9a8859627
--- /dev/null
+++ b/source4/librpc/tests/fuzzed_drsuapi_DsReplicaAttribute.txt
@@ -0,0 +1,31 @@
+pull returned Success
+WARNING! 179 unread bytes
+[0000] 00 00 00 00 00 FF 00 00   00 00 00 00 00 00 00 00   ........ ........
+skipping zero buffer bytes
+[0040] 00 00 00 00 00 00 00 00   00 40 00 00 00 00 00 00   ........ .@......
+[0060] 00 00 00 40 00 00 00 00   00 00 00 00 00 00 00 00   ...@.... ........
+[0080] 00 00 00 40 00 00 00 00   00 00 00 00 00 00 00 00   ...@.... ........
+[0090] 00 00 00 00 00 00 00 00   00 00 00 00 00 40 00 00   ........ .....@..
+[00B0] 00 00 00                                           ... 
+    drsuapi_DsReplicaAttribute: struct drsuapi_DsReplicaAttribute
+        attid                    : DRSUAPI_ATTID_objectClass (0x0)
+        value_ctr: struct drsuapi_DsAttributeValueCtr
+            num_values               : 0x00000001 (1)
+            values                   : *
+                values: ARRAY(1)
+                    values: struct drsuapi_DsAttributeValue
+                        attid                    : 'NULL'
+push returned Success
+pull returned Success
+    drsuapi_DsReplicaAttribute: struct drsuapi_DsReplicaAttribute
+        attid                    : DRSUAPI_ATTID_objectClass (0x0)
+        value_ctr: struct drsuapi_DsAttributeValueCtr
+            num_values               : 0x00000001 (1)
+            values                   : *
+                values: ARRAY(1)
+                    values: struct drsuapi_DsAttributeValue
+                        attid                    : 'NULL'
+WARNING! orig bytes:203 validated pushed bytes:24
+WARNING! orig and validated differ at byte 0x08 (8)
+WARNING! orig byte[0x08] = 0x01 validated byte[0x08] = 0x00
+dump OK
diff --git a/source4/librpc/tests/fuzzed_ntlmssp-AUTHENTICATE_MESSAGE.b64.txt b/source4/librpc/tests/fuzzed_ntlmssp-AUTHENTICATE_MESSAGE.b64.txt
new file mode 100644
index 00000000000..0a10ab03911
--- /dev/null
+++ b/source4/librpc/tests/fuzzed_ntlmssp-AUTHENTICATE_MESSAGE.b64.txt
@@ -0,0 +1 @@
+AA4AAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAzOQAAAAAAAAABAAAAAAAAAAD//gAAAAAAAAAABDMyMTUyMTE1MDI2MzE0Njg3/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+5+T2dekB8vfW3brf3WrDRDczOQAAAAA=
diff --git a/source4/librpc/tests/fuzzed_ntlmssp-AUTHENTICATE_MESSAGE.txt b/source4/librpc/tests/fuzzed_ntlmssp-AUTHENTICATE_MESSAGE.txt
new file mode 100644
index 00000000000..8dbe6e6dac2
--- /dev/null
+++ b/source4/librpc/tests/fuzzed_ntlmssp-AUTHENTICATE_MESSAGE.txt
@@ -0,0 +1,134 @@
+pull returned Success
+WARNING! 188 unread bytes
+[0000] 04 33 32 31 35 32 31 31   35 30 32 36 33 31 34 36   .3215211 50263146
+[0010] 38 37 FE FE FE FE FE FE   FE FE FE FE FE FE FE FE   87...... ........
+[0020] FE FE FE FE FE FE FE FE   FE FE FE FE FE FE FE FE   ........ ........
+[0030] FE FE FE FE FE FE FE FE   FE FE FE FE FE FE FE FE   ........ ........
+[0040] FE FE FE FE FE FE FE FE   FE FE FE FE FE FE FE FE   ........ ........
+[0050] FE FE FE FE FE FE FE FE   FE FE FE FE FE FE FE FE   ........ ........
+[0060] FE FE FE FE FE FE FE FE   FE FE FE FE FE FE FE FE   ........ ........
+[0070] FE FE FE FE FE FE FE FE   FE FE FE FE FE FE FE FE   ........ ........
+[0080] FE FE FE FE FE FE FE FE   FE FE FE FE FE FE FE FE   ........ ........
+[0090] FE FE FE FE FE FE FE FE   FE FE FE FE FE FE FE FE   ........ ........
+[00A0] FE FE FE FE FE E7 E4 F6   75 E9 01 F2 F7 D6 DD BA   ........ u.......
+[00B0] DF DD 6A C3 44 37 33 39   00 00 00 00               ..j.D739 ....
+    AUTHENTICATE_MESSAGE: struct AUTHENTICATE_MESSAGE
+        Signature                : ''
+        MessageType              : UNKNOWN_ENUM_VALUE (0)
+        LmChallengeResponseLen   : 0x0000 (0)
+        LmChallengeResponseMaxLen: 0x0000 (0)
+        LmChallengeResponse      : NULL
+        NtChallengeResponseLen   : 0x0000 (0)
+        NtChallengeResponseMaxLen: 0x0000 (0)
+        NtChallengeResponse      : NULL
+        DomainNameLen            : 0x0000 (0)
+        DomainNameMaxLen         : 0x0000 (0)
+        DomainName               : NULL
+        UserNameLen              : 0x0000 (0)
+        UserNameMaxLen           : 0x0001 (1)
+        UserName                 : NULL
+        WorkstationLen           : 0x3933 (14643)
+        WorkstationMaxLen        : 0x0000 (0)
+        Workstation              : NULL
+        EncryptedRandomSessionKeyLen: 0x0100 (256)
+        EncryptedRandomSessionKeyMaxLen: 0x0000 (0)
+        EncryptedRandomSessionKey: NULL
+        NegotiateFlags           : 0xfeff0000 (4278124544)
+               0: NTLMSSP_NEGOTIATE_UNICODE
+               0: NTLMSSP_NEGOTIATE_OEM    
+               0: NTLMSSP_REQUEST_TARGET   
+               0: NTLMSSP_NEGOTIATE_SIGN   
+               0: NTLMSSP_NEGOTIATE_SEAL   
+               0: NTLMSSP_NEGOTIATE_DATAGRAM
+               0: NTLMSSP_NEGOTIATE_LM_KEY 
+               0: NTLMSSP_NEGOTIATE_NETWARE
+               0: NTLMSSP_NEGOTIATE_NTLM   
+               0: NTLMSSP_NEGOTIATE_NT_ONLY
+               0: NTLMSSP_ANONYMOUS        
+               0: NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED
+               0: NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED
+               0: NTLMSSP_NEGOTIATE_THIS_IS_LOCAL_CALL
+               0: NTLMSSP_NEGOTIATE_ALWAYS_SIGN
+               1: NTLMSSP_TARGET_TYPE_DOMAIN
+               1: NTLMSSP_TARGET_TYPE_SERVER
+               1: NTLMSSP_TARGET_TYPE_SHARE
+               1: NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY
+               1: NTLMSSP_NEGOTIATE_IDENTIFY
+               1: NTLMSSP_REQUEST_NON_NT_SESSION_KEY
+               1: NTLMSSP_NEGOTIATE_TARGET_INFO
+               1: NTLMSSP_NEGOTIATE_VERSION
+               1: NTLMSSP_NEGOTIATE_128    
+               1: NTLMSSP_NEGOTIATE_KEY_EXCH
+               1: NTLMSSP_NEGOTIATE_56     
+        Version: struct ntlmssp_VERSION
+            ProductMajorVersion      : UNKNOWN_ENUM_VALUE (0)
+            ProductMinorVersion      : NTLMSSP_WINDOWS_MINOR_VERSION_0 (0)
+            ProductBuild             : 0x0000 (0)
+            Reserved: ARRAY(3)
+                [0]                      : 0x00 (0)
+                [1]                      : 0x00 (0)
+                [2]                      : 0x00 (0)
+            NTLMRevisionCurrent      : UNKNOWN_ENUM_VALUE (0)
+push returned Success
+pull returned Success
+    AUTHENTICATE_MESSAGE: struct AUTHENTICATE_MESSAGE
+        Signature                : 'NTLMSSP'
+        MessageType              : NtLmAuthenticate (3)
+        LmChallengeResponseLen   : 0x0000 (0)
+        LmChallengeResponseMaxLen: 0x0000 (0)
+        LmChallengeResponse      : NULL
+        NtChallengeResponseLen   : 0x0000 (0)
+        NtChallengeResponseMaxLen: 0x0000 (0)
+        NtChallengeResponse      : NULL
+        DomainNameLen            : 0x0000 (0)
+        DomainNameMaxLen         : 0x0000 (0)
+        DomainName               : NULL
+        UserNameLen              : 0x0000 (0)
+        UserNameMaxLen           : 0x0000 (0)
+        UserName                 : NULL
+        WorkstationLen           : 0x0000 (0)
+        WorkstationMaxLen        : 0x0000 (0)
+        Workstation              : NULL
+        EncryptedRandomSessionKeyLen: 0x0000 (0)
+        EncryptedRandomSessionKeyMaxLen: 0x0000 (0)
+        EncryptedRandomSessionKey: NULL
+        NegotiateFlags           : 0xfeff0000 (4278124544)
+               0: NTLMSSP_NEGOTIATE_UNICODE
+               0: NTLMSSP_NEGOTIATE_OEM    
+               0: NTLMSSP_REQUEST_TARGET   
+               0: NTLMSSP_NEGOTIATE_SIGN   
+               0: NTLMSSP_NEGOTIATE_SEAL   
+               0: NTLMSSP_NEGOTIATE_DATAGRAM
+               0: NTLMSSP_NEGOTIATE_LM_KEY 
+               0: NTLMSSP_NEGOTIATE_NETWARE
+               0: NTLMSSP_NEGOTIATE_NTLM   
+               0: NTLMSSP_NEGOTIATE_NT_ONLY
+               0: NTLMSSP_ANONYMOUS        
+               0: NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED
+               0: NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED
+               0: NTLMSSP_NEGOTIATE_THIS_IS_LOCAL_CALL
+               0: NTLMSSP_NEGOTIATE_ALWAYS_SIGN
+               1: NTLMSSP_TARGET_TYPE_DOMAIN
+               1: NTLMSSP_TARGET_TYPE_SERVER
+               1: NTLMSSP_TARGET_TYPE_SHARE
+               1: NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY
+               1: NTLMSSP_NEGOTIATE_IDENTIFY
+               1: NTLMSSP_REQUEST_NON_NT_SESSION_KEY
+               1: NTLMSSP_NEGOTIATE_TARGET_INFO
+               1: NTLMSSP_NEGOTIATE_VERSION
+               1: NTLMSSP_NEGOTIATE_128    
+               1: NTLMSSP_NEGOTIATE_KEY_EXCH
+               1: NTLMSSP_NEGOTIATE_56     
+        Version: struct ntlmssp_VERSION
+            ProductMajorVersion      : UNKNOWN_ENUM_VALUE (0)
+            ProductMinorVersion      : NTLMSSP_WINDOWS_MINOR_VERSION_0 (0)
+            ProductBuild             : 0x0000 (0)
+            Reserved: ARRAY(3)
+                [0]                      : 0x00 (0)
+                [1]                      : 0x00 (0)
+                [2]                      : 0x00 (0)
+            NTLMRevisionCurrent      : UNKNOWN_ENUM_VALUE (0)
+WARNING! orig bytes:260 validated pushed bytes:72
+WARNING! orig and validated differ at byte 0x00 (0)
+WARNING! orig byte[0x00] = 0x00 validated byte[0x00] = 0x4E
+dump OK
diff --git a/source4/librpc/tests/fuzzed_ntlmssp-CHALLENGE_MESSAGE.txt b/source4/librpc/tests/fuzzed_ntlmssp-CHALLENGE_MESSAGE.txt
new file mode 100644
index 00000000000..f489979d173
--- /dev/null
+++ b/source4/librpc/tests/fuzzed_ntlmssp-CHALLENGE_MESSAGE.txt
@@ -0,0 +1,43 @@
+pull returned Success
+    CHALLENGE_MESSAGE: struct CHALLENGE_MESSAGE
+        Signature                : ''
+        MessageType              : UNKNOWN_ENUM_VALUE (0x22700)
+        TargetNameLen            : 0x0000 (0)
+        TargetNameMaxLen         : 0x0000 (0)
+        TargetName               : *
+            TargetName               : ''
+        NegotiateFlags           : 0x00000000 (0)
+               0: NTLMSSP_NEGOTIATE_UNICODE
+               0: NTLMSSP_NEGOTIATE_OEM    
+               0: NTLMSSP_REQUEST_TARGET   
+               0: NTLMSSP_NEGOTIATE_SIGN   
+               0: NTLMSSP_NEGOTIATE_SEAL   
+               0: NTLMSSP_NEGOTIATE_DATAGRAM
+               0: NTLMSSP_NEGOTIATE_LM_KEY 
+               0: NTLMSSP_NEGOTIATE_NETWARE
+               0: NTLMSSP_NEGOTIATE_NTLM   
+               0: NTLMSSP_NEGOTIATE_NT_ONLY
+               0: NTLMSSP_ANONYMOUS        
+               0: NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED
+               0: NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED
+               0: NTLMSSP_NEGOTIATE_THIS_IS_LOCAL_CALL
+               0: NTLMSSP_NEGOTIATE_ALWAYS_SIGN
+               0: NTLMSSP_TARGET_TYPE_DOMAIN
+               0: NTLMSSP_TARGET_TYPE_SERVER
+               0: NTLMSSP_TARGET_TYPE_SHARE
+               0: NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY
+               0: NTLMSSP_NEGOTIATE_IDENTIFY
+               0: NTLMSSP_REQUEST_NON_NT_SESSION_KEY
+               0: NTLMSSP_NEGOTIATE_TARGET_INFO
+               0: NTLMSSP_NEGOTIATE_VERSION
+               0: NTLMSSP_NEGOTIATE_128    
+               0: NTLMSSP_NEGOTIATE_KEY_EXCH
+               0: NTLMSSP_NEGOTIATE_56     
+        ServerChallenge          : 00801b846f2eca4f
+        Reserved                 : 5d00bd26404ef730
+        TargetInfoLen            : 0x0000 (0)
+        TargetInfoMaxLen         : 0x0000 (0)
+        TargetInfo               : NULL
+ndr_push_subcontext_end: ndr_push_error(Subcontext Error): Bad subcontext (PUSH) content_size 1 is larger than size_is(0) at ../../librpc/ndr/ndr.c:905
+push returned Subcontext Error
+validate push FAILED
diff --git a/source4/librpc/tests/xattr_NTACL.dat b/source4/librpc/tests/xattr_NTACL.dat
new file mode 100644
index 00000000000..8ec2eda5aa9
--- /dev/null
+++ b/source4/librpc/tests/xattr_NTACL.dat
@@ -0,0 +1,20 @@
+[0000] 04 00 04 00 00 00 02 00   04 00 02 00 01 00 04 07   ........ ........
+[0010] 8B 57 A0 0C F3 F7 9D 64   DF 3E 91 46 09 B8 07 A5   .W.....d .>.F....
+[0020] F1 6C BE 38 DC 55 5B 1F   38 0C 23 A8 4A 85 00 00   .l.8.U[. 8.#.J...
+[0030] 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+[0040] 00 00 00 00 00 00 00 00   00 00 00 00 00 00 70 6F   ........ ......po
+[0050] 73 69 78 5F 61 63 6C 00   62 A2 D8 8C 4B AA D5 01   six_acl. b...K...
+[0060] 5D 60 E7 56 A5 D4 54 92   1A 77 A5 E1 DC E2 A9 28   ]`.V..T. .w.....(
+[0070] A9 5D 3B 97 71 6C F7 59   F4 92 FF E3 42 A5 E9 B5   .];.ql.Y ....B...
+[0080] 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+[0090] 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00   ........ ........
+[00A0] 01 00 14 90 B4 00 00 00   D0 00 00 00 00 00 00 00   ........ ........
+[00B0] E0 00 00 00 01 05 00 00   00 00 00 05 15 00 00 00   ........ ........
+[00C0] 70 CB 8E 6B F1 F8 4E 7C   31 87 57 84 F4 01 00 00   p..k..N| 1.W.....
+[00D0] 01 02 00 00 00 00 00 05   20 00 00 00 20 02 00 00   ........  ... ...
+[00E0] 04 00 60 00 04 00 00 00   00 03 18 00 FF 01 1F 00   ..`..... ........
+[00F0] 01 02 00 00 00 00 00 05   20 00 00 00 20 02 00 00   ........  ... ...
+[0100] 00 03 18 00 A9 00 12 00   01 02 00 00 00 00 00 05   ........ ........
+[0110] 20 00 00 00 25 02 00 00   00 03 14 00 FF 01 1F 00    ...%... ........
+[0120] 01 01 00 00 00 00 00 05   12 00 00 00 00 03 14 00   ........ ........
+[0130] A9 00 12 00 01 01 00 00   00 00 00 05 0B 00 00 00   ........ ........
diff --git a/source4/librpc/tests/xattr_NTACL.txt b/source4/librpc/tests/xattr_NTACL.txt
new file mode 100644
index 00000000000..9b60a7f587b
--- /dev/null
+++ b/source4/librpc/tests/xattr_NTACL.txt
@@ -0,0 +1,99 @@
+pull returned Success
+    xattr_NTACL: struct xattr_NTACL
+        version                  : 0x0004 (4)
+        info                     : union xattr_NTACL_Info(case 4)
+        sd_hs4                   : *
+            sd_hs4: struct security_descriptor_hash_v4
+                sd                       : *
+                    sd: struct security_descriptor
+                        revision                 : SECURITY_DESCRIPTOR_REVISION_1 (1)
+                        type                     : 0x9014 (36884)
+                               0: SEC_DESC_OWNER_DEFAULTED 
+                               0: SEC_DESC_GROUP_DEFAULTED 
+                               1: SEC_DESC_DACL_PRESENT    
+                               0: SEC_DESC_DACL_DEFAULTED  
+                               1: SEC_DESC_SACL_PRESENT    
+                               0: SEC_DESC_SACL_DEFAULTED  
+                               0: SEC_DESC_DACL_TRUSTED    
+                               0: SEC_DESC_SERVER_SECURITY 
+                               0: SEC_DESC_DACL_AUTO_INHERIT_REQ
+                               0: SEC_DESC_SACL_AUTO_INHERIT_REQ
+                               0: SEC_DESC_DACL_AUTO_INHERITED
+                               0: SEC_DESC_SACL_AUTO_INHERITED
+                               1: SEC_DESC_DACL_PROTECTED  
+                               0: SEC_DESC_SACL_PROTECTED  
+                               0: SEC_DESC_RM_CONTROL_VALID
+                               1: SEC_DESC_SELF_RELATIVE   
+                        owner_sid                : *
+                            owner_sid                : S-1-5-21-1804520304-2085550321-2220328753-500
+                        group_sid                : *
+                            group_sid                : S-1-5-32-544
+                        sacl                     : NULL
+                        dacl                     : *
+                            dacl: struct security_acl
+                                revision                 : SECURITY_ACL_REVISION_ADS (4)
+                                size                     : 0x0060 (96)
+                                num_aces                 : 0x00000004 (4)
+                                aces: ARRAY(4)
+                                    aces: struct security_ace
+                                        type                     : SEC_ACE_TYPE_ACCESS_ALLOWED (0)
+                                        flags                    : 0x03 (3)
+                                               1: SEC_ACE_FLAG_OBJECT_INHERIT
+                                               1: SEC_ACE_FLAG_CONTAINER_INHERIT
+                                               0: SEC_ACE_FLAG_NO_PROPAGATE_INHERIT
+                                               0: SEC_ACE_FLAG_INHERIT_ONLY
+                                               0: SEC_ACE_FLAG_INHERITED_ACE
+                                            0x03: SEC_ACE_FLAG_VALID_INHERIT (3)
+                                               0: SEC_ACE_FLAG_SUCCESSFUL_ACCESS
+                                               0: SEC_ACE_FLAG_FAILED_ACCESS
+                                        size                     : 0x0018 (24)
+                                        access_mask              : 0x001f01ff (2032127)
+                                        object                   : union security_ace_object_ctr(case 0)
+                                        trustee                  : S-1-5-32-544
+                                    aces: struct security_ace
+                                        type                     : SEC_ACE_TYPE_ACCESS_ALLOWED (0)
+                                        flags                    : 0x03 (3)
+                                               1: SEC_ACE_FLAG_OBJECT_INHERIT
+                                               1: SEC_ACE_FLAG_CONTAINER_INHERIT
+                                               0: SEC_ACE_FLAG_NO_PROPAGATE_INHERIT
+                                               0: SEC_ACE_FLAG_INHERIT_ONLY
+                                               0: SEC_ACE_FLAG_INHERITED_ACE
+                                            0x03: SEC_ACE_FLAG_VALID_INHERIT (3)
+                                               0: SEC_ACE_FLAG_SUCCESSFUL_ACCESS
+                                               0: SEC_ACE_FLAG_FAILED_ACCESS
+                                        size                     : 0x0018 (24)
+                                        access_mask              : 0x001200a9 (1179817)
+                                        object                   : union security_ace_object_ctr(case 0)
+                                        trustee                  : S-1-5-32-549
+                                    aces: struct security_ace
+                                        type                     : SEC_ACE_TYPE_ACCESS_ALLOWED (0)
+                                        flags                    : 0x03 (3)
+                                               1: SEC_ACE_FLAG_OBJECT_INHERIT
+                                               1: SEC_ACE_FLAG_CONTAINER_INHERIT
+                                               0: SEC_ACE_FLAG_NO_PROPAGATE_INHERIT
+                                               0: SEC_ACE_FLAG_INHERIT_ONLY
+                                               0: SEC_ACE_FLAG_INHERITED_ACE
+                                            0x03: SEC_ACE_FLAG_VALID_INHERIT (3)
+                                               0: SEC_ACE_FLAG_SUCCESSFUL_ACCESS
+                                               0: SEC_ACE_FLAG_FAILED_ACCESS
+                                        size                     : 0x0014 (20)
+                                        access_mask              : 0x001f01ff (2032127)
+                                        object                   : union security_ace_object_ctr(case 0)
+                                        trustee                  : S-1-5-18
+                                    aces: struct security_ace
+                                        type                     : SEC_ACE_TYPE_ACCESS_ALLOWED (0)
+                                        flags                    : 0x03 (3)
+                                               1: SEC_ACE_FLAG_OBJECT_INHERIT
+                                               1: SEC_ACE_FLAG_CONTAINER_INHERIT
+                                               0: SEC_ACE_FLAG_NO_PROPAGATE_INHERIT
+                                               0: SEC_ACE_FLAG_INHERIT_ONLY
+                                               0: SEC_ACE_FLAG_INHERITED_ACE
+                                            0x03: SEC_ACE_FLAG_VALID_INHERIT (3)
+                                               0: SEC_ACE_FLAG_SUCCESSFUL_ACCESS
+                                               0: SEC_ACE_FLAG_FAILED_ACCESS
+                                        size                     : 0x0014 (20)
+                                        access_mask              : 0x001200a9 (1179817)
+                                        object                   : union security_ace_object_ctr(case 0)
+                                        trustee                  : S-1-5-11
+                hash_type                : 0x0001 (1)
+                hash: ARRAY(64)
diff --git a/source4/librpc/wscript_build b/source4/librpc/wscript_build
index 7dab8bcf72d..009b2e13d2e 100644
--- a/source4/librpc/wscript_build
+++ b/source4/librpc/wscript_build
@@ -5,12 +5,6 @@ bld.RECURSE('../../librpc/tools')
 bld.RECURSE('idl')
 
 
-bld.SAMBA_SUBSYSTEM('NDR_WINSTATION',
-	source='gen_ndr/ndr_winstation.c',
-	public_deps='ndr'
-	)
-
-
 bld.SAMBA_SUBSYSTEM('NDR_IRPC',
 	source='gen_ndr/ndr_irpc.c',
 	public_deps='ndr NDR_SECURITY ndr_nbt'
@@ -26,7 +20,7 @@ bld.SAMBA_SUBSYSTEM('NDR_SASL_HELPERS',
 
 bld.SAMBA_SUBSYSTEM('NDR_WINSIF',
 	source='gen_ndr/ndr_winsif.c',
-	public_deps='ndr'
+	public_deps='ndr NDR_WINSREPL'
 	)
 
 
diff --git a/source4/nbt_server/wins/winsdb.c b/source4/nbt_server/wins/winsdb.c
index 41a9fd8550d..be1d8ba8050 100644
--- a/source4/nbt_server/wins/winsdb.c
+++ b/source4/nbt_server/wins/winsdb.c
@@ -985,6 +985,8 @@ struct winsdb_handle *winsdb_connect(TALLOC_CTX *mem_ctx,
 				     const char *owner,
 				     enum winsdb_handle_caller caller)
 {
+	const struct loadparm_substitution *lp_sub =
+		lpcfg_noop_substitution();
 	struct winsdb_handle *h = NULL;
 	unsigned int flags = 0;
 	bool ret;
@@ -1005,7 +1007,7 @@ struct winsdb_handle *winsdb_connect(TALLOC_CTX *mem_ctx,
 	if (!h->ldb) goto failed;
 
 	h->caller = caller;
-	h->hook_script = lpcfg_wins_hook(lp_ctx, h);
+	h->hook_script = lpcfg_wins_hook(lp_ctx, lp_sub, h);
 
 	h->local_owner = talloc_strdup(h, owner);
 	if (!h->local_owner) goto failed;
diff --git a/source4/rpc_server/dnsserver/dcerpc_dnsserver.c b/source4/rpc_server/dnsserver/dcerpc_dnsserver.c
index 993e5dc4e56..b6389f2328a 100644
--- a/source4/rpc_server/dnsserver/dcerpc_dnsserver.c
+++ b/source4/rpc_server/dnsserver/dcerpc_dnsserver.c
@@ -1763,6 +1763,7 @@ static WERROR dnsserver_enumerate_records(struct dnsserver_state *dsstate,
 	struct DNS_RPC_RECORDS_ARRAY *recs;
 	char **add_names = NULL;
 	char *rname;
+	const char *preference_name = NULL;
 	int add_count = 0;
 	int i, ret, len;
 	WERROR status;
@@ -1779,6 +1780,7 @@ static WERROR dnsserver_enumerate_records(struct dnsserver_state *dsstate,
 		ret = ldb_search(dsstate->samdb, tmp_ctx, &res, z->zone_dn,
 				 LDB_SCOPE_ONELEVEL, attrs,
 				 "(&(objectClass=dnsNode)(!(dNSTombstoned=TRUE)))");
+		preference_name = "@";
 	} else {
 		char *encoded_name
 			= ldb_binary_encode_string(tmp_ctx, name);
@@ -1786,6 +1788,7 @@ static WERROR dnsserver_enumerate_records(struct dnsserver_state *dsstate,
 				 LDB_SCOPE_ONELEVEL, attrs,
 				 "(&(objectClass=dnsNode)(|(name=%s)(name=*.%s))(!(dNSTombstoned=TRUE)))",
 				 encoded_name, encoded_name);
+		preference_name = name;
 	}
 	if (ret != LDB_SUCCESS) {
 		talloc_free(tmp_ctx);
@@ -1799,16 +1802,18 @@ static WERROR dnsserver_enumerate_records(struct dnsserver_state *dsstate,
 	recs = talloc_zero(mem_ctx, struct DNS_RPC_RECORDS_ARRAY);
 	W_ERROR_HAVE_NO_MEMORY_AND_FREE(recs, tmp_ctx);
 
-	/* Sort the names, so that the first record is the parent record */
-	ldb_qsort(res->msgs, res->count, sizeof(struct ldb_message *), name,
-			(ldb_qsort_cmp_fn_t)dns_name_compare);
+	/*
+	 * Sort the names, so that the records are in order by the child
+	 * component below "name".
+	 *
+	 * A full tree sort is not required, so we pass in "name" so
+	 * we know which level to sort, as only direct children are
+	 * eventually returned
+	 */
+	LDB_TYPESAFE_QSORT(res->msgs, res->count, name, dns_name_compare);
 
 	/* Build a tree of name components from dns name */
-	if (strcasecmp(name, z->name) == 0) {
-		tree = dns_build_tree(tmp_ctx, "@", res);
-	} else {
-		tree = dns_build_tree(tmp_ctx, name, res);
-	}
+	tree = dns_build_tree(tmp_ctx, preference_name, res);
 	W_ERROR_HAVE_NO_MEMORY_AND_FREE(tree, tmp_ctx);
 
 	/* Find the parent record in the tree */
diff --git a/source4/rpc_server/dnsserver/dnsdata.c b/source4/rpc_server/dnsserver/dnsdata.c
index 2dc098a64a0..47d6f5d5c88 100644
--- a/source4/rpc_server/dnsserver/dnsdata.c
+++ b/source4/rpc_server/dnsserver/dnsdata.c
@@ -801,10 +801,11 @@ struct dns_tree *dns_build_tree(TALLOC_CTX *mem_ctx, const char *name, struct ld
 			goto failed;
 		}
 
-		if (strcmp(ptr, "@") == 0) {
-			base->data = res->msgs[i];
-			continue;
-		} else if (strcasecmp(ptr, name) == 0) {
+		/*
+		 * This might be the sub-domain in the zone being
+		 * requested, or @ for the root of the zone
+		 */
+		if (strcasecmp(ptr, name) == 0) {
 			base->data = res->msgs[i];
 			continue;
 		}
@@ -1065,8 +1066,8 @@ WERROR dns_fill_records_array(TALLOC_CTX *mem_ctx,
 }
 
 
-int dns_name_compare(const struct ldb_message **m1, const struct ldb_message **m2,
-				char *search_name)
+int dns_name_compare(struct ldb_message * const *m1, struct ldb_message * const *m2,
+		     const char *search_name)
 {
 	const char *name1, *name2;
 	const char *ptr1, *ptr2;
@@ -1077,21 +1078,6 @@ int dns_name_compare(const struct ldb_message **m1, const struct ldb_message **m
 		return 0;
 	}
 
-	/* '@' record and the search_name record gets preference */
-	if (name1[0] == '@') {
-		return -1;
-	}
-	if (search_name && strcasecmp(name1, search_name) == 0) {
-		return -1;
-	}
-
-	if (name2[0] == '@') {
-		return 1;
-	}
-	if (search_name && strcasecmp(name2, search_name) == 0) {
-		return 1;
-	}
-
 	/* Compare the last components of names.
 	 * If search_name is not NULL, compare the second last components of names */
 	ptr1 = strrchr(name1, '.');
diff --git a/source4/rpc_server/dnsserver/dnsserver.h b/source4/rpc_server/dnsserver/dnsserver.h
index a8307ef836a..2e46e7c66a4 100644
--- a/source4/rpc_server/dnsserver/dnsserver.h
+++ b/source4/rpc_server/dnsserver/dnsserver.h
@@ -188,8 +188,8 @@ struct DNS_ADDR_ARRAY *dns_addr_array_copy(TALLOC_CTX *mem_ctx, struct DNS_ADDR_
 int dns_split_name_components(TALLOC_CTX *mem_ctx, const char *name, char ***components);
 char *dns_split_node_name(TALLOC_CTX *mem_ctx, const char *node_name, const char *zone_name);
 
-int dns_name_compare(const struct ldb_message **m1, const struct ldb_message **m2,
-			char *search_name);
+int dns_name_compare(struct ldb_message * const *m1, struct ldb_message * const *m2,
+		     const char *search_name);
 bool dns_record_match(struct dnsp_DnssrvRpcRecord *rec1, struct dnsp_DnssrvRpcRecord *rec2);
 
 void dnsp_to_dns_copy(TALLOC_CTX *mem_ctx, struct dnsp_DnssrvRpcRecord *dnsp,
diff --git a/source4/rpc_server/netlogon/dcerpc_netlogon.c b/source4/rpc_server/netlogon/dcerpc_netlogon.c
index 1a36cc6ddca..0ab55afeab0 100644
--- a/source4/rpc_server/netlogon/dcerpc_netlogon.c
+++ b/source4/rpc_server/netlogon/dcerpc_netlogon.c
@@ -680,7 +680,8 @@ static NTSTATUS dcesrv_netr_ServerPasswordSet(struct dcesrv_call_state *dce_call
 		return NT_STATUS_INVALID_SYSTEM_SERVICE;
 	}
 
-	netlogon_creds_des_decrypt(creds, r->in.new_password);
+	nt_status = netlogon_creds_des_decrypt(creds, r->in.new_password);
+	NT_STATUS_NOT_OK_RETURN(nt_status);
 
 	/* fetch the old password hashes (the NT hash has to exist) */
 
@@ -4206,11 +4207,17 @@ static NTSTATUS dcesrv_netr_ServerGetTrustInfo(struct dcesrv_call_state *dce_cal
 
 	if (curNtHash != NULL) {
 		*r->out.new_owf_password = *curNtHash;
-		netlogon_creds_des_encrypt(creds, r->out.new_owf_password);
+		nt_status = netlogon_creds_des_encrypt(creds, r->out.new_owf_password);
+		if (!NT_STATUS_IS_OK(nt_status)) {
+			return nt_status;
+		}
 	}
 	if (prevNtHash != NULL) {
 		*r->out.old_owf_password = *prevNtHash;
-		netlogon_creds_des_encrypt(creds, r->out.old_owf_password);
+		nt_status = netlogon_creds_des_encrypt(creds, r->out.old_owf_password);
+		if (!NT_STATUS_IS_OK(nt_status)) {
+			return nt_status;
+		}
 	}
 
 	if (trust_info != NULL) {
diff --git a/source4/rpc_server/remote/dcesrv_remote.c b/source4/rpc_server/remote/dcesrv_remote.c
index 916e59e5f4b..825c4cd9bd2 100644
--- a/source4/rpc_server/remote/dcesrv_remote.c
+++ b/source4/rpc_server/remote/dcesrv_remote.c
@@ -277,9 +277,6 @@ static NTSTATUS remote_op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CT
         /* unravel the NDR for the packet */
 	ndr_err = table->calls[opnum].ndr_pull(pull, NDR_IN, *r);
 	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
-		dcerpc_log_packet(dce_call->conn->packet_log_dir,
-						  table, opnum, NDR_IN,
-				  &dce_call->pkt.u.request.stub_and_verifier);
 		dce_call->fault_code = DCERPC_FAULT_NDR;
 		return NT_STATUS_NET_WRITE_FAULT;
 	}
@@ -449,6 +446,12 @@ static NTSTATUS remote_op_init_server(struct dcesrv_context *dce_ctx, const stru
 	return NT_STATUS_OK;
 }
 
+static NTSTATUS remote_op_shutdown_server(struct dcesrv_context *dce_ctx,
+				const struct dcesrv_endpoint_server *ep_server)
+{
+	return NT_STATUS_OK;
+}
+
 static bool remote_fill_interface(struct dcesrv_interface *iface, const struct ndr_interface_table *if_tabl)
 {
 	iface->name = if_tabl->name;
@@ -499,8 +502,11 @@ NTSTATUS dcerpc_server_remote_init(TALLOC_CTX *ctx)
 		/* fill in our name */
 		.name = "remote",
 
+		.initialized = false,
+
 		/* fill in all the operations */
 		.init_server = remote_op_init_server,
+		.shutdown_server = remote_op_shutdown_server,
 
 		.interface_by_uuid = remote_op_interface_by_uuid,
 		.interface_by_name = remote_op_interface_by_name
diff --git a/source4/rpc_server/samr/samr_password.c b/source4/rpc_server/samr/samr_password.c
index 7cb261c8c9b..52a644176e2 100644
--- a/source4/rpc_server/samr/samr_password.c
+++ b/source4/rpc_server/samr/samr_password.c
@@ -237,7 +237,11 @@ NTSTATUS dcesrv_samr_OemChangePasswordUser2(struct dcesrv_call_state *dce_call,
 	new_unicode_password.length = unicode_pw_len;
 
 	E_deshash(new_pass, new_lm_hash);
-	E_old_pw_hash(new_lm_hash, lm_pwd->hash, lm_verifier.hash);
+	rc = E_old_pw_hash(new_lm_hash, lm_pwd->hash, lm_verifier.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto failed;
+	}
 	if (memcmp(lm_verifier.hash, r->in.hash->hash, 16) != 0) {
 		authsam_update_bad_pwd_count(sam_ctx, res[0], ldb_get_default_basedn(sam_ctx));
 		status =  NT_STATUS_WRONG_PASSWORD;
@@ -446,6 +450,10 @@ NTSTATUS dcesrv_samr_ChangePasswordUser3(struct dcesrv_call_state *dce_call,
 	mdfour(new_nt_hash, new_password.data, new_password.length);
 
 	E_old_pw_hash(new_nt_hash, nt_pwd->hash, nt_verifier.hash);
+	if (rc != 0) {
+		status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		goto failed;
+	}
 	if (memcmp(nt_verifier.hash, r->in.nt_verifier->hash, 16) != 0) {
 		status = NT_STATUS_WRONG_PASSWORD;
 		goto failed;
@@ -464,7 +472,11 @@ NTSTATUS dcesrv_samr_ChangePasswordUser3(struct dcesrv_call_state *dce_call,
 					  new_password.length,
 					  (void **)&new_pass, &converted_size)) {
 			E_deshash(new_pass, new_lm_hash);
-			E_old_pw_hash(new_nt_hash, lm_pwd->hash, lm_verifier.hash);
+			rc = E_old_pw_hash(new_nt_hash, lm_pwd->hash, lm_verifier.hash);
+			if (rc != 0) {
+				status = gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+				goto failed;
+			}
 			if (memcmp(lm_verifier.hash, r->in.lm_verifier->hash, 16) != 0) {
 				status = NT_STATUS_WRONG_PASSWORD;
 				goto failed;
@@ -599,10 +611,9 @@ NTSTATUS samr_set_password(struct dcesrv_call_state *dce_call,
 
 	nt_status = dcesrv_transport_session_key(dce_call, &session_key);
 	if (!NT_STATUS_IS_OK(nt_status)) {
-		DEBUG(3,("samr: failed to get session key: %s "
-			 "=> NT_STATUS_WRONG_PASSWORD\n",
-			nt_errstr(nt_status)));
-		return NT_STATUS_WRONG_PASSWORD;
+		DBG_NOTICE("samr: failed to get session key: %s\n",
+			   nt_errstr(nt_status));
+		return nt_status;
 	}
 
 	_session_key = (gnutls_datum_t) {
@@ -729,6 +740,7 @@ NTSTATUS samr_set_password_buffers(struct dcesrv_call_state *dce_call,
 	DATA_BLOB session_key = data_blob(NULL, 0);
 	DATA_BLOB in, out;
 	NTSTATUS nt_status = NT_STATUS_OK;
+	int rc;
 
 	nt_status = dcesrv_transport_session_key(dce_call, &session_key);
 	if (NT_STATUS_EQUAL(nt_status, NT_STATUS_NO_USER_SESSION_KEY)) {
@@ -753,7 +765,11 @@ NTSTATUS samr_set_password_buffers(struct dcesrv_call_state *dce_call,
 		in = data_blob_const(lm_pwd_hash, 16);
 		out = data_blob_talloc_zero(mem_ctx, 16);
 
-		sess_crypt_blob(&out, &in, &session_key, false);
+		rc = sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_DECRYPT);
+		if (rc != 0) {
+			return gnutls_error_to_ntstatus(rc,
+							NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 
 		d_lm_pwd_hash = (struct samr_Password *) out.data;
 	}
@@ -761,7 +777,11 @@ NTSTATUS samr_set_password_buffers(struct dcesrv_call_state *dce_call,
 		in = data_blob_const(nt_pwd_hash, 16);
 		out = data_blob_talloc_zero(mem_ctx, 16);
 
-		sess_crypt_blob(&out, &in, &session_key, false);
+		rc = sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_DECRYPT);
+		if (rc != 0) {
+			return gnutls_error_to_ntstatus(rc,
+							NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 
 		d_nt_pwd_hash = (struct samr_Password *) out.data;
 	}
diff --git a/source4/rpc_server/service_rpc.c b/source4/rpc_server/service_rpc.c
index ef4bfab237a..96ebc2dbe57 100644
--- a/source4/rpc_server/service_rpc.c
+++ b/source4/rpc_server/service_rpc.c
@@ -129,6 +129,7 @@ static NTSTATUS dcesrv_task_init(struct task_server *task)
 {
 	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
 	struct dcesrv_context *dce_ctx;
+	const char **ep_servers = NULL;
 
 	dcerpc_server_init(task->lp_ctx);
 
@@ -136,13 +137,18 @@ static NTSTATUS dcesrv_task_init(struct task_server *task)
 
 	status = dcesrv_init_context(task->event_ctx,
 				     task->lp_ctx,
-				     lpcfg_dcerpc_endpoint_servers(task->lp_ctx),
 				     &srv_callbacks,
 				     &dce_ctx);
 	if (!NT_STATUS_IS_OK(status)) {
 		return status;
 	}
 
+	ep_servers = lpcfg_dcerpc_endpoint_servers(task->lp_ctx);
+	status = dcesrv_init_ep_servers(dce_ctx, ep_servers);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
 	/* Make sure the directory for NCALRPC exists */
 	if (!directory_exist(lpcfg_ncalrpc_dir(task->lp_ctx))) {
 		mkdir(lpcfg_ncalrpc_dir(task->lp_ctx), 0755);
diff --git a/source4/rpc_server/srvsvc/dcesrv_srvsvc.c b/source4/rpc_server/srvsvc/dcesrv_srvsvc.c
index 09673f6345c..7294c90a328 100644
--- a/source4/rpc_server/srvsvc/dcesrv_srvsvc.c
+++ b/source4/rpc_server/srvsvc/dcesrv_srvsvc.c
@@ -1437,6 +1437,8 @@ static WERROR dcesrv_srvsvc_NetSrvGetInfo(struct dcesrv_call_state *dce_call, TA
 {
 	struct dcesrv_context *dce_ctx = dce_call->conn->dce_ctx;
 	struct dcerpc_server_info *server_info = lpcfg_dcerpc_server_info(mem_ctx, dce_ctx->lp_ctx);
+	const struct loadparm_substitution *lp_sub =
+		lpcfg_noop_substitution();
 
 	ZERO_STRUCTP(r->out.info);
 
@@ -1469,7 +1471,7 @@ static WERROR dcesrv_srvsvc_NetSrvGetInfo(struct dcesrv_call_state *dce_call, TA
 		info101->version_major	= server_info->version_major;
 		info101->version_minor	= server_info->version_minor;
 		info101->server_type	= dcesrv_common_get_server_type(mem_ctx, dce_call->event_ctx, dce_ctx);
-		info101->comment	= lpcfg_server_string(dce_ctx->lp_ctx, mem_ctx);
+		info101->comment	= lpcfg_server_string(dce_ctx->lp_ctx, lp_sub, mem_ctx);
 		W_ERROR_HAVE_NO_MEMORY(info101->comment);
 
 		r->out.info->info101 = info101;
@@ -1489,7 +1491,7 @@ static WERROR dcesrv_srvsvc_NetSrvGetInfo(struct dcesrv_call_state *dce_call, TA
 		info102->version_major	= server_info->version_major;
 		info102->version_minor	= server_info->version_minor;
 		info102->server_type	= dcesrv_common_get_server_type(mem_ctx, dce_call->event_ctx, dce_ctx);
-		info102->comment	= lpcfg_server_string(dce_ctx->lp_ctx, mem_ctx);
+		info102->comment	= lpcfg_server_string(dce_ctx->lp_ctx, lp_sub, mem_ctx);
 		W_ERROR_HAVE_NO_MEMORY(info102->comment);
 
 		info102->users		= dcesrv_common_get_users(mem_ctx, dce_ctx);
diff --git a/source4/rpc_server/wscript_build b/source4/rpc_server/wscript_build
index 8d896c1722f..186e6a269e5 100644
--- a/source4/rpc_server/wscript_build
+++ b/source4/rpc_server/wscript_build
@@ -167,16 +167,15 @@ bld.SAMBA_MODULE('service_dcerpc',
 	deps='dcerpc_server'
 	)
 
-if bld.CONFIG_GET('ENABLE_SELFTEST'):
-    bld.SAMBA_BINARY(
-        'test_rpc_dns_server_dnsutils',
-        source='tests/rpc_dns_server_dnsutils_test.c',
-        deps='''
+bld.SAMBA_BINARY(
+    'test_rpc_dns_server_dnsutils',
+    source='tests/rpc_dns_server_dnsutils_test.c',
+    deps='''
             dnsserver_common
             dcerpc_server
             cmocka
             talloc
-        ''',
-        install=False,
-        enabled=bld.AD_DC_BUILD_IS_ENABLED()
-    )
+    ''',
+    for_selftest=True,
+    enabled=bld.AD_DC_BUILD_IS_ENABLED()
+)
diff --git a/source4/selftest/tests.py b/source4/selftest/tests.py
index 642dc680fa4..f570d35dfba 100755
--- a/source4/selftest/tests.py
+++ b/source4/selftest/tests.py
@@ -87,7 +87,7 @@ finally:
 have_heimdal_support = ("SAMBA4_USES_HEIMDAL" in config_hash)
 
 for options in ['-U"$USERNAME%$PASSWORD"']:
-    plantestsuite("samba4.ldb.ldaps with options %s(ad_dc_default)" % options, "ad_dc_default",
+    plantestsuite("samba4.ldb.ldaps with options %s(ad_dc_ntvfs)" % options, "ad_dc_ntvfs",
                   "%s/test_ldb.sh ldaps $SERVER_IP %s" % (bbdir, options))
 
 creds_options = [
@@ -192,9 +192,10 @@ auto_rpc_tests = list(filter(lambda t: t not in all_rpc_tests, rpc_tests))
 for bindoptions in ["seal,padcheck"] + validate_list + ["bigendian"]:
     for transport in ["ncalrpc", "ncacn_np", "ncacn_ip_tcp"]:
         env = "ad_dc_default"
+        local = ""
         if transport == "ncalrpc":
             tests = ncalrpc_tests
-            env = "ad_dc_default:local"
+            local = ":local"
         elif transport == "ncacn_np":
             tests = ncacn_np_tests
         elif transport == "ncacn_ip_tcp":
@@ -202,8 +203,10 @@ for bindoptions in ["seal,padcheck"] + validate_list + ["bigendian"]:
         else:
             raise AssertionError("invalid transport %r" % transport)
         for t in tests:
-            plansmbtorture4testsuite(t, env, ["%s:$SERVER[%s]" % (transport, bindoptions), '-U$USERNAME%$PASSWORD', '--workgroup=$DOMAIN'], "samba4.%s on %s with %s" % (t, transport, bindoptions))
-        plansmbtorture4testsuite('rpc.samba3-sharesec', env, ["%s:$SERVER[%s]" % (transport, bindoptions), '-U$USERNAME%$PASSWORD', '--workgroup=$DOMAIN', '--option=torture:share=tmp'], "samba4.rpc.samba3.sharesec on %s with %s" % (transport, bindoptions))
+            if t == "rpc.netlogon":
+                env = "ad_dc_ntvfs"
+            plansmbtorture4testsuite(t, env + local, ["%s:$SERVER[%s]" % (transport, bindoptions), '-U$USERNAME%$PASSWORD', '--workgroup=$DOMAIN'], "samba4.%s on %s with %s" % (t, transport, bindoptions))
+        plansmbtorture4testsuite('rpc.samba3-sharesec', env + local, ["%s:$SERVER[%s]" % (transport, bindoptions), '-U$USERNAME%$PASSWORD', '--workgroup=$DOMAIN', '--option=torture:share=tmp'], "samba4.rpc.samba3.sharesec on %s with %s" % (transport, bindoptions))
 
 # Plugin S4 DC tests (confirms named pipe auth forwarding).  This can be expanded once kerberos is supported in the plugin DC
 #
@@ -215,7 +218,10 @@ for bindoptions in ["seal,padcheck"] + validate_list + ["bigendian"]:
 
 for bindoptions in [""] + validate_list + ["bigendian"]:
     for t in auto_rpc_tests:
-        plansmbtorture4testsuite(t, "ad_dc_default", ["$SERVER[%s]" % bindoptions, '-U$USERNAME%$PASSWORD', '--workgroup=$DOMAIN'], "samba4.%s with %s" % (t, bindoptions))
+        env = "ad_dc_default"
+        if t in ["rpc.srvsvc", "rpc.mgmt"]:
+            env = "ad_dc_ntvfs"
+        plansmbtorture4testsuite(t, env, ["$SERVER[%s]" % bindoptions, '-U$USERNAME%$PASSWORD', '--workgroup=$DOMAIN'], "samba4.%s with %s" % (t, bindoptions))
 
 t = "rpc.countcalls"
 plansmbtorture4testsuite(t, "ad_dc_default:local", ["$SERVER[%s]" % bindoptions, '-U$USERNAME%$PASSWORD', '--workgroup=$DOMAIN'], modname="samba4.%s" % t)
@@ -346,6 +352,7 @@ smb2_s3only = [
     "smb2.durable-v2-delay",
     "smb2.aio_delay",
     "smb2.fileid",
+    "smb2.timestamps",
 ]
 smb2 = [x for x in smbtorture4_testsuites("smb2.") if x not in smb2_s3only]
 
@@ -458,6 +465,7 @@ if have_heimdal_support:
     plantestsuite("samba4.blackbox.kinit_trust", "fl2003dc:local", [os.path.join(bbdir, "test_kinit_trusts_heimdal.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$REALM', '$DOMAIN', '$TRUST_SERVER', '$TRUST_USERNAME', '$TRUST_PASSWORD', '$TRUST_REALM', '$TRUST_DOMAIN', '$PREFIX', "external", "arcfour-hmac-md5"])
     plantestsuite("samba4.blackbox.export.keytab", "ad_dc_ntvfs:local", [os.path.join(bbdir, "test_export_keytab_heimdal.sh"), '$SERVER', '$USERNAME', '$REALM', '$DOMAIN', "$PREFIX", smbclient4])
     plantestsuite("samba4.blackbox.kpasswd", "ad_dc_ntvfs:local", [os.path.join(bbdir, "test_kpasswd_heimdal.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$REALM', '$DOMAIN', "$PREFIX/ad_dc_ntvfs"])
+    plantestsuite("samba4.blackbox.krb5.s4u", "fl2008r2dc:local", [os.path.join(bbdir, "test_s4u_heimdal.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$REALM', '$DOMAIN', '$PREFIX', configuration])
 else:
     plantestsuite("samba4.blackbox.kinit", "ad_dc_ntvfs:local", [os.path.join(bbdir, "test_kinit_mit.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$REALM', '$DOMAIN', '$PREFIX', smbclient4, configuration])
     plantestsuite("samba4.blackbox.kinit", "fl2000dc:local", [os.path.join(bbdir, "test_kinit_mit.sh"), '$SERVER', '$USERNAME', '$PASSWORD', '$REALM', '$DOMAIN', '$PREFIX', smbclient4, configuration])
@@ -650,7 +658,7 @@ planpythontestsuite("ad_dc_default:local", "samba.tests.dsdb")
 planpythontestsuite("none", "samba.tests.dsdb_lock")
 planpythontestsuite("ad_dc_default:local", "samba.tests.dcerpc.bare")
 planpythontestsuite("ad_dc_default:local", "samba.tests.dcerpc.unix")
-planpythontestsuite("ad_dc_default:local", "samba.tests.dcerpc.srvsvc")
+planpythontestsuite("ad_dc_ntvfs:local", "samba.tests.dcerpc.srvsvc")
 planpythontestsuite("ad_dc_default:local", "samba.tests.samba_tool.timecmd")
 planpythontestsuite("ad_dc_default:local", "samba.tests.samba_tool.join")
 planpythontestsuite("ad_dc_default",
@@ -684,7 +692,7 @@ for env in ["ad_dc_ntvfs", "ad_dc", "offlinebackupdc", "renamedc",
     planpythontestsuite(env + ":local", "samba.tests.samba_tool.gpo")
 
 planpythontestsuite("ad_dc_default:local", "samba.tests.samba_tool.processes")
-planpythontestsuite("ad_dc_default:local", "samba.tests.samba_tool.user")
+planpythontestsuite("ad_dc_ntvfs:local", "samba.tests.samba_tool.user")
 planpythontestsuite("ad_dc_default:local", "samba.tests.samba_tool.user_wdigest")
 planpythontestsuite("ad_dc:local", "samba.tests.samba_tool.user")
 planpythontestsuite("ad_dc:local", "samba.tests.samba_tool.user_virtualCryptSHA")
@@ -702,6 +710,8 @@ planpythontestsuite("none", "samba.tests.samba_tool.help")
 planpythontestsuite("ad_dc_default:local", "samba.tests.samba_tool.passwordsettings")
 planpythontestsuite("ad_dc:local", "samba.tests.samba_tool.dsacl")
 
+planpythontestsuite("none", "samba.tests.samba_upgradedns_lmdb")
+
 # Run these against chgdcpass to share the runtime load
 planpythontestsuite("chgdcpass:local", "samba.tests.samba_tool.sites")
 planpythontestsuite("chgdcpass:local", "samba.tests.samba_tool.dnscmd")
@@ -899,7 +909,7 @@ for env in ['ad_dc_default:local', 'schema_dc:local']:
     planpythontestsuite(env, "samba.tests.dsdb_schema_attributes")
 
 plantestsuite_loadlist("samba4.urgent_replication.python(ad_dc_ntvfs)", "ad_dc_ntvfs:local", [python, os.path.join(DSDB_PYTEST_DIR, "urgent_replication.py"), '$PREFIX_ABS/ad_dc_ntvfs/private/sam.ldb', '$LOADLIST', '$LISTOPT'])
-plantestsuite_loadlist("samba4.ldap.dirsync.python(ad_dc_default)", "ad_dc_default", [python, os.path.join(DSDB_PYTEST_DIR, "dirsync.py"), '$SERVER', '-U"$USERNAME%$PASSWORD"', '--workgroup=$DOMAIN', '$LOADLIST', '$LISTOPT'])
+plantestsuite_loadlist("samba4.ldap.dirsync.python(ad_dc_ntvfs)", "ad_dc_ntvfs", [python, os.path.join(DSDB_PYTEST_DIR, "dirsync.py"), '$SERVER', '-U"$USERNAME%$PASSWORD"', '--workgroup=$DOMAIN', '$LOADLIST', '$LISTOPT'])
 plantestsuite_loadlist("samba4.ldap.match_rules.python", "ad_dc_ntvfs", [python, os.path.join(srcdir(), "lib/ldb-samba/tests/match_rules.py"), '$PREFIX_ABS/ad_dc_ntvfs/private/sam.ldb', '-U"$USERNAME%$PASSWORD"', '--workgroup=$DOMAIN', '$LOADLIST', '$LISTOPT'])
 plantestsuite("samba4.ldap.index.python", "none", [python, os.path.join(srcdir(), "lib/ldb-samba/tests/index.py")])
 plantestsuite_loadlist("samba4.ldap.notification.python(ad_dc_ntvfs)", "ad_dc_ntvfs", [python, os.path.join(DSDB_PYTEST_DIR, "notification.py"), '$SERVER', '-U"$USERNAME%$PASSWORD"', '--workgroup=$DOMAIN', '$LOADLIST', '$LISTOPT'])
@@ -936,7 +946,7 @@ plantestsuite_loadlist("samba4.ldap.subtree_rename.python(ad_dc_ntvfs)",
                         '$LISTOPT'])
 
 planoldpythontestsuite(
-    "ad_dc_default",
+    "ad_dc_ntvfs",
     "samba.tests.ldap_referrals",
     environ={
         'SERVER': '$SERVER',
@@ -1129,6 +1139,11 @@ for env in ['vampire_dc', 'promoted_dc']:
                            extra_path=[os.path.join(samba4srcdir, 'torture/drs/python')],
                            environ={'DC1': "$DC_SERVER", 'DC2': '$SERVER'},
                            extra_args=['-U$DOMAIN/$DC_USERNAME%$DC_PASSWORD'])
+    planoldpythontestsuite(env, "repl_secdesc",
+                           name="samba4.drs.repl_secdesc.python(%s)" % env,
+                           extra_path=[os.path.join(samba4srcdir, 'torture/drs/python')],
+                           environ={'DC1': "$DC_SERVER", 'DC2': '$SERVER'},
+                           extra_args=['-U$DOMAIN/$DC_USERNAME%$DC_PASSWORD'])
     planoldpythontestsuite(env, "repl_move",
                            extra_path=[os.path.join(samba4srcdir, 'torture/drs/python')],
                            name="samba4.drs.repl_move.python(%s)" % env,
@@ -1317,6 +1332,8 @@ plantestsuite("samba4.dcerpc.dnsserver.dnsutils", "none",
               [os.path.join(bindir(), "test_rpc_dns_server_dnsutils")])
 plantestsuite("libcli.drsuapi.repl_decrypt", "none",
               [os.path.join(bindir(), "test_repl_decrypt")])
+plantestsuite("librpc.ndr.ndr_string", "none",
+              [os.path.join(bindir(), "test_ndr_string")])
 
 # process restart and limit tests, these break the environment so need to run
 # in their own specific environment
diff --git a/source4/setup/tests/blackbox_group.sh b/source4/setup/tests/blackbox_group.sh
index 4adfa0c7f4f..ae3a9849a70 100755
--- a/source4/setup/tests/blackbox_group.sh
+++ b/source4/setup/tests/blackbox_group.sh
@@ -14,15 +14,25 @@ shift 1
 
 
 rm -rf $PREFIX/simple-dc
+mkdir -p $PREFIX
 testit "simple-dc" $PYTHON $BINDIR/samba-tool domain provision --server-role="dc" --domain=FOO --realm=foo.example.com --domain-sid=S-1-5-21-4177067393-1453636373-93818738 --targetdir=$PREFIX/simple-dc --use-ntvfs
 samba_tool="./bin/samba-tool"
 
 CONFIG="--configfile=$PREFIX/simple-dc/etc/smb.conf"
 
-#creation of two test subjects
+#creation of two test users
 testit "user add" $PYTHON $samba_tool user create $CONFIG --given-name="User" --surname="Tester" --initial="UT" testuser testp@ssw0Rd
 testit "user add" $PYTHON $samba_tool user create $CONFIG --given-name="User1" --surname="Tester" --initial="UT" testuser1 testp@ssw0Rd
 
+# test samba-tool user getgroups command
+user_getgroups_primary_only() {
+	res=$($PYTHON $samba_tool user getgroups $CONFIG testuser)
+
+	primary_group=$(echo $res)
+	echo $primary_group | grep -q "^Domain Users$" || return 1
+}
+testit "user getgroups primary only" user_getgroups_primary_only
+
 #test creation of six different groups
 testit "group add" $PYTHON $samba_tool group add $CONFIG --group-scope='Domain' --group-type='Security' --description='DomainSecurityGroup' --mail-address='dsg@samba.org' --notes='Notes' dsg
 testit "group add" $PYTHON $samba_tool group add $CONFIG --group-scope='Global' --group-type='Security' --description='GlobalSecurityGroup' --mail-address='gsg@samba.org' --notes='Notes' gsg
@@ -39,6 +49,55 @@ testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG ddg testu
 testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG gdg testuser,testuser1
 testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG udg testuser,testuser1
 
+# test samba-tool user getgroups command
+user_getgroups() {
+	groups="dsg gsg usg ddg gdg udg"
+
+	res=$($PYTHON $samba_tool user getgroups $CONFIG testuser)
+	for g in $groups ; do
+		echo "$res" | grep -q "^${g}$" || return 1
+	done
+
+	# the users primary group is expected in the first line
+	primary_group=$(echo "$res" | head -1)
+	echo $primary_group | grep -q "^Domain Users$" || return 1
+}
+testit "user getgroups" user_getgroups
+
+# test samba-tool user getgroups --full-dn command
+user_getgroups_full_dn() {
+	groups="dsg gsg usg ddg gdg udg"
+
+	res=$($PYTHON $samba_tool user getgroups --full-dn $CONFIG testuser)
+	for g in $groups ; do
+		group_dn=$($PYTHON $samba_tool group show $CONFIG $g --attributes=dn)
+		echo "$res" | grep -q "^${group_dn}$" || return 1
+	done
+
+	# the users primary group is expected in the first line
+	primary_group=$(echo "$res" | head -1)
+	group_dn=$($PYTHON $samba_tool group show $CONFIG "Domain Users" --attributes=dn)
+	echo $primary_group | grep -q "^${group_dn}$" || return 1
+}
+testit "user getgroups full-dn" user_getgroups
+
+# test settings a users primary group
+user_getgroups_primary_first() {
+	expected_primary_group=$1
+	res=$($PYTHON $samba_tool user getgroups $CONFIG testuser)
+
+	# the users primary group is expected in the first line
+	primary_group=$(echo "$res" | head -1)
+	echo $primary_group | grep -q "^${expected_primary_group}$" || return 1
+}
+testit "user setprimarygroup" $PYTHON $samba_tool user setprimarygroup $CONFIG testuser dsg
+testit "user getgroups primary first" user_getgroups_primary_first dsg
+testit "user setprimarygroup" $PYTHON $samba_tool user setprimarygroup $CONFIG testuser gsg
+testit "user getgroups primary first" user_getgroups_primary_first gsg
+
+# reset group (without testit, because I do not know how to quote the groupname)
+$PYTHON $samba_tool user setprimarygroup $CONFIG testuser 'Domain Users'
+
 #test removing test users from all groups by their username
 testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG dsg testuser,testuser1
 testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG gsg testuser,testuser1
@@ -47,6 +106,64 @@ testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG ddg
 testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG gdg testuser,testuser1
 testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG udg testuser,testuser1
 
+# creation of two test contacts
+testit "contact create" $PYTHON $samba_tool contact create $CONFIG --given-name="Con" --surname="Tester" --initial="CT" testcontact
+testit "contact create" $PYTHON $samba_tool contact create $CONFIG --given-name="Con1" --surname="Tester" --initial="CT" testcontact1
+
+# test adding test contacts to all groups by their cn
+testit "group addmembers contact" $PYTHON $samba_tool group addmembers $CONFIG dsg testcontact,testcontact1 --object-types=contact
+testit "group addmembers contact" $PYTHON $samba_tool group addmembers $CONFIG gsg testcontact,testcontact1 --object-types=contact
+testit "group addmembers contact" $PYTHON $samba_tool group addmembers $CONFIG usg testcontact,testcontact1 --object-types=contact
+testit "group addmembers contact" $PYTHON $samba_tool group addmembers $CONFIG ddg testcontact,testcontact1 --object-types=contact
+testit "group addmembers contact" $PYTHON $samba_tool group addmembers $CONFIG gdg testcontact,testcontact1 --object-types=contact
+testit "group addmembers contact" $PYTHON $samba_tool group addmembers $CONFIG udg testcontact,testcontact1 --object-types=contact
+
+# test removing test contacts from all groups by their cn
+testit "group removemembers contact" $PYTHON $samba_tool group removemembers $CONFIG dsg testcontact,testcontact1 --object-types=contact
+testit "group removemembers contact" $PYTHON $samba_tool group removemembers $CONFIG gsg testcontact,testcontact1 --object-types=contact
+testit "group removemembers contact" $PYTHON $samba_tool group removemembers $CONFIG usg testcontact,testcontact1 --object-types=contact
+testit "group removemembers contact" $PYTHON $samba_tool group removemembers $CONFIG ddg testcontact,testcontact1 --object-types=contact
+testit "group removemembers contact" $PYTHON $samba_tool group removemembers $CONFIG gdg testcontact,testcontact1 --object-types=contact
+testit "group removemembers contact" $PYTHON $samba_tool group removemembers $CONFIG udg testcontact,testcontact1 --object-types=contact
+
+# should not find test contact, because --object-types=user is specified
+testit_expect_failure "group addmembers contact failure" $PYTHON $samba_tool group addmembers $CONFIG dsg testcontact --object-types=user
+
+# test add contact with --object-types=all
+testit "group addmembers contact object-type all" $PYTHON $samba_tool group addmembers $CONFIG dsg testcontact --object-types=all
+
+# test remove contact with --object-types=all
+testit "group removemembers contact object-type all" $PYTHON $samba_tool group removemembers $CONFIG dsg testcontact --object-types=all
+
+# add test contact by DN
+testit "group addmembers contact dn" $PYTHON $samba_tool group addmembers $CONFIG dsg --member-dn=CN=testcontact,DC=foo,DC=example,DC=com
+
+# remove test contact by DN
+testit "group removemembers contact dn" $PYTHON $samba_tool group removemembers $CONFIG dsg --member-dn=CN=testcontact,DC=foo,DC=example,DC=com
+
+# delete test contacts
+testit "contact delete" $PYTHON $samba_tool contact delete $CONFIG testcontact
+testit "contact delete" $PYTHON $samba_tool contact delete $CONFIG testcontact1
+
+# creation of two test contacts with the same name in different OUs
+testit "ou create" $PYTHON $samba_tool ou create $CONFIG OU=tconou1
+testit "ou create" $PYTHON $samba_tool ou create $CONFIG OU=tconou2
+testit "contact create ou" $PYTHON $samba_tool contact create $CONFIG testcontact --ou=OU=tconou1
+testit "contact create ou" $PYTHON $samba_tool contact create $CONFIG testcontact --ou=OU=tconou2
+
+# expect failure here, since there are multiple results for testcontact
+testit_expect_failure "group addmembers contact same name failure" $PYTHON $samba_tool group addmembers $CONFIG dsg testcontact
+
+# add both contacts by DN
+testit "group addmembers contact dn" $PYTHON $samba_tool group addmembers $CONFIG dsg --member-dn=CN=testcontact,OU=tconou1,DC=foo,DC=example,DC=com --member-dn=CN=testcontact,OU=tconou2,DC=foo,DC=example,DC=com
+
+# remove both contacts by DN
+testit "group removemembers contact dn" $PYTHON $samba_tool group removemembers $CONFIG dsg --member-dn=CN=testcontact,OU=tconou1,DC=foo,DC=example,DC=com --member-dn=CN=testcontact,OU=tconou2,DC=foo,DC=example,DC=com
+
+# delete both contacts by DN
+testit "contact delete" $PYTHON $samba_tool contact delete $CONFIG CN=testcontact,OU=tconou1
+testit "contact delete" $PYTHON $samba_tool contact delete $CONFIG CN=testcontact,OU=tconou2
+
 #test adding test users to all groups by their cn
 #testit "group addmembers" $samba_tool group addmembers $CONFIG dsg "User UT. Tester,User1 UT. Tester"
 #testit "group addmembers" $samba_tool group addmembers $CONFIG gsg "User UT. Tester,User1 UT. Tester"
@@ -63,6 +180,55 @@ testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG udg
 #testit "group removemembers" $samba_tool group removemembers $CONFIG gdg "User UT. Tester,User1 UT. Tester"
 #testit "group removemembers" $samba_tool group removemembers $CONFIG ugg "User UT. Tester,User1 UT. Tester"
 
+# delete test users
+testit "user delete" $PYTHON $samba_tool user delete $CONFIG testuser
+testit "user delete" $PYTHON $samba_tool user delete $CONFIG testuser1
+
+# creation of two new test users without spaces in cn
+# testit fails when spaces are used in arguments
+testit "user add" $PYTHON $samba_tool user create $CONFIG --given-name="User" --surname="Tester" --initial="UT" --use-username-as-cn testuser testp@ssw0Rd
+testit "user add" $PYTHON $samba_tool user create $CONFIG --given-name="User1" --surname="Tester" --initial="UT" --use-username-as-cn testuser1 testp@ssw0Rd
+
+# test adding test users to all groups by their DN
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG dsg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com
+
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG dsg --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG gsg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG gsg --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG usg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG usg --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG ddg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG ddg --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+
+# add two members by DN and listofmembers in one call
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG gdg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com testuser1
+
+# add two members by DN with one call
+testit "group addmembers" $PYTHON $samba_tool group addmembers $CONFIG udg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+
+# test removing test users from all groups by their DN
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG dsg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG dsg --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG gsg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG gsg --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG usg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG usg --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG ddg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG ddg --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+
+# remove two members by DN and listofmembers in one call
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG gdg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com testuser1
+
+# remove two members by DN with one call
+testit "group removemembers" $PYTHON $samba_tool group removemembers $CONFIG udg --member-dn=CN=testuser,CN=Users,DC=foo,DC=example,DC=com --member-dn=CN=testuser1,CN=Users,DC=foo,DC=example,DC=com
+
+# test --member-base-dn option - expect failure here, due to invalid base
+testit_expect_failure "group addmembers with invalid search member base" $PYTHON $samba_tool group addmembers $CONFIG dsg testcontact --member-base-dn=OU=doesnotexist,DC=foo,DC=example,DC=com
+
+# test --member-base-dn option
+testit "group addmembers with member search base" $PYTHON $samba_tool group addmembers $CONFIG dsg testuser --member-base-dn=CN=Users,DC=foo,DC=example,DC=com
+testit "group removemembers with member search base" $PYTHON $samba_tool group removemembers $CONFIG dsg testuser --member-base-dn=CN=Users,DC=foo,DC=example,DC=com
+
 #test deletion of the groups
 testit "group delete" $PYTHON $samba_tool group delete $CONFIG dsg
 testit "group delete" $PYTHON $samba_tool group delete $CONFIG gsg
@@ -71,6 +237,10 @@ testit "group delete" $PYTHON $samba_tool group delete $CONFIG ddg
 testit "group delete" $PYTHON $samba_tool group delete $CONFIG gdg
 testit "group delete" $PYTHON $samba_tool group delete $CONFIG udg
 
+# delete test users
+testit "user delete" $PYTHON $samba_tool user delete $CONFIG testuser
+testit "user delete" $PYTHON $samba_tool user delete $CONFIG testuser1
+
 #test listing of all groups
 testit "group list" $PYTHON $samba_tool group list $CONFIG
 
diff --git a/source4/smb_server/smb_server.c b/source4/smb_server/smb_server.c
index 45641a4f2c9..0b80f2fbd20 100644
--- a/source4/smb_server/smb_server.c
+++ b/source4/smb_server/smb_server.c
@@ -44,7 +44,6 @@ static NTSTATUS smbsrv_recv_generic_request(void *private_data, DATA_BLOB blob)
 	if (CVAL(blob.data,0) != 0) {
 		status = smbsrv_init_smb_connection(smb_conn, smb_conn->lp_ctx);
 		NT_STATUS_NOT_OK_RETURN(status);
-		packet_set_callback(smb_conn->packet, smbsrv_recv_smb_request);
 		return smbsrv_recv_smb_request(smb_conn, blob);
 	}
 
diff --git a/source4/smbd/process_prefork.c b/source4/smbd/process_prefork.c
index a7222079624..5667fb5f1ef 100644
--- a/source4/smbd/process_prefork.c
+++ b/source4/smbd/process_prefork.c
@@ -518,7 +518,8 @@ static void prefork_child_pipe_handler(struct tevent_context *ev,
 		DBG_ERR("Parent %d, Child %d terminated with signal %d\n",
 			getpid(), pid, status);
 		if (status == SIGABRT || status == SIGBUS || status == SIGFPE ||
-		    status == SIGILL || status == SIGSYS || status == SIGSEGV) {
+		    status == SIGILL || status == SIGSYS || status == SIGSEGV ||
+		    status == SIGKILL) {
 
 			prefork_restart(ev, rc);
 		}
diff --git a/source4/smbd/server.c b/source4/smbd/server.c
index 0fc9125cbba..95acb99b86c 100644
--- a/source4/smbd/server.c
+++ b/source4/smbd/server.c
@@ -630,7 +630,7 @@ static int binary_smbd_main(const char *binary_name,
 		binary_name,
 		SAMBA_VERSION_STRING));
 	DEBUGADD(0,("Copyright Andrew Tridgell and the Samba Team"
-		" 1992-2019\n"));
+		" 1992-2020\n"));
 
 	if (sizeof(uint16_t) < 2 ||
 			sizeof(uint32_t) < 4 ||
diff --git a/source4/torture/basic/delete.c b/source4/torture/basic/delete.c
index a8c4e3fa3f1..d14d5a55746 100644
--- a/source4/torture/basic/delete.c
+++ b/source4/torture/basic/delete.c
@@ -1865,6 +1865,10 @@ static bool deltest20(struct torture_context *tctx, struct smbcli_state *cli1, s
 	NTSTATUS status;
 	int ret;
 
+	if (geteuid() == 0) {
+		torture_skip(tctx, "This test doesn't work as user root.");
+	}
+
 	del_clean_area(cli1, cli2);
 
 	/* Test 20 -- non-empty directory hardest to get right... */
diff --git a/source4/torture/drs/python/repl_secdesc.py b/source4/torture/drs/python/repl_secdesc.py
new file mode 100644
index 00000000000..58212907e23
--- /dev/null
+++ b/source4/torture/drs/python/repl_secdesc.py
@@ -0,0 +1,400 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#
+# Unix SMB/CIFS implementation.
+# Copyright (C) Catalyst.Net Ltd. 2017
+# Copyright (C) Andrew Bartlett <abartlet@samba.org> 2019
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+import drs_base
+import ldb
+import samba
+from samba import sd_utils
+from ldb import LdbError
+
+class ReplAclTestCase(drs_base.DrsBaseTestCase):
+
+    def setUp(self):
+        super(ReplAclTestCase, self).setUp()
+        self.mod = "(A;CIOI;GA;;;SY)"
+        self.mod_becomes = "(A;OICIIO;GA;;;SY)"
+        self.mod_inherits_as = "(A;OICIIOID;GA;;;SY)"
+
+        self.sd_utils_dc1 = sd_utils.SDUtils(self.ldb_dc1)
+        self.sd_utils_dc2 = sd_utils.SDUtils(self.ldb_dc2)
+
+        self.ou = samba.tests.create_test_ou(self.ldb_dc1,
+                                             "test_acl_inherit")
+
+        # disable replication for the tests so we can control at what point
+        # the DCs try to replicate
+        self._disable_all_repl(self.dnsname_dc1)
+        self._disable_all_repl(self.dnsname_dc2)
+
+        # make sure DCs are synchronized before the test
+        self._net_drs_replicate(DC=self.dnsname_dc2, fromDC=self.dnsname_dc1, forced=True)
+        self._net_drs_replicate(DC=self.dnsname_dc1, fromDC=self.dnsname_dc2, forced=True)
+
+    def tearDown(self):
+        self.ldb_dc1.delete(self.ou, ["tree_delete:1"])
+
+        # re-enable replication
+        self._enable_all_repl(self.dnsname_dc1)
+        self._enable_all_repl(self.dnsname_dc2)
+
+        super(ReplAclTestCase, self).tearDown()
+
+    def test_acl_inheirt_new_object_1_pass(self):
+        # Set the inherited ACL on the parent OU
+        self.sd_utils_dc1.dacl_add_ace(self.ou, self.mod)
+
+        # Assert ACL set stuck as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc1.get_sd_as_sddl(self.ou))
+
+        # Make a new object
+        dn = ldb.Dn(self.ldb_dc1, "OU=l2,%s" % self.ou)
+        self.ldb_dc1.add({"dn": dn, "objectclass": "organizationalUnit"})
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Assert ACL replicated as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc2.get_sd_as_sddl(self.ou))
+
+        # Confirm inherited ACLs are identical and were inherited
+
+        self.assertIn(self.mod_inherits_as,
+                      self.sd_utils_dc1.get_sd_as_sddl(dn))
+        self.assertEquals(self.sd_utils_dc1.get_sd_as_sddl(dn),
+                          self.sd_utils_dc2.get_sd_as_sddl(dn))
+
+    def test_acl_inheirt_new_object(self):
+        # Set the inherited ACL on the parent OU
+        self.sd_utils_dc1.dacl_add_ace(self.ou, self.mod)
+
+        # Assert ACL set stuck as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc1.get_sd_as_sddl(self.ou))
+
+        # Replicate to DC2
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Make a new object
+        dn = ldb.Dn(self.ldb_dc1, "OU=l2,%s" % self.ou)
+        self.ldb_dc1.add({"dn": dn, "objectclass": "organizationalUnit"})
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Assert ACL replicated as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc2.get_sd_as_sddl(self.ou))
+
+        # Confirm inherited ACLs are identical and were inheritied
+
+        self.assertIn(self.mod_inherits_as,
+                      self.sd_utils_dc1.get_sd_as_sddl(dn))
+        self.assertEquals(self.sd_utils_dc1.get_sd_as_sddl(dn),
+                          self.sd_utils_dc2.get_sd_as_sddl(dn))
+
+    def test_acl_inherit_existing_object(self):
+        # Make a new object
+        dn = ldb.Dn(self.ldb_dc1, "OU=l2,%s" % self.ou)
+        self.ldb_dc1.add({"dn": dn, "objectclass": "organizationalUnit"})
+
+        try:
+            self.ldb_dc2.search(scope=ldb.SCOPE_BASE,
+                                base=dn,
+                                attrs=[])
+            self.fail()
+        except LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_NO_SUCH_OBJECT)
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Confirm it is now replicated
+        self.ldb_dc2.search(scope=ldb.SCOPE_BASE,
+                            base=dn,
+                            attrs=[])
+
+        # Set the inherited ACL on the parent OU
+        self.sd_utils_dc1.dacl_add_ace(self.ou, self.mod)
+
+        # Assert ACL set stuck as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc1.get_sd_as_sddl(self.ou))
+
+        # Replicate to DC2
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Confirm inherited ACLs are identical and were inherited
+
+        # Assert ACL replicated as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc2.get_sd_as_sddl(self.ou))
+
+        self.assertIn(self.mod_inherits_as,
+                      self.sd_utils_dc1.get_sd_as_sddl(dn))
+        self.assertEquals(self.sd_utils_dc1.get_sd_as_sddl(dn),
+                          self.sd_utils_dc2.get_sd_as_sddl(dn))
+
+    def test_acl_inheirt_existing_object_1_pass(self):
+        # Make a new object
+        dn = ldb.Dn(self.ldb_dc1, "OU=l2,%s" % self.ou)
+        self.ldb_dc1.add({"dn": dn, "objectclass": "organizationalUnit"})
+
+        try:
+            self.ldb_dc2.search(scope=ldb.SCOPE_BASE,
+                                base=dn,
+                                attrs=[])
+            self.fail()
+        except LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_NO_SUCH_OBJECT)
+
+        # Set the inherited ACL on the parent OU
+        self.sd_utils_dc1.dacl_add_ace(self.ou, self.mod)
+
+        # Assert ACL set as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc1.get_sd_as_sddl(self.ou))
+
+        # Replicate to DC2
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Assert ACL replicated as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc2.get_sd_as_sddl(self.ou))
+
+        # Confirm inherited ACLs are identical and were inherited
+
+        self.assertIn(self.mod_inherits_as,
+                      self.sd_utils_dc1.get_sd_as_sddl(dn))
+        self.assertEquals(self.sd_utils_dc1.get_sd_as_sddl(dn),
+                          self.sd_utils_dc2.get_sd_as_sddl(dn))
+
+    def test_acl_inheirt_renamed_object(self):
+        # Make a new object
+        new_ou = samba.tests.create_test_ou(self.ldb_dc1,
+                                            "acl_test_l2")
+
+        sub_ou_dn = ldb.Dn(self.ldb_dc1, "OU=l2,%s" % self.ou)
+
+        try:
+            self.ldb_dc2.search(scope=ldb.SCOPE_BASE,
+                                base=new_ou,
+                                attrs=[])
+            self.fail()
+        except LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_NO_SUCH_OBJECT)
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Confirm it is now replicated
+        self.ldb_dc2.search(scope=ldb.SCOPE_BASE,
+                            base=new_ou,
+                            attrs=[])
+
+        # Set the inherited ACL on the parent OU on DC1
+        self.sd_utils_dc1.dacl_add_ace(self.ou, self.mod)
+
+        # Assert ACL set as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc1.get_sd_as_sddl(self.ou))
+
+        # Replicate to DC2
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Assert ACL replicated as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc2.get_sd_as_sddl(self.ou))
+
+        # Rename to under self.ou
+
+        self.ldb_dc1.rename(new_ou, sub_ou_dn)
+
+        # Replicate to DC2
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Confirm inherited ACLs are identical and were inherited
+        self.assertIn(self.mod_inherits_as,
+                      self.sd_utils_dc1.get_sd_as_sddl(sub_ou_dn))
+        self.assertEquals(self.sd_utils_dc1.get_sd_as_sddl(sub_ou_dn),
+                          self.sd_utils_dc2.get_sd_as_sddl(sub_ou_dn))
+
+
+    def test_acl_inheirt_renamed_child_object(self):
+        # Make a new OU
+        new_ou = samba.tests.create_test_ou(self.ldb_dc1,
+                                            "acl_test_l2")
+
+        # Here is where the new OU will end up at the end.
+        sub2_ou_dn_final = ldb.Dn(self.ldb_dc1, "OU=l2,%s" % self.ou)
+
+        sub3_ou_dn = ldb.Dn(self.ldb_dc1, "OU=l3,%s" % new_ou)
+        sub3_ou_dn_final = ldb.Dn(self.ldb_dc1, "OU=l3,%s" % sub2_ou_dn_final)
+
+        self.ldb_dc1.add({"dn": sub3_ou_dn,
+                          "objectclass": "organizationalUnit"})
+
+        sub4_ou_dn = ldb.Dn(self.ldb_dc1, "OU=l4,%s" % sub3_ou_dn)
+        sub4_ou_dn_final = ldb.Dn(self.ldb_dc1, "OU=l4,%s" % sub3_ou_dn_final)
+
+        self.ldb_dc1.add({"dn": sub4_ou_dn,
+                          "objectclass": "organizationalUnit"})
+
+        try:
+            self.ldb_dc2.search(scope=ldb.SCOPE_BASE,
+                                base=new_ou,
+                                attrs=[])
+            self.fail()
+        except LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_NO_SUCH_OBJECT)
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Confirm it is now replicated
+        self.ldb_dc2.search(scope=ldb.SCOPE_BASE,
+                            base=new_ou,
+                            attrs=[])
+
+        #
+        # Given a tree new_ou -> l3 -> l4
+        #
+
+        # Set the inherited ACL on the grandchild OU (l3) on DC1
+        self.sd_utils_dc1.dacl_add_ace(sub3_ou_dn, self.mod)
+
+        # Assert ACL set stuck as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc1.get_sd_as_sddl(sub3_ou_dn))
+
+        # Rename new_ou (l2) to under self.ou (this must happen second).  If the
+        # inheritence between l3 and l4 is name-based, this could
+        # break.
+
+        # The tree is now self.ou -> l2 -> l3 -> l4
+
+        self.ldb_dc1.rename(new_ou, sub2_ou_dn_final)
+
+        # Assert ACL set remained as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc1.get_sd_as_sddl(sub3_ou_dn_final))
+
+        # Replicate to DC2
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Confirm set ACLs (on l3 ) are identical and were inherited
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc2.get_sd_as_sddl(sub3_ou_dn_final))
+        self.assertEquals(self.sd_utils_dc1.get_sd_as_sddl(sub3_ou_dn_final),
+                          self.sd_utils_dc2.get_sd_as_sddl(sub3_ou_dn_final))
+
+        # Confirm inherited ACLs (from l3 to l4) are identical
+        # and where inherited
+        self.assertIn(self.mod_inherits_as,
+                      self.sd_utils_dc1.get_sd_as_sddl(sub4_ou_dn_final))
+        self.assertEquals(self.sd_utils_dc1.get_sd_as_sddl(sub4_ou_dn_final),
+                          self.sd_utils_dc2.get_sd_as_sddl(sub4_ou_dn_final))
+
+
+    def test_acl_inheirt_renamed_object_in_conflict(self):
+        # Make a new object to be renamed under self.ou
+        new_ou = samba.tests.create_test_ou(self.ldb_dc1,
+                                            "acl_test_l2")
+
+        # Make a new OU under self.ou (on DC2)
+        sub_ou_dn = ldb.Dn(self.ldb_dc2, "OU=l2,%s" % self.ou)
+        self.ldb_dc2.add({"dn": sub_ou_dn,
+                          "objectclass": "organizationalUnit"})
+
+        # Set the inherited ACL on the parent OU
+        self.sd_utils_dc1.dacl_add_ace(self.ou, self.mod)
+
+        # Assert ACL set stuck as expected
+        self.assertIn(self.mod_becomes,
+                      self.sd_utils_dc1.get_sd_as_sddl(self.ou))
+
+        # Replicate to DC2
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        # Rename to under self.ou
+        self.ldb_dc1.rename(new_ou, sub_ou_dn)
+        self.assertIn(self.mod_inherits_as,
+                      self.sd_utils_dc1.get_sd_as_sddl(sub_ou_dn))
+
+        # Replicate to DC2 (will cause a conflict, DC1 to win, version
+        # is higher since named twice)
+
+        self._net_drs_replicate(DC=self.dnsname_dc2,
+                                fromDC=self.dnsname_dc1,
+                                forced=True)
+
+        children = self.ldb_dc2.search(scope=ldb.SCOPE_ONELEVEL,
+                                       base=self.ou,
+                                       attrs=[])
+        for child in children:
+            self.assertIn(self.mod_inherits_as,
+                          self.sd_utils_dc2.get_sd_as_sddl(child.dn))
+            self.assertEquals(self.sd_utils_dc1.get_sd_as_sddl(sub_ou_dn),
+                              self.sd_utils_dc2.get_sd_as_sddl(child.dn))
+
+        # Replicate back
+        self._net_drs_replicate(DC=self.dnsname_dc1,
+                                fromDC=self.dnsname_dc2,
+                                forced=True)
+
+        self.assertIn(self.mod_inherits_as,
+                      self.sd_utils_dc1.get_sd_as_sddl(sub_ou_dn))
+
+        for child in children:
+            self.assertIn(self.mod_inherits_as,
+                          self.sd_utils_dc1.get_sd_as_sddl(child.dn))
+            self.assertEquals(self.sd_utils_dc1.get_sd_as_sddl(child.dn),
+                              self.sd_utils_dc2.get_sd_as_sddl(child.dn))
diff --git a/source4/torture/local/local.c b/source4/torture/local/local.c
index 86c537a9227..913daa39fbe 100644
--- a/source4/torture/local/local.c
+++ b/source4/torture/local/local.c
@@ -23,8 +23,6 @@
 #include "torture/ndr/proto.h"
 #include "torture/auth/proto.h"
 #include "../lib/crypto/test_proto.h"
-#include "../lib/crypto/aes_ccm_test_proto.h"
-#include "../lib/crypto/aes_gcm_test_proto.h"
 #ifndef HAVE_GNUTLS_AES_CMAC
 #include "../lib/crypto/aes_cmac_test_proto.h"
 #endif
@@ -101,10 +99,6 @@ NTSTATUS torture_local_init(TALLOC_CTX *ctx)
 	torture_suite_add_simple_test(suite, "crypto.aes_cmac_128",
 				      torture_local_crypto_aes_cmac_128);
 #endif
-	torture_suite_add_simple_test(suite, "crypto.aes_ccm_128",
-				      torture_local_crypto_aes_ccm_128);
-	torture_suite_add_simple_test(suite, "crypto.aes_gcm_128",
-				      torture_local_crypto_aes_gcm_128);
 
 	for (i = 0; suite_generators[i]; i++)
 		torture_suite_add_suite(suite,
diff --git a/source4/torture/ndr/dnsp.c b/source4/torture/ndr/dnsp.c
index 07bebeceb01..3d0cd942d11 100644
--- a/source4/torture/ndr/dnsp.c
+++ b/source4/torture/ndr/dnsp.c
@@ -337,6 +337,23 @@ static bool dnsp_dnsProperty_deleted_by_check(struct torture_context *tctx,
 	return true;
 }
 
+/*
+ * Copy of dnsp_dnsProperty_deleted_by_b64 with wDataLength set to 0
+ * and no data in the data element.
+ * This is a reproducer for https://bugzilla.samba.org/show_bug.cgi?id=14206
+ * The dns_property_id was retained so once parsed this structure referenced
+ * memory past it's end.
+ *
+ * [0000] 00 00 00 00 01 EE C4 71   00 00 00 00 01 00 00 00   &......q ........
+ * [0010] 80 00 00 00 77 00 32 00   6B 00 33 00 2D 00 31 00   ....w.2. k.3.-.1.
+ * [0020] 39 00 31 00 2E 00 77 00   32 00 6B 00 33 00 2E 00   9.1...w. 2.k.3...
+ * [0030] 62 00 61 00 73 00 65 00   00 00 C4 71 EC F3         b.a.s.e. ...q..
+ */
+static const uint8_t dnsp_dnsProperty_deleted_by_zero_wDataLength[] = {
+	0x00, 0x00, 0x00, 0x00, 0x01, 0xEE, 0xC4, 0x71, 0x00, 0x00, 0x00,
+	0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	0xC4, 0x71, 0xEC, 0xF3 };
+
 struct torture_suite *ndr_dnsp_suite(TALLOC_CTX *ctx)
 {
 	struct torture_suite *suite = torture_suite_create(ctx, "dnsp");
@@ -362,5 +379,11 @@ struct torture_suite *ndr_dnsp_suite(TALLOC_CTX *ctx)
 		dnsp_dnsProperty_deleted_by_b64,
 		dnsp_dnsProperty_deleted_by_check);
 
+	torture_suite_add_ndr_pull_invalid_data_test(
+		suite,
+		dnsp_DnsProperty,
+		dnsp_dnsProperty_deleted_by_zero_wDataLength,
+		NDR_ERR_BUFSIZE);
+
 	return suite;
 }
diff --git a/source4/torture/ndr/ndr.c b/source4/torture/ndr/ndr.c
index e65a39ddb7f..32efe90757d 100644
--- a/source4/torture/ndr/ndr.c
+++ b/source4/torture/ndr/ndr.c
@@ -35,6 +35,7 @@ struct ndr_pull_test_data {
 	ndr_print_function_t print_function;
 	int ndr_flags;
 	int flags;
+	enum ndr_err_code ndr_err;
 };
 
 static enum ndr_err_code torture_ndr_push_struct_blob_flags(DATA_BLOB *blob, TALLOC_CTX *mem_ctx, uint32_t flags, uint32_t ndr_flags, const void *p, ndr_push_flags_fn_t fn)
@@ -301,6 +302,72 @@ _PUBLIC_ struct torture_test *_torture_suite_add_ndr_pull_inout_test(
 	return test;
 }
 
+static bool wrap_ndr_pull_invalid_data_test(struct torture_context *tctx,
+					    struct torture_tcase *tcase,
+					    struct torture_test *test)
+{
+	const struct ndr_pull_test_data *data = (const struct ndr_pull_test_data *)test->data;
+	struct ndr_pull *ndr = ndr_pull_init_blob(&(data->data), tctx);
+	void *ds = talloc_zero_size(ndr, data->struct_size);
+	bool ret = true;
+
+	torture_assert(tctx, data, "out of memory");
+	torture_assert(tctx, ndr, "out of memory");
+	torture_assert(tctx, ds, "out of memory");
+
+	ndr->flags |= data->flags;
+
+	ndr->flags |= LIBNDR_FLAG_REF_ALLOC;
+
+	torture_assert_ndr_err_equal(
+		tctx,
+		data->pull_fn(ndr, data->ndr_flags, ds),
+		NDR_ERR_BUFSIZE,
+		"pulling invalid data");
+
+	talloc_free(ndr);
+	return ret;
+}
+
+_PUBLIC_ struct torture_test *_torture_suite_add_ndr_pull_invalid_data_test(
+	struct torture_suite *suite,
+	const char *name,
+	ndr_pull_flags_fn_t pull_fn,
+	DATA_BLOB db,
+	size_t struct_size,
+	int ndr_flags,
+	int flags,
+	enum ndr_err_code ndr_err)
+{
+	struct torture_test *test;
+	struct torture_tcase *tcase;
+	struct ndr_pull_test_data *data;
+
+	tcase = torture_suite_add_tcase(suite, name);
+
+	test = talloc(tcase, struct torture_test);
+
+	test->name = talloc_strdup(test, name);
+	test->description = NULL;
+	test->run = wrap_ndr_pull_invalid_data_test;
+
+	data = talloc_zero(test, struct ndr_pull_test_data);
+	data->data = db;
+	data->ndr_flags = ndr_flags;
+	data->flags = flags;
+	data->struct_size = struct_size;
+	data->pull_fn = pull_fn;
+	data->ndr_err = ndr_err;
+
+	test->data = data;
+	test->fn = NULL;
+	test->dangerous = false;
+
+	DLIST_ADD_END(tcase->tests, test);
+
+	return test;
+}
+
 static bool test_check_string_terminator(struct torture_context *tctx)
 {
 	struct ndr_pull *ndr;
diff --git a/source4/torture/ndr/ndr.h b/source4/torture/ndr/ndr.h
index 58ab19354ab..0cc21825fb4 100644
--- a/source4/torture/ndr/ndr.h
+++ b/source4/torture/ndr/ndr.h
@@ -48,6 +48,16 @@ _PUBLIC_ struct torture_test *_torture_suite_add_ndr_pull_inout_test(
 					int flags,
 					bool (*check_fn) (struct torture_context *ctx, void *data));
 
+_PUBLIC_ struct torture_test *_torture_suite_add_ndr_pull_invalid_data_test(
+	struct torture_suite *suite,
+	const char *name,
+	ndr_pull_flags_fn_t pull_fn,
+	DATA_BLOB db,
+	size_t struct_size,
+	int ndr_flags,
+	int flags,
+	enum ndr_err_code ndr_err);
+
 #define torture_suite_add_ndr_pull_test(suite,name,data,check_fn) \
 		_torture_suite_add_ndr_pullpush_test(suite, #name, \
 			 (ndr_pull_flags_fn_t)ndr_pull_ ## name, \
@@ -59,6 +69,16 @@ _PUBLIC_ struct torture_test *_torture_suite_add_ndr_pull_inout_test(
 			 NDR_SCALARS|NDR_BUFFERS, 0, \
 			 (bool (*) (struct torture_context *, void *)) check_fn);
 
+#define torture_suite_add_ndr_pull_invalid_data_test(suite,name,data,ndr_err) \
+		_torture_suite_add_ndr_pull_invalid_data_test( \
+			suite, \
+			#name, \
+			(ndr_pull_flags_fn_t)ndr_pull_ ## name, \
+			data_blob_const(data, sizeof(data)), \
+			sizeof(struct name), \
+			NDR_SCALARS|NDR_BUFFERS, 0, \
+			ndr_err);
+
 #define torture_suite_add_ndr_pull_fn_test(suite,name,data,flags,check_fn) \
 		_torture_suite_add_ndr_pullpush_test(suite, #name "_" #flags, \
 			 (ndr_pull_flags_fn_t)ndr_pull_ ## name, \
diff --git a/source4/torture/rpc/clusapi.c b/source4/torture/rpc/clusapi.c
index 6597b441841..99a272daf24 100644
--- a/source4/torture/rpc/clusapi.c
+++ b/source4/torture/rpc/clusapi.c
@@ -28,6 +28,9 @@ struct torture_clusapi_context {
 	struct dcerpc_pipe *p;
 	const char *NodeName;
 	const char *ClusterName;
+	uint16_t lpwMajorVersion;
+	uint16_t lpwMinorVersion;
+	uint16_t lpwBuildNumber;
 };
 
 static bool test_OpenCluster_int(struct torture_context *tctx,
@@ -1209,7 +1212,7 @@ static bool test_ResourceTypeControl_int(struct torture_context *tctx,
 	/* now try what happens when we query with a buffer large enough to hold
 	 * the entire packet */
 
-	r.in.nOutBufferSize = 0x400;
+	r.in.nOutBufferSize = 0x4000;
 	r.out.lpOutBuffer = talloc_zero_array(tctx, uint8_t, r.in.nOutBufferSize);
 
 	torture_assert_ntstatus_ok(tctx,
@@ -1641,7 +1644,7 @@ static bool test_NodeControl_int(struct torture_context *tctx,
 	/* now try what happens when we query with a buffer large enough to hold
 	 * the entire packet */
 
-	r.in.nOutBufferSize = 0x400;
+	r.in.nOutBufferSize = 0x4000;
 	r.out.lpOutBuffer = talloc_zero_array(tctx, uint8_t, r.in.nOutBufferSize);
 
 	torture_assert_ntstatus_ok(tctx,
@@ -1657,8 +1660,8 @@ static bool test_NodeControl_int(struct torture_context *tctx,
 		const char *str;
 		DATA_BLOB blob = data_blob_const(r.out.lpOutBuffer, *r.out.lpBytesReturned);
 
-		torture_assert(tctx, *r.out.lpBytesReturned < 4, "unexpected size");
-		torture_assert(tctx, *r.out.lpBytesReturned % 2, "must be a multiple of 2");
+		torture_assert(tctx, *r.out.lpBytesReturned >= 4, "must be at least 4 bytes long");
+		torture_assert(tctx, (*r.out.lpBytesReturned % 2) == 0, "must be a multiple of 2");
 
 		torture_assert(tctx,
 			pull_reg_sz(tctx, &blob, &str),
@@ -2322,17 +2325,17 @@ static bool test_OfflineGroup(struct torture_context *tctx,
 
 static bool test_one_group(struct torture_context *tctx,
 			   struct dcerpc_pipe *p,
-			   const char *node_name)
+			   const char *group_name)
 {
 	struct policy_handle hGroup;
 
 	torture_assert(tctx,
-		test_OpenGroup_int(tctx, p, node_name, &hGroup),
+		test_OpenGroup_int(tctx, p, group_name, &hGroup),
 		"failed to open group");
 	test_CloseGroup_int(tctx, p, &hGroup);
 
 	torture_assert(tctx,
-		test_OpenGroupEx_int(tctx, p, node_name, &hGroup),
+		test_OpenGroupEx_int(tctx, p, group_name, &hGroup),
 		"failed to openex group");
 
 	torture_assert(tctx,
@@ -3406,7 +3409,7 @@ static bool test_EnumValue_int(struct torture_context *tctx,
 	int i = 0;
 
 	do {
-		uint32_t lpcbData = 1024;
+		uint32_t lpcbData = 2048;
 
 		r.in.hKey = *hKey;
 		r.in.dwIndex = i++;
@@ -3696,6 +3699,150 @@ static bool test_all_keys(struct torture_context *tctx,
 	return true;
 }
 
+static bool test_OpenGroupSet_int(struct torture_context *tctx,
+				  struct dcerpc_pipe *p,
+				  const char *lpszGroupSetName,
+				  struct policy_handle *hGroupSet)
+{
+	struct dcerpc_binding_handle *b = p->binding_handle;
+	struct clusapi_OpenGroupSet r;
+	WERROR Status;
+	WERROR rpc_status;
+
+	r.in.lpszGroupSetName = lpszGroupSetName;
+	r.out.rpc_status = &rpc_status;
+	r.out.Status = &Status;
+	r.out.hGroupSet = hGroupSet;
+
+	torture_assert_ntstatus_ok(tctx,
+		dcerpc_clusapi_OpenGroupSet_r(b, tctx, &r),
+		"OpenGroupSet failed");
+	torture_assert_werr_ok(tctx,
+		*r.out.Status,
+		"OpenGroupSet failed");
+
+	return true;
+}
+
+static bool test_CloseGroupSet_int(struct torture_context *tctx,
+				   struct dcerpc_pipe *p,
+				   struct policy_handle *GroupSet)
+{
+	struct dcerpc_binding_handle *b = p->binding_handle;
+	struct clusapi_CloseGroupSet r;
+
+	r.in.GroupSet = GroupSet;
+	r.out.GroupSet = GroupSet;
+
+	torture_assert_ntstatus_ok(tctx,
+		dcerpc_clusapi_CloseGroupSet_r(b, tctx, &r),
+		"CloseGroupSet failed");
+	torture_assert_werr_ok(tctx,
+		r.out.result,
+		"CloseGroupSet failed");
+	torture_assert(tctx,
+		ndr_policy_handle_empty(GroupSet),
+		"policy_handle non empty after CloseGroupSet");
+
+	return true;
+}
+
+static bool test_OpenGroupSet(struct torture_context *tctx,
+			      void *data)
+{
+	struct torture_clusapi_context *t =
+		talloc_get_type_abort(data, struct torture_clusapi_context);
+	struct policy_handle hGroupSet;
+
+	if (t->lpwMajorVersion < 0x000a) {
+		torture_skip(tctx, "GroupSet fn not available on old clusters");
+		return true;
+	}
+
+	if (!test_OpenGroupSet_int(tctx, t->p, "Cluster Group", &hGroupSet)) {
+		return false;
+	}
+
+	test_CloseGroupSet_int(tctx, t->p, &hGroupSet);
+
+	return true;
+}
+
+static bool test_CloseGroupSet(struct torture_context *tctx,
+			       void *data)
+{
+	struct torture_clusapi_context *t =
+		talloc_get_type_abort(data, struct torture_clusapi_context);
+	struct policy_handle hGroupSet;
+
+	if (t->lpwMajorVersion < 0x000a) {
+		torture_skip(tctx, "GroupSet fn not available on old clusters");
+		return true;
+	}
+
+	if (!test_OpenGroupSet_int(tctx, t->p, "Cluster Group", &hGroupSet)) {
+		return false;
+	}
+
+	return test_CloseGroupSet_int(tctx, t->p, &hGroupSet);
+}
+
+static bool test_one_groupset(struct torture_context *tctx,
+			      struct dcerpc_pipe *p,
+			      const char *groupset_name)
+{
+	struct policy_handle hGroupSet;
+
+	torture_assert(tctx,
+		test_OpenGroupSet_int(tctx, p, groupset_name, &hGroupSet),
+		"failed to open groupset");
+
+	test_CloseGroupSet_int(tctx, p, &hGroupSet);
+
+	return true;
+}
+
+static bool test_all_groupsets(struct torture_context *tctx,
+			       void *data)
+{
+	struct torture_clusapi_context *t =
+		talloc_get_type_abort(data, struct torture_clusapi_context);
+	struct dcerpc_binding_handle *b = t->p->binding_handle;
+	struct clusapi_CreateGroupSetEnum r;
+	struct ENUM_LIST *ReturnEnum;
+	struct policy_handle Cluster;
+	WERROR rpc_status;
+	int i;
+
+	if (!test_OpenCluster_int(tctx, t->p, &Cluster)) {
+		return false;
+	}
+
+	r.in.hCluster = Cluster;
+	r.out.ReturnEnum = &ReturnEnum;
+	r.out.rpc_status = &rpc_status;
+
+	torture_assert_ntstatus_ok(tctx,
+		dcerpc_clusapi_CreateGroupSetEnum_r(b, tctx, &r),
+		"CreateGroupSetEnum failed");
+	torture_assert_werr_ok(tctx,
+		r.out.result,
+		"CreateGroupSetEnum failed");
+
+	test_CloseCluster_int(tctx, t->p, &Cluster);
+
+	for (i=0; i < ReturnEnum->EntryCount; i++) {
+
+		struct ENUM_ENTRY e = ReturnEnum->Entry[i];
+
+		torture_assert(tctx,
+			test_one_groupset(tctx, t->p, e.Name),
+			"failed to test one groupset");
+	}
+
+	return true;
+}
+
 static bool torture_rpc_clusapi_setup_common(struct torture_context *tctx,
 					     struct torture_clusapi_context *t)
 {
@@ -3705,11 +3852,11 @@ static bool torture_rpc_clusapi_setup_common(struct torture_context *tctx,
 		torture_rpc_connection(tctx, &t->p, &ndr_table_clusapi),
 		"Error connecting to server");
 
+	b = t->p->binding_handle;
+
 	{
 		struct clusapi_GetClusterName r;
 
-		b = t->p->binding_handle;
-
 		r.out.ClusterName = &t->ClusterName;
 		r.out.NodeName = &t->NodeName;
 
@@ -3720,6 +3867,28 @@ static bool torture_rpc_clusapi_setup_common(struct torture_context *tctx,
 			r.out.result,
 			"GetClusterName failed");
 	}
+	{
+		struct clusapi_GetClusterVersion2 r;
+		const char *lpszVendorId;
+		const char *lpszCSDVersion;
+		struct CLUSTER_OPERATIONAL_VERSION_INFO *ppClusterOpVerInfo;
+		WERROR rpc_status;
+
+		r.out.lpwMajorVersion = &t->lpwMajorVersion;
+		r.out.lpwMinorVersion = &t->lpwMinorVersion;
+		r.out.lpwBuildNumber = &t->lpwBuildNumber;
+		r.out.lpszVendorId = &lpszVendorId;
+		r.out.lpszCSDVersion = &lpszCSDVersion;
+		r.out.ppClusterOpVerInfo = &ppClusterOpVerInfo;
+		r.out.rpc_status = &rpc_status;
+
+		torture_assert_ntstatus_ok(tctx,
+			dcerpc_clusapi_GetClusterVersion2_r(b, tctx, &r),
+			"GetClusterVersion2 failed");
+		torture_assert_werr_ok(tctx,
+			r.out.result,
+			"GetClusterVersion2 failed");
+	}
 
 	return true;
 }
@@ -3924,6 +4093,16 @@ void torture_tcase_registry(struct torture_tcase *tcase)
 				      test_all_keys);
 }
 
+void torture_tcase_groupset(struct torture_tcase *tcase)
+{
+	torture_tcase_add_simple_test(tcase, "OpenGroupSet",
+				      test_OpenGroupSet);
+	torture_tcase_add_simple_test(tcase, "CloseGroupSet",
+				      test_CloseGroupSet);
+	torture_tcase_add_simple_test(tcase, "all_groupsets",
+				      test_all_groupsets);
+}
+
 struct torture_suite *torture_rpc_clusapi(TALLOC_CTX *mem_ctx)
 {
 	struct torture_tcase *tcase;
@@ -3994,5 +4173,13 @@ struct torture_suite *torture_rpc_clusapi(TALLOC_CTX *mem_ctx)
 
 	torture_tcase_registry(tcase);
 
+	tcase = torture_suite_add_tcase(suite, "groupset");
+
+	torture_tcase_set_fixture(tcase,
+				  torture_rpc_clusapi_setup,
+				  torture_rpc_clusapi_teardown);
+
+	torture_tcase_groupset(tcase);
+
 	return suite;
 }
diff --git a/source4/torture/rpc/mdssvc.c b/source4/torture/rpc/mdssvc.c
index afdb4d5c03e..507a4a1d2e4 100644
--- a/source4/torture/rpc/mdssvc.c
+++ b/source4/torture/rpc/mdssvc.c
@@ -403,7 +403,7 @@ static bool test_mdssvc_close(struct torture_context *tctx,
 				     &close_ph,
 				     &close_status);
 	torture_assert_ntstatus_ok_goto(tctx, status, ok, done,
-					"dcerpc_mdssvc_open failed\n");
+					"dcerpc_mdssvc_close failed\n");
 
 	torture_assert_data_blob_equal(tctx, close_ph_blob, ph_blob,
 				       "bad blob");
diff --git a/source4/torture/rpc/samr.c b/source4/torture/rpc/samr.c
index 1d807876fd4..e02d66adaf3 100644
--- a/source4/torture/rpc/samr.c
+++ b/source4/torture/rpc/samr.c
@@ -1007,14 +1007,14 @@ static bool test_SetUserPass_18(struct dcerpc_pipe *p, struct torture_context *t
 		DATA_BLOB in,out;
 		in = data_blob_const(nt_hash, 16);
 		out = data_blob_talloc_zero(tctx, 16);
-		sess_crypt_blob(&out, &in, &session_key, true);
+		sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
 		memcpy(u.info18.nt_pwd.hash, out.data, out.length);
 	}
 	{
 		DATA_BLOB in,out;
 		in = data_blob_const(lm_hash, 16);
 		out = data_blob_talloc_zero(tctx, 16);
-		sess_crypt_blob(&out, &in, &session_key, true);
+		sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
 		memcpy(u.info18.lm_pwd.hash, out.data, out.length);
 	}
 
@@ -1096,7 +1096,7 @@ static bool test_SetUserPass_21(struct dcerpc_pipe *p, struct torture_context *t
 		in = data_blob_const(u.info21.lm_owf_password.array,
 				     u.info21.lm_owf_password.length);
 		out = data_blob_talloc_zero(tctx, 16);
-		sess_crypt_blob(&out, &in, &session_key, true);
+		sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
 		u.info21.lm_owf_password.array = (uint16_t *)out.data;
 	}
 
@@ -1105,7 +1105,7 @@ static bool test_SetUserPass_21(struct dcerpc_pipe *p, struct torture_context *t
 		in = data_blob_const(u.info21.nt_owf_password.array,
 				     u.info21.nt_owf_password.length);
 		out = data_blob_talloc_zero(tctx, 16);
-		sess_crypt_blob(&out, &in, &session_key, true);
+		sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
 		u.info21.nt_owf_password.array = (uint16_t *)out.data;
 	}
 
@@ -1272,14 +1272,14 @@ static bool test_SetUserPass_level_ex(struct dcerpc_pipe *p,
 			DATA_BLOB in,out;
 			in = data_blob_const(u.info18.nt_pwd.hash, 16);
 			out = data_blob_talloc_zero(tctx, 16);
-			sess_crypt_blob(&out, &in, &session_key, true);
+			sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
 			memcpy(u.info18.nt_pwd.hash, out.data, out.length);
 		}
 		{
 			DATA_BLOB in,out;
 			in = data_blob_const(u.info18.lm_pwd.hash, 16);
 			out = data_blob_talloc_zero(tctx, 16);
-			sess_crypt_blob(&out, &in, &session_key, true);
+			sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
 			memcpy(u.info18.lm_pwd.hash, out.data, out.length);
 		}
 
@@ -1290,7 +1290,7 @@ static bool test_SetUserPass_level_ex(struct dcerpc_pipe *p,
 			in = data_blob_const(u.info21.lm_owf_password.array,
 					     u.info21.lm_owf_password.length);
 			out = data_blob_talloc_zero(tctx, 16);
-			sess_crypt_blob(&out, &in, &session_key, true);
+			sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
 			u.info21.lm_owf_password.array = (uint16_t *)out.data;
 		}
 		if (fields_present & SAMR_FIELD_NT_PASSWORD_PRESENT) {
@@ -1298,7 +1298,7 @@ static bool test_SetUserPass_level_ex(struct dcerpc_pipe *p,
 			in = data_blob_const(u.info21.nt_owf_password.array,
 					     u.info21.nt_owf_password.length);
 			out = data_blob_talloc_zero(tctx, 16);
-			sess_crypt_blob(&out, &in, &session_key, true);
+			sess_crypt_blob(&out, &in, &session_key, SAMBA_GNUTLS_ENCRYPT);
 			u.info21.nt_owf_password.array = (uint16_t *)out.data;
 		}
 		break;
diff --git a/source4/torture/rpc/samsync.c b/source4/torture/rpc/samsync.c
index 869d3ba96b6..6b9759b88fd 100644
--- a/source4/torture/rpc/samsync.c
+++ b/source4/torture/rpc/samsync.c
@@ -36,6 +36,7 @@
 #include "librpc/gen_ndr/ndr_samr_c.h"
 #include "librpc/gen_ndr/ndr_security.h"
 #include "param/param.h"
+#include "lib/crypto/gnutls_helpers.h"
 
 #define TEST_MACHINE_NAME "samsynctest"
 #define TEST_WKSTA_MACHINE_NAME "samsynctest2"
@@ -61,6 +62,7 @@ static NTSTATUS test_SamLogon(struct torture_context *tctx,
 	union netr_Validation validation;
 	uint8_t authoritative;
 	struct dcerpc_binding_handle *b = p->binding_handle;
+	int rc;
 
 	ninfo.identity_info.domain_name.string = domain;
 	ninfo.identity_info.parameter_control = 0;
@@ -72,7 +74,11 @@ static NTSTATUS test_SamLogon(struct torture_context *tctx,
 	if (nt_hash) {
 		ninfo.nt.length = 24;
 		ninfo.nt.data = talloc_array(mem_ctx, uint8_t, 24);
-		SMBOWFencrypt(nt_hash->hash, ninfo.challenge, ninfo.nt.data);
+		rc = SMBOWFencrypt(nt_hash->hash, ninfo.challenge,
+				   ninfo.nt.data);
+		if (rc != 0) {
+			return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 	} else {
 		ninfo.nt.length = 0;
 		ninfo.nt.data = NULL;
@@ -81,7 +87,11 @@ static NTSTATUS test_SamLogon(struct torture_context *tctx,
 	if (lm_hash) {
 		ninfo.lm.length = 24;
 		ninfo.lm.data = talloc_array(mem_ctx, uint8_t, 24);
-		SMBOWFencrypt(lm_hash->hash, ninfo.challenge, ninfo.lm.data);
+		rc = SMBOWFencrypt(lm_hash->hash, ninfo.challenge,
+				   ninfo.lm.data);
+		if (rc != 0) {
+			return gnutls_error_to_ntstatus(rc, NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER);
+		}
 	} else {
 		ninfo.lm.length = 0;
 		ninfo.lm.data = NULL;
diff --git a/source4/torture/rpc/spoolss.c b/source4/torture/rpc/spoolss.c
index bf3a9377322..9dc52dcfd14 100644
--- a/source4/torture/rpc/spoolss.c
+++ b/source4/torture/rpc/spoolss.c
@@ -6127,6 +6127,206 @@ static bool test_add_print_processor(struct torture_context *tctx,
 	return true;
 }
 
+static bool test_AddPerMachineConnection(struct torture_context *tctx,
+					 struct dcerpc_binding_handle *b,
+					 const char *servername,
+					 const char *printername,
+					 const char *printserver,
+					 const char *provider,
+					 WERROR expected_error)
+{
+	struct spoolss_AddPerMachineConnection r;
+	const char *composed_printername = printername;
+
+	if (servername != NULL) {
+		composed_printername = talloc_asprintf(tctx, "%s\\%s",
+						servername,
+						printername);
+	}
+	r.in.server = servername;
+	r.in.printername = composed_printername;
+	r.in.printserver = printserver;
+	r.in.provider = provider;
+
+	torture_comment(tctx, "Testing AddPerMachineConnection(%s|%s|%s)\n",
+		printername, printserver, provider);
+
+	torture_assert_ntstatus_ok(tctx,
+		dcerpc_spoolss_AddPerMachineConnection_r(b, tctx, &r),
+		"spoolss_AddPerMachineConnection failed");
+	torture_assert_werr_equal(tctx, r.out.result, expected_error,
+		"spoolss_AddPerMachineConnection failed");
+
+	return true;
+}
+
+static bool test_DeletePerMachineConnection(struct torture_context *tctx,
+					    struct dcerpc_binding_handle *b,
+					    const char *servername,
+					    const char *printername,
+					    WERROR expected_error)
+{
+	struct spoolss_DeletePerMachineConnection r;
+	const char *composed_printername = printername;
+
+	if (servername != NULL) {
+		composed_printername = talloc_asprintf(tctx, "%s\\%s",
+						servername,
+						printername);
+	}
+
+	r.in.server = servername;
+	r.in.printername = composed_printername;
+
+	torture_comment(tctx, "Testing DeletePerMachineConnection(%s)\n",
+		printername);
+
+	torture_assert_ntstatus_ok(tctx,
+		dcerpc_spoolss_DeletePerMachineConnection_r(b, tctx, &r),
+		"spoolss_DeletePerMachineConnection failed");
+	torture_assert_werr_equal(tctx, r.out.result, expected_error,
+		"spoolss_DeletePerMachineConnection failed");
+
+	return true;
+}
+
+static bool test_EnumPerMachineConnections(struct torture_context *tctx,
+					   struct dcerpc_binding_handle *b,
+					   const char *servername)
+{
+	struct spoolss_EnumPerMachineConnections r;
+	DATA_BLOB blob = data_blob_null;
+	struct spoolss_PrinterInfo4 *info;
+	uint32_t needed;
+	uint32_t count;
+
+	r.in.server = servername;
+	r.in.buffer = &blob;
+	r.in.offered = 0;
+
+	r.out.info = &info;
+	r.out.needed = &needed;
+	r.out.count = &count;
+
+	torture_comment(tctx, "Testing EnumPerMachineConnections(%s)\n",
+		servername);
+
+	torture_assert_ntstatus_ok(tctx,
+		dcerpc_spoolss_EnumPerMachineConnections_r(b, tctx, &r),
+		"spoolss_EnumPerMachineConnections failed");
+	if (W_ERROR_EQUAL(r.out.result, WERR_INSUFFICIENT_BUFFER)) {
+		blob = data_blob_talloc_zero(tctx, needed);
+		r.in.buffer = &blob;
+		r.in.offered = needed;
+
+		torture_assert_ntstatus_ok(tctx,
+			dcerpc_spoolss_EnumPerMachineConnections_r(b, tctx, &r),
+			"spoolss_EnumPerMachineConnections failed");
+	}
+	torture_assert_werr_ok(tctx, r.out.result,
+		"spoolss_EnumPerMachineConnections failed");
+
+	return true;
+}
+
+static bool test_addpermachineconnection(struct torture_context *tctx,
+					 void *private_data)
+{
+	struct test_spoolss_context *ctx =
+		talloc_get_type_abort(private_data, struct test_spoolss_context);
+	struct dcerpc_pipe *p = ctx->spoolss_pipe;
+	struct dcerpc_binding_handle *b = p->binding_handle;
+	const char *server_name_slash = talloc_asprintf(tctx, "\\\\%s", dcerpc_server_name(p));
+	int i;
+
+	struct {
+		const char *servername;
+		const char *printername;
+		const char *printserver;
+		const char *provider;
+		WERROR expected_add_result;
+		WERROR expected_del_result;
+	} tests[] = {
+		{
+			.servername		= NULL,
+			.printername		= "foo",
+			.printserver		= "",
+			.provider		= "unknown",
+			.expected_add_result	= WERR_INVALID_PRINTER_NAME,
+			.expected_del_result	= WERR_INVALID_PRINTER_NAME
+		},{
+			.servername		= NULL,
+			.printername		= "Microsoft Print to PDF",
+			.printserver		= "samba.org",
+			.provider		= "unknown",
+			.expected_add_result	= WERR_INVALID_PRINTER_NAME,
+			.expected_del_result	= WERR_INVALID_PRINTER_NAME
+		},{
+			.servername		= NULL,
+			.printername		= "Microsoft Print to PDF",
+			.printserver		= "samba.org",
+			.provider		= "",
+			.expected_add_result	= WERR_INVALID_PRINTER_NAME,
+			.expected_del_result	= WERR_INVALID_PRINTER_NAME
+		},{
+			.servername		= server_name_slash,
+			.printername		= "foo",
+			.printserver		= "",
+			.provider		= "unknown",
+			.expected_add_result	= WERR_FILE_NOT_FOUND,
+			.expected_del_result	= WERR_INVALID_PRINTER_NAME
+		},{
+			.servername		= server_name_slash,
+			.printername		= "foo",
+			.printserver		= "",
+			.provider		= "",
+			.expected_add_result	= WERR_OK,
+			.expected_del_result	= WERR_OK
+		},{
+			.servername		= server_name_slash,
+			.printername		= "Microsoft Print to PDF",
+			.printserver		= "samba.org",
+			.provider		= "unknown",
+			.expected_add_result	= WERR_FILE_NOT_FOUND,
+			.expected_del_result	= WERR_INVALID_PRINTER_NAME
+		},{
+			.servername		= server_name_slash,
+			.printername		= "Microsoft Print to PDF",
+			.printserver		= "samba.org",
+			.provider		= "",
+			.expected_add_result	= WERR_OK,
+			.expected_del_result	= WERR_OK
+		}
+	};
+
+	for (i=0; i < ARRAY_SIZE(tests); i++) {
+		torture_assert(tctx,
+			test_AddPerMachineConnection(tctx, b,
+						     tests[i].servername,
+						     tests[i].printername,
+						     tests[i].printserver,
+						     tests[i].provider,
+						     tests[i].expected_add_result),
+			"add per machine connection failed");
+		torture_assert(tctx,
+			test_EnumPerMachineConnections(tctx, b,
+						       tests[i].servername),
+			"enum per machine connections failed");
+		torture_assert(tctx,
+			test_DeletePerMachineConnection(tctx, b,
+							tests[i].servername,
+							tests[i].printername,
+							tests[i].expected_del_result),
+			"delete per machine connection failed");
+		torture_assert(tctx,
+			test_EnumPerMachineConnections(tctx, b,
+						       tests[i].servername),
+			"enum per machine connections failed");
+	}
+
+	return true;
+}
+
 static bool test_GetChangeID_PrinterData(struct torture_context *tctx,
 					 struct dcerpc_binding_handle *b,
 					 struct policy_handle *handle,
@@ -7968,7 +8168,7 @@ static bool test_get_core_printer_drivers_arch_guid(struct torture_context *tctx
 {
 	struct spoolss_GetCorePrinterDrivers r;
 	struct spoolss_CorePrinterDriver core_printer_drivers;
-	DATA_BLOB blob;
+	DATA_BLOB blob = data_blob_talloc_zero(tctx, 2);
 	const char **s;
 	struct dcerpc_binding_handle *b = p->binding_handle;
 	struct GUID guid;
@@ -7978,7 +8178,7 @@ static bool test_get_core_printer_drivers_arch_guid(struct torture_context *tctx
 	r.in.servername	= talloc_asprintf(tctx, "\\\\%s", dcerpc_server_name(p));
 	r.in.architecture = "foobar";
 	r.in.core_driver_size = 0;
-	r.in.core_driver_dependencies = "";
+	r.in.core_driver_dependencies = (uint16_t *)blob.data;
 	r.in.core_printer_driver_count = 0;
 	r.out.core_printer_drivers = &core_printer_drivers;
 
@@ -7995,8 +8195,8 @@ static bool test_get_core_printer_drivers_arch_guid(struct torture_context *tctx
 		push_reg_multi_sz(tctx, &blob, s),
 		"push_reg_multi_sz failed");
 
-	r.in.core_driver_size = blob.length;
-	r.in.core_driver_dependencies = s[0];
+	r.in.core_driver_size = blob.length/2;
+	r.in.core_driver_dependencies = (uint16_t *)blob.data;
 	r.in.core_printer_driver_count = 1;
 	r.out.core_printer_drivers = talloc_zero_array(tctx, struct spoolss_CorePrinterDriver, r.in.core_printer_driver_count);
 
@@ -8022,8 +8222,8 @@ static bool test_get_core_printer_drivers_arch_guid(struct torture_context *tctx
 		push_reg_multi_sz(tctx, &blob, s),
 		"push_reg_multi_sz failed");
 
-	r.in.core_driver_size = blob.length;
-	r.in.core_driver_dependencies = s[0];
+	r.in.core_driver_size = blob.length/2;
+	r.in.core_driver_dependencies = (uint16_t *)blob.data;
 	r.in.core_printer_driver_count = 1;
 	r.out.core_printer_drivers = talloc_zero_array(tctx, struct spoolss_CorePrinterDriver, r.in.core_printer_driver_count);
 
@@ -9654,6 +9854,7 @@ struct torture_suite *torture_rpc_spoolss(TALLOC_CTX *mem_ctx)
 	torture_tcase_add_simple_test(tcase, "get_printer", test_get_printer_printserverhandle);
 	torture_tcase_add_simple_test(tcase, "set_printer", test_set_printer_printserverhandle);
 	torture_tcase_add_simple_test(tcase, "printserver_info_winreg", test_printserver_info_winreg);
+	torture_tcase_add_simple_test(tcase, "addpermachineconnection", test_addpermachineconnection);
 
 	torture_suite_add_suite(suite, torture_rpc_spoolss_printer(suite));
 
diff --git a/source4/torture/rpc/spoolss_notify.c b/source4/torture/rpc/spoolss_notify.c
index 33d49c9092a..8c17d76cd3c 100644
--- a/source4/torture/rpc/spoolss_notify.c
+++ b/source4/torture/rpc/spoolss_notify.c
@@ -68,9 +68,6 @@ static NTSTATUS spoolss__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_
         /* unravel the NDR for the packet */
 	ndr_err = ndr_table_spoolss.calls[opnum].ndr_pull(pull, NDR_IN, *r);
 	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
-		dcerpc_log_packet(dce_call->conn->packet_log_dir,
-						  &ndr_table_spoolss, opnum, NDR_IN,
-				  &dce_call->pkt.u.request.stub_and_verifier);
 		dce_call->fault_code = DCERPC_FAULT_NDR;
 		return NT_STATUS_NET_WRITE_FAULT;
 	}
@@ -185,9 +182,6 @@ static NTSTATUS spoolss__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_
 	}
 
 	if (dce_call->fault_code != 0) {
-		dcerpc_log_packet(dce_call->conn->packet_log_dir,
-						  &ndr_table_spoolss, opnum, NDR_IN,
-				  &dce_call->pkt.u.request.stub_and_verifier);
 		return NT_STATUS_NET_WRITE_FAULT;
 	}
 	return NT_STATUS_OK;
@@ -268,6 +262,12 @@ static NTSTATUS spoolss__op_init_server(struct dcesrv_context *dce_ctx, const st
 	return NT_STATUS_OK;
 }
 
+static NTSTATUS spoolss__op_shutdown_server(struct dcesrv_context *dce_ctx,
+				const struct dcesrv_endpoint_server *ep_server)
+{
+	return NT_STATUS_OK;
+}
+
 static bool test_OpenPrinter(struct torture_context *tctx,
 			     struct dcerpc_pipe *p,
 			     struct policy_handle *handle,
@@ -464,8 +464,11 @@ static bool test_start_dcerpc_server(struct torture_context *tctx,
 	/* fill in our name */
 	ep_server.name = "spoolss";
 
+	ep_server.initialized = false;
+
 	/* fill in all the operations */
 	ep_server.init_server = spoolss__op_init_server;
+	ep_server.shutdown_server = spoolss__op_shutdown_server;
 
 	ep_server.interface_by_uuid = spoolss__op_interface_by_uuid;
 	ep_server.interface_by_name = spoolss__op_interface_by_name;
@@ -489,11 +492,15 @@ static bool test_start_dcerpc_server(struct torture_context *tctx,
 				   address, NULL);
 	torture_assert_ntstatus_ok(tctx, status, "starting smb server");
 
-	status = dcesrv_init_context(tctx, tctx->lp_ctx, endpoints,
-				     &srv_cb, &dce_ctx);
+	status = dcesrv_init_context(tctx, tctx->lp_ctx, &srv_cb, &dce_ctx);
 	torture_assert_ntstatus_ok(tctx, status,
 				   "unable to initialize DCE/RPC server");
 
+	status = dcesrv_init_ep_servers(dce_ctx, endpoints);
+	torture_assert_ntstatus_ok(tctx,
+				   status,
+				   "unable to initialize DCE/RPC ep servers");
+
 	for (e=dce_ctx->endpoint_list;e;e=e->next) {
 		status = dcesrv_add_ep(dce_ctx, tctx->lp_ctx,
 				       e, tctx->ev,
diff --git a/source4/torture/smb2/attr.c b/source4/torture/smb2/attr.c
new file mode 100644
index 00000000000..5947997c05f
--- /dev/null
+++ b/source4/torture/smb2/attr.c
@@ -0,0 +1,496 @@
+/*
+   Unix SMB/CIFS implementation.
+
+   openattr tester
+
+   Copyright (C) Andrew Tridgell 2003
+   Copyright (C) David Mulder 2019
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "includes.h"
+#include "libcli/smb2/smb2.h"
+#include "libcli/smb2/smb2_calls.h"
+#include "torture/torture.h"
+#include "libcli/security/security_descriptor.h"
+#include "torture/smb2/proto.h"
+
+static const uint32_t open_attrs_table[] = {
+		FILE_ATTRIBUTE_NORMAL,
+		FILE_ATTRIBUTE_ARCHIVE,
+		FILE_ATTRIBUTE_READONLY,
+		FILE_ATTRIBUTE_HIDDEN,
+		FILE_ATTRIBUTE_SYSTEM,
+
+		FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY,
+		FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN,
+		FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM,
+		FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN,
+		FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM,
+		FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM,
+
+		FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN,
+		FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM,
+		FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM,
+		FILE_ATTRIBUTE_HIDDEN,FILE_ATTRIBUTE_SYSTEM,
+};
+
+struct trunc_open_results {
+	unsigned int num;
+	uint32_t init_attr;
+	uint32_t trunc_attr;
+	uint32_t result_attr;
+};
+
+static const struct trunc_open_results attr_results[] = {
+	{ 0, FILE_ATTRIBUTE_NORMAL, FILE_ATTRIBUTE_NORMAL, FILE_ATTRIBUTE_ARCHIVE },
+	{ 1, FILE_ATTRIBUTE_NORMAL, FILE_ATTRIBUTE_ARCHIVE, FILE_ATTRIBUTE_ARCHIVE },
+	{ 2, FILE_ATTRIBUTE_NORMAL, FILE_ATTRIBUTE_READONLY, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY },
+	{ 16, FILE_ATTRIBUTE_ARCHIVE, FILE_ATTRIBUTE_NORMAL, FILE_ATTRIBUTE_ARCHIVE },
+	{ 17, FILE_ATTRIBUTE_ARCHIVE, FILE_ATTRIBUTE_ARCHIVE, FILE_ATTRIBUTE_ARCHIVE },
+	{ 18, FILE_ATTRIBUTE_ARCHIVE, FILE_ATTRIBUTE_READONLY, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY },
+	{ 51, FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN },
+	{ 54, FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN },
+	{ 56, FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN },
+	{ 68, FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM },
+	{ 71, FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM },
+	{ 73, FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM },
+	{ 99, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_HIDDEN,FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN },
+	{ 102, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN },
+	{ 104, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN },
+	{ 116, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM },
+	{ 119,  FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM,  FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM },
+	{ 121, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM },
+	{ 170, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_HIDDEN },
+	{ 173, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM },
+	{ 227, FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN },
+	{ 230, FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN },
+	{ 232, FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN },
+	{ 244, FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM },
+	{ 247, FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_SYSTEM },
+	{ 249, FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM }
+};
+
+static NTSTATUS smb2_setatr(struct smb2_tree *tree, const char *name,
+			    uint32_t attrib)
+{
+	NTSTATUS status;
+	struct smb2_create create_io = {0};
+	union smb_setfileinfo io;
+
+	create_io.in.desired_access = SEC_FILE_READ_DATA |
+				      SEC_FILE_WRITE_ATTRIBUTE;
+	create_io.in.file_attributes = FILE_ATTRIBUTE_NORMAL;
+	create_io.in.share_access = NTCREATEX_SHARE_ACCESS_NONE;
+	create_io.in.create_disposition = NTCREATEX_DISP_OPEN;
+	create_io.in.fname = name;
+	status = smb2_create(tree, tree, &create_io);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	ZERO_STRUCT(io);
+	io.basic_info.level = RAW_SFILEINFO_BASIC_INFORMATION;
+	io.basic_info.in.file.handle = create_io.out.file.handle;
+	io.basic_info.in.attrib = attrib;
+	status = smb2_setinfo_file(tree, &io);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	status = smb2_util_close(tree, create_io.out.file.handle);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	return status;
+}
+
+bool torture_smb2_openattrtest(struct torture_context *tctx,
+			       struct smb2_tree *tree)
+{
+	NTSTATUS status;
+	const char *fname = "openattr.file";
+	uint16_t attr;
+	unsigned int i, j, k, l;
+	int ret = true;
+
+	for (k = 0, i = 0; i < sizeof(open_attrs_table)/sizeof(uint32_t); i++) {
+		struct smb2_create create_io = {0};
+		smb2_setatr(tree, fname, FILE_ATTRIBUTE_NORMAL);
+		smb2_util_unlink(tree, fname);
+		create_io.in.create_flags = 0;
+		create_io.in.desired_access = SEC_FILE_WRITE_DATA;
+		create_io.in.file_attributes = open_attrs_table[i];
+		create_io.in.share_access = NTCREATEX_SHARE_ACCESS_NONE;
+		create_io.in.create_disposition = NTCREATEX_DISP_OVERWRITE_IF;
+		create_io.in.create_options = 0;
+		create_io.in.security_flags = 0;
+		create_io.in.fname = fname;
+		status = smb2_create(tree, tctx, &create_io);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+			talloc_asprintf(tctx, "open %d (1) of %s failed (%s)",
+			i, fname, nt_errstr(status)));
+
+		status = smb2_util_close(tree, create_io.out.file.handle);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+			talloc_asprintf(tctx, "close %d (1) of %s failed (%s)",
+			i, fname, nt_errstr(status)));
+
+		for (j = 0; j < ARRAY_SIZE(open_attrs_table); j++) {
+			create_io = (struct smb2_create){0};
+			create_io.in.create_flags = 0;
+			create_io.in.desired_access = SEC_FILE_READ_DATA|
+						      SEC_FILE_WRITE_DATA;
+			create_io.in.file_attributes = open_attrs_table[j];
+			create_io.in.share_access = NTCREATEX_SHARE_ACCESS_NONE;
+			create_io.in.create_disposition = NTCREATEX_DISP_OVERWRITE;
+			create_io.in.create_options = 0;
+			create_io.in.security_flags = 0;
+			create_io.in.fname = fname;
+			status = smb2_create(tree, tctx, &create_io);
+
+			if (!NT_STATUS_IS_OK(status)) {
+				for (l = 0; l < ARRAY_SIZE(attr_results); l++) {
+					torture_assert_goto(tctx,
+						attr_results[l].num != k,
+						ret, error_exit,
+						talloc_asprintf(tctx,
+							"[%d] trunc open 0x%x "
+							"-> 0x%x of %s failed "
+							"- should have "
+							"succeeded !(%s)",
+							k, open_attrs_table[i],
+							open_attrs_table[j],
+							fname,
+							nt_errstr(status)));
+				}
+				torture_assert_ntstatus_equal_goto(tctx,
+					status, NT_STATUS_ACCESS_DENIED,
+					ret, error_exit,
+					talloc_asprintf(tctx,
+							"[%d] trunc open 0x%x "
+							"-> 0x%x failed with "
+							"wrong error code %s",
+							k, open_attrs_table[i],
+							open_attrs_table[j],
+							nt_errstr(status)));
+				k++;
+				continue;
+			}
+
+			status = smb2_util_close(tree, create_io.out.file.handle);
+			torture_assert_ntstatus_ok_goto(tctx, status, ret,
+				error_exit, talloc_asprintf(tctx,
+					"close %d (2) of %s failed (%s)", j,
+					fname, nt_errstr(status)));
+
+			status = smb2_util_getatr(tree, fname, &attr, NULL, NULL);
+			torture_assert_ntstatus_ok_goto(tctx, status, ret,
+				error_exit, talloc_asprintf(tctx,
+					"getatr(2) failed (%s)",
+					nt_errstr(status)));
+
+			for (l = 0; l < ARRAY_SIZE(attr_results); l++) {
+				if (attr_results[l].num == k) {
+					if (attr != attr_results[l].result_attr ||
+					    open_attrs_table[i] != attr_results[l].init_attr ||
+					    open_attrs_table[j] != attr_results[l].trunc_attr) {
+						ret = false;
+						torture_fail_goto(tctx, error_exit,
+							talloc_asprintf(tctx,
+							"[%d] getatr check "
+							"failed. [0x%x] trunc "
+							"[0x%x] got attr 0x%x,"
+							" should be 0x%x",
+							k, open_attrs_table[i],
+							open_attrs_table[j],
+							(unsigned int)attr,
+							attr_results[l].result_attr));
+					}
+					break;
+				}
+			}
+			k++;
+		}
+	}
+error_exit:
+	smb2_setatr(tree, fname, FILE_ATTRIBUTE_NORMAL);
+	smb2_util_unlink(tree, fname);
+
+
+	return ret;
+}
+
+bool torture_smb2_winattrtest(struct torture_context *tctx,
+			      struct smb2_tree *tree)
+{
+	const char *fname = "winattr1.file";
+	const char *dname = "winattr1.dir";
+	uint16_t attr;
+	uint16_t j;
+	uint32_t aceno;
+	bool ret = true;
+	union smb_fileinfo query, query_org;
+	NTSTATUS status;
+	struct security_descriptor *sd1 = NULL, *sd2 = NULL;
+	struct smb2_create create_io = {0};
+	ZERO_STRUCT(query);
+	ZERO_STRUCT(query_org);
+
+	/* Test winattrs for file */
+	smb2_util_unlink(tree, fname);
+
+	/* Open a file*/
+	create_io.in.create_flags = 0;
+	create_io.in.desired_access = SEC_FILE_READ_DATA | SEC_FILE_WRITE_DATA;
+	create_io.in.file_attributes = 0;
+	create_io.in.share_access = NTCREATEX_SHARE_ACCESS_NONE;
+	create_io.in.create_disposition = FILE_SUPERSEDE;
+	create_io.in.create_options = 0;
+	create_io.in.security_flags = 0;
+	create_io.in.fname = fname;
+	status = smb2_create(tree, tctx, &create_io);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+		talloc_asprintf(tctx, "open(1) of %s failed (%s)\n",
+		fname, nt_errstr(status)));
+
+	/* Get security descriptor and store it*/
+	query_org.generic.level = RAW_FILEINFO_SEC_DESC;
+	query_org.generic.in.file.handle = create_io.out.file.handle;
+	status = smb2_getinfo_file(tree, NULL, &query_org);
+	if(!NT_STATUS_IS_OK(status)){
+		NTSTATUS s = smb2_util_close(tree, create_io.out.file.handle);
+		torture_assert_ntstatus_ok_goto(tctx, s, ret, error_exit,
+				talloc_asprintf(tctx,
+					"close(1) of %s failed (%s)\n",
+					fname, nt_errstr(s)));
+		ret = false;
+		torture_fail_goto(tctx, error_exit, talloc_asprintf(tctx,
+			"smb2_getinfo_file(1) of %s failed (%s)\n",
+			fname, nt_errstr(status)));
+	}
+	sd1 = query_org.query_secdesc.out.sd;
+
+	status = smb2_util_close(tree, create_io.out.file.handle);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+		       talloc_asprintf(tctx, "close(1) of %s failed (%s)\n",
+				       fname, nt_errstr(status)));
+
+	/*Set and get attributes*/
+	for (j = 0; j < ARRAY_SIZE(open_attrs_table); j++) {
+		status = smb2_setatr(tree, fname, open_attrs_table[j]);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret,
+			error_exit,
+			talloc_asprintf(tctx, "setatr(2) failed (%s)",
+				nt_errstr(status)));
+
+		status = smb2_util_getatr(tree, fname, &attr, NULL, NULL);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret,
+			error_exit,
+			talloc_asprintf(tctx, "getatr(2) failed (%s)",
+			nt_errstr(status)));
+
+		/* Check the result */
+		torture_assert_goto(tctx, attr == open_attrs_table[j], ret,
+			error_exit, talloc_asprintf(tctx,
+				"getatr check failed. \
+				Attr applied [0x%x],got attr 0x%x, \
+				should be 0x%x ", open_attrs_table[j],
+				(uint16_t)attr, open_attrs_table[j]));
+
+		create_io = (struct smb2_create){0};
+		create_io.in.create_flags = 0;
+		create_io.in.desired_access = SEC_FILE_READ_ATTRIBUTE;
+		create_io.in.file_attributes = 0;
+		create_io.in.share_access = NTCREATEX_SHARE_ACCESS_NONE;
+		create_io.in.create_disposition = FILE_OPEN_IF;
+		create_io.in.create_options = 0;
+		create_io.in.security_flags = 0;
+		create_io.in.fname = fname;
+		status = smb2_create(tree, tctx, &create_io);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret,
+			error_exit,
+			talloc_asprintf(tctx, "open(2) of %s failed (%s)\n",
+			fname, nt_errstr(status)));
+		/*Get security descriptor */
+		query.query_secdesc.level = RAW_FILEINFO_SEC_DESC;
+		query.query_secdesc.in.file.handle = create_io.out.file.handle;
+		status = smb2_getinfo_file(tree, tctx, &query);
+		if(!NT_STATUS_IS_OK(status)){
+			NTSTATUS s = smb2_util_close(tree, create_io.out.file.handle);
+			torture_assert_ntstatus_ok_goto(tctx, s, ret,
+				error_exit,
+				talloc_asprintf(tctx,
+					"close(2) of %s failed (%s)\n",
+					fname, nt_errstr(s)));
+			ret = false;
+			torture_fail_goto(tctx, error_exit,
+				talloc_asprintf(tctx,
+				"smb2_getinfo_file(2) of %s failed (%s)\n",
+				fname, nt_errstr(status)));
+		}
+		sd2 = query.query_secdesc.out.sd;
+
+		status = smb2_util_close(tree, create_io.out.file.handle);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+		       talloc_asprintf(tctx, "close(2) of %s failed (%s)\n",
+				       fname, nt_errstr(status)));
+
+		/*Compare security descriptors -- Must be same*/
+		for (aceno=0;(sd1->dacl&&aceno < sd1->dacl->num_aces);aceno++){
+			struct security_ace *ace1 = &sd1->dacl->aces[aceno];
+			struct security_ace *ace2 = &sd2->dacl->aces[aceno];
+
+			torture_assert_goto(tctx, security_ace_equal(ace1, ace2),
+				ret, error_exit,
+				"ACLs changed! Not expected!\n");
+		}
+
+		torture_comment(tctx, "[%d] setattr = [0x%x] got attr 0x%x\n",
+			j,  open_attrs_table[j], attr );
+
+	}
+
+
+/* Check for Directory. */
+
+	smb2_deltree(tree, dname);
+	smb2_util_rmdir(tree, dname);
+
+	/* Open a directory */
+	create_io = (struct smb2_create){0};
+	create_io.in.create_flags = 0;
+	create_io.in.desired_access = SEC_RIGHTS_DIR_ALL;
+	create_io.in.file_attributes = FILE_ATTRIBUTE_DIRECTORY;
+	create_io.in.share_access = NTCREATEX_SHARE_ACCESS_NONE;
+	create_io.in.create_disposition = NTCREATEX_DISP_OPEN_IF;
+	create_io.in.create_options = NTCREATEX_OPTIONS_DIRECTORY;
+	create_io.in.security_flags = 0;
+	create_io.in.fname = dname;
+	status = smb2_create(tree, tctx, &create_io);
+
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+			talloc_asprintf(tctx,
+			"open (1) of %s failed (%s)",
+			dname, nt_errstr(status)));
+
+
+	/* Get Security Descriptor */
+	query_org.generic.level = RAW_FILEINFO_SEC_DESC;
+	query_org.generic.in.file.handle = create_io.out.file.handle;
+	status = smb2_getinfo_file(tree, tctx, &query_org);
+	if(!NT_STATUS_IS_OK(status)){
+		NTSTATUS s = smb2_util_close(tree, create_io.out.file.handle);
+		torture_assert_ntstatus_ok_goto(tctx, s, ret, error_exit,
+				talloc_asprintf(tctx,
+					"close(1) of %s failed (%s)\n",
+					dname, nt_errstr(s)));
+		ret = false;
+		torture_fail_goto(tctx, error_exit, talloc_asprintf(tctx,
+			"smb2_getinfo_file(1) of %s failed (%s)\n", dname,
+			nt_errstr(status)));
+	}
+	sd1 = query_org.query_secdesc.out.sd;
+
+	status = smb2_util_close(tree, create_io.out.file.handle);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+				talloc_asprintf(tctx,
+				"close (1) of %s failed (%s)", dname,
+				nt_errstr(status)));
+
+	/* Set and get win attributes*/
+	for (j = 1; j < ARRAY_SIZE(open_attrs_table); j++) {
+
+		status = smb2_setatr(tree, dname, open_attrs_table[j]);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+			talloc_asprintf(tctx, "setatr(2) failed (%s)",
+				nt_errstr(status)));
+
+		status = smb2_util_getatr(tree, dname, &attr, NULL, NULL);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+			talloc_asprintf(tctx, "getatr(2) failed (%s)",
+				nt_errstr(status)));
+
+		torture_comment(tctx, "[%d] setatt = [0x%x] got attr 0x%x\n",
+			j,  open_attrs_table[j], attr );
+
+		/* Check the result */
+		torture_assert_goto(tctx,
+			attr == (open_attrs_table[j]|FILE_ATTRIBUTE_DIRECTORY),
+			ret, error_exit, talloc_asprintf(tctx,
+			"getatr check failed. set attr "
+			"[0x%x], got attr 0x%x, should be 0x%x\n",
+			open_attrs_table[j], (uint16_t)attr,
+			(unsigned int)(open_attrs_table[j]|FILE_ATTRIBUTE_DIRECTORY)));
+
+		create_io = (struct smb2_create){0};
+		create_io.in.create_flags = 0;
+		create_io.in.desired_access = SEC_RIGHTS_DIR_READ;
+		create_io.in.file_attributes = FILE_ATTRIBUTE_DIRECTORY;
+		create_io.in.share_access = NTCREATEX_SHARE_ACCESS_NONE;
+		create_io.in.create_disposition = NTCREATEX_DISP_OPEN;
+		create_io.in.create_options = 0;
+		create_io.in.security_flags = 0;
+		create_io.in.fname = dname;
+		status = smb2_create(tree, tctx, &create_io);
+
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+			talloc_asprintf(tctx,
+			"open (2) of %s failed (%s)",
+			dname, nt_errstr(status)));
+		/* Get security descriptor */
+		query.generic.level = RAW_FILEINFO_SEC_DESC;
+		query.generic.in.file.handle = create_io.out.file.handle;
+		status = smb2_getinfo_file(tree, tctx, &query);
+		if(!NT_STATUS_IS_OK(status)){
+			NTSTATUS s = smb2_util_close(tree, create_io.out.file.handle);
+			torture_assert_ntstatus_ok_goto(tctx, s, ret, error_exit,
+					talloc_asprintf(tctx,
+					"close (2) of %s failed (%s)", dname,
+					nt_errstr(s)));
+			ret = false;
+			torture_fail_goto(tctx, error_exit,
+				talloc_asprintf(tctx,
+				"smb2_getinfo_file(2) of %s failed(%s)\n",
+				dname, nt_errstr(status)));
+		}
+		sd2 = query.query_secdesc.out.sd;
+		status = smb2_util_close(tree, create_io.out.file.handle);
+		torture_assert_ntstatus_ok_goto(tctx, status, ret, error_exit,
+				talloc_asprintf(tctx,
+				"close (2) of %s failed (%s)", dname,
+				nt_errstr(status)));
+
+		/* Security descriptor must be same*/
+		for (aceno=0;(sd1->dacl&&aceno < sd1->dacl->num_aces);aceno++){
+			struct security_ace *ace1 = &sd1->dacl->aces[aceno];
+			struct security_ace *ace2 = &sd2->dacl->aces[aceno];
+
+			torture_assert_goto(tctx, security_ace_equal(ace1, ace2),
+				ret, error_exit,
+				"ACLs changed! Not expected!\n");
+		}
+
+	}
+
+error_exit:
+	smb2_setatr(tree, fname, FILE_ATTRIBUTE_NORMAL);
+	smb2_util_unlink(tree, fname);
+	smb2_deltree(tree, dname);
+	smb2_util_rmdir(tree, dname);
+
+	return ret;
+}
diff --git a/source4/torture/smb2/durable_v2_open.c b/source4/torture/smb2/durable_v2_open.c
index 7609987e31f..b2c519db3f6 100644
--- a/source4/torture/smb2/durable_v2_open.c
+++ b/source4/torture/smb2/durable_v2_open.c
@@ -1277,7 +1277,7 @@ bool test_durable_v2_open_reopen2_lease(struct torture_context *tctx,
 
 	smb2_util_unlink(tree, fname);
 
-	lease_key = random();
+	lease_key = generate_random_u64();
 	smb2_lease_create(&io, &ls, false /* dir */, fname,
 			  lease_key, smb2_util_lease_state("RWH"));
 	io.in.durable_open = false;
@@ -2058,7 +2058,9 @@ static bool test_durable_v2_reconnect_delay(struct torture_context *tctx,
 	previous_session_id = smb2cli_session_current_id(tree->session->smbXcli);
 
 	/* Choose a random name in case the state is left a little funky. */
-	snprintf(fname, 256, "durable_v2_reconnect_delay_%s.dat",
+	snprintf(fname,
+		 sizeof(fname),
+		 "durable_v2_reconnect_delay_%s.dat",
 		 generate_random_str(tctx, 8));
 
 	smb2_util_unlink(tree, fname);
@@ -2120,12 +2122,108 @@ done:
 	return ret;
 }
 
+/**
+ * basic test for doing a durable open with 1msec cleanup time
+ * tcp disconnect, wait a bit, reconnect, do a durable reopen (fails)
+ */
+static bool test_durable_v2_reconnect_delay_msec(
+	struct torture_context *tctx, struct smb2_tree *tree)
+{
+	NTSTATUS status;
+	TALLOC_CTX *mem_ctx = talloc_new(tctx);
+	char fname[256];
+	struct smb2_handle _h;
+	struct smb2_handle *h = NULL;
+	struct smb2_create io;
+	struct smb2_lease ls;
+	struct GUID create_guid = GUID_random();
+	struct smbcli_options options;
+	uint64_t previous_session_id;
+	uint8_t b = 0;
+	bool ret = true;
+
+	options = tree->session->transport->options;
+	previous_session_id = smb2cli_session_current_id(tree->session->smbXcli);
+
+	/* Choose a random name in case the state is left a little funky. */
+	snprintf(fname,
+		 sizeof(fname),
+		 "durable_v2_reconnect_delay_%s.dat",
+		 generate_random_str(tctx, 8));
+
+	smb2_util_unlink(tree, fname);
+
+	smb2_lease_create(
+		&io,
+		&ls,
+		false /* dir */,
+		fname,
+		generate_random_u64(),
+		smb2_util_lease_state("RWH"));
+	io.in.durable_open = false;
+	io.in.durable_open_v2 = true;
+	io.in.persistent_open = false;
+	io.in.create_guid = create_guid;
+	io.in.timeout = 1;
+
+	status = smb2_create(tree, mem_ctx, &io);
+	CHECK_STATUS(status, NT_STATUS_OK);
+
+	_h = io.out.file.handle;
+	h = &_h;
+	CHECK_VAL(io.out.oplock_level, SMB2_OPLOCK_LEVEL_LEASE);
+	CHECK_VAL(io.out.durable_open_v2, true);
+
+	status = smb2_util_write(tree, *h, &b, 0, 1);
+	CHECK_STATUS(status, NT_STATUS_OK);
+
+	/* disconnect, leaving the durable open */
+	TALLOC_FREE(tree);
+
+	if (!torture_smb2_connection_ext(tctx, previous_session_id,
+					 &options, &tree)) {
+		torture_warning(tctx, "couldn't reconnect, bailing\n");
+		ret = false;
+		goto done;
+	}
+
+	sleep(10);
+
+	ZERO_STRUCT(io);
+	io.in.fname = fname;
+	io.in.durable_open_v2 = false;
+	io.in.durable_handle_v2 = h;
+	io.in.create_guid = create_guid;
+	h = NULL;
+
+	status = smb2_create(tree, mem_ctx, &io);
+	CHECK_STATUS(status, NT_STATUS_OBJECT_NAME_NOT_FOUND);
+	_h = io.out.file.handle;
+	h = &_h;
+
+done:
+	if (h != NULL) {
+		smb2_util_close(tree, *h);
+	}
+
+	smb2_util_unlink(tree, fname);
+
+	talloc_free(tree);
+
+	talloc_free(mem_ctx);
+
+	return ret;
+}
+
 struct torture_suite *torture_smb2_durable_v2_delay_init(TALLOC_CTX *ctx)
 {
 	struct torture_suite *suite =
 	    torture_suite_create(ctx, "durable-v2-delay");
 
 	torture_suite_add_1smb2_test(suite, "durable_v2_reconnect_delay", test_durable_v2_reconnect_delay);
+	torture_suite_add_1smb2_test(suite,
+				     "durable_v2_reconnect_delay_msec",
+				     test_durable_v2_reconnect_delay_msec);
 
 	return suite;
 }
diff --git a/source4/torture/smb2/read_write.c b/source4/torture/smb2/read_write.c
new file mode 100644
index 00000000000..bc8898cec31
--- /dev/null
+++ b/source4/torture/smb2/read_write.c
@@ -0,0 +1,163 @@
+/*
+   Unix SMB/CIFS implementation.
+   SMB read/write torture tester
+   Copyright (C) Andrew Tridgell 1997-2003
+   Copyright (C) Jelmer Vernooij 2006
+   Copyright (C) David Mulder 2019
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "includes.h"
+#include "torture/smbtorture.h"
+#include "libcli/smb2/smb2.h"
+#include "libcli/smb2/smb2_calls.h"
+#include "torture/torture.h"
+#include "torture/smb2/proto.h"
+
+static bool run_smb2_readwritetest(struct torture_context *tctx,
+				   struct smb2_tree *t1, struct smb2_tree *t2)
+{
+	const char *lockfname = "torture2.lck";
+	struct smb2_create f1 = {0};
+	struct smb2_create f2 = {0};
+	struct smb2_handle h1 = {{0}};
+	struct smb2_handle h2 = {{0}};
+	int i;
+	uint8_t buf[131072];
+	bool correct = true;
+	NTSTATUS status;
+	int ret = 0;
+
+	ret = smb2_deltree(t1, lockfname);
+	torture_assert(tctx, ret != -1, "unlink failed");
+
+	f1.in.desired_access = SEC_FILE_ALL;
+	f1.in.share_access = NTCREATEX_SHARE_ACCESS_READ |
+			     NTCREATEX_SHARE_ACCESS_WRITE;
+	f1.in.create_disposition = FILE_CREATE;
+	f1.in.fname = lockfname;
+
+	status = smb2_create(t1, tctx, &f1);
+	torture_assert_ntstatus_ok_goto(tctx, status, correct, done,
+		talloc_asprintf(tctx, "first open read/write of %s failed (%s)",
+		lockfname, nt_errstr(status)));
+	h1 = f1.out.file.handle;
+
+	f2.in.desired_access = SEC_FILE_READ_DATA;
+	f2.in.share_access = NTCREATEX_SHARE_ACCESS_READ |
+			     NTCREATEX_SHARE_ACCESS_WRITE;
+	f2.in.create_disposition = FILE_OPEN;
+	f2.in.fname = lockfname;
+
+	status = smb2_create(t2, tctx, &f2);
+	torture_assert_ntstatus_ok_goto(tctx, status, correct, done,
+		talloc_asprintf(tctx, "second open read-only of %s failed (%s)",
+		lockfname, nt_errstr(status)));
+	h2 = f2.out.file.handle;
+
+	torture_comment(tctx, "Checking data integrity over %d ops\n",
+			torture_numops);
+
+	for (i = 0; i < torture_numops; i++) {
+		struct smb2_write w = {0};
+		struct smb2_read r = {0};
+		size_t buf_size = ((unsigned int)random()%(sizeof(buf)-1))+ 1;
+
+		if (i % 10 == 0) {
+			if (torture_setting_bool(tctx, "progress", true)) {
+				torture_comment(tctx, "%d\r", i); fflush(stdout);
+			}
+		}
+
+		generate_random_buffer(buf, buf_size);
+
+		w.in.file.handle = h1;
+		w.in.offset = 0;
+		w.in.data.data = buf;
+		w.in.data.length = buf_size;
+
+		status = smb2_write(t1, &w);
+		if (!NT_STATUS_IS_OK(status) || w.out.nwritten != buf_size) {
+			torture_comment(tctx, "write failed (%s)\n",
+					nt_errstr(status));
+			torture_result(tctx, TORTURE_FAIL,
+				       "wrote %d, expected %d\n",
+				       (int)w.out.nwritten, (int)buf_size);
+			correct = false;
+			goto done;
+		}
+
+		r.in.file.handle = h2;
+		r.in.offset = 0;
+		r.in.length = buf_size;
+		status = smb2_read(t2, tctx, &r);
+		if (!NT_STATUS_IS_OK(status) || r.out.data.length != buf_size) {
+			torture_comment(tctx, "read failed (%s)\n",
+					nt_errstr(status));
+			torture_result(tctx, TORTURE_FAIL,
+				       "read %d, expected %d\n",
+				       (int)r.out.data.length, (int)buf_size);
+			correct = false;
+			goto done;
+		}
+
+		torture_assert_mem_equal_goto(tctx, r.out.data.data, buf,
+			buf_size, correct, done, "read/write compare failed\n");
+	}
+
+	status = smb2_util_close(t2, h2);
+	torture_assert_ntstatus_ok_goto(tctx, status, correct, done,
+		talloc_asprintf(tctx, "close failed (%s)", nt_errstr(status)));
+	ZERO_STRUCT(h2);
+
+	status = smb2_util_close(t1, h1);
+	torture_assert_ntstatus_ok_goto(tctx, status, correct, done,
+		talloc_asprintf(tctx, "close failed (%s)", nt_errstr(status)));
+	ZERO_STRUCT(h1);
+
+done:
+	if (!smb2_util_handle_empty(h2)) {
+		smb2_util_close(t2, h2);
+	}
+	if (!smb2_util_handle_empty(h1)) {
+		smb2_util_close(t1, h1);
+	}
+
+	status = smb2_util_unlink(t1, lockfname);
+	if (!NT_STATUS_IS_OK(status)) {
+		torture_comment(tctx, "unlink failed (%s)", nt_errstr(status));
+	}
+
+	return correct;
+}
+
+
+static bool run_smb2_wrap_readwritetest(struct torture_context *tctx,
+					struct smb2_tree *tree1,
+					struct smb2_tree *tree2)
+{
+	return run_smb2_readwritetest(tctx, tree1, tree1);
+}
+
+struct torture_suite *torture_smb2_readwrite_init(TALLOC_CTX *ctx)
+{
+	struct torture_suite *suite = torture_suite_create(ctx, "rw");
+
+	torture_suite_add_2smb2_test(suite, "rw1", run_smb2_readwritetest);
+	torture_suite_add_2smb2_test(suite, "rw2", run_smb2_wrap_readwritetest);
+
+	suite->description = talloc_strdup(suite, "SMB2 Samba4 Read/Write");
+
+	return suite;
+}
diff --git a/source4/torture/smb2/sharemode.c b/source4/torture/smb2/sharemode.c
index 5b1b8c4afba..6a581cd60ab 100644
--- a/source4/torture/smb2/sharemode.c
+++ b/source4/torture/smb2/sharemode.c
@@ -545,7 +545,7 @@ done:
 
 /*
  * Test conflicting sharemodes through SMB2: First open file with
- * different access masks, second open requests potentially conflict
+ * different access masks, second open requests potentially conflicting
  * sharemode.
  */
 static bool test_smb2_access_sharemode(struct torture_context *tctx,
diff --git a/source4/torture/smb2/smb2.c b/source4/torture/smb2/smb2.c
index 7cca19e65d3..c258c15ff91 100644
--- a/source4/torture/smb2/smb2.c
+++ b/source4/torture/smb2/smb2.c
@@ -197,6 +197,10 @@ NTSTATUS torture_smb2_init(TALLOC_CTX *ctx)
 	torture_suite_add_suite(suite, torture_smb2_doc_init(suite));
 	torture_suite_add_suite(suite, torture_smb2_multichannel_init(suite));
 	torture_suite_add_suite(suite, torture_smb2_samba3misc_init(suite));
+	torture_suite_add_suite(suite, torture_smb2_timestamps_init(suite));
+	torture_suite_add_1smb2_test(suite, "openattr", torture_smb2_openattrtest);
+	torture_suite_add_1smb2_test(suite, "winattr", torture_smb2_winattrtest);
+	torture_suite_add_suite(suite, torture_smb2_readwrite_init(suite));
 
 	suite->description = talloc_strdup(suite, "SMB2-specific tests");
 
diff --git a/source4/torture/smb2/timestamps.c b/source4/torture/smb2/timestamps.c
new file mode 100644
index 00000000000..9655e5bc164
--- /dev/null
+++ b/source4/torture/smb2/timestamps.c
@@ -0,0 +1,309 @@
+/*
+   Unix SMB/CIFS implementation.
+
+   test timestamps
+
+   Copyright (C) Ralph Boehme 2019
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "includes.h"
+#include "libcli/smb2/smb2.h"
+#include "libcli/smb2/smb2_calls.h"
+#include "torture/torture.h"
+#include "torture/util.h"
+#include "torture/smb2/proto.h"
+
+#define BASEDIR "smb2-timestamps"
+
+static bool test_time_t(struct torture_context *tctx,
+			struct smb2_tree *tree,
+			const char *fname,
+			time_t t)
+{
+	char *filename = NULL;
+	struct smb2_create cr;
+	struct smb2_handle handle = {{0}};
+	struct smb2_handle testdirh = {{0}};
+	struct timespec ts = { .tv_sec = t };
+	uint64_t nttime;
+	union smb_fileinfo gi;
+	union smb_setfileinfo si;
+	struct smb2_find find;
+	unsigned int count;
+	union smb_search_data *d;
+	NTSTATUS status;
+	bool ret = true;
+
+	smb2_deltree(tree, BASEDIR);
+
+	status = torture_smb2_testdir(tree, BASEDIR, &testdirh);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"torture_smb2_testdir failed\n");
+
+	filename = talloc_asprintf(tctx, "%s\\%s", BASEDIR, fname);
+	torture_assert_not_null_goto(tctx, filename, ret, done,
+				     "talloc_asprintf failed\n");
+
+	cr = (struct smb2_create) {
+		.in.desired_access = SEC_FLAG_MAXIMUM_ALLOWED,
+		.in.file_attributes = FILE_ATTRIBUTE_NORMAL,
+		.in.share_access = NTCREATEX_SHARE_ACCESS_MASK,
+		.in.create_disposition = NTCREATEX_DISP_OPEN_IF,
+		.in.impersonation_level = NTCREATEX_IMPERSONATION_ANONYMOUS,
+		.in.fname = filename,
+	};
+
+	status = smb2_create(tree, tctx, &cr);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_create failed\n");
+	handle = cr.out.file.handle;
+
+	si = (union smb_setfileinfo) {
+		.basic_info.level = RAW_SFILEINFO_BASIC_INFORMATION,
+		.basic_info.in.file.handle = handle,
+	};
+
+	nttime = full_timespec_to_nt_time(&ts);
+	si.basic_info.in.create_time = nttime;
+	si.basic_info.in.write_time = nttime;
+	si.basic_info.in.change_time = nttime;
+
+	status = smb2_setinfo_file(tree, &si);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_setinfo_file failed\n");
+
+	gi = (union smb_fileinfo) {
+		.generic.level = SMB_QFILEINFO_BASIC_INFORMATION,
+		.generic.in.file.handle = handle,
+	};
+
+	status = smb2_getinfo_file(tree, tctx, &gi);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_getinfo_file failed\n");
+
+	torture_comment(tctx, "Got: create: %s, write: %s, change: %s\n",
+			nt_time_string(tctx, gi.basic_info.out.create_time),
+			nt_time_string(tctx, gi.basic_info.out.write_time),
+			nt_time_string(tctx, gi.basic_info.out.change_time));
+
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      gi.basic_info.out.create_time,
+				      ret, done,
+				      "Wrong create time\n");
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      gi.basic_info.out.write_time,
+				      ret, done,
+				      "Wrong write time\n");
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      gi.basic_info.out.change_time,
+				      ret, done,
+				      "Wrong change time\n");
+
+	find = (struct smb2_find) {
+		.in.file.handle = testdirh,
+		.in.pattern = fname,
+		.in.max_response_size = 0x1000,
+		.in.level = SMB2_FIND_ID_BOTH_DIRECTORY_INFO,
+	};
+
+	status = smb2_find_level(tree, tree, &find, &count, &d);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_find_level failed\n");
+
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      d[0].id_both_directory_info.create_time,
+				      ret, done,
+				      "Wrong create time\n");
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      d[0].id_both_directory_info.write_time,
+				      ret, done,
+				      "Wrong write time\n");
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      d[0].id_both_directory_info.change_time,
+				      ret, done,
+				      "Wrong change time\n");
+
+	status = smb2_util_close(tree, handle);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_util_close failed\n");
+	ZERO_STRUCT(handle);
+
+	cr = (struct smb2_create) {
+		.in.desired_access = SEC_FLAG_MAXIMUM_ALLOWED,
+		.in.file_attributes = FILE_ATTRIBUTE_NORMAL,
+		.in.share_access = NTCREATEX_SHARE_ACCESS_MASK,
+		.in.create_disposition = NTCREATEX_DISP_OPEN,
+		.in.impersonation_level = NTCREATEX_IMPERSONATION_ANONYMOUS,
+		.in.fname = filename,
+	};
+
+	status = smb2_create(tree, tctx, &cr);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_create failed\n");
+	handle = cr.out.file.handle;
+
+	gi = (union smb_fileinfo) {
+		.generic.level = SMB_QFILEINFO_BASIC_INFORMATION,
+		.generic.in.file.handle = handle,
+	};
+
+	status = smb2_getinfo_file(tree, tctx, &gi);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_getinfo_file failed\n");
+
+	torture_comment(tctx, "Got: create: %s, write: %s, change: %s\n",
+			nt_time_string(tctx, gi.basic_info.out.create_time),
+			nt_time_string(tctx, gi.basic_info.out.write_time),
+			nt_time_string(tctx, gi.basic_info.out.change_time));
+
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      gi.basic_info.out.create_time,
+				      ret, done,
+				      "Wrong create time\n");
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      gi.basic_info.out.write_time,
+				      ret, done,
+				      "Wrong write time\n");
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      gi.basic_info.out.change_time,
+				      ret, done,
+				      "Wrong change time\n");
+
+	find = (struct smb2_find) {
+		.in.continue_flags = SMB2_CONTINUE_FLAG_RESTART,
+		.in.file.handle = testdirh,
+		.in.pattern = fname,
+		.in.max_response_size = 0x1000,
+		.in.level = SMB2_FIND_ID_BOTH_DIRECTORY_INFO,
+	};
+
+	status = smb2_find_level(tree, tree, &find, &count, &d);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_find_level failed\n");
+
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      d[0].id_both_directory_info.create_time,
+				      ret, done,
+				      "Wrong create time\n");
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      d[0].id_both_directory_info.write_time,
+				      ret, done,
+				      "Wrong write time\n");
+	torture_assert_u64_equal_goto(tctx,
+				      nttime,
+				      d[0].id_both_directory_info.change_time,
+				      ret, done,
+				      "Wrong change time\n");
+
+	status = smb2_util_close(tree, handle);
+	torture_assert_ntstatus_ok_goto(tctx, status, ret, done,
+					"smb2_util_close failed\n");
+	ZERO_STRUCT(handle);
+
+done:
+	if (!smb2_util_handle_empty(handle)) {
+		smb2_util_close(tree, handle);
+	}
+	if (!smb2_util_handle_empty(testdirh)) {
+		smb2_util_close(tree, testdirh);
+	}
+	smb2_deltree(tree, BASEDIR);
+	return ret;
+}
+
+static bool test_time_t_100000000000(struct torture_context *tctx,
+				    struct smb2_tree *tree)
+{
+	return test_time_t(tctx, tree, "test_time_t_100000000000.txt",
+			   100000000000 /* >> INT32_MAX */);
+}
+
+static bool test_time_t_10000000000(struct torture_context *tctx,
+				    struct smb2_tree *tree)
+{
+	return test_time_t(tctx, tree, "test_time_t_10000000000.txt",
+			   10000000000 /* >> INT32_MAX */);
+}
+
+static bool test_time_t_4294967295(struct torture_context *tctx,
+				   struct smb2_tree *tree)
+{
+	return test_time_t(tctx, tree, "test_time_t_4294967295.txt",
+			   4294967295 /* INT32_MAX */);
+}
+
+static bool test_time_t_1(struct torture_context *tctx,
+			  struct smb2_tree *tree)
+{
+	return test_time_t(tctx, tree, "test_time_t_1.txt", 1);
+}
+
+static bool test_time_t_0(struct torture_context *tctx,
+			  struct smb2_tree *tree)
+{
+	return test_time_t(tctx, tree, "test_time_t_0.txt", 0);
+}
+
+static bool test_time_t_minus_1(struct torture_context *tctx,
+				struct smb2_tree *tree)
+{
+	return test_time_t(tctx, tree, "test_time_t_-1.txt", -1);
+}
+
+static bool test_time_t_minus_2(struct torture_context *tctx,
+				struct smb2_tree *tree)
+{
+	return test_time_t(tctx, tree, "test_time_t_-2.txt", -2);
+}
+
+static bool test_time_t_1968(struct torture_context *tctx,
+			     struct smb2_tree *tree)
+{
+	return test_time_t(tctx, tree, "test_time_t_1968.txt",
+			   -63158400 /* 1968 */);
+}
+
+/*
+   basic testing of SMB2 timestamps
+*/
+struct torture_suite *torture_smb2_timestamps_init(TALLOC_CTX *ctx)
+{
+	struct torture_suite *suite = torture_suite_create(ctx, "timestamps");
+
+	torture_suite_add_1smb2_test(suite, "time_t_100000000000", test_time_t_100000000000);
+	torture_suite_add_1smb2_test(suite, "time_t_10000000000", test_time_t_10000000000);
+	torture_suite_add_1smb2_test(suite, "time_t_4294967295", test_time_t_4294967295);
+	torture_suite_add_1smb2_test(suite, "time_t_1", test_time_t_1);
+	torture_suite_add_1smb2_test(suite, "time_t_0", test_time_t_0);
+	torture_suite_add_1smb2_test(suite, "time_t_-1", test_time_t_minus_1);
+	torture_suite_add_1smb2_test(suite, "time_t_-2", test_time_t_minus_2);
+	torture_suite_add_1smb2_test(suite, "time_t_1968", test_time_t_1968);
+
+	suite->description = talloc_strdup(suite, "SMB2 timestamp tests");
+
+	return suite;
+}
diff --git a/source4/torture/smb2/wscript_build b/source4/torture/smb2/wscript_build
index 8b17cfb36d4..873fcd60364 100644
--- a/source4/torture/smb2/wscript_build
+++ b/source4/torture/smb2/wscript_build
@@ -3,6 +3,7 @@
 bld.SAMBA_MODULE('TORTURE_SMB2',
 	source='''
         acls.c
+        attr.c
         block.c
         compound.c
         connect.c
@@ -26,6 +27,7 @@ bld.SAMBA_MODULE('TORTURE_SMB2',
         notify_disabled.c
         oplock.c
         read.c
+        read_write.c
         rename.c
         replay.c
         scan.c
@@ -35,6 +37,7 @@ bld.SAMBA_MODULE('TORTURE_SMB2',
         smb2.c
         streams.c
         samba3misc.c
+        timestamps.c
         util.c
         ''',
 	subsystem='smbtorture',
diff --git a/source4/utils/oLschema2ldif/test.c b/source4/utils/oLschema2ldif/test.c
index 6748ce08c33..3834ea462fd 100644
--- a/source4/utils/oLschema2ldif/test.c
+++ b/source4/utils/oLschema2ldif/test.c
@@ -19,6 +19,7 @@
 
 #include <stdarg.h>
 #include <stddef.h>
+#include <stdint.h>
 #include <setjmp.h>
 #include <cmocka.h>
 
diff --git a/testprogs/blackbox/test_s4u_heimdal.sh b/testprogs/blackbox/test_s4u_heimdal.sh
new file mode 100755
index 00000000000..0e12c7ec096
--- /dev/null
+++ b/testprogs/blackbox/test_s4u_heimdal.sh
@@ -0,0 +1,73 @@
+#!/bin/sh
+
+if [ $# -lt 5 ]; then
+cat <<EOF
+Usage: test_kinit.sh SERVER USERNAME PASSWORD REALM DOMAIN PREFIX
+EOF
+exit 1;
+fi
+
+SERVER=$1
+USERNAME=$2
+PASSWORD=$3
+REALM=$4
+DOMAIN=$5
+PREFIX=$6
+shift 6
+failed=0
+
+
+samba_tool="$VALGRIND $PYTHON $BINDIR/samba-tool"
+
+samba4kinit=kinit
+if test -x $BINDIR/samba4kinit; then
+	samba4kinit=$BINDIR/samba4kinit
+fi
+
+samba4kgetcred=kgetcred
+if test -x $BINDIR/samba4kgetcred; then
+	samba4kgetcred=$BINDIR/samba4kgetcred
+fi
+
+. `dirname $0`/subunit.sh
+. `dirname $0`/common_test_fns.inc
+
+ocache="$PREFIX/tmpoutcache"
+KRB5CCNAME_PATH="$PREFIX/tmpccache"
+KRB5CCNAME="FILE:$KRB5CCNAME_PATH"
+export KRB5CCNAME
+rm -rf $KRB5CCNAME_PATH
+
+princ=test_impersonate_princ
+impersonator=test_impersonator
+target="CIFS/$SERVER.$REALM"
+
+
+testit "add impersonator principal" $samba_tool user add $impersonator $PASSWORD || failed=`expr $failed + 1`
+testit "become a service" $samba_tool spn add "HOST/$impersonator" $impersonator || failed=`expr $failed + 1`
+
+testit "set TrustedToAuthForDelegation" $samba_tool delegation for-any-protocol $impersonator on || failed=`expr $failed + 1`
+testit "add msDS-AllowedToDelegateTo" $samba_tool delegation add-service $impersonator $target || failed=`expr $failed + 1`
+
+testit "add a new principal" $samba_tool user add $princ --random-password || failed=`expr $failed + 1`
+testit "set not-delegated flag" $samba_tool user sensitive $princ on || failed=`expr $failed + 1`
+
+
+echo $PASSWORD > $PREFIX/tmppassfile
+testit "kinit with password" $samba4kinit -f --password-file=$PREFIX/tmppassfile $impersonator || failed=`expr $failed + 1`
+
+testit "test S4U2Self with normal user" $samba4kgetcred --out-cache=$ocache --forwardable --impersonate=${USERNAME} $impersonator || failed=`expr $failed + 1`
+testit "test S4U2Proxy with normal user" $samba4kgetcred --out-cache=$ocache --delegation-credential-cache=${ocache} $target || failed=`expr $failed + 1`
+
+testit "test S4U2Self with sensitive user" $samba4kgetcred --out-cache=$ocache --forwardable --impersonate=$princ $impersonator || failed=`expr $failed + 1`
+testit_expect_failure "test S4U2Proxy with sensitive user" $samba4kgetcred --out-cache=$ocache --delegation-credential-cache=${ocache} $target || failed=`expr $failed + 1`
+
+rm -f $ocache
+testit "unset not-delegated flag" $samba_tool user sensitive $princ off || failed=`expr $failed + 1`
+
+testit "test S4U2Self after unsetting ND flag" $samba4kgetcred --out-cache=$ocache --forwardable --impersonate=$princ $impersonator || failed=`expr $failed + 1`
+testit "test S4U2Proxy after unsetting ND flag" $samba4kgetcred --out-cache=$ocache --delegation-credential-cache=${ocache} $target || failed=`expr $failed + 1`
+
+
+rm -f $ocache $PREFIX/tmpccache tmppassfile
+exit $failed
diff --git a/third_party/aesni-intel/wscript b/third_party/aesni-intel/wscript
index 955b5162140..382b3c6a7ff 100644
--- a/third_party/aesni-intel/wscript
+++ b/third_party/aesni-intel/wscript
@@ -21,7 +21,8 @@ def configure(conf):
             raise Errors.WafError('--accel-aes=intelaesni selected and linker rejects -z noexecstack')
 
 def build(bld):
-    if not bld.CONFIG_SET('HAVE_AESNI_INTEL'):
+    if (not bld.CONFIG_SET('HAVE_AESNI_INTEL') or
+        bld.CONFIG_SET('HAVE_GNUTLS_AES_CMAC')):
         return
 
     bld.SAMBA_LIBRARY('aesni-intel',
diff --git a/wscript_build b/wscript_build
index f9e033c0dab..b2e32987acb 100644
--- a/wscript_build
+++ b/wscript_build
@@ -38,6 +38,11 @@ bld.CONFIGURE_FILE('docs-xml/build/DTD/samba.build.version',
                    DOC_VERSION=bld.env.DOC_VERSION)
 bld.RECURSE('docs-xml')
 
+# This needs to be earlier than anything containing IDL
+# That in turn allows the build rules for fuzz_ndr_X to be
+# near the code
+bld.RECURSE('lib/fuzzing')
+
 bld.RECURSE('lib/replace')
 bld.RECURSE('lib/socket')
 bld.RECURSE('lib/talloc')
@@ -150,7 +155,6 @@ bld.RECURSE('dfs_server')
 bld.RECURSE('file_server')
 bld.RECURSE('lib/krb5_wrap')
 bld.RECURSE('packaging')
-bld.RECURSE('lib/fuzzing')
 
 bld.RECURSE('testsuite/headers')
 
diff --git a/wscript_configure_system_gnutls b/wscript_configure_system_gnutls
index f6d9ac3c65e..b2b955f3c90 100644
--- a/wscript_configure_system_gnutls
+++ b/wscript_configure_system_gnutls
@@ -1,5 +1,8 @@
 from waflib import Options
 
+def parse_version(v):
+    return tuple(map(int, (v.split("."))))
+
 gnutls_min_required_version = "3.4.7"
 
 gnutls_required_version = gnutls_min_required_version
@@ -9,14 +12,22 @@ conf.CHECK_CFG(package='gnutls',
                      msg='Checking for GnuTLS >= %s' % gnutls_required_version,
                      mandatory=True)
 
+gnutls_version = conf.cmd_and_log(conf.env.PKGCONFIG + ['--modversion', 'gnutls']).strip()
+
 # Define gnutls as a system library
 conf.SET_TARGET_TYPE('gnutls', 'SYSLIB')
 
 # Check for gnutls_pkcs7_get_embedded_data_oid (>= 3.5.5) required by libmscat
 conf.CHECK_FUNCS_IN('gnutls_pkcs7_get_embedded_data_oid', 'gnutls')
 
-# Check for gnutls_aead_cipher_encryptv2 (>= 3.6.10)
-conf.CHECK_FUNCS_IN('gnutls_aead_cipher_encryptv2', 'gnutls')
+# Check for gnutls_aead_cipher_encryptv2
+#
+# This is available since version 3.6.10, but 3.6.10 has a bug which got fixed
+# in 3.6.11, see:
+#
+#     https://gitlab.com/gnutls/gnutls/-/merge_requests/1085
+if (parse_version('3.6.10') != parse_version(gnutls_version)):
+    conf.CHECK_FUNCS_IN('gnutls_aead_cipher_encryptv2', 'gnutls')
 
 if conf.CHECK_VALUEOF('GNUTLS_CIPHER_AES_128_CFB8', headers='gnutls/gnutls.h'):
     conf.DEFINE('HAVE_GNUTLS_AES_CFB8', 1)
