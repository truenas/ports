From d1f8186627f7d505d87f2632567ea124de1e9744 Mon Sep 17 00:00:00 2001
From: Andrew Walker <awalker@ixsystems.com>
Date: Mon, 10 Oct 2022 15:08:59 -0500
Subject: [PATCH] net/rsync - add support for FreeBSD ACLs to 3.2.5

This patchset adds support for NFSv4 ACLs to rsync 3.2.
It contains a few minor optimizations from earlier versions
of this patchset in that it avoids getpwnam() and getgrnam()
calls when processing ACLs and also uses pathconf(2) to
determine ACL branding rather than opening file, and getting
ACL.
---
 acls.c        | 232 ++++++++++++++++++++++++++++++++++++++++++++++++++
 hlink.c       |   4 +
 ifuncs.h      |   3 +
 lib/sysacls.h |  10 +++
 rsync.c       |  26 +++---
 rsync.h       |  14 ++-
 6 files changed, 275 insertions(+), 14 deletions(-)

diff --git a/acls.c b/acls.c
index 12e662cf..9e6b43e0 100644
--- a/acls.c
+++ b/acls.c
@@ -54,6 +54,22 @@ extern int preserve_specials;
 
 /* === ACL structures === */
 
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+typedef struct nfs4_acl {
+	char *nfs4_acl_text;
+	ssize_t nfs4_acl_len;
+} nfs4_acl;
+
+typedef struct {
+	nfs4_acl nacl;
+	SMB_ACL_T sacl;
+} nfs4_duo;
+
+static const nfs4_acl empty_nfs4_acl = { NULL, -1 };
+static item_list nfs4_acl_list = EMPTY_ITEM_LIST;
+static size_t prior_nfs4_count = (size_t)-1;
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
+
 typedef struct {
 	id_t id;
 	uint32 access;
@@ -93,8 +109,127 @@ static item_list default_acl_list = EMPTY_ITEM_LIST;
 static size_t prior_access_count = (size_t)-1;
 static size_t prior_default_count = (size_t)-1;
 
+static const char *str_acl_type(SMB_ACL_TYPE_T type);
 /* === Calculations on ACL types === */
 
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+static nfs4_acl *create_nfs4_acl(void)
+{
+	nfs4_acl *nacl = new(nfs4_acl);
+	if (!nacl)
+		out_of_memory("create_nfs4_acl");
+	*nacl = empty_nfs4_acl;
+	return nacl;
+}
+
+static BOOL nfs4_acl_equal(const nfs4_acl *nacl1, const nfs4_acl *nacl2)
+{
+	return (strcmp(nacl1->nfs4_acl_text, nacl2->nfs4_acl_text) == 0);
+}
+
+static void nfs4_acl_free(nfs4_acl *nacl)
+{
+	if (nacl->nfs4_acl_text)
+		free(nacl->nfs4_acl_text);
+	*nacl = empty_nfs4_acl;
+}
+
+static int find_matching_nfs4_acl(const nfs4_acl *nacl, const item_list *nfs4_acl_list)
+{
+	static int nfs4_match = -1;
+	int *match = &nfs4_match;
+	size_t count = nfs4_acl_list->count;
+
+	if (*match == -1)
+		*match = nfs4_acl_list->count -1;
+	while (count--) {
+		nfs4_acl *base = nfs4_acl_list->items;
+		if (nfs4_acl_equal(base + *match, nacl))
+			return *match;
+		if (!(*match)--)
+			*match = nfs4_acl_list->count -1;
+	}
+
+	*match = -1;
+	return *match;
+}
+
+static void send_nfs4_acl(int f, nfs4_acl *nacl, item_list *nfs4_list)
+{
+	int ndx = find_matching_nfs4_acl(nacl, nfs4_list);
+
+	/* Send 0 (-1 + 1) to indicate that literal ACL data follows */
+	write_varint(f, ndx + 1);
+
+	if (ndx < 0) {
+		nfs4_acl *new_acl = EXPAND_ITEM_LIST(&nfs4_acl_list, nfs4_acl, 1000);
+
+		write_varint(f, nacl->nfs4_acl_len);
+		write_buf(f, nacl->nfs4_acl_text, nacl->nfs4_acl_len);
+
+		*new_acl = *nacl;
+		*nacl = empty_nfs4_acl;
+	}
+}
+
+static int recv_nfs4_acl(int f, item_list *nfs4_acl_list, struct file_struct *file __unused)
+{
+	nfs4_duo *duo_item = NULL;
+	int ndx = read_varint(f);
+
+	if (ndx < 0 || (size_t)ndx > nfs4_acl_list->count) {
+		rprintf(FERROR_XFER, "recv_nfs4_index: %s ACL index %d > %d\n",
+			str_acl_type(SMB_ACL_TYPE_NFS4), ndx, (int)nfs4_acl_list->count);
+		exit_cleanup(RERR_STREAMIO);
+	}
+
+	if (ndx != 0)
+		return ndx - 1;
+
+	ndx = nfs4_acl_list->count;
+	duo_item = EXPAND_ITEM_LIST(nfs4_acl_list, nfs4_duo, 1000);
+	duo_item->nacl = empty_nfs4_acl;
+
+	duo_item->nacl.nfs4_acl_len = read_varint(f);
+	duo_item->nacl.nfs4_acl_text = new_array(char, duo_item->nacl.nfs4_acl_len + 1);
+	if (!duo_item->nacl.nfs4_acl_text)
+		out_of_memory("recv_nfs4_acl");
+
+	read_buf(f, duo_item->nacl.nfs4_acl_text, duo_item->nacl.nfs4_acl_len);
+	duo_item->nacl.nfs4_acl_text[duo_item->nacl.nfs4_acl_len] = 0;
+
+	duo_item->sacl = NULL;
+	return ndx;
+}
+
+static int cache_nfs4_acl(nfs4_acl *nacl, item_list *nfs4_list)
+{
+	int ndx = -1;
+	if (nacl && ((ndx = find_matching_nfs4_acl(nacl, nfs4_list)) == -1)) {
+		nfs4_duo *new_duo = NULL;
+		ndx = nfs4_list->count;
+		new_duo = EXPAND_ITEM_LIST(nfs4_list, nfs4_duo, 1000);
+		new_duo->nacl = *nacl;
+		new_duo->sacl = NULL;
+		*nacl = empty_nfs4_acl;
+	}
+
+	return ndx;
+}
+
+static void uncache_nfs4_acls(item_list *nfs4_list, size_t start)
+{
+	nfs4_duo *nfs4_item = nfs4_list->items;
+	nfs4_duo *nfs4_start = nfs4_item + start;
+
+	while (nfs4_item-- > nfs4_start) {
+		nfs4_acl_free(&nfs4_item->nacl);
+		if (nfs4_item->sacl)
+			sys_acl_free_acl(nfs4_item->sacl);
+	}
+}
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
+
 static const char *str_acl_type(SMB_ACL_TYPE_T type)
 {
 	switch (type) {
@@ -242,6 +377,13 @@ void free_acl(stat_x *sxp)
 		free(sxp->def_acl);
 		sxp->def_acl = NULL;
 	}
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+	if (sxp->nfs4_acl) {
+		nfs4_acl_free(sxp->nfs4_acl);
+		free(sxp->nfs4_acl);
+		sxp->nfs4_acl = NULL;
+	}
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 }
 
 #ifdef SMB_ACL_NEED_SORT
@@ -537,6 +679,33 @@ static int get_rsync_acl(const char *fname, rsync_acl *racl,
 /* Return the Access Control List for the given filename. */
 int get_acl(const char *fname, stat_x *sxp)
 {
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+	int rv;
+	if ((rv = pathconf(fname, _PC_ACL_NFS4)) == 1) {
+		sxp->brand = SMB_ACL_BRAND_NFS4;
+		SMB_ACL_T sacl;
+		sacl = sys_acl_get_file(fname, SMB_ACL_TYPE_NFS4);
+		if (sacl == NULL) {
+			return -1;
+		}
+
+		sxp->nfs4_acl = create_nfs4_acl();
+		sxp->nfs4_acl->nfs4_acl_text = acl_to_text_np(
+			sacl, &sxp->nfs4_acl->nfs4_acl_len,
+			numeric_ids ? ACL_TEXT_NUMERIC_IDS : 0
+		);
+		sys_acl_free_acl(sacl);
+		return 0;
+	} else if (rv == -1) {
+		return -1;
+	}
+	if (pathconf(fname, _PC_ACL_EXTENDED) == 1) {
+		sxp->brand = SMB_ACL_BRAND_POSIX;
+	} else {
+		sxp->brand = SMB_ACL_BRAND_UNKNOWN;
+	}
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
+
 	sxp->acc_acl = create_racl();
 
 	if (S_ISREG(sxp->st.st_mode) || S_ISDIR(sxp->st.st_mode)) {
@@ -649,6 +818,13 @@ static void send_rsync_acl(int f, rsync_acl *racl, SMB_ACL_TYPE_T type,
  * This also frees the ACL data. */
 void send_acl(int f, stat_x *sxp)
 {
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+	if (sxp->brand == SMB_ACL_BRAND_NFS4) {
+		write_varint(f, SMB_ACL_TYPE_NFS4);
+		send_nfs4_acl(f, sxp->nfs4_acl, &nfs4_acl_list);
+		return;
+	}
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 	if (!sxp->acc_acl) {
 		sxp->acc_acl = create_racl();
 		rsync_acl_fake_perms(sxp->acc_acl, sxp->st.st_mode);
@@ -656,12 +832,18 @@ void send_acl(int f, stat_x *sxp)
 	/* Avoid sending values that can be inferred from other data. */
 	rsync_acl_strip_perms(sxp);
 
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+	write_varint(f, SMB_ACL_TYPE_ACCESS);
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 	send_rsync_acl(f, sxp->acc_acl, SMB_ACL_TYPE_ACCESS, &access_acl_list);
 
 	if (S_ISDIR(sxp->st.st_mode)) {
 		if (!sxp->def_acl)
 			sxp->def_acl = create_racl();
 
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+		write_varint(f, SMB_ACL_TYPE_DEFAULT);
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 		send_rsync_acl(f, sxp->def_acl, SMB_ACL_TYPE_DEFAULT, &default_acl_list);
 	}
 }
@@ -783,7 +965,19 @@ static int recv_rsync_acl(int f, item_list *racl_list, SMB_ACL_TYPE_T type, mode
 /* Receive the ACL info the sender has included for this file-list entry. */
 void receive_acl(int f, struct file_struct *file)
 {
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+	int ndx;
+	SMB_ACL_TYPE_T type;
+
+	type = read_varint(f);
+	if (type == SMB_ACL_TYPE_NFS4) {
+		ndx = recv_nfs4_acl(f, &nfs4_acl_list, file);
+		F_ACL(file) = ndx;
+		return;
+	}
+#else
 	F_ACL(file) = recv_rsync_acl(f, &access_acl_list, SMB_ACL_TYPE_ACCESS, file->mode);
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 
 	if (S_ISDIR(file->mode))
 		F_DIR_DEFACL(file) = recv_rsync_acl(f, &default_acl_list, SMB_ACL_TYPE_DEFAULT, 0);
@@ -811,6 +1005,14 @@ static int cache_rsync_acl(rsync_acl *racl, SMB_ACL_TYPE_T type, item_list *racl
  * values in the file struct. */
 void cache_tmp_acl(struct file_struct *file, stat_x *sxp)
 {
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+	if (sxp->brand == SMB_ACL_BRAND_NFS4) {
+		if (prior_nfs4_count == (size_t)-1)
+			prior_nfs4_count = nfs4_acl_list.count;
+		F_ACL(file) = cache_nfs4_acl(sxp->nfs4_acl, &nfs4_acl_list);
+		return;
+	}
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 	if (prior_access_count == (size_t)-1)
 		prior_access_count = access_acl_list.count;
 
@@ -849,6 +1051,12 @@ void uncache_tmp_acls(void)
 		uncache_duo_acls(&default_acl_list, prior_default_count);
 		prior_default_count = (size_t)-1;
 	}
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+	if (prior_nfs4_count != (size_t)-1) {
+		uncache_nfs4_acls(&nfs4_acl_list, prior_nfs4_count);
+		prior_nfs4_count = (size_t)-1;
+	}
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 }
 
 #ifndef HAVE_OSX_ACLS
@@ -1019,6 +1227,30 @@ int set_acl(const char *fname, const struct file_struct *file, stat_x *sxp, mode
 		return -1;
 	}
 
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+	if (sxp->brand == SMB_ACL_BRAND_NFS4) {
+		ndx = F_ACL(file);
+		if (ndx >= 0 && (size_t)ndx < nfs4_acl_list.count) {
+			nfs4_duo *duo_item = nfs4_acl_list.items;
+			duo_item += ndx;
+			changed = 1;
+
+			if (!duo_item->sacl) {
+				duo_item->sacl = acl_from_text(duo_item->nacl.nfs4_acl_text);
+				if (!duo_item->sacl)
+					return -1;
+			}
+			if (!dry_run && fname) {
+				if (sys_acl_set_file(fname, SMB_ACL_TYPE_NFS4, duo_item->sacl) < 0) {
+					rsyserr(FERROR_XFER, errno, "set_acl: sys_acl_set_file(%s, %s)",
+						fname, str_acl_type(SMB_ACL_TYPE_NFS4));
+					return -1;
+				}
+				return changed;
+			}
+		}
+	}
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 	ndx = F_ACL(file);
 	if (ndx >= 0 && (size_t)ndx < access_acl_list.count) {
 		acl_duo *duo_item = access_acl_list.items;
diff --git a/hlink.c b/hlink.c
index 66810a3e..a0a2e531 100644
--- a/hlink.c
+++ b/hlink.c
@@ -423,6 +423,10 @@ int hard_link_check(struct file_struct *file, int ndx, char *fname,
 					sxp->acc_acl = alt_sx.acc_acl;
 					sxp->def_acl = alt_sx.def_acl;
 					alt_sx.acc_acl = alt_sx.def_acl = NULL;
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+					sxp->nfs4_acl = alt_sx.nfs4_acl;
+					alt_sx.nfs4_acl = NULL;
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 				}
 			}
 #endif
diff --git a/ifuncs.h b/ifuncs.h
index 956fc22e..b607e039 100644
--- a/ifuncs.h
+++ b/ifuncs.h
@@ -78,6 +78,9 @@ init_stat_x(stat_x *sx_p)
 	sx_p->crtime = 0;
 #ifdef SUPPORT_ACLS
 	sx_p->acc_acl = sx_p->def_acl = NULL;
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+	sx_p->nfs4_acl = NULL;
+#endif
 #endif
 #ifdef SUPPORT_XATTRS
 	sx_p->xattr = NULL;
diff --git a/lib/sysacls.h b/lib/sysacls.h
index c0695974..e659b0f7 100644
--- a/lib/sysacls.h
+++ b/lib/sysacls.h
@@ -64,6 +64,16 @@
 
 #define SMB_ACL_NEED_SORT
 
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+#define SMB_ACL_EVERYONE	ACL_EVERYONE
+
+#define SMB_ACL_TYPE_NFS4	ACL_TYPE_NFS4
+
+#define SMB_ACL_BRAND_UNKNOWN	ACL_BRAND_UNKNOWN
+#define SMB_ACL_BRAND_POSIX	ACL_BRAND_POSIX
+#define SMB_ACL_BRAND_NFS4	ACL_BRAND_NFS4
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
+
 #elif defined HAVE_TRU64_ACLS /*---------------------------------------------*/
 
 /* This is for DEC/Compaq Tru64 UNIX */
diff --git a/rsync.c b/rsync.c
index cd288f57..e7ef907b 100644
--- a/rsync.c
+++ b/rsync.c
@@ -639,19 +639,6 @@ int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
 		}
 	}
 
-#ifdef SUPPORT_ACLS
-	/* It's OK to call set_acl() now, even for a dir, as the generator
-	 * will enable owner-writability using chmod, if necessary.
-	 *
-	 * If set_acl() changes permission bits in the process of setting
-	 * an access ACL, it changes sxp->st.st_mode so we know whether we
-	 * need to chmod(). */
-	if (preserve_acls && !S_ISLNK(new_mode)) {
-		if (set_acl(fname, file, sxp, new_mode) > 0)
-			updated |= UPDATED_ACLS;
-	}
-#endif
-
 #ifdef HAVE_CHMOD
 	if (!BITS_EQUAL(sxp->st.st_mode, new_mode, CHMOD_BITS)) {
 		int ret = am_root < 0 ? 0 : do_chmod(fname, new_mode);
@@ -666,6 +653,19 @@ int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
 	}
 #endif
 
+#ifdef SUPPORT_ACLS
+	/* It's OK to call set_acl() now, even for a dir, as the generator
+	 * will enable owner-writability using chmod, if necessary.
+	 *
+	 * If set_acl() changes permission bits in the process of setting
+	 * an access ACL, it changes sxp->st.st_mode so we know whether we
+	 * need to chmod(). */
+	if (preserve_acls && !S_ISLNK(new_mode)) {
+		if (set_acl(fname, file, sxp, new_mode) > 0)
+			updated |= UPDATED_ACLS;
+	}
+#endif
+
 	if (INFO_GTE(NAME, 2) && flags & ATTRS_REPORT) {
 		if (updated)
 			rprintf(FCLIENT, "%s\n", fname);
diff --git a/rsync.h b/rsync.h
index 1cc037c5..df8ae390 100644
--- a/rsync.h
+++ b/rsync.h
@@ -1140,13 +1140,25 @@ typedef struct {
 #ifdef SUPPORT_ACLS
     struct rsync_acl *acc_acl; /* access ACL */
     struct rsync_acl *def_acl; /* default ACL */
-#endif
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+    struct nfs4_acl *nfs4_acl; /* default ACL */
+    int brand;
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
+#endif /* SUPPORT_ACLS */
 #ifdef SUPPORT_XATTRS
     item_list *xattr;
 #endif
 } stat_x;
 
+#ifdef FREEBSD_NFS4_ACL_SUPPORT
+#include "lib/sysacls.h"
+
+#define ACL_READY_POSIX(sx) ((sx).acc_acl != NULL)
+#define ACL_READY_NFS4(sx) ((sx).nfs4_acl != NULL)
+#define ACL_READY(sx) (((sx).brand == SMB_ACL_BRAND_NFS4) ? (ACL_READY_NFS4(sx)) : (ACL_READY_POSIX(sx)))
+#else
 #define ACL_READY(sx) ((sx).acc_acl != NULL)
+#endif /* FREEBSD_NFS4_ACL_SUPPORT */
 #define XATTR_READY(sx) ((sx).xattr != NULL)
 
 #define CLVL_NOT_SPECIFIED INT_MIN
-- 
2.36.1

