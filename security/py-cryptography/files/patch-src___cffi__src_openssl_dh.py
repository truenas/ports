--- src/_cffi_src/openssl/dh.py.orig	2022-10-17 11:10:57 UTC
+++ src/_cffi_src/openssl/dh.py
@@ -37,117 +37,9 @@ int Cryptography_i2d_DHxparams_bio(BIO *bp, DH *x);
 """
 
 CUSTOMIZATIONS = """
-#if CRYPTOGRAPHY_IS_LIBRESSL
-#ifndef DH_CHECK_Q_NOT_PRIME
-#define DH_CHECK_Q_NOT_PRIME            0x10
-#endif
-
-#ifndef DH_CHECK_INVALID_Q_VALUE
-#define DH_CHECK_INVALID_Q_VALUE        0x20
-#endif
-
-#ifndef DH_CHECK_INVALID_J_VALUE
-#define DH_CHECK_INVALID_J_VALUE        0x40
-#endif
-
-/* DH_check implementation taken from OpenSSL 1.1.0pre6 */
-
-/*-
- * Check that p is a safe prime and
- * if g is 2, 3 or 5, check that it is a suitable generator
- * where
- * for 2, p mod 24 == 11
- * for 3, p mod 12 == 5
- * for 5, p mod 10 == 3 or 7
- * should hold.
- */
-
-int Cryptography_DH_check(const DH *dh, int *ret)
-{
-    int ok = 0, r;
-    BN_CTX *ctx = NULL;
-    BN_ULONG l;
-    BIGNUM *t1 = NULL, *t2 = NULL;
-
-    *ret = 0;
-    ctx = BN_CTX_new();
-    if (ctx == NULL)
-        goto err;
-    BN_CTX_start(ctx);
-    t1 = BN_CTX_get(ctx);
-    if (t1 == NULL)
-        goto err;
-    t2 = BN_CTX_get(ctx);
-    if (t2 == NULL)
-        goto err;
-
-    if (dh->q) {
-        if (BN_cmp(dh->g, BN_value_one()) <= 0)
-            *ret |= DH_NOT_SUITABLE_GENERATOR;
-        else if (BN_cmp(dh->g, dh->p) >= 0)
-            *ret |= DH_NOT_SUITABLE_GENERATOR;
-        else {
-            /* Check g^q == 1 mod p */
-            if (!BN_mod_exp(t1, dh->g, dh->q, dh->p, ctx))
-                goto err;
-            if (!BN_is_one(t1))
-                *ret |= DH_NOT_SUITABLE_GENERATOR;
-        }
-        r = BN_is_prime_ex(dh->q, BN_prime_checks, ctx, NULL);
-        if (r < 0)
-            goto err;
-        if (!r)
-            *ret |= DH_CHECK_Q_NOT_PRIME;
-        /* Check p == 1 mod q  i.e. q divides p - 1 */
-        if (!BN_div(t1, t2, dh->p, dh->q, ctx))
-            goto err;
-        if (!BN_is_one(t2))
-            *ret |= DH_CHECK_INVALID_Q_VALUE;
-        if (dh->j && BN_cmp(dh->j, t1))
-            *ret |= DH_CHECK_INVALID_J_VALUE;
-
-    } else if (BN_is_word(dh->g, DH_GENERATOR_2)) {
-        l = BN_mod_word(dh->p, 24);
-        if (l == (BN_ULONG)-1)
-            goto err;
-        if (l != 11)
-            *ret |= DH_NOT_SUITABLE_GENERATOR;
-    } else if (BN_is_word(dh->g, DH_GENERATOR_5)) {
-        l = BN_mod_word(dh->p, 10);
-        if (l == (BN_ULONG)-1)
-            goto err;
-        if ((l != 3) && (l != 7))
-            *ret |= DH_NOT_SUITABLE_GENERATOR;
-    } else
-        *ret |= DH_UNABLE_TO_CHECK_GENERATOR;
-
-    r = BN_is_prime_ex(dh->p, BN_prime_checks, ctx, NULL);
-    if (r < 0)
-        goto err;
-    if (!r)
-        *ret |= DH_CHECK_P_NOT_PRIME;
-    else if (!dh->q) {
-        if (!BN_rshift1(t1, dh->p))
-            goto err;
-        r = BN_is_prime_ex(t1, BN_prime_checks, ctx, NULL);
-        if (r < 0)
-            goto err;
-        if (!r)
-            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;
-    }
-    ok = 1;
- err:
-    if (ctx != NULL) {
-        BN_CTX_end(ctx);
-        BN_CTX_free(ctx);
-    }
-    return (ok);
-}
-#else
 int Cryptography_DH_check(const DH *dh, int *ret) {
     return DH_check(dh, ret);
 }
-#endif
 
 /* These functions were added in OpenSSL 1.1.0f commit d0c50e80a8 */
 /* Define our own to simplify support across all versions. */
